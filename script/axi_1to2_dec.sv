/*-----------------------------------------------------*/
// axi_1to2_dec.sv is generated by ./gen_axi_dec.sh
//
//                                         2021-10-09
//                                           18:09:40
/*-----------------------------------------------------*/

module axi_1to2_dec (
    input                  aclk,
    input                  aresetn,
    input         [  1: 0] s_awburst,
    input         [  9: 0] s_awid,
    input         [ 31: 0] s_awaddr,
    input         [  2: 0] s_awsize,
    input         [  7: 0] s_awlen,
    input                  s_awvalid,
    output logic           s_awready,
    input         [  3: 0] s_wstrb,
    input         [  9: 0] s_wid,
    input         [ 31: 0] s_wdata,
    input                  s_wlast,
    input                  s_wvalid,
    output logic           s_wready,
    output logic  [  9: 0] s_bid,
    output logic  [  1: 0] s_bresp,
    output logic           s_bvalid,
    input                  s_bready,
    input         [ 31: 0] s_araddr,
    input         [  1: 0] s_arburst,
    input         [  2: 0] s_arsize,
    input         [  9: 0] s_arid,
    input         [  7: 0] s_arlen,
    input                  s_arvalid,
    output logic           s_arready,
    output logic  [ 31: 0] s_rdata,
    output logic  [  1: 0] s_rresp,
    output logic  [  9: 0] s_rid,
    output logic           s_rlast,
    output logic           s_rvalid,
    input                  s_rready,
    output logic  [  1: 0] m0_awburst,
    output logic  [  9: 0] m0_awid,
    output logic  [ 31: 0] m0_awaddr,
    output logic  [  2: 0] m0_awsize,
    output logic  [  7: 0] m0_awlen,
    output logic           m0_awvalid,
    input                  m0_awready,
    output logic  [  3: 0] m0_wstrb,
    output logic  [  9: 0] m0_wid,
    output logic  [ 31: 0] m0_wdata,
    output logic           m0_wlast,
    output logic           m0_wvalid,
    input                  m0_wready,
    input         [  9: 0] m0_bid,
    input         [  1: 0] m0_bresp,
    input                  m0_bvalid,
    output logic           m0_bready,
    output logic  [ 31: 0] m0_araddr,
    output logic  [  1: 0] m0_arburst,
    output logic  [  2: 0] m0_arsize,
    output logic  [  9: 0] m0_arid,
    output logic  [  7: 0] m0_arlen,
    output logic           m0_arvalid,
    input                  m0_arready,
    input         [ 31: 0] m0_rdata,
    input         [  1: 0] m0_rresp,
    input         [  9: 0] m0_rid,
    input                  m0_rlast,
    input                  m0_rvalid,
    output logic           m0_rready,
    output logic  [  1: 0] m1_awburst,
    output logic  [  9: 0] m1_awid,
    output logic  [ 31: 0] m1_awaddr,
    output logic  [  2: 0] m1_awsize,
    output logic  [  7: 0] m1_awlen,
    output logic           m1_awvalid,
    input                  m1_awready,
    output logic  [  3: 0] m1_wstrb,
    output logic  [  9: 0] m1_wid,
    output logic  [ 31: 0] m1_wdata,
    output logic           m1_wlast,
    output logic           m1_wvalid,
    input                  m1_wready,
    input         [  9: 0] m1_bid,
    input         [  1: 0] m1_bresp,
    input                  m1_bvalid,
    output logic           m1_bready,
    output logic  [ 31: 0] m1_araddr,
    output logic  [  1: 0] m1_arburst,
    output logic  [  2: 0] m1_arsize,
    output logic  [  9: 0] m1_arid,
    output logic  [  7: 0] m1_arlen,
    output logic           m1_arvalid,
    input                  m1_arready,
    input         [ 31: 0] m1_rdata,
    input         [  1: 0] m1_rresp,
    input         [  9: 0] m1_rid,
    input                  m1_rlast,
    input                  m1_rvalid,
    output logic           m1_rready
);

logic [  1: 0] m_awburst  [0:   2];
logic [  9: 0] m_awid     [0:   2];
logic [ 31: 0] m_awaddr   [0:   2];
logic [  2: 0] m_awsize   [0:   2];
logic [  7: 0] m_awlen    [0:   2];
logic [  3: 0] m_wstrb    [0:   2];
logic [  9: 0] m_wid      [0:   2];
logic [ 31: 0] m_wdata    [0:   2];
logic [  9: 0] m_bid      [0:   2];
logic [  1: 0] m_bresp    [0:   2];
logic [ 31: 0] m_araddr   [0:   2];
logic [  1: 0] m_arburst  [0:   2];
logic [  2: 0] m_arsize   [0:   2];
logic [  9: 0] m_arid     [0:   2];
logic [  7: 0] m_arlen    [0:   2];
logic [ 31: 0] m_rdata    [0:   2];
logic [  1: 0] m_rresp    [0:   2];
logic [  9: 0] m_rid      [0:   2];

logic [  2: 0] m_arvalid;
logic [  2: 0] m_arready;
logic [  2: 0] m_rlast;
logic [  2: 0] m_rvalid;
logic [  2: 0] m_rready;
logic [  2: 0] m_awvalid;
logic [  2: 0] m_awready;
logic [  2: 0] m_wlast;
logic [  2: 0] m_wvalid;
logic [  2: 0] m_wready;
logic [  2: 0] m_bvalid;
logic [  2: 0] m_bready;

assign m0_awburst = m_awburst [0];
assign m0_awid    = m_awid    [0];
assign m0_awaddr  = m_awaddr  [0];
assign m0_awsize  = m_awsize  [0];
assign m0_awlen   = m_awlen   [0];
assign m0_wstrb   = m_wstrb   [0];
assign m0_wid     = m_wid     [0];
assign m0_wdata   = m_wdata   [0];
assign m0_araddr  = m_araddr  [0];
assign m0_arburst = m_arburst [0];
assign m0_arsize  = m_arsize  [0];
assign m0_arid    = m_arid    [0];
assign m0_arlen   = m_arlen   [0];
assign m1_awburst = m_awburst [1];
assign m1_awid    = m_awid    [1];
assign m1_awaddr  = m_awaddr  [1];
assign m1_awsize  = m_awsize  [1];
assign m1_awlen   = m_awlen   [1];
assign m1_wstrb   = m_wstrb   [1];
assign m1_wid     = m_wid     [1];
assign m1_wdata   = m_wdata   [1];
assign m1_araddr  = m_araddr  [1];
assign m1_arburst = m_arburst [1];
assign m1_arsize  = m_arsize  [1];
assign m1_arid    = m_arid    [1];
assign m1_arlen   = m_arlen   [1];

assign m_bid     [0] = m0_bid;
assign m_bresp   [0] = m0_bresp;
assign m_rdata   [0] = m0_rdata;
assign m_rresp   [0] = m0_rresp;
assign m_rid     [0] = m0_rid;
assign m_bid     [1] = m1_bid;
assign m_bresp   [1] = m1_bresp;
assign m_rdata   [1] = m1_rdata;
assign m_rresp   [1] = m1_rresp;
assign m_rid     [1] = m1_rid;

assign m0_arvalid = m_arvalid [0];
assign m0_awvalid = m_awvalid [0];
assign m0_wvalid  = m_wvalid  [0];
assign m0_wlast   = m_wlast   [0];
assign m0_bready  = m_bready  [0];
assign m0_rready  = m_rready  [0];
assign m1_arvalid = m_arvalid [1];
assign m1_awvalid = m_awvalid [1];
assign m1_wvalid  = m_wvalid  [1];
assign m1_wlast   = m_wlast   [1];
assign m1_bready  = m_bready  [1];
assign m1_rready  = m_rready  [1];

assign m_arready [0] = m0_arready;
assign m_awready [0] = m0_awready;
assign m_wready  [0] = m0_wready;
assign m_bvalid  [0] = m0_bvalid;
assign m_rlast   [0] = m0_rlast;
assign m_rvalid  [0] = m0_rvalid;
assign m_arready [1] = m1_arready;
assign m_awready [1] = m1_awready;
assign m_wready  [1] = m1_wready;
assign m_bvalid  [1] = m1_bvalid;
assign m_rlast   [1] = m1_rlast;
assign m_rvalid  [1] = m1_rvalid;

logic [  2: 0] awsel;
logic [  2: 0] wsel;
logic [  2: 0] bsel;
logic [  2: 0] arsel;
logic [  2: 0] rsel;

logic          b_fifo_wr;
logic          b_fifo_rd;
logic          b_fifo_empty;
logic          b_fifo_full;
logic          r_fifo_wr;
logic          r_fifo_rd;
logic          r_fifo_empty;
logic          r_fifo_full;

assign awsel[  0] = s_awaddr >= 32'h0_0000 && s_awaddr < 32'h0_0000 + 32'h1_0000;
assign awsel[  1] = s_awaddr >= 32'h1_0000 && s_awaddr < 32'h1_0000 + 32'h1_0000;
assign awsel[  2] = ~|awsel[1:0]; // default slv

assign arsel[  0] = s_araddr >= 32'h0_0000 && s_araddr < 32'h0_0000 + 32'h1_0000;
assign arsel[  1] = s_araddr >= 32'h1_0000 && s_araddr < 32'h1_0000 + 32'h1_0000;
assign arsel[  2] = ~|arsel[1:0]; // default slv

assign b_fifo_wr = s_awvalid & s_awready;
assign b_fifo_rd = s_bvalid  & s_bready;

assign r_fifo_wr = s_arvalid & s_arready;
assign r_fifo_rd = s_rvalid  & s_rvalid & s_rready;

axi_dec_fifo u_b_fifo (
    .clk           ( aclk       ),
    .rstn          ( aresetn    ),
    .wr            ( b_fifo_wr  ),
    .wdata         ( awsel      ),
    .rd            ( b_fifo_rd  ),
    .rdata         ( bsel       ),
    .empty         ( b_fifo_empty ),
    .full          ( b_fifo_full )
);

axi_dec_fifo u_r_fifo (
    .clk           ( aclk       ),
    .rstn          ( aresetn    ),
    .wr            ( r_fifo_wr  ),
    .wdata         ( arsel      ),
    .rd            ( r_fifo_rd  ),
    .rdata         ( rsel       ),
    .empty         ( r_fifo_empty ),
    .full          ( r_fifo_full )
);

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        wsel <= 3'b0;
    end
    else begin
        if (s_awvalid & s_awready & ~|wsel) begin
            wsel <= awsel;
        end
        else if (s_wlast & s_wvalid & s_wready) begin
            wsel <= 3'b0;
        end
    end
end

always_comb begin
    integer i;

    for (i = 0; i <= 2; i = i + 1) begin
        m_awburst [i] = {    2{awsel[i]}} & s_awburst;
        m_awid    [i] = {   10{awsel[i]}} & s_awid;
        m_awaddr  [i] = {   32{awsel[i]}} & s_awaddr;
        m_awsize  [i] = {    3{awsel[i]}} & s_awsize;
        m_awlen   [i] = {    8{awsel[i]}} & s_awlen;

        m_wstrb   [i] = {    4{ wsel[i]}} & s_wstrb;
        m_wid     [i] = {   10{ wsel[i]}} & s_wid;
        m_wdata   [i] = {   32{ wsel[i]}} & s_wdata;

        m_araddr  [i] = {   32{arsel[i]}} & s_araddr;
        m_arburst [i] = {    2{arsel[i]}} & s_arburst;
        m_arsize  [i] = {    3{arsel[i]}} & s_arsize;
        m_arid    [i] = {   10{arsel[i]}} & s_arid;
        m_arlen   [i] = {    8{arsel[i]}} & s_arlen;
    end
end

always_comb begin
    integer i;

    s_bid      =  10'b0;
    s_bresp    =   2'b0;

    s_rdata    =  32'b0;
    s_rresp    =   2'b0;
    s_rid      =  10'b0;
    for (i = 0; i <= 2; i = i + 1) begin
        s_bid      = s_bid      | ({   10{bsel[i]}} & m_bid     [i]);
        s_bresp    = s_bresp    | ({    2{bsel[i]}} & m_bresp   [i]);

        s_rdata    = s_rdata    | ({   32{rsel[i]}} & m_rdata   [i]);
        s_rresp    = s_rresp    | ({    2{rsel[i]}} & m_rresp   [i]);
        s_rid      = s_rid      | ({   10{rsel[i]}} & m_rid     [i]);
    end
end

assign m_awvalid = awsel & {3{s_awvalid & ~b_fifo_full}};
assign s_awready = |(awsel & m_awready) & ~b_fifo_full;

assign m_wlast   = wsel & {3{s_wlast }};
assign m_wvalid  = wsel & {3{s_wvalid}};
assign s_wready  = |(wsel  & m_wready );

assign s_bvalid  = |(bsel  & m_bvalid) & ~b_fifo_empty;
assign m_bready  = bsel & {3{s_bready}};

assign m_arvalid = arsel & {3{s_arvalid & ~r_fifo_full}};
assign s_arready = |(arsel & m_arready) & ~r_fifo_full;

assign s_rlast   = |(rsel  & m_rlast ) & ~r_fifo_empty;
assign s_rvalid  = |(rsel  & m_rvalid) & ~r_fifo_empty;
assign m_rready  = rsel & {3{s_rready}};

axi_dfslv u_axi_dfslv (
    .aclk          ( aclk       ),
    .aresetn       ( aresetn    ),
    .s_awburst     ( m_awburst[2] ),
    .s_awid        ( m_awid[2]  ),
    .s_awaddr      ( m_awaddr[2] ),
    .s_awsize      ( m_awsize[2] ),
    .s_awlen       ( m_awlen[2] ),
    .s_awvalid     ( m_awvalid[2] ),
    .s_awready     ( m_awready[2] ),
    .s_wstrb       ( m_wstrb[2] ),
    .s_wid         ( m_wid[2]   ),
    .s_wdata       ( m_wdata[2] ),
    .s_wlast       ( m_wlast[2] ),
    .s_wvalid      ( m_wvalid[2] ),
    .s_wready      ( m_wready[2] ),
    .s_bid         ( m_bid[2]   ),
    .s_bresp       ( m_bresp[2] ),
    .s_bvalid      ( m_bvalid[2] ),
    .s_bready      ( m_bready[2] ),
    .s_araddr      ( m_araddr[2] ),
    .s_arburst     ( m_arburst[2] ),
    .s_arsize      ( m_arsize[2] ),
    .s_arid        ( m_arid[2]  ),
    .s_arlen       ( m_arlen[2] ),
    .s_arvalid     ( m_arvalid[2] ),
    .s_arready     ( m_arready[2] ),
    .s_rdata       ( m_rdata[2] ),
    .s_rresp       ( m_rresp[2] ),
    .s_rid         ( m_rid[2]   ),
    .s_rlast       ( m_rlast[2] ),
    .s_rvalid      ( m_rvalid[2] ),
    .s_rready      ( m_rready[2] )
);

endmodule

module axi_dec_fifo (
    input                  clk,
    input                  rstn,
    input                  wr,
    input         [  2: 0] wdata,
    input                  rd,
    output logic  [  2: 0] rdata,
    output logic           empty,
    output logic           full
);

parameter FIFO_DEPTH = 4;

logic [  2: 0] fifo       [0: FIFO_DEPTH - 1];

logic [  2: 0] wptr;
logic [  2: 0] rptr;

assign empty = wptr == rptr;
assign full  = (wptr[2] ^ rptr[2]) && (wptr[0+:2] == rptr[0+:2]);

assign rdata = fifo[rptr[0+:2]];

always_ff @(posedge clk or negedge rstn) begin
    integer i;

    if (~rstn) begin
        wptr <= 3'b0;
        rptr <= 3'b0;
    end
    else begin
        if (wr & ~full)  wptr <= wptr + 3'b1;
        if (rd & ~empty) rptr <= rptr + 3'b1;
    end

    if (~rstn) begin
        for (i = 0; i < FIFO_DEPTH; i = i + 1)
            fifo[i] <= 3'b0;
    end
    else begin
        if (wr & ~full) fifo[wptr[0+:2]] <= wdata;
    end
end
endmodule

module axi_dfslv (
    input                  aclk,
    input                  aresetn,
    input         [  1: 0] s_awburst,
    input         [  9: 0] s_awid,
    input         [ 31: 0] s_awaddr,
    input         [  2: 0] s_awsize,
    input         [  7: 0] s_awlen,
    input                  s_awvalid,
    output logic           s_awready,
    input         [  3: 0] s_wstrb,
    input         [  9: 0] s_wid,
    input         [ 31: 0] s_wdata,
    input                  s_wlast,
    input                  s_wvalid,
    output logic           s_wready,
    output logic  [  9: 0] s_bid,
    output logic  [  1: 0] s_bresp,
    output logic           s_bvalid,
    input                  s_bready,
    input         [ 31: 0] s_araddr,
    input         [  1: 0] s_arburst,
    input         [  2: 0] s_arsize,
    input         [  9: 0] s_arid,
    input         [  7: 0] s_arlen,
    input                  s_arvalid,
    output logic           s_arready,
    output logic  [ 31: 0] s_rdata,
    output logic  [  1: 0] s_rresp,
    output logic  [  9: 0] s_rid,
    output logic           s_rlast,
    output logic           s_rvalid,
    input                  s_rready
);

`define AXI_RESP_OKAY   2'b00
`define AXI_RESP_EXOKAY 2'b01
`define AXI_RESP_SLVERR 2'b10
`define AXI_RESP_DECERR 2'b11

// READ
logic [  7: 0] rlen;

assign s_rdata    =  32'b0;
assign s_rresp    = `AXI_RESP_DECERR;
assign s_rlast    = ~|rlen;
assign s_arready  = ~s_rvalid | (s_rlast & s_rvalid & s_rready);

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        s_rid <=  10'b0;
    end
    else begin
        if (s_arvalid & s_arready) begin
            s_rid <= s_arid;
        end
    end

    if (~aresetn) begin
        rlen <= 8'b0;
    end
    else begin
        if (s_arvalid & s_arready) begin
            rlen <= s_arlen;
        end
        else if (~s_rlast & s_rvalid & s_rready) begin
            rlen <= rlen - 8'b1;
        end
    end

    if (~aresetn) begin
        s_rvalid <= 1'b0;
    end
    else begin
        if (s_arvalid & s_arready) begin
            s_rvalid <= 1'b1;
        end
        else if (s_rlast & s_rvalid & s_rready) begin
            s_rvalid <= 1'b0;
        end
    end
end

// WRITE
assign s_bresp    = `AXI_RESP_DECERR;
assign s_awready  = (~s_wready & ~s_bvalid) | (s_bvalid & s_bready);

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        s_wready <= 1'b0;
    end
    else begin
        if (s_awvalid & s_awready) begin
            s_wready <= 1'b1;
        end
        else if (s_wvalid & s_wlast) begin
            s_wready <= 1'b0;
        end
    end

    if (~aresetn) begin
        s_bid <= 10'b0;
    end
    else begin
        if (s_awvalid & s_awready) begin
            s_bid <= s_awid;
        end
    end

    if (~aresetn) begin
        s_bvalid <= 1'b0;
    end
    else begin
        if (s_wvalid & s_wlast & s_wready) begin
            s_bvalid <= 1'b1;
        end
        else if (s_bready) begin
            s_bvalid <= 1'b0;
        end
    end
end

endmodule
