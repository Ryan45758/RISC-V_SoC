/*-----------------------------------------------------*/
// axi_2to1_mux.sv is generated by gen_axi_mux.sh
//
//                                         2021-10-16
//                                           13:11:29
/*-----------------------------------------------------*/

module axi_2to1_mux (
    input                  aclk,
    input                  aresetn,
    input         [  1: 0] s0_awburst,
    input         [  9: 0] s0_awid,
    input         [ 31: 0] s0_awaddr,
    input         [  2: 0] s0_awsize,
    input         [  7: 0] s0_awlen,
    input                  s0_awvalid,
    output logic           s0_awready,
    input         [  3: 0] s0_wstrb,
    input         [  9: 0] s0_wid,
    input         [ 31: 0] s0_wdata,
    input                  s0_wlast,
    input                  s0_wvalid,
    output logic           s0_wready,
    output logic  [  9: 0] s0_bid,
    output logic  [  1: 0] s0_bresp,
    output logic           s0_bvalid,
    input                  s0_bready,
    input         [ 31: 0] s0_araddr,
    input         [  1: 0] s0_arburst,
    input         [  2: 0] s0_arsize,
    input         [  9: 0] s0_arid,
    input         [  7: 0] s0_arlen,
    input                  s0_arvalid,
    output logic           s0_arready,
    output logic  [ 31: 0] s0_rdata,
    output logic  [  1: 0] s0_rresp,
    output logic  [  9: 0] s0_rid,
    output logic           s0_rlast,
    output logic           s0_rvalid,
    input                  s0_rready,
    input         [  1: 0] s1_awburst,
    input         [  9: 0] s1_awid,
    input         [ 31: 0] s1_awaddr,
    input         [  2: 0] s1_awsize,
    input         [  7: 0] s1_awlen,
    input                  s1_awvalid,
    output logic           s1_awready,
    input         [  3: 0] s1_wstrb,
    input         [  9: 0] s1_wid,
    input         [ 31: 0] s1_wdata,
    input                  s1_wlast,
    input                  s1_wvalid,
    output logic           s1_wready,
    output logic  [  9: 0] s1_bid,
    output logic  [  1: 0] s1_bresp,
    output logic           s1_bvalid,
    input                  s1_bready,
    input         [ 31: 0] s1_araddr,
    input         [  1: 0] s1_arburst,
    input         [  2: 0] s1_arsize,
    input         [  9: 0] s1_arid,
    input         [  7: 0] s1_arlen,
    input                  s1_arvalid,
    output logic           s1_arready,
    output logic  [ 31: 0] s1_rdata,
    output logic  [  1: 0] s1_rresp,
    output logic  [  9: 0] s1_rid,
    output logic           s1_rlast,
    output logic           s1_rvalid,
    input                  s1_rready,
    output logic  [  1: 0] m_awburst,
    output logic  [ 10: 0] m_awid,
    output logic  [ 31: 0] m_awaddr,
    output logic  [  2: 0] m_awsize,
    output logic  [  7: 0] m_awlen,
    output logic           m_awvalid,
    input                  m_awready,
    output logic  [  3: 0] m_wstrb,
    output logic  [ 10: 0] m_wid,
    output logic  [ 31: 0] m_wdata,
    output logic           m_wlast,
    output logic           m_wvalid,
    input                  m_wready,
    input         [ 10: 0] m_bid,
    input         [  1: 0] m_bresp,
    input                  m_bvalid,
    output logic           m_bready,
    output logic  [ 31: 0] m_araddr,
    output logic  [  1: 0] m_arburst,
    output logic  [  2: 0] m_arsize,
    output logic  [ 10: 0] m_arid,
    output logic  [  7: 0] m_arlen,
    output logic           m_arvalid,
    input                  m_arready,
    input         [ 31: 0] m_rdata,
    input         [  1: 0] m_rresp,
    input         [ 10: 0] m_rid,
    input                  m_rlast,
    input                  m_rvalid,
    output logic           m_rready
);

logic [  1: 0] s_awburst  [0:   1];
logic [  9: 0] s_awid     [0:   1];
logic [ 31: 0] s_awaddr   [0:   1];
logic [  2: 0] s_awsize   [0:   1];
logic [  7: 0] s_awlen    [0:   1];
logic [  3: 0] s_wstrb    [0:   1];
logic [  9: 0] s_wid      [0:   1];
logic [ 31: 0] s_wdata    [0:   1];
logic [  9: 0] s_bid      [0:   1];
logic [  1: 0] s_bresp    [0:   1];
logic [ 31: 0] s_araddr   [0:   1];
logic [  1: 0] s_arburst  [0:   1];
logic [  2: 0] s_arsize   [0:   1];
logic [  9: 0] s_arid     [0:   1];
logic [  7: 0] s_arlen    [0:   1];
logic [ 31: 0] s_rdata    [0:   1];
logic [  1: 0] s_rresp    [0:   1];
logic [  9: 0] s_rid      [0:   1];

logic [  1: 0] s_arvalid;
logic [  1: 0] s_arready;
logic [  1: 0] s_rlast;
logic [  1: 0] s_rvalid;
logic [  1: 0] s_rready;
logic [  1: 0] s_awvalid;
logic [  1: 0] s_awready;
logic [  1: 0] s_wlast;
logic [  1: 0] s_wvalid;
logic [  1: 0] s_wready;
logic [  1: 0] s_bvalid;
logic [  1: 0] s_bready;

assign s_awburst [0] = s0_awburst;
assign s_awid    [0] = s0_awid;
assign s_awaddr  [0] = s0_awaddr;
assign s_awsize  [0] = s0_awsize;
assign s_awlen   [0] = s0_awlen;
assign s_wstrb   [0] = s0_wstrb;
assign s_wid     [0] = s0_wid;
assign s_wdata   [0] = s0_wdata;
assign s_araddr  [0] = s0_araddr;
assign s_arburst [0] = s0_arburst;
assign s_arsize  [0] = s0_arsize;
assign s_arid    [0] = s0_arid;
assign s_arlen   [0] = s0_arlen;
assign s_awburst [1] = s1_awburst;
assign s_awid    [1] = s1_awid;
assign s_awaddr  [1] = s1_awaddr;
assign s_awsize  [1] = s1_awsize;
assign s_awlen   [1] = s1_awlen;
assign s_wstrb   [1] = s1_wstrb;
assign s_wid     [1] = s1_wid;
assign s_wdata   [1] = s1_wdata;
assign s_araddr  [1] = s1_araddr;
assign s_arburst [1] = s1_arburst;
assign s_arsize  [1] = s1_arsize;
assign s_arid    [1] = s1_arid;
assign s_arlen   [1] = s1_arlen;

assign s0_bid     = s_bid     [0];
assign s0_bresp   = s_bresp   [0];
assign s0_rdata   = s_rdata   [0];
assign s0_rresp   = s_rresp   [0];
assign s0_rid     = s_rid     [0];
assign s1_bid     = s_bid     [1];
assign s1_bresp   = s_bresp   [1];
assign s1_rdata   = s_rdata   [1];
assign s1_rresp   = s_rresp   [1];
assign s1_rid     = s_rid     [1];

assign s_arvalid [0] = s0_arvalid;
assign s_awvalid [0] = s0_awvalid;
assign s_wvalid  [0] = s0_wvalid;
assign s_wlast   [0] = s0_wlast;
assign s_bready  [0] = s0_bready;
assign s_rready  [0] = s0_rready;
assign s_arvalid [1] = s1_arvalid;
assign s_awvalid [1] = s1_awvalid;
assign s_wvalid  [1] = s1_wvalid;
assign s_wlast   [1] = s1_wlast;
assign s_bready  [1] = s1_bready;
assign s_rready  [1] = s1_rready;

assign s0_arready = s_arready [0];
assign s0_awready = s_awready [0];
assign s0_wready  = s_wready  [0];
assign s0_bvalid  = s_bvalid  [0];
assign s0_rlast   = s_rlast   [0];
assign s0_rvalid  = s_rvalid  [0];
assign s1_arready = s_arready [1];
assign s1_awready = s_awready [1];
assign s1_wready  = s_wready  [1];
assign s1_bvalid  = s_bvalid  [1];
assign s1_rlast   = s_rlast   [1];
assign s1_rvalid  = s_rvalid  [1];

axi_arbitrator_2s u_axi_arbitrator (
    .aclk          ( aclk       ),
    .aresetn       ( aresetn    ),
    .s_arvalid     ( s_arvalid  ),
    .s_arready     ( s_arready  ),
    .s_awvalid     ( s_awvalid  ),
    .s_awready     ( s_awready  ),
    .s_wlast       ( s_wlast    ),
    .s_wvalid      ( s_wvalid   ),
    .s_wready      ( s_wready   ),
    .m_arvalid     ( m_arvalid  ),
    .m_arready     ( m_arready  ),
    .m_awvalid     ( m_awvalid  ),
    .m_awready     ( m_awready  ),
    .m_wlast       ( m_wlast    ),
    .m_wvalid      ( m_wvalid   ),
    .m_wready      ( m_wready   )
);

always_comb begin
    integer i;

    m_awburst  = {          2{1'b0}};
    m_awid     = {( 10 +   1){1'b0}};
    m_awaddr   = {         32{1'b0}};
    m_awsize   = {          3{1'b0}};
    m_awlen    = {          8{1'b0}};
    for (i = 0; i < 2; i = i + 1) begin
        m_awburst            = m_awburst        | ({  2{s_awready[i]}} & s_awburst [i]);
        m_awid    [  0+:  1] = m_awid[  0+:  1] | ({  1{s_awready[i]}} &            i );
        m_awid    [  1+: 10] = m_awid[  1+: 10] | ({ 10{s_awready[i]}} & s_awid    [i]);
        m_awaddr             = m_awaddr         | ({ 32{s_awready[i]}} & s_awaddr  [i]);
        m_awsize             = m_awsize         | ({  3{s_awready[i]}} & s_awsize  [i]);
        m_awlen              = m_awlen          | ({  8{s_awready[i]}} & s_awlen   [i]);
    end

    m_wstrb    = {          4{1'b0}};
    m_wid      = {( 10 +   1){1'b0}};
    m_wdata    = {         32{1'b0}};
    for (i = 0; i < 2; i = i + 1) begin
        m_wstrb              = m_wstrb          | ({  4{s_wready[i]}} & s_wstrb   [i]);
        m_wid     [  0+:  1] = m_wid [  0+:  1] | ({  1{s_wready[i]}} &            i );
        m_wid     [  1+: 10] = m_wid [  1+: 10] | ({ 10{s_wready[i]}} & s_wid     [i]);
        m_wdata              = m_wdata          | ({ 32{s_wready[i]}} & s_wdata   [i]);
    end

    m_araddr   = {         32{1'b0}};
    m_arburst  = {          2{1'b0}};
    m_arsize   = {          3{1'b0}};
    m_arid     = {( 10 +   1){1'b0}};
    m_arlen    = {          8{1'b0}};
    for (i = 0; i < 2; i = i + 1) begin
        m_araddr             = m_araddr         | ({ 32{s_arready[i]}} & s_araddr  [i]);
        m_arburst            = m_arburst        | ({  2{s_arready[i]}} & s_arburst [i]);
        m_arsize             = m_arsize         | ({  3{s_arready[i]}} & s_arsize  [i]);
        m_arid    [  0+:  1] = m_arid[  0+:  1] | ({  1{s_arready[i]}} &            i );
        m_arid    [  1+: 10] = m_arid[  1+: 10] | ({ 10{s_arready[i]}} & s_arid    [i]);
        m_arlen              = m_arlen          | ({  8{s_arready[i]}} & s_arlen   [i]);
    end
end

logic          bsel;
logic          rsel;

always_comb begin
    integer i;

    for (i = 0; i < 2; i = i + 1) begin
        s_bid     [i] = { 10{bsel == i}} & m_bid[  1+: 10];
        s_bresp   [i] = {  2{bsel == i}} & m_bresp;
        s_bvalid  [i] = {  1{bsel == i}} & m_bvalid;

        s_rdata   [i] = { 32{rsel == i}} & m_rdata;
        s_rresp   [i] = {  2{rsel == i}} & m_rresp;
        s_rid     [i] = { 10{rsel == i}} & m_rid[  1+: 10];
        s_rlast   [i] = {  1{rsel == i}} & m_rlast;
        s_rvalid  [i] = {  1{rsel == i}} & m_rvalid;
    end
end

assign bsel = m_bid[  0+:  1];
assign rsel = m_rid[  0+:  1];

assign m_bready = s_bready[bsel];
assign m_rready = s_rready[rsel];

endmodule

module axi_arbitrator_2s (
    input                  aclk,
    input                  aresetn,
    input         [  1: 0] s_arvalid,
    output logic  [  1: 0] s_arready,
    input         [  1: 0] s_awvalid,
    output logic  [  1: 0] s_awready,
    input         [  1: 0] s_wlast,
    input         [  1: 0] s_wvalid,
    output logic  [  1: 0] s_wready,
    output logic           m_arvalid,
    input                  m_arready,
    output logic           m_awvalid,
    input                  m_awready,
    output logic           m_wlast,
    output logic           m_wvalid,
    input                  m_wready
);

parameter SLV_NUM = 2;

// AR arbitrator
logic [SLV_NUM - 1:0] ar_prior;
logic [SLV_NUM - 1:0] ar_prior_nxt;

assign ar_prior_nxt = {ar_prior[SLV_NUM - 2:0], ar_prior[SLV_NUM - 1]};

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        ar_prior <= {{(SLV_NUM-1){1'b0}}, 1'b1};
    end
    else begin
        if (m_arvalid & m_arready) begin
            ar_prior <= ar_prior_nxt;
        end
    end
end

logic [SLV_NUM - 1:0] ar_grant_matrix [0:SLV_NUM - 1];

always_comb begin
    // integer i, j, k;
    // for (i = 0; i < SLV_NUM; i = i + 1) begin
    //     ar_grant_matrix[i] = ar_prior;
    //     for (j = 1; j < SLV_NUM; j = j + 1) begin
    //         for (k = 1; k < SLV_NUM; k = k + 1) begin
    //             ar_grant_matrix[i][(i + j) % SLV_NUM] =  ar_grant_matrix[i][(i + j) % SLV_NUM] &
    //                                                      ~s_arvalid[(i + k) % SLV_NUM];
    //         end
    //     end
    // end
    ar_grant_matrix[0][0] = ar_prior[0];
    ar_grant_matrix[0][1] = ~s_arvalid[1];
    ar_grant_matrix[1][0] = ~s_arvalid[0];
    ar_grant_matrix[1][1] = ar_prior[1];
end

always_comb begin
    integer i;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        s_arready[i]  = s_arvalid[i] & (|ar_grant_matrix[i]) & m_arready;
    end
end

assign m_arvalid = |(s_arready & s_arvalid);

// AW arbitrator
logic [SLV_NUM - 1:0] aw_prior;
logic [SLV_NUM - 1:0] aw_prior_nxt;

assign aw_prior_nxt = {aw_prior[SLV_NUM - 2:0], aw_prior[SLV_NUM - 1]};

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        aw_prior <= {{(SLV_NUM-1){1'b0}}, 1'b1};
    end
    else begin
        if (m_wlast & m_wvalid & m_wready) begin
            aw_prior <= aw_prior_nxt;
        end
    end
end
logic [SLV_NUM - 1:0] aw_grant_matrix [0:SLV_NUM - 1];

always_comb begin
    // integer i, j, k;
    // for (i = 0; i < SLV_NUM; i = i + 1) begin
    //     aw_grant_matrix[i] = aw_prior;
    //     for (j = 1; j < SLV_NUM; j = j + 1) begin
    //         for (k = 1; k < SLV_NUM; k = k + 1) begin
    //             aw_grant_matrix[i][(i + j) % SLV_NUM] =  aw_grant_matrix[i][(i + j) % SLV_NUM] &
    //                                                      ~s_awvalid[(i + k) % SLV_NUM];
    //         end
    //     end
    // end
    aw_grant_matrix[0][0] = aw_prior[0];
    aw_grant_matrix[0][1] = ~s_awvalid[1];
    aw_grant_matrix[1][0] = ~s_awvalid[0];
    aw_grant_matrix[1][1] = aw_prior[1];
end

logic [SLV_NUM - 1:0] s_wsel;

always_comb begin
    integer i;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        s_awready[i]  = s_awvalid[i] & (|aw_grant_matrix[i]) & ~|s_wsel & m_awready;
    end
end

assign m_awvalid = |(s_awready & s_awvalid);

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        s_wsel <= {SLV_NUM{1'b0}};
    end
    else begin
        if (m_wready & m_wvalid & m_wlast) begin
            s_wsel <= {SLV_NUM{1'b0}};
        end
        else if (~|s_wsel & m_awvalid & m_awready) begin
            s_wsel <= s_awready;
        end
    end
end

assign s_wready = s_wsel & {SLV_NUM{m_wready}};

assign m_wvalid = |(s_wsel & s_wvalid) & m_wready;
assign m_wlast  = |(s_wsel & s_wlast);
endmodule
