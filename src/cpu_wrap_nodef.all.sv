/*-----------------------------------------------------*/
// cpu_wrap.all.sv is generated by /home/fred2/RISCV/./script/merge_sv.sh
//
//                                         2021-12-09
//                                           17:34:25
/*-----------------------------------------------------*/

/*--------------------------------------*/
// FILE: ../src/cpu/cpu_wrap.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif


`define ALU_OP_LEN 4
`define CSR_OP_LEN 2

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       `XLEN'h0
`define CAUSE_INSTRUCTION_ACCESS     `XLEN'h1
`define CAUSE_ILLEGAL_INSTRUCTION    `XLEN'h2
`define CAUSE_BREAKPOINT             `XLEN'h3
`define CAUSE_MISALIGNED_LOAD        `XLEN'h4
`define CAUSE_LOAD_ACCESS            `XLEN'h5
`define CAUSE_MISALIGNED_STORE       `XLEN'h6
`define CAUSE_STORE_ACCESS           `XLEN'h7
`define CAUSE_USER_ECALL             `XLEN'h8
`define CAUSE_SUPERVISOR_ECALL       `XLEN'h9
`define CAUSE_HYPERVISOR_ECALL       `XLEN'ha
`define CAUSE_MACHINE_ECALL          `XLEN'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT `XLEN'hc
`define CAUSE_LOAD_PAGE_FAULT        `XLEN'hd
`define CAUSE_STORE_PAGE_FAULT       `XLEN'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`ifdef RV32
  `define SATP_PPN_WIDTH  22
  `define SATP_ASID_WIDTH  9
  `define SATP_MODE_WIDTH  1
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   22+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   31+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 31

`else
  `define SATP_PPN_WIDTH  44
  `define SATP_ASID_WIDTH 16
  `define SATP_MODE_WIDTH  4
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   44+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   60+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 63
`endif

`define PADDR_LEN       (`SATP_PPN_WIDTH + 12)

`endif
`ifndef __INTF_DEFINE__
`define __INTF_DEFINE__

`define AXI_INTF_CONNECT(PORT, WIRE) \
    .``PORT``_awburst ( WIRE``_awburst ), \
    .``PORT``_awid    ( WIRE``_awid    ), \
    .``PORT``_awaddr  ( WIRE``_awaddr  ), \
    .``PORT``_awsize  ( WIRE``_awsize  ), \
    .``PORT``_awlen   ( WIRE``_awlen   ), \
    .``PORT``_awvalid ( WIRE``_awvalid ), \
    .``PORT``_awready ( WIRE``_awready ), \
    .``PORT``_wstrb   ( WIRE``_wstrb   ), \
    .``PORT``_wid     ( WIRE``_wid     ), \
    .``PORT``_wdata   ( WIRE``_wdata   ), \
    .``PORT``_wlast   ( WIRE``_wlast   ), \
    .``PORT``_wvalid  ( WIRE``_wvalid  ), \
    .``PORT``_wready  ( WIRE``_wready  ), \
    .``PORT``_bid     ( WIRE``_bid     ), \
    .``PORT``_bresp   ( WIRE``_bresp   ), \
    .``PORT``_bvalid  ( WIRE``_bvalid  ), \
    .``PORT``_bready  ( WIRE``_bready  ), \
    .``PORT``_araddr  ( WIRE``_araddr  ), \
    .``PORT``_arburst ( WIRE``_arburst ), \
    .``PORT``_arsize  ( WIRE``_arsize  ), \
    .``PORT``_arid    ( WIRE``_arid    ), \
    .``PORT``_arlen   ( WIRE``_arlen   ), \
    .``PORT``_arvalid ( WIRE``_arvalid ), \
    .``PORT``_arready ( WIRE``_arready ), \
    .``PORT``_rdata   ( WIRE``_rdata   ), \
    .``PORT``_rresp   ( WIRE``_rresp   ), \
    .``PORT``_rid     ( WIRE``_rid     ), \
    .``PORT``_rlast   ( WIRE``_rlast   ), \
    .``PORT``_rvalid  ( WIRE``_rvalid  ), \
    .``PORT``_rready  ( WIRE``_rready  )

`define AXI_INTF_SLV_DEF(NAME, ID) \
    input         [     1: 0] NAME``_awburst, \
    input         [ID - 1: 0] NAME``_awid,    \
    input         [    31: 0] NAME``_awaddr,  \
    input         [     2: 0] NAME``_awsize,  \
    input         [     7: 0] NAME``_awlen,   \
    input                     NAME``_awvalid, \
    output logic              NAME``_awready, \
    input         [     3: 0] NAME``_wstrb,   \
    input         [ID - 1: 0] NAME``_wid,     \
    input         [    31: 0] NAME``_wdata,   \
    input                     NAME``_wlast,   \
    input                     NAME``_wvalid,  \
    output logic              NAME``_wready,  \
    output logic  [ID - 1: 0] NAME``_bid,     \
    output logic  [     1: 0] NAME``_bresp,   \
    output logic              NAME``_bvalid,  \
    input                     NAME``_bready,  \
    input         [    31: 0] NAME``_araddr,  \
    input         [     1: 0] NAME``_arburst, \
    input         [     2: 0] NAME``_arsize,  \
    input         [ID - 1: 0] NAME``_arid,    \
    input         [     7: 0] NAME``_arlen,   \
    input                     NAME``_arvalid, \
    output logic              NAME``_arready, \
    output logic  [    31: 0] NAME``_rdata,   \
    output logic  [     1: 0] NAME``_rresp,   \
    output logic  [ID - 1: 0] NAME``_rid,     \
    output logic              NAME``_rlast,   \
    output logic              NAME``_rvalid,  \
    input                     NAME``_rready

`define AXI_INTF_MST_DEF(NAME, ID) \
    output logic  [     1: 0] NAME``_awburst, \
    output logic  [ID - 1: 0] NAME``_awid,    \
    output logic  [    31: 0] NAME``_awaddr,  \
    output logic  [     2: 0] NAME``_awsize,  \
    output logic  [     7: 0] NAME``_awlen,   \
    output logic              NAME``_awvalid, \
    input                     NAME``_awready, \
    output logic  [     3: 0] NAME``_wstrb,   \
    output logic  [ID - 1: 0] NAME``_wid,     \
    output logic  [    31: 0] NAME``_wdata,   \
    output logic              NAME``_wlast,   \
    output logic              NAME``_wvalid,  \
    input                     NAME``_wready,  \
    input         [ID - 1: 0] NAME``_bid,     \
    input         [     1: 0] NAME``_bresp,   \
    input                     NAME``_bvalid,  \
    output logic              NAME``_bready,  \
    output logic  [    31: 0] NAME``_araddr,  \
    output logic  [     1: 0] NAME``_arburst, \
    output logic  [     2: 0] NAME``_arsize,  \
    output logic  [ID - 1: 0] NAME``_arid,    \
    output logic  [     7: 0] NAME``_arlen,   \
    output logic              NAME``_arvalid, \
    input                     NAME``_arready, \
    input         [    31: 0] NAME``_rdata,   \
    input         [     1: 0] NAME``_rresp,   \
    input         [ID - 1: 0] NAME``_rid,     \
    input                     NAME``_rlast,   \
    input                     NAME``_rvalid,  \
    output logic              NAME``_rready

`define AXI_INTF_DEF(NAME, ID) \
    logic  [     1: 0] NAME``_awburst; \
    logic  [ID - 1: 0] NAME``_awid;    \
    logic  [    31: 0] NAME``_awaddr;  \
    logic  [     2: 0] NAME``_awsize;  \
    logic  [     7: 0] NAME``_awlen;   \
    logic              NAME``_awvalid; \
    logic              NAME``_awready; \
    logic  [     3: 0] NAME``_wstrb;   \
    logic  [ID - 1: 0] NAME``_wid;     \
    logic  [    31: 0] NAME``_wdata;   \
    logic              NAME``_wlast;   \
    logic              NAME``_wvalid;  \
    logic              NAME``_wready;  \
    logic  [ID - 1: 0] NAME``_bid;     \
    logic  [     1: 0] NAME``_bresp;   \
    logic              NAME``_bvalid;  \
    logic              NAME``_bready;  \
    logic  [    31: 0] NAME``_araddr;  \
    logic  [     1: 0] NAME``_arburst; \
    logic  [     2: 0] NAME``_arsize;  \
    logic  [ID - 1: 0] NAME``_arid;    \
    logic  [     7: 0] NAME``_arlen;   \
    logic              NAME``_arvalid; \
    logic              NAME``_arready; \
    logic  [    31: 0] NAME``_rdata;   \
    logic  [     1: 0] NAME``_rresp;   \
    logic  [ID - 1: 0] NAME``_rid;     \
    logic              NAME``_rlast;   \
    logic              NAME``_rvalid;  \
    logic              NAME``_rready;

`endif

module cpu_wrap (
    input                  clk,
    input                  rstn,

    // external AXI interface
    input         [  1: 0] axi_ext_awburst,
    input         [  9: 0] axi_ext_awid,
    input         [ 31: 0] axi_ext_awaddr,
    input         [  2: 0] axi_ext_awsize,
    input         [  7: 0] axi_ext_awlen,
    input                  axi_ext_awvalid,
    output logic           axi_ext_awready,
    input         [  3: 0] axi_ext_wstrb,
    input         [  9: 0] axi_ext_wid,
    input         [ 31: 0] axi_ext_wdata,
    input                  axi_ext_wlast,
    input                  axi_ext_wvalid,
    output logic           axi_ext_wready,
    output logic  [  9: 0] axi_ext_bid,
    output logic  [  1: 0] axi_ext_bresp,
    output logic           axi_ext_bvalid,
    input                  axi_ext_bready,
    input         [ 31: 0] axi_ext_araddr,
    input         [  1: 0] axi_ext_arburst,
    input         [  2: 0] axi_ext_arsize,
    input         [  9: 0] axi_ext_arid,
    input         [  7: 0] axi_ext_arlen,
    input                  axi_ext_arvalid,
    output logic           axi_ext_arready,
    output logic  [ 31: 0] axi_ext_rdata,
    output logic  [  1: 0] axi_ext_rresp,
    output logic  [  9: 0] axi_ext_rid,
    output logic           axi_ext_rlast,
    output logic           axi_ext_rvalid,
    input                  axi_ext_rready,

    // debug APB interface
    input                  dbg_psel,
    input                  dbg_penable,
    input         [ 31: 0] dbg_paddr,
    input                  dbg_pwrite,
    input         [  3: 0] dbg_pstrb,
    input         [  2: 0] dbg_pprot,
    input         [ 31: 0] dbg_pwdata,
    output logic  [ 31: 0] dbg_prdata,
    output logic           dbg_pslverr,
    output logic           dbg_pready
);

logic                             core_rstn;

logic                             msip;
logic                             mtip;
logic                             meip;

logic                             imem_en;
logic [       `IM_ADDR_LEN - 1:0] imem_addr;
logic [       `IM_DATA_LEN - 1:0] imem_rdata;
logic [                      1:0] imem_bad;
logic                             imem_busy;

logic                             dmem_en;
logic [       `IM_ADDR_LEN - 1:0] dmem_addr;
logic                             dmem_write;
logic [(`IM_DATA_LEN >> 3) - 1:0] dmem_strb;
logic [       `IM_DATA_LEN - 1:0] dmem_wdata;
logic [       `IM_DATA_LEN - 1:0] dmem_rdata;
logic [                      1:0] dmem_bad;
logic                             dmem_busy;

logic [                  8 - 1:0] pmpcfg  [16];
logic [              `XLEN - 1:0] pmpaddr [16];
logic [                  8 - 1:0] pmacfg  [16];
logic [              `XLEN - 1:0] pmaaddr [16];

logic                             ipmp_v;
logic                             ipmp_l;
logic                             ipmp_x;
logic                             ipmp_w;
logic                             ipmp_r;
logic                             ipma_v;
logic                             ipma_l;
logic                             ipma_c;
logic                             ipma_e;

logic                             dpmp_v;
logic                             dpmp_l;
logic                             dpmp_x;
logic                             dpmp_w;
logic                             dpmp_r;
logic                             dpma_v;
logic                             dpma_l;
logic                             dpma_c;
logic                             dpma_e;

logic [    `SATP_PPN_WIDTH - 1:0] satp_ppn;
logic [   `SATP_ASID_WIDTH - 1:0] satp_asid;
logic [   `SATP_MODE_WIDTH - 1:0] satp_mode;
logic [                      1:0] prv;
logic                             sum;
logic                             mprv;
logic [                      1:0] mpp;
logic                             tlb_flush_req;
logic                             tlb_flush_all_vaddr;
logic                             tlb_flush_all_asid;
logic [              `XLEN - 1:0] tlb_flush_vaddr;
logic [              `XLEN - 1:0] tlb_flush_asid;
logic                             ic_flush;

logic          mem_ck_0;
logic          mem_ck_1;

logic          cs_0;
logic          we_0;
logic [ 31: 0] addr_0;
logic [  3: 0] byte_0;
logic [ 31: 0] di_0;
logic [ 31: 0] do_0;
logic          busy_0;
              
logic          cs_1;
logic          we_1;
logic [ 31: 0] addr_1;
logic [  3: 0] byte_1;
logic [ 31: 0] di_1;
logic [ 31: 0] do_1;
logic          busy_1;

logic          icache_bypass;
logic          immu_pa_vld;
logic [  1: 0] immu_pa_bad;
logic [ 55: 0] immu_pa;
logic [ 55: 0] immu_pa_pre;

logic          dcache_bypass;
logic          dmmu_pa_vld;
logic [  1: 0] dmmu_pa_bad;
logic [ 55: 0] dmmu_pa;
logic [ 55: 0] dmmu_pa_pre;

logic          core_psel;
logic          core_penable;
logic [ 31: 0] core_paddr;
logic          core_pwrite;
logic [  3: 0] core_pstrb;
logic [ 31: 0] core_pwdata;
logic [ 31: 0] core_prdata;
logic          core_pslverr;
logic          core_pready;

logic          intc_psel;
logic          intc_penable;
logic [ 31: 0] intc_paddr;
logic          intc_pwrite;
logic [  3: 0] intc_pstrb;
logic [ 31: 0] intc_pwdata;
logic [ 31: 0] intc_prdata;
logic          intc_pslverr;
logic          intc_pready;

logic          cfgreg_psel;
logic          cfgreg_penable;
logic [ 31: 0] cfgreg_paddr;
logic          cfgreg_pwrite;
logic [  3: 0] cfgreg_pstrb;
logic [ 31: 0] cfgreg_pwdata;
logic [ 31: 0] cfgreg_prdata;
logic          cfgreg_pslverr;
logic          cfgreg_pready;

logic          uart_psel;
logic          uart_penable;
logic [ 31: 0] uart_paddr;
logic          uart_pwrite;
logic [  3: 0] uart_pstrb;
logic [ 31: 0] uart_pwdata;
logic [ 31: 0] uart_prdata;
logic          uart_pslverr;
logic          uart_pready;

logic  [ 11: 0] dbg_addr;
logic  [ 31: 0] dbg_wdata;
logic           dbg_gpr_rd;
logic           dbg_gpr_wr;
logic  [ 31: 0] dbg_gpr_rdata;
logic           dbg_csr_rd;
logic           dbg_csr_wr;
logic  [ 31: 0] dbg_csr_rdata;
logic  [ 31: 0] dbg_pc;
logic  [ 31: 0] dbg_inst;
logic           dbg_exec;
logic           dbg_halted;
logic           dbg_attach;


`AXI_INTF_DEF(immu, 10)
`AXI_INTF_DEF(dmmu, 10)
`AXI_INTF_DEF(l1ic, 10)
`AXI_INTF_DEF(l1dc, 10)
`AXI_INTF_DEF(axi_ext_remap, 10)

cpu_top u_cpu_top (
    .clk                 ( clk                 ),
    .rstn                ( core_rstn           ),
    .cpu_id              ( `XLEN'd0            ),

    // mpu csr
    .pmpcfg              ( pmpcfg              ),
    .pmpaddr             ( pmpaddr             ),
    .pmacfg              ( pmacfg              ),
    .pmaaddr             ( pmaaddr             ),

    // mmu csr
    .satp_ppn            ( satp_ppn            ),
    .satp_asid           ( satp_asid           ),
    .satp_mode           ( satp_mode           ),
    .prv                 ( prv                 ),
    .sum                 ( sum                 ),
    .mprv                ( mprv                ),
    .mpp                 ( mpp                 ),

    // TLB control
    .tlb_flush_req       ( tlb_flush_req       ),
    .tlb_flush_all_vaddr ( tlb_flush_all_vaddr ),
    .tlb_flush_all_asid  ( tlb_flush_all_asid  ),
    .tlb_flush_vaddr     ( tlb_flush_vaddr     ),
    .tlb_flush_asid      ( tlb_flush_asid      ),
   
    // interrupt interface
    .msip                ( msip                ),
    .mtip                ( mtip                ),
    .meip                ( meip                ),

    // inst interface
    .imem_en             ( imem_en             ),
    .imem_addr           ( imem_addr           ),
    .imem_rdata          ( imem_rdata          ),
    .imem_bad            ( imem_bad            ),
    .imem_busy           ( imem_busy           ),
    .ic_flush            ( ic_flush            ),

    // data interface
    .dmem_en             ( dmem_en             ),
    .dmem_addr           ( dmem_addr           ),
    .dmem_write          ( dmem_write          ),
    .dmem_strb           ( dmem_strb           ),
    .dmem_wdata          ( dmem_wdata          ),
    .dmem_rdata          ( dmem_rdata          ),
    .dmem_bad            ( dmem_bad            ),
    .dmem_busy           ( dmem_busy           ),

    // debug intface
    .dbg_addr            ( dbg_addr            ),
    .dbg_wdata           ( dbg_wdata           ),
    .dbg_gpr_rd          ( dbg_gpr_rd          ),
    .dbg_gpr_wr          ( dbg_gpr_wr          ),
    .dbg_gpr_out         ( dbg_gpr_rdata       ),
    .dbg_csr_rd          ( dbg_csr_rd          ),
    .dbg_csr_wr          ( dbg_csr_wr          ),
    .dbg_csr_out         ( dbg_csr_rdata       ),
    .dbg_pc_out          ( dbg_pc              ),
    .dbg_exec            ( dbg_exec            ),
    .dbg_inst            ( dbg_inst            ),
    .attach              ( dbg_attach          ),
    .halted              ( dbg_halted          )
);

mmu u_immu(
    .clk                 ( clk                 ),
    .rstn                ( core_rstn           ),
    
    // access type
    .access_w            ( 1'b0                ),
    .access_x            ( 1'b1                ),

    // TLB control
    .tlb_flush_req       ( tlb_flush_req       ),
    .tlb_flush_all_vaddr ( tlb_flush_all_vaddr ),
    .tlb_flush_all_asid  ( tlb_flush_all_asid  ),
    .tlb_flush_vaddr     ( tlb_flush_vaddr     ),
    .tlb_flush_asid      ( tlb_flush_asid      ),

    // mpu csr
    .pmp_v               ( ipmp_v              ),
    .pmp_l               ( ipmp_l              ),
    .pmp_x               ( ipmp_x              ),
    .pmp_w               ( ipmp_w              ),
    .pmp_r               ( ipmp_r              ),

    .pma_v               ( ipma_v              ),
    .pma_l               ( ipma_l              ),
    .pma_c               ( ipma_c              ),
    .pma_e               ( ipma_e              ),

    // mmu csr
    .satp_ppn            ( satp_ppn            ),
    .satp_asid           ( satp_asid           ),
    .satp_mode           ( satp_mode           ),
    .prv                 ( prv                 ),
    .sum                 ( sum                 ),
    .mprv                ( mprv                ),
    .mpp                 ( mpp                 ),

    // virtual address
    .va_valid            ( imem_en             ),
    .va                  ( {16'b0, imem_addr}  ),

    // Cache bypass
    .cache_bypass        ( icache_bypass       ),

    // physical address
    .pa_valid            ( immu_pa_vld         ),
    .pa_bad              ( immu_pa_bad         ),
    .pa                  ( immu_pa             ),
    .pa_pre              ( immu_pa_pre         ),
    
    // AXI interface
    `AXI_INTF_CONNECT(m, immu)
);

mmu u_dmmu(
    .clk                 ( clk                 ),
    .rstn                ( core_rstn           ),
    
    // access type
    .access_w            ( dmem_write          ),
    .access_x            ( 1'b0                ),

    // TLB control
    .tlb_flush_req       ( tlb_flush_req       ),
    .tlb_flush_all_vaddr ( tlb_flush_all_vaddr ),
    .tlb_flush_all_asid  ( tlb_flush_all_asid  ),
    .tlb_flush_vaddr     ( tlb_flush_vaddr     ),
    .tlb_flush_asid      ( tlb_flush_asid      ),

    // mpu csr
    .pmp_v               ( dpmp_v              ),
    .pmp_l               ( dpmp_l              ),
    .pmp_x               ( dpmp_x              ),
    .pmp_w               ( dpmp_w              ),
    .pmp_r               ( dpmp_r              ),

    .pma_v               ( dpma_v              ),
    .pma_l               ( dpma_l              ),
    .pma_c               ( dpma_c              ),
    .pma_e               ( dpma_e              ),

    // mmu csr
    .satp_ppn            ( satp_ppn            ),
    .satp_asid           ( satp_asid           ),
    .satp_mode           ( satp_mode           ),
    .prv                 ( prv                 ),
    .sum                 ( sum                 ),
    .mprv                ( mprv                ),
    .mpp                 ( mpp                 ),

    // virtual address
    .va_valid            ( dmem_en             ),
    .va                  ( {16'b0, dmem_addr}  ),

    // Cache bypass
    .cache_bypass        ( dcache_bypass       ),

    // physical address
    .pa_valid            ( dmmu_pa_vld         ),
    .pa_bad              ( dmmu_pa_bad         ),
    .pa                  ( dmmu_pa             ),
    .pa_pre              ( dmmu_pa_pre         ),
    
    // AXI interface
    `AXI_INTF_CONNECT(m, dmmu)
);

mpu u_impu (
    .clk      ( clk         ),
    .rstn     ( core_rstn   ),
    .pmpcfg   ( pmpcfg      ),
    .pmpaddr  ( pmpaddr     ),
    .pmacfg   ( pmacfg      ),
    .pmaaddr  ( pmaaddr     ),
    .paddr    ( immu_pa_pre[33:0] ),

    .pmp_v    ( ipmp_v      ),
    .pmp_l    ( ipmp_l      ),
    .pmp_x    ( ipmp_x      ),
    .pmp_w    ( ipmp_w      ),
    .pmp_r    ( ipmp_r      ),
        
    .pma_v    ( ipma_v      ),
    .pma_l    ( ipma_l      ),
    .pma_c    ( ipma_c      ),
    .pma_e    ( ipma_e      )
        
);

mpu u_dmpu (
    .clk      ( clk         ),
    .rstn     ( core_rstn   ),
    .pmpcfg   ( pmpcfg      ),
    .pmpaddr  ( pmpaddr     ),
    .pmacfg   ( pmacfg      ),
    .pmaaddr  ( pmaaddr     ),
    .paddr    ( dmmu_pa_pre[33:0] ),

    .pmp_v    ( dpmp_v      ),
    .pmp_l    ( dpmp_l      ),
    .pmp_x    ( dpmp_x      ),
    .pmp_w    ( dpmp_w      ),
    .pmp_r    ( dpmp_r      ),
        
    .pma_v    ( dpma_v      ),
    .pma_l    ( dpma_l      ),
    .pma_c    ( dpma_c      ),
    .pma_e    ( dpma_e      )

);

l1c u_l1ic (
    .clk         ( clk           ),
    .rstn        ( core_rstn     ),

    .core_bypass ( icache_bypass ),
    .core_flush  ( ic_flush      ),
    .core_pa_vld ( immu_pa_vld   ),
    .core_pa_bad ( immu_pa_bad   ),
    .core_paddr  ( immu_pa[31:0] ),
    .core_req    ( imem_en       ),
    .core_wr     ( 1'b0          ),
    .core_vaddr  ( imem_addr     ),
    .core_byte   ( 4'hf          ),
    .core_wdata  ( 32'b0         ),
    .core_rdata  ( imem_rdata    ),
    .core_bad    ( imem_bad      ),
    .core_busy   ( imem_busy     ),

    `AXI_INTF_CONNECT(m, l1ic)
);

l1c u_l1dc (
    .clk         ( clk           ),
    .rstn        ( core_rstn     ),

    .core_bypass ( dcache_bypass ),
    .core_flush  ( 1'b0          ),
    .core_pa_vld ( dmmu_pa_vld   ),
    .core_paddr  ( dmmu_pa[31:0] ),
    .core_pa_bad ( dmmu_pa_bad   ),
    .core_req    ( dmem_en       ),
    .core_wr     ( dmem_write    ),
    .core_vaddr  ( dmem_addr     ),
    .core_byte   ( dmem_strb     ),
    .core_wdata  ( dmem_wdata    ),
    .core_rdata  ( dmem_rdata    ),
    .core_bad    ( dmem_bad      ),
    .core_busy   ( dmem_busy     ),

    `AXI_INTF_CONNECT(m, l1dc)
);

assign intc_psel      = core_paddr[27] && core_psel;
assign intc_penable   = core_paddr[27] && core_penable;
assign intc_paddr     = core_paddr;
assign intc_pwrite    = core_pwrite;
assign intc_pstrb     = core_pstrb;
assign intc_pwdata    = core_pwdata;

assign cfgreg_psel    = ~core_paddr[27] && core_psel;
assign cfgreg_penable = ~core_paddr[27] && core_penable;
assign cfgreg_paddr   = core_paddr;
assign cfgreg_pwrite  = core_pwrite;
assign cfgreg_pstrb   = core_pstrb;
assign cfgreg_pwdata  = core_pwdata;

assign core_prdata    = core_paddr[27] ? intc_prdata  : cfgreg_prdata;
assign core_pslverr   = core_paddr[27] ? intc_pslverr : cfgreg_pslverr;
assign core_pready    = core_paddr[27] ? intc_pready  : cfgreg_pready;

cfgreg u_cfgreg (
    .pclk      ( clk            ),
    .presetn   ( rstn           ),
    .psel      ( cfgreg_psel    ),
    .penable   ( cfgreg_penable ),
    .paddr     ( cfgreg_paddr   ),
    .pwrite    ( cfgreg_pwrite  ),
    .pstrb     ( cfgreg_pstrb   ),
    .pwdata    ( cfgreg_pwdata  ),
    .prdata    ( cfgreg_prdata  ),
    .pslverr   ( cfgreg_pslverr ),
    .pready    ( cfgreg_pready  ),

    .core_rstn ( core_rstn      )
);

iommu u_iommu (
    .aclk       ( clk          ),
    .aresetn    ( rstn         ),

    `AXI_INTF_CONNECT(s, axi_ext),
    `AXI_INTF_CONNECT(m, axi_ext_remap)
);

marb u_marb (
    .clk        ( clk          ),
    .rstn       ( rstn         ),

    `AXI_INTF_CONNECT(s0, immu),
    `AXI_INTF_CONNECT(s1, dmmu),
    `AXI_INTF_CONNECT(s2, l1ic),
    `AXI_INTF_CONNECT(s3, l1dc),
    `AXI_INTF_CONNECT(s4, axi_ext_remap),

    .m0_cs      ( cs_0         ),
    .m0_we      ( we_0         ),
    .m0_addr    ( addr_0       ),
    .m0_byte    ( byte_0       ),
    .m0_di      ( di_0         ),
    .m0_do      ( do_0         ),
    .m0_busy    ( busy_0       ),

    .m1_cs      ( cs_1         ),
    .m1_we      ( we_1         ),
    .m1_addr    ( addr_1       ),
    .m1_byte    ( byte_1       ),
    .m1_di      ( di_1         ),
    .m1_do      ( do_1         ),
    .m1_busy    ( busy_1       ),

    .m2_psel    ( core_psel    ),
    .m2_penable ( core_penable ),
    .m2_paddr   ( core_paddr   ),
    .m2_pwrite  ( core_pwrite  ),
    .m2_pstrb   ( core_pstrb   ),
    .m2_pwdata  ( core_pwdata  ),
    .m2_prdata  ( core_prdata  ),
    .m2_pslverr ( core_pslverr ),
    .m2_pready  ( core_pready  ),

    .m3_psel    ( uart_psel    ),
    .m3_penable ( uart_penable ),
    .m3_paddr   ( uart_paddr   ),
    .m3_pwrite  ( uart_pwrite  ),
    .m3_pstrb   ( uart_pstrb   ),
    .m3_pwdata  ( uart_pwdata  ),
    .m3_prdata  ( uart_prdata  ),
    .m3_pslverr ( uart_pslverr ),
    .m3_pready  ( uart_pready  )
);

// assign msip = 1'b0;
// assign mtip = 1'b0;
// assign meip = 1'b0;
// 
// assign core_rstn = rstn;
// 
// assign imem_bad  = 2'b0;
// assign imem_busy = 1'b0;
// 
// always_ff @(posedge clk or negedge rstn) begin
//     if (~rstn) begin
//         imem_rdata <= 32'b0;
//     end
//     else begin
//         imem_rdata <= u_sram_0.memory[imem_addr[15:2]];
//     end
// end
// 
// assign dmem_bad  = 2'b0;
// assign dmem_busy = 1'b0;
// 
// always_ff @(posedge clk or negedge rstn) begin
//     if (~rstn) begin
//         dmem_rdata <= 32'b0;
//     end
//     else begin
//         dmem_rdata <= dmem_addr[16] ? u_sram_1.memory[dmem_addr[15:2]] : u_sram_0.memory[dmem_addr[15:2]];
//     end
// end
// 
// always_ff @(posedge clk or negedge rstn) begin
//     if (dmem_write & dmem_en & dmem_addr[16]) begin
//         if (dmem_strb[0]) u_sram_1.memory[dmem_addr[15:2]][ 0+:8] <= dmem_wdata[ 0+:8];
//         if (dmem_strb[1]) u_sram_1.memory[dmem_addr[15:2]][ 8+:8] <= dmem_wdata[ 8+:8];
//         if (dmem_strb[2]) u_sram_1.memory[dmem_addr[15:2]][16+:8] <= dmem_wdata[16+:8];
//         if (dmem_strb[3]) u_sram_1.memory[dmem_addr[15:2]][24+:8] <= dmem_wdata[24+:8];
//     end
// end
// 
// assign cs_0 = 1'b0;
// assign cs_1 = 1'b0;

CG u_mem_cg_0 (
    .CK   ( clk      ),
    .EN   ( cs_0     ),
    .CKEN ( mem_ck_0 )
);

CG u_mem_cg_1 (
    .CK   ( clk      ),
    .EN   ( cs_1     ),
    .CKEN ( mem_ck_1 )
);

sram u_sram_0 (
    .CK   ( mem_ck_0      ),
    .CS   ( cs_0          ),
    .A    ( addr_0[2+:14] ),
    .BYTE ( byte_0        ),
    .WE   ( we_0          ),
    .DI   ( di_0          ),
    .DO   ( do_0          )
);

assign busy_0 = 1'b0;

sram u_sram_1 (
    .CK   ( mem_ck_1      ),
    .CS   ( cs_1          ),
    .A    ( addr_1[2+:14] ),
    .BYTE ( byte_1        ),
    .WE   ( we_1          ),
    .DI   ( di_1          ),
    .DO   ( do_1          )
);

assign busy_1 = 1'b0;

intc u_intc(
    .clk    ( clk          ),
    .rstn   ( core_rstn    ),
    .psel   ( intc_psel    ),
    .penable( intc_penable ),
    .paddr  ( intc_paddr   ),
    .pwrite ( intc_pwrite  ),
    .pstrb  ( intc_pstrb   ),
    .pwdata ( intc_pwdata  ),
    .prdata ( intc_prdata  ),
    .pslverr( intc_pslverr ),
    .pready ( intc_pready  ),
                            
    .msip   ( msip         ),
    .mtip   ( mtip         ),
    .meip   ( meip         ),
`ifdef DC
    .ints   ( ~32'b0       )
`else
    .ints   ( 32'b0        )
`endif
);

dbgapb u_dbgapb (
    .pclk      ( clk           ),
    .presetn   ( core_rstn     ),
    .psel      ( dbg_psel      ),
    .penable   ( dbg_penable   ),
    .paddr     ( dbg_paddr     ),
    .pwrite    ( dbg_pwrite    ),
    .pstrb     ( dbg_pstrb     ),
    .pwdata    ( dbg_pwdata    ),
    .prdata    ( dbg_prdata    ),
    .pslverr   ( dbg_pslverr   ),
    .pready    ( dbg_pready    ),

    .addr_out  ( dbg_addr      ),
    .wdata_out ( dbg_wdata     ),
    .gpr_rd    ( dbg_gpr_rd    ),
    .gpr_wr    ( dbg_gpr_wr    ),
    .gpr_in    ( dbg_gpr_rdata ),
    .csr_rd    ( dbg_csr_rd    ),
    .csr_wr    ( dbg_csr_wr    ),
    .csr_in    ( dbg_csr_rdata ),
    .pc        ( dbg_pc        ),
    .inst_out  ( dbg_inst      ),
    .exec      ( dbg_exec      ),
    .halted    ( dbg_halted    ),
    .attach    ( dbg_attach    )
);

uart u_uart(
    .pclk    ( clk          ),
    .presetn ( rstn         ),
    .psel    ( uart_psel    ),
    .penable ( uart_penable ),
    .paddr   ( uart_paddr   ),
    .pwrite  ( uart_pwrite  ),
    .pstrb   ( uart_pstrb   ),
    .pwdata  ( uart_pwdata  ),
    .prdata  ( uart_prdata  ),
    .pslverr ( uart_pslverr ),
    .pready  ( uart_pready  ),

    .uart_rx ( 1'b0 ),
    .uart_tx (  )
);
endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/marb.sv
/*--------------------------------------*/

`ifndef __INTF_DEFINE__
`define __INTF_DEFINE__

`define AXI_INTF_CONNECT(PORT, WIRE) \
    .``PORT``_awburst ( WIRE``_awburst ), \
    .``PORT``_awid    ( WIRE``_awid    ), \
    .``PORT``_awaddr  ( WIRE``_awaddr  ), \
    .``PORT``_awsize  ( WIRE``_awsize  ), \
    .``PORT``_awlen   ( WIRE``_awlen   ), \
    .``PORT``_awvalid ( WIRE``_awvalid ), \
    .``PORT``_awready ( WIRE``_awready ), \
    .``PORT``_wstrb   ( WIRE``_wstrb   ), \
    .``PORT``_wid     ( WIRE``_wid     ), \
    .``PORT``_wdata   ( WIRE``_wdata   ), \
    .``PORT``_wlast   ( WIRE``_wlast   ), \
    .``PORT``_wvalid  ( WIRE``_wvalid  ), \
    .``PORT``_wready  ( WIRE``_wready  ), \
    .``PORT``_bid     ( WIRE``_bid     ), \
    .``PORT``_bresp   ( WIRE``_bresp   ), \
    .``PORT``_bvalid  ( WIRE``_bvalid  ), \
    .``PORT``_bready  ( WIRE``_bready  ), \
    .``PORT``_araddr  ( WIRE``_araddr  ), \
    .``PORT``_arburst ( WIRE``_arburst ), \
    .``PORT``_arsize  ( WIRE``_arsize  ), \
    .``PORT``_arid    ( WIRE``_arid    ), \
    .``PORT``_arlen   ( WIRE``_arlen   ), \
    .``PORT``_arvalid ( WIRE``_arvalid ), \
    .``PORT``_arready ( WIRE``_arready ), \
    .``PORT``_rdata   ( WIRE``_rdata   ), \
    .``PORT``_rresp   ( WIRE``_rresp   ), \
    .``PORT``_rid     ( WIRE``_rid     ), \
    .``PORT``_rlast   ( WIRE``_rlast   ), \
    .``PORT``_rvalid  ( WIRE``_rvalid  ), \
    .``PORT``_rready  ( WIRE``_rready  )

`define AXI_INTF_SLV_DEF(NAME, ID) \
    input         [     1: 0] NAME``_awburst, \
    input         [ID - 1: 0] NAME``_awid,    \
    input         [    31: 0] NAME``_awaddr,  \
    input         [     2: 0] NAME``_awsize,  \
    input         [     7: 0] NAME``_awlen,   \
    input                     NAME``_awvalid, \
    output logic              NAME``_awready, \
    input         [     3: 0] NAME``_wstrb,   \
    input         [ID - 1: 0] NAME``_wid,     \
    input         [    31: 0] NAME``_wdata,   \
    input                     NAME``_wlast,   \
    input                     NAME``_wvalid,  \
    output logic              NAME``_wready,  \
    output logic  [ID - 1: 0] NAME``_bid,     \
    output logic  [     1: 0] NAME``_bresp,   \
    output logic              NAME``_bvalid,  \
    input                     NAME``_bready,  \
    input         [    31: 0] NAME``_araddr,  \
    input         [     1: 0] NAME``_arburst, \
    input         [     2: 0] NAME``_arsize,  \
    input         [ID - 1: 0] NAME``_arid,    \
    input         [     7: 0] NAME``_arlen,   \
    input                     NAME``_arvalid, \
    output logic              NAME``_arready, \
    output logic  [    31: 0] NAME``_rdata,   \
    output logic  [     1: 0] NAME``_rresp,   \
    output logic  [ID - 1: 0] NAME``_rid,     \
    output logic              NAME``_rlast,   \
    output logic              NAME``_rvalid,  \
    input                     NAME``_rready

`define AXI_INTF_MST_DEF(NAME, ID) \
    output logic  [     1: 0] NAME``_awburst, \
    output logic  [ID - 1: 0] NAME``_awid,    \
    output logic  [    31: 0] NAME``_awaddr,  \
    output logic  [     2: 0] NAME``_awsize,  \
    output logic  [     7: 0] NAME``_awlen,   \
    output logic              NAME``_awvalid, \
    input                     NAME``_awready, \
    output logic  [     3: 0] NAME``_wstrb,   \
    output logic  [ID - 1: 0] NAME``_wid,     \
    output logic  [    31: 0] NAME``_wdata,   \
    output logic              NAME``_wlast,   \
    output logic              NAME``_wvalid,  \
    input                     NAME``_wready,  \
    input         [ID - 1: 0] NAME``_bid,     \
    input         [     1: 0] NAME``_bresp,   \
    input                     NAME``_bvalid,  \
    output logic              NAME``_bready,  \
    output logic  [    31: 0] NAME``_araddr,  \
    output logic  [     1: 0] NAME``_arburst, \
    output logic  [     2: 0] NAME``_arsize,  \
    output logic  [ID - 1: 0] NAME``_arid,    \
    output logic  [     7: 0] NAME``_arlen,   \
    output logic              NAME``_arvalid, \
    input                     NAME``_arready, \
    input         [    31: 0] NAME``_rdata,   \
    input         [     1: 0] NAME``_rresp,   \
    input         [ID - 1: 0] NAME``_rid,     \
    input                     NAME``_rlast,   \
    input                     NAME``_rvalid,  \
    output logic              NAME``_rready

`define AXI_INTF_DEF(NAME, ID) \
    logic  [     1: 0] NAME``_awburst; \
    logic  [ID - 1: 0] NAME``_awid;    \
    logic  [    31: 0] NAME``_awaddr;  \
    logic  [     2: 0] NAME``_awsize;  \
    logic  [     7: 0] NAME``_awlen;   \
    logic              NAME``_awvalid; \
    logic              NAME``_awready; \
    logic  [     3: 0] NAME``_wstrb;   \
    logic  [ID - 1: 0] NAME``_wid;     \
    logic  [    31: 0] NAME``_wdata;   \
    logic              NAME``_wlast;   \
    logic              NAME``_wvalid;  \
    logic              NAME``_wready;  \
    logic  [ID - 1: 0] NAME``_bid;     \
    logic  [     1: 0] NAME``_bresp;   \
    logic              NAME``_bvalid;  \
    logic              NAME``_bready;  \
    logic  [    31: 0] NAME``_araddr;  \
    logic  [     1: 0] NAME``_arburst; \
    logic  [     2: 0] NAME``_arsize;  \
    logic  [ID - 1: 0] NAME``_arid;    \
    logic  [     7: 0] NAME``_arlen;   \
    logic              NAME``_arvalid; \
    logic              NAME``_arready; \
    logic  [    31: 0] NAME``_rdata;   \
    logic  [     1: 0] NAME``_rresp;   \
    logic  [ID - 1: 0] NAME``_rid;     \
    logic              NAME``_rlast;   \
    logic              NAME``_rvalid;  \
    logic              NAME``_rready;

`endif

module marb (
    input                  clk,
    input                  rstn,

    `AXI_INTF_SLV_DEF(s0, 10),
    `AXI_INTF_SLV_DEF(s1, 10),
    `AXI_INTF_SLV_DEF(s2, 10),
    `AXI_INTF_SLV_DEF(s3, 10),
    `AXI_INTF_SLV_DEF(s4, 10),
    // input                  s0_cs, 
    // input                  s0_we, 
    // input         [ 31: 0] s0_addr,
    // input         [  3: 0] s0_byte,
    // input         [ 31: 0] s0_di,
    // output logic  [ 31: 0] s0_do,
    // output logic           s0_busy,
    // output logic           s0_err,

    // input                  s1_cs, 
    // input                  s1_we, 
    // input         [ 31: 0] s1_addr,
    // input         [  3: 0] s1_byte,
    // input         [ 31: 0] s1_di,
    // output logic  [ 31: 0] s1_do,
    // output logic           s1_busy,
    // output logic           s1_err,

    output logic           m0_cs, 
    output logic           m0_we, 
    output logic  [ 31: 0] m0_addr,
    output logic  [  3: 0] m0_byte,
    output logic  [ 31: 0] m0_di,
    input         [ 31: 0] m0_do,
    input                  m0_busy,

    output logic           m1_cs, 
    output logic           m1_we, 
    output logic  [ 31: 0] m1_addr,
    output logic  [  3: 0] m1_byte,
    output logic  [ 31: 0] m1_di,
    input         [ 31: 0] m1_do,
    input                  m1_busy,

    output logic           m2_psel,
    output logic           m2_penable,
    output logic  [ 31: 0] m2_paddr,
    output logic           m2_pwrite,
    output logic  [  3: 0] m2_pstrb,
    output logic  [ 31: 0] m2_pwdata,
    input         [ 31: 0] m2_prdata,
    input                  m2_pslverr,
    input                  m2_pready,

    output logic           m3_psel,
    output logic           m3_penable,
    output logic  [ 31: 0] m3_paddr,
    output logic           m3_pwrite,
    output logic  [  3: 0] m3_pstrb,
    output logic  [ 31: 0] m3_pwdata,
    input         [ 31: 0] m3_prdata,
    input                  m3_pslverr,
    input                  m3_pready
);

`AXI_INTF_DEF(m0, 13)
`AXI_INTF_DEF(m1, 13)
`AXI_INTF_DEF(m2, 13)
`AXI_INTF_DEF(m3, 13)

axi_5to4_biu u_axi_5to4_biu (
    .aclk       ( clk        ),
    .aresetn    ( rstn       ),

    `AXI_INTF_CONNECT(s0, s0),
    `AXI_INTF_CONNECT(s1, s1),
    `AXI_INTF_CONNECT(s2, s2),
    `AXI_INTF_CONNECT(s3, s3),
    `AXI_INTF_CONNECT(s4, s4),
    `AXI_INTF_CONNECT(m0, m0),
    `AXI_INTF_CONNECT(m1, m1),
    `AXI_INTF_CONNECT(m2, m2),
    `AXI_INTF_CONNECT(m3, m3)
);

axi2mem_bridge u_axi2mem0 (
    .aclk      ( clk        ),
    .aresetn   ( rstn       ),
    // AXI slave port
    `AXI_INTF_CONNECT(s, m0),

    // Memory intface master port
    .m_cs      ( m0_cs      ),
    .m_we      ( m0_we      ),
    .m_addr    ( m0_addr    ),
    .m_byte    ( m0_byte    ),
    .m_di      ( m0_di      ),
    .m_do      ( m0_do      ),
    .m_busy    ( m0_busy    )
);

axi2mem_bridge u_axi2mem1 (
    .aclk      ( clk        ),
    .aresetn   ( rstn       ),
    // AXI slave port
    `AXI_INTF_CONNECT(s, m1),

    // Memory intface master port
    .m_cs      ( m1_cs      ),
    .m_we      ( m1_we      ),
    .m_addr    ( m1_addr    ),
    .m_byte    ( m1_byte    ),
    .m_di      ( m1_di      ),
    .m_do      ( m1_do      ),
    .m_busy    ( m1_busy    )
);

axi2apb_bridge u_axi2apb_m2 (
    .aclk      ( clk        ),
    .aresetn   ( rstn       ),
    `AXI_INTF_CONNECT(s, m2),

    // APB master port
    .psel    ( m2_psel    ),
    .penable ( m2_penable ),
    .paddr   ( m2_paddr   ),
    .pwrite  ( m2_pwrite  ),
    .pstrb   ( m2_pstrb   ),
    .pwdata  ( m2_pwdata  ),
    .prdata  ( m2_prdata  ),
    .pslverr ( m2_pslverr ),
    .pready  ( m2_pready  )
);

axi2apb_bridge u_axi2apb_m3 (
    .aclk      ( clk        ),
    .aresetn   ( rstn       ),
    `AXI_INTF_CONNECT(s, m3),

    // APB master port
    .psel    ( m3_psel    ),
    .penable ( m3_penable ),
    .paddr   ( m3_paddr   ),
    .pwrite  ( m3_pwrite  ),
    .pstrb   ( m3_pstrb   ),
    .pwdata  ( m3_pwdata  ),
    .prdata  ( m3_prdata  ),
    .pslverr ( m3_pslverr ),
    .pready  ( m3_pready  )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/cpu_top.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif


`define ALU_OP_LEN 4
`define CSR_OP_LEN 2

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       `XLEN'h0
`define CAUSE_INSTRUCTION_ACCESS     `XLEN'h1
`define CAUSE_ILLEGAL_INSTRUCTION    `XLEN'h2
`define CAUSE_BREAKPOINT             `XLEN'h3
`define CAUSE_MISALIGNED_LOAD        `XLEN'h4
`define CAUSE_LOAD_ACCESS            `XLEN'h5
`define CAUSE_MISALIGNED_STORE       `XLEN'h6
`define CAUSE_STORE_ACCESS           `XLEN'h7
`define CAUSE_USER_ECALL             `XLEN'h8
`define CAUSE_SUPERVISOR_ECALL       `XLEN'h9
`define CAUSE_HYPERVISOR_ECALL       `XLEN'ha
`define CAUSE_MACHINE_ECALL          `XLEN'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT `XLEN'hc
`define CAUSE_LOAD_PAGE_FAULT        `XLEN'hd
`define CAUSE_STORE_PAGE_FAULT       `XLEN'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`ifdef RV32
  `define SATP_PPN_WIDTH  22
  `define SATP_ASID_WIDTH  9
  `define SATP_MODE_WIDTH  1
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   22+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   31+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 31

`else
  `define SATP_PPN_WIDTH  44
  `define SATP_ASID_WIDTH 16
  `define SATP_MODE_WIDTH  4
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   44+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   60+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 63
`endif

`define PADDR_LEN       (`SATP_PPN_WIDTH + 12)

`endif

module cpu_top (
    input                                    clk,
    input                                    rstn,
    input        [              `XLEN - 1:0] cpu_id,

    // mpu csr
    output logic [                  8 - 1:0] pmpcfg  [16],
    output logic [              `XLEN - 1:0] pmpaddr [16],
    output logic [                  8 - 1:0] pmacfg  [16],
    output logic [              `XLEN - 1:0] pmaaddr [16],

    // mmu csr
    output logic [    `SATP_PPN_WIDTH - 1:0] satp_ppn,
    output logic [   `SATP_ASID_WIDTH - 1:0] satp_asid,
    output logic [   `SATP_MODE_WIDTH - 1:0] satp_mode,
    output logic [                      1:0] prv,
    output logic                             sum,
    output logic                             mprv,
    output logic [                      1:0] mpp,

    // TLB control
    output logic                             tlb_flush_req,
    output logic                             tlb_flush_all_vaddr,
    output logic                             tlb_flush_all_asid,
    output logic [              `XLEN - 1:0] tlb_flush_vaddr,
    output logic [              `XLEN - 1:0] tlb_flush_asid,

    // interrupt interface
    input                                    msip,
    input                                    mtip,
    input                                    meip,

    // inst interface
    output logic                             imem_en,
    output logic [       `IM_ADDR_LEN - 1:0] imem_addr,
    input        [       `IM_DATA_LEN - 1:0] imem_rdata,
    input        [                      1:0] imem_bad,
    input                                    imem_busy,
    output logic                             ic_flush,

    // data interface                             
    output logic                             dmem_en,
    output logic [       `IM_ADDR_LEN - 1:0] dmem_addr,
    output logic                             dmem_write,
    output logic [(`IM_DATA_LEN >> 3) - 1:0] dmem_strb,
    output logic [       `IM_DATA_LEN - 1:0] dmem_wdata,
    input        [       `IM_DATA_LEN - 1:0] dmem_rdata,
    input        [                      1:0] dmem_bad,
    input                                    dmem_busy,

    // debug intface
    input        [                     11:0] dbg_addr,
    input        [                     31:0] dbg_wdata,
    input                                    dbg_gpr_rd,
    input                                    dbg_gpr_wr,
    output logic [                     31:0] dbg_gpr_out,
    input                                    dbg_csr_rd,
    input                                    dbg_csr_wr,
    output logic [                     31:0] dbg_csr_out,
    output logic [       `IM_ADDR_LEN - 1:0] dbg_pc_out,
    input                                    dbg_exec,
    input        [       `IM_ADDR_LEN - 1:0] dbg_inst,
    input                                    attach,
    output logic                             halted
);

logic                             rstn_sync;
logic                             wakeup_event;
logic                             sleep;
logic                             stall_wfi;
logic [                      4:0] inst_valid;
logic [       `IM_ADDR_LEN - 1:0] irq_vec;
logic [       `IM_ADDR_LEN - 1:0] ret_epc;

// Hazard Control Unit
logic                             if_stall;
logic                             id_stall;
logic                             exe_stall;
logic                             ma_stall;
logic                             mr_stall;
logic                             wb_stall;
logic                             if_flush;
logic                             id_flush;
logic                             exe_flush;
logic                             ma_flush;
logic                             mr_flush;
logic                             wb_flush;
logic                             if_flush_force;
logic                             id_flush_force;
logic                             exe_flush_force;
logic                             ma_flush_force;
logic                             mr_flush_force;
logic                             wb_flush_force;

// IF stage
logic                             if_pc_jump_en;
logic [       `IM_ADDR_LEN - 1:0] if_pc_jump;
logic                             if_pc_alu_en;
logic [       `IM_ADDR_LEN - 1:0] if_pc_alu;
logic [       `IM_ADDR_LEN - 1:0] if_pc;
logic [       `IM_DATA_LEN - 1:0] if_inst;
logic                             if_inst_valid;
logic                             if_inst_misaligned;
logic                             if_inst_page_fault;
logic                             if_inst_xes_fault;

// IF/ID pipeline
logic [       `IM_DATA_LEN - 1:0] if2id_inst;
logic                             if2id_inst_valid;
logic                             if2id_inst_misaligned;
logic                             if2id_inst_page_fault;
logic                             if2id_inst_xes_fault;
logic [       `IM_ADDR_LEN - 1:0] if2id_pc;
logic                             if2id_attach;

// ID stage
logic [                      4:0] id_rd_addr;
logic [                      4:0] id_rs1_addr;
logic [                      4:0] id_rs2_addr;
logic [              `XLEN - 1:0] id_gpr_rs1_data;
logic [              `XLEN - 1:0] id_gpr_rs2_data;
logic [              `XLEN - 1:0] id_rs1_data;
logic [              `XLEN - 1:0] id_rs2_data;
logic [                     11:0] id_csr_addr;
logic [              `XLEN - 1:0] id_imm;

logic [                      1:0] id_prv_req;
logic                             id_ill_inst;
logic                             id_fence;
logic                             id_fence_i;
logic                             id_ecall;
logic                             id_ebreak;
logic                             id_wfi;
logic                             id_sret;
logic                             id_mret;
logic                             id_jump;
logic                             id_jump_alu;

logic [        `ALU_OP_LEN - 1:0] id_alu_op;
logic                             id_rs1_zero_sel;
logic                             id_rs2_imm_sel;
logic                             id_pc_imm_sel;
logic                             id_branch;
logic                             id_branch_zcmp;
logic [        `CSR_OP_LEN - 1:0] id_csr_op;
logic                             id_uimm_rs1_sel;
logic                             id_pc_alu_sel;
logic                             id_csr_alu_sel;
logic                             id_mem_req;
logic                             id_mem_wr;
logic [(`DM_DATA_LEN >> 3) - 1:0] id_mem_byte;
logic                             id_mem_sign_ext;
logic                             id_tlb_flush_req;
logic                             id_tlb_flush_all_vaddr;
logic                             id_tlb_flush_all_asid;

logic                             id_mem_cal_sel;
logic                             id_rd_wr;

logic                             id_hazard;
logic                             id_csr_rd;
logic                             id_csr_wr;
logic                             id_pmu_csr_wr;
logic                             id_fpu_csr_wr;
logic                             id_dbg_csr_wr;
logic                             id_mmu_csr_wr;
logic                             id_mpu_csr_wr;
logic                             id_sru_csr_wr;
logic [              `XLEN - 1:0] id_csr_rdata;
logic [              `XLEN - 1:0] id_pmu_csr_rdata;
logic [              `XLEN - 1:0] id_fpu_csr_rdata;
logic [              `XLEN - 1:0] id_dbg_csr_rdata;
logic [              `XLEN - 1:0] id_mmu_csr_rdata;
logic [              `XLEN - 1:0] id_mpu_csr_rdata;
logic [              `XLEN - 1:0] id_sru_csr_rdata;

// ID/EXE pipeline
logic [       `IM_ADDR_LEN - 1:0] id2exe_pc;
logic [       `IM_DATA_LEN - 1:0] id2exe_inst;
logic                             id2exe_inst_valid;
logic [                      4:0] id2exe_rd_addr;
logic [                      4:0] id2exe_rs1_addr;
logic [                      4:0] id2exe_rs2_addr;
logic [              `XLEN - 1:0] id2exe_rs1_data;
logic [              `XLEN - 1:0] id2exe_rs2_data;
logic [                     11:0] id2exe_csr_waddr;
logic [              `XLEN - 1:0] id2exe_csr_rdata;
logic [              `XLEN - 1:0] id2exe_imm;

logic [        `ALU_OP_LEN - 1:0] id2exe_alu_op;
logic                             id2exe_rs1_zero_sel;
logic                             id2exe_rs2_imm_sel;
logic                             id2exe_pc_imm_sel;
logic                             id2exe_jump_alu;
logic                             id2exe_branch;
logic                             id2exe_branch_zcmp;
logic [        `CSR_OP_LEN - 1:0] id2exe_csr_op;
logic                             id2exe_uimm_rs1_sel;
logic                             id2exe_csr_rd;
logic                             id2exe_pmu_csr_wr;
logic                             id2exe_fpu_csr_wr;
logic                             id2exe_dbg_csr_wr;
logic                             id2exe_mmu_csr_wr;
logic                             id2exe_mpu_csr_wr;
logic                             id2exe_sru_csr_wr;

logic                             id2exe_pc_alu_sel;
logic                             id2exe_csr_alu_sel;
logic                             id2exe_mem_req;
logic                             id2exe_mem_wr;
logic [(`DM_DATA_LEN >> 3) - 1:0] id2exe_mem_byte;
logic                             id2exe_mem_sign_ext;

logic                             id2exe_mem_cal_sel;
logic                             id2exe_rd_wr;
logic                             id2exe_wfi;
logic                             id2exe_ecall;
logic                             id2exe_ebreak;
logic                             id2exe_sret;
logic                             id2exe_mret;
logic                             id2exe_ill_inst;
logic [                      1:0] id2exe_prv_req;
logic                             id2exe_inst_misaligned;
logic                             id2exe_inst_page_fault;
logic                             id2exe_inst_xes_fault;
logic                             id2exe_tlb_flush_req;
logic                             id2exe_tlb_flush_all_vaddr;
logic                             id2exe_tlb_flush_all_asid;
logic                             id2exe_fence_i;
logic                             id2exe_attach;
logic                             id2exe_ext_csr_wr;
logic [              `XLEN - 1:0] id2exe_ext_csr_wdata;

// EXE stage
logic                             exe_alu_zero;
logic                             exe_branch_match;
logic [              `XLEN - 1:0] exe_pc_imm;
logic [              `XLEN - 1:0] exe_pc_add_4;
logic [              `XLEN - 1:0] exe_rs1_data;
logic [              `XLEN - 1:0] exe_rs2_data;
logic [              `XLEN - 1:0] exe_alu_src1;
logic [              `XLEN - 1:0] exe_alu_src2;
logic [              `XLEN - 1:0] exe_alu_out;
logic [              `XLEN - 1:0] exe_pc2rd;
logic                             exe_hazard;
logic [              `XLEN - 1:0] exe_csr_src1;
logic [              `XLEN - 1:0] exe_csr_src2;
logic [              `XLEN - 1:0] exe_csr_wdata;
logic                             exe_pmu_csr_wr;
logic                             exe_fpu_csr_wr;
logic                             exe_dbg_csr_wr;
logic                             exe_mmu_csr_wr;
logic                             exe_mpu_csr_wr;
logic                             exe_sru_csr_wr;
logic                             exe_sret;
logic                             exe_mret;
logic                             exe_satp_upd;
logic                             exe_inst_misaligned;
logic [              `XLEN - 1:0] exe_inst_misaligned_badaddr;
logic                             exe_mstatus_tsr;
logic                             exe_mstatus_tvm;
logic                             exe_irq_en;
logic [                      1:0] exe_prv;
logic                             exe_trap_en;
logic [       `IM_ADDR_LEN - 1:0] exe_trap_epc;
logic [              `XLEN - 1:0] exe_trap_cause;
logic [              `XLEN - 1:0] exe_trap_val;
logic [              `XLEN - 1:0] exe_cause;
logic [              `XLEN - 1:0] exe_tval;
logic [    `SATP_PPN_WIDTH - 1:0] exe_satp_ppn;
logic [   `SATP_ASID_WIDTH - 1:0] exe_satp_asid;
logic [   `SATP_MODE_WIDTH - 1:0] exe_satp_mode;

// EXE/MEM pipeline
logic [       `IM_ADDR_LEN - 1:0] exe2ma_pc;
logic [       `IM_DATA_LEN - 1:0] exe2ma_inst;
logic                             exe2ma_inst_valid;
logic                             exe2ma_mem_req;
logic                             exe2ma_mem_wr;
logic [(`DM_DATA_LEN >> 3) - 1:0] exe2ma_mem_byte;
logic                             exe2ma_mem_sign_ext;
logic [              `XLEN - 1:0] exe2ma_csr_rdata;
logic                             exe2ma_pc_alu_sel;
logic                             exe2ma_csr_alu_sel;
logic                             exe2ma_mem_cal_sel;
logic                             exe2ma_rd_wr;
logic [                      4:0] exe2ma_rd_addr;
logic [                      4:0] exe2ma_rs1_addr;
logic [                      4:0] exe2ma_rs2_addr;
logic [              `XLEN - 1:0] exe2ma_alu_out;
logic [              `XLEN - 1:0] exe2ma_pc2rd;
logic [              `XLEN - 1:0] exe2ma_rs1_data;
logic [              `XLEN - 1:0] exe2ma_rs2_data;
logic                             exe2ma_csr_wr;
logic [                     11:0] exe2ma_csr_waddr;
logic [              `XLEN - 1:0] exe2ma_csr_wdata;
logic                             exe2ma_wfi;
logic [                      1:0] exe2ma_prv;
logic                             exe2ma_trap_en;
logic [              `XLEN - 1:0] exe2ma_cause;
logic [              `XLEN - 1:0] exe2ma_tval;
logic [       `IM_ADDR_LEN - 1:0] exe2ma_epc;
logic                             exe2ma_tlb_flush_req;
logic                             exe2ma_tlb_flush_all_vaddr;
logic                             exe2ma_tlb_flush_all_asid;
logic                             exe2ma_fence_i;
logic                             exe2ma_attach;

// MA stage
logic [              `XLEN - 1:0] ma_rd_data;

logic [              `XLEN - 1:0] ma_rs1_data;
logic                             ma_dpu_req;
logic                             ma_dpu_wr;
logic [(`DM_DATA_LEN >> 3) - 1:0] ma_dpu_byte;
logic [       `DM_ADDR_LEN - 1:0] ma_dpu_addr;
logic [       `DM_DATA_LEN - 1:0] ma_dpu_wdata;

logic [       `DM_DATA_LEN - 1:0] ma_dpu_rdata;
logic                             ma_dpu_hazard;
logic                             ma_dpu_fault;

logic [       `DM_ADDR_LEN - 1:0] ma_bad_dxes_val;
logic                             ma_load_misaligned;
logic                             ma_load_page_fault;
logic                             ma_load_xes_fault;
logic                             ma_store_misaligned;
logic                             ma_store_page_fault;
logic                             ma_store_xes_fault;
logic [       `IM_ADDR_LEN - 1:0] ma_dpu_pc;
logic                             ma_pipe_restart;

// MA/MR pipeline
logic [       `IM_ADDR_LEN - 1:0] ma2mr_pc;
logic [       `IM_DATA_LEN - 1:0] ma2mr_inst;
logic                             ma2mr_inst_valid;
logic [                      4:0] ma2mr_rd_addr;
logic                             ma2mr_rd_wr;
logic [(`DM_DATA_LEN >> 3) - 1:0] ma2mr_mem_byte;
logic                             ma2mr_mem_sign_ext;
logic                             ma2mr_mem_cal_sel;
logic [              `XLEN - 1:0] ma2mr_rd_data;
logic [              `XLEN - 1:0] ma2mr_pc2rd;
logic [       `DM_ADDR_LEN - 1:0] ma2mr_mem_addr;
logic [       `DM_DATA_LEN - 1:0] ma2mr_mem_wdata;
logic                             ma2mr_mem_req;
logic                             ma2mr_mem_wr;
logic                             ma2mr_csr_wr;
logic [                     11:0] ma2mr_csr_waddr;
logic [              `XLEN - 1:0] ma2mr_csr_wdata;
logic                             ma2mr_wfi;
logic [                      1:0] ma2mr_prv;
logic                             ma2mr_trap_en;
logic [              `XLEN - 1:0] ma2mr_cause;
logic [              `XLEN - 1:0] ma2mr_tval;
logic [       `IM_ADDR_LEN - 1:0] ma2mr_epc;
logic                             ma2mr_attach;
logic                             ma2mr_tlb_flush_req;
logic                             ma2mr_tlb_flush_all_vaddr;
logic                             ma2mr_tlb_flush_all_asid;
logic [              `XLEN - 1:0] ma2mr_tlb_flush_vaddr;
logic [              `XLEN - 1:0] ma2mr_tlb_flush_asid;
logic                             ma2mr_fence_i;
logic                             ma2mr_pipe_restart;

// MR stage
logic [              `XLEN - 1:0] mr_rd_data;
logic                             mr_pipe_restart;

// MR/WB pipeline
logic [       `IM_ADDR_LEN - 1:0] mr2wb_pc;
logic [       `IM_DATA_LEN - 1:0] mr2wb_inst;
logic                             mr2wb_inst_valid;
logic [                      4:0] mr2wb_rd_addr;
logic                             mr2wb_rd_wr;
logic [(`DM_DATA_LEN >> 3) - 1:0] mr2wb_mem_byte;
logic                             mr2wb_mem_sign_ext;
logic [              `XLEN - 1:0] mr2wb_rd_data;
logic [       `DM_ADDR_LEN - 1:0] mr2wb_mem_addr;
logic [       `DM_DATA_LEN - 1:0] mr2wb_mem_wdata;
logic                             mr2wb_mem_req;
logic                             mr2wb_mem_wr;
logic                             mr2wb_csr_wr;
logic [                     11:0] mr2wb_csr_waddr;
logic [              `XLEN - 1:0] mr2wb_csr_wdata;
logic                             mr2wb_wfi;
logic [                      1:0] mr2wb_prv;
logic                             mr2wb_trap_en;
logic [              `XLEN - 1:0] mr2wb_cause;
logic [              `XLEN - 1:0] mr2wb_tval;
logic [       `IM_ADDR_LEN - 1:0] mr2wb_epc;
logic                             mr2wb_attach;

// WB stage
logic [              `XLEN - 1:0] wb_rd_data;
logic                             wb_rd_wr;
logic                             wb_inst_valid;
logic                             wb_wfi;

// Forward
logic                             fwd_wb2id_rd_rs1;
logic                             fwd_wb2id_rd_rs2;
logic                             fwd_ma2exe_rd_rs1;
logic                             fwd_ma2exe_rd_rs2;
logic                             fwd_mr2exe_rd_rs1;
logic                             fwd_mr2exe_rd_rs2;
logic                             fwd_wb2exe_rd_rs1;
logic                             fwd_wb2exe_rd_rs2;
logic                             fwd_mr2ma_rd_rs1;
logic                             fwd_mr2ma_rd_rs2;
logic                             fwd_wb2ma_rd_rs1;
logic                             fwd_wb2ma_rd_rs2;

parameter [`CSR_OP_LEN - 1:0] CSR_OP_NONE = `CSR_OP_LEN'b00,
                              CSR_OP_SET  = `CSR_OP_LEN'b01,
                              CSR_OP_CLR  = `CSR_OP_LEN'b10;

resetn_synchronizer u_sync (
    .clk        ( clk       ),
    .rstn_async ( rstn      ),
    .rstn_sync  ( rstn_sync )
);

assign stall_wfi  = (exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event;
assign inst_valid = {mr2wb_inst_valid, exe2ma_inst_valid, id2exe_inst_valid, if2id_inst_valid, 1'b1};

clkmnt u_clkmnt (
    .clk_free ( clk          ),
    .rstn     ( rstn_sync    ),
    .wfi      ( wb_wfi       ),
    .wakeup   ( wakeup_event ),
    .clk_ret  ( clk_wfi      ),
    .sleep    ( sleep        )
);

hzu u_hzu (
    .inst_valid      ( inst_valid      ),
    .pc_jump_en      ( if_pc_jump_en   ),
    .pc_alu_en       ( if_pc_alu_en    ),
    .irq_en          ( exe_irq_en      ),
    .trap_en         ( exe_trap_en     ),
    .eret_en         ( exe_eret_en     ),
    .pipe_restart_en ( mr_pipe_restart ),
    .id_hazard       ( id_hazard       ),
    .exe_hazard      ( exe_hazard      ),
    .dpu_hazard      ( ma_dpu_hazard   ),
    .dpu_fault       ( ma_dpu_fault    ),
    .if_stall        ( if_stall        ),
    .id_stall        ( id_stall        ),
    .exe_stall       ( exe_stall       ),
    .ma_stall        ( ma_stall        ),
    .mr_stall        ( mr_stall        ),
    .wb_stall        ( wb_stall        ),
    .if_flush        ( if_flush        ),
    .id_flush        ( id_flush        ),
    .exe_flush       ( exe_flush       ),
    .ma_flush        ( ma_flush        ),
    .mr_flush        ( mr_flush        ),
    .wb_flush        ( wb_flush        ),
    .if_flush_force  ( if_flush_force  ),
    .id_flush_force  ( id_flush_force  ),
    .exe_flush_force ( exe_flush_force ),
    .ma_flush_force  ( ma_flush_force  ),
    .mr_flush_force  ( mr_flush_force  ),
    .wb_flush_force  ( wb_flush_force  )
);

// IF stage
ifu u_ifu (
    .clk             ( clk                          ),
    .rstn            ( rstn_sync                    ),
    .irq_en          ( exe_irq_en | exe_trap_en     ),
    .irq_vec         ( irq_vec                      ),
    .eret_en         ( exe_eret_en                  ),
    .ret_epc         ( ret_epc                      ),
    .pc_jump_en      ( if_pc_jump_en                ),
    .pc_jump         ( if_pc_jump                   ),
    .pc_alu_en       ( if_pc_alu_en                 ),
    .pc_alu          ( if_pc_alu                    ),
    .pipe_restart_en ( mr_pipe_restart              ),
    .pipe_restart    ( ma2mr_pc2rd                  ),
    .imem_req        ( imem_en                      ),
    .imem_addr       ( imem_addr                    ),
    .imem_rdata      ( imem_rdata                   ),
    .imem_bad        ( imem_bad                     ),
    .imem_busy       ( imem_busy                    ),
    .pc              ( if_pc                        ),
    .inst            ( if_inst                      ),
    .inst_valid      ( if_inst_valid                ),
    .misaligned      ( if_inst_misaligned           ),
    .page_fault      ( if_inst_page_fault           ),
    .xes_fault       ( if_inst_xes_fault            ),
    .flush           ( if_flush                     ),
    .stall           ( if_stall | stall_wfi | sleep ),
    .attach          ( attach                       ),
    .dbg_exec        ( dbg_exec                     ),
    .dbg_inst        ( dbg_inst                     )
);

assign exe_branch_match = id2exe_branch & (id2exe_branch_zcmp == exe_alu_zero);

assign if_pc_jump_en = id_jump & if2id_inst_valid & ~id_stall & ~id_flush & ~stall_wfi;
assign if_pc_jump    = id_imm + if2id_pc;
assign if_pc_alu_en  = (id2exe_jump_alu | exe_branch_match) & id2exe_inst_valid & ~exe_stall;
assign if_pc_alu     = ({`IM_ADDR_LEN{id2exe_jump_alu}}  & exe_alu_out) |
                       ({`IM_ADDR_LEN{exe_branch_match}} & exe_pc_imm[`IM_ADDR_LEN - 1:0] );

// IF/ID pipeline
always_ff @(posedge clk_wfi or negedge rstn_sync) begin
    if (~rstn_sync) begin
        if2id_pc              <= `IM_ADDR_LEN'b0;
        if2id_inst            <= `IM_DATA_LEN'b0;
        if2id_inst_valid      <= 1'b0;
        if2id_inst_misaligned <= 1'b0;
        if2id_inst_page_fault <= 1'b0;
        if2id_inst_xes_fault  <= 1'b0;
        if2id_attach          <= 1'b0;
    end
    else begin
        if ((~id_stall & ~stall_wfi) | if_flush_force) begin
            if2id_pc              <= if_pc;
            if2id_inst            <= if_inst;
            if2id_inst_valid      <= ~if_flush & if_inst_valid;
            if2id_inst_misaligned <= if_inst_misaligned;
            if2id_inst_page_fault <= if_inst_page_fault;
            if2id_inst_xes_fault  <= if_inst_xes_fault;
            if2id_attach          <= attach;
        end
    end
end

// ID stage
idu u_idu (
    .clk                 ( clk_wfi                ),
    .rstn                ( rstn_sync              ),
    .inst                ( if2id_inst             ),
    .inst_valid          ( if2id_inst_valid       ),
    .pc                  ( if2id_pc               ),
    .rd_wr_i             ( wb_rd_wr               ),
    .rd_addr_i           ( mr2wb_rd_addr          ),
    .rd_data             ( wb_rd_data             ),
    .rd_addr_o           ( id_rd_addr             ),
    .rs1_addr            ( id_rs1_addr            ),
    .rs2_addr            ( id_rs2_addr            ),
    .rs1_data            ( id_gpr_rs1_data        ),
    .rs2_data            ( id_gpr_rs2_data        ),
    .csr_addr            ( id_csr_addr            ),
    .imm                 ( id_imm                 ),
    // Control
    .prv_req             ( id_prv_req             ),
    .ill_inst            ( id_ill_inst            ),
    .fence               ( id_fence               ),
    .fence_i             ( id_fence_i             ),
    .ecall               ( id_ecall               ),
    .ebreak              ( id_ebreak              ),
    .wfi                 ( id_wfi                 ),
    .sret                ( id_sret                ),
    .mret                ( id_mret                ),
    .jump                ( id_jump                ),
    .jump_alu            ( id_jump_alu            ),
    // For EXE stage
    .alu_op              ( id_alu_op              ),
    .rs1_zero_sel        ( id_rs1_zero_sel        ),
    .rs2_imm_sel         ( id_rs2_imm_sel         ),
    .pc_imm_sel          ( id_pc_imm_sel          ),
    .branch              ( id_branch              ),
    .branch_zcmp         ( id_branch_zcmp         ),
    .csr_op              ( id_csr_op              ),
    .uimm_rs1_sel        ( id_uimm_rs1_sel        ),
    .csr_rd              ( id_csr_rd              ),
    .csr_wr              ( id_csr_wr              ),
    // For MEM stage
    .pc_alu_sel          ( id_pc_alu_sel          ),
    .csr_alu_sel         ( id_csr_alu_sel         ),
    .mem_req             ( id_mem_req             ),
    .mem_wr              ( id_mem_wr              ),
    .mem_byte            ( id_mem_byte            ),
    .mem_sign_ext        ( id_mem_sign_ext        ),
    .tlb_flush_req       ( id_tlb_flush_req       ),
    .tlb_flush_all_vaddr ( id_tlb_flush_all_vaddr ),
    .tlb_flush_all_asid  ( id_tlb_flush_all_asid  ),
    // For WB stage
    .mem_cal_sel         ( id_mem_cal_sel         ),
    .rd_wr_o             ( id_rd_wr               ),

    .halted              ( halted                 ),
    .dbg_addr            ( dbg_addr               ),
    .dbg_wdata           ( dbg_wdata              ),
    .dbg_gpr_rd          ( dbg_gpr_rd             ),
    .dbg_gpr_wr          ( dbg_gpr_wr             ),
    .dbg_gpr_out         ( dbg_gpr_out            ),
    .dbg_csr_rd          ( dbg_csr_rd             ),
    .dbg_csr_wr          ( dbg_csr_wr             )
);

assign id_fpu_csr_rdata = `XLEN'b0;
assign id_dbg_csr_rdata = `XLEN'b0;

csr u_csr (
    .clk           ( clk_wfi          ),
    .rstn          ( rstn_sync        ),
    .rd            ( id_csr_rd        ),
    .wr            ( id_csr_wr        ),
    .raddr         ( id_csr_addr      ),
    .rdata         ( id_csr_rdata     ),
    .pmu_csr_wr    ( id_pmu_csr_wr    ),
    .fpu_csr_wr    ( id_fpu_csr_wr    ),
    .dbg_csr_wr    ( id_dbg_csr_wr    ),
    .mmu_csr_wr    ( id_mmu_csr_wr    ),
    .mpu_csr_wr    ( id_mpu_csr_wr    ),
    .sru_csr_wr    ( id_sru_csr_wr    ),
    .pmu_csr_rdata ( id_pmu_csr_rdata ),
    .fpu_csr_rdata ( id_fpu_csr_rdata ),
    .dbg_csr_rdata ( id_dbg_csr_rdata ),
    .mmu_csr_rdata ( id_mmu_csr_rdata ),
    .mpu_csr_rdata ( id_mpu_csr_rdata ),
    .sru_csr_rdata ( id_sru_csr_rdata )
);

assign dbg_csr_out = id_csr_rdata;

// ID forward
assign fwd_wb2id_rd_rs1 = mr2wb_rd_wr & (id_rs1_addr == mr2wb_rd_addr );
assign fwd_wb2id_rd_rs2 = mr2wb_rd_wr & (id_rs2_addr == mr2wb_rd_addr );

assign id_rs1_data = fwd_wb2id_rd_rs1 ? mr2wb_rd_data :
                                        id_gpr_rs1_data;
assign id_rs2_data = fwd_wb2id_rd_rs2 ? mr2wb_rd_data :
                                        id_gpr_rs2_data;

// ID Hazard
assign id_hazard = (id_csr_rd &&
                    (exe_pmu_csr_wr | exe_fpu_csr_wr | exe_dbg_csr_wr |
                     exe_mmu_csr_wr | exe_mpu_csr_wr | exe_sru_csr_wr) &&
                    (id_csr_addr == id2exe_csr_waddr)) ||
                   (id_jump && (exe2ma_mem_req || id2exe_mem_req));


// ID/EXE pipeline
always_ff @(posedge clk_wfi or negedge rstn_sync) begin
    if (~rstn_sync) begin
        id2exe_pc                  <= `IM_ADDR_LEN'b0;
        id2exe_inst                <= `IM_DATA_LEN'b0;
        id2exe_inst_valid          <= 1'b0;
        id2exe_rd_addr             <= 5'b0;
        id2exe_rs1_addr            <= 5'b0;
        id2exe_rs2_addr            <= 5'b0;
        id2exe_rs1_data            <= `XLEN'b0;
        id2exe_rs2_data            <= `XLEN'b0;
        id2exe_csr_waddr           <= 12'b0;
        id2exe_csr_rdata           <= `XLEN'b0;
        id2exe_imm                 <= `XLEN'b0;
        id2exe_alu_op              <= `ALU_OP_LEN'b0;
        id2exe_rs1_zero_sel        <= 1'b0;
        id2exe_rs2_imm_sel         <= 1'b0;
        id2exe_pc_imm_sel          <= 1'b0;
        id2exe_jump_alu            <= 1'b0;
        id2exe_branch              <= 1'b0;
        id2exe_branch_zcmp         <= 1'b0;
        id2exe_csr_op              <= `CSR_OP_LEN'b0;
        id2exe_uimm_rs1_sel        <= 1'b0;
        id2exe_csr_rd              <= 1'b0;
        id2exe_pmu_csr_wr          <= 1'b0;
        id2exe_fpu_csr_wr          <= 1'b0;
        id2exe_dbg_csr_wr          <= 1'b0;
        id2exe_mmu_csr_wr          <= 1'b0;
        id2exe_mpu_csr_wr          <= 1'b0;
        id2exe_sru_csr_wr          <= 1'b0;
        id2exe_pc_alu_sel          <= 1'b0;
        id2exe_csr_alu_sel         <= 1'b0;
        id2exe_mem_req             <= 1'b0;
        id2exe_mem_wr              <= 1'b0;
        id2exe_mem_byte            <= {(`DM_DATA_LEN >> 3){1'b0}};
        id2exe_mem_sign_ext        <= 1'b0;
        id2exe_mem_cal_sel         <= 1'b0;
        id2exe_rd_wr               <= 1'b0;
        id2exe_wfi                 <= 1'b0;
        id2exe_ecall               <= 1'b0;
        id2exe_ebreak              <= 1'b0;
        id2exe_sret                <= 1'b0;
        id2exe_mret                <= 1'b0;
        id2exe_ill_inst            <= 1'b0;
        id2exe_prv_req             <= 2'b0;
        id2exe_inst_misaligned     <= 1'b0;
        id2exe_inst_page_fault     <= 1'b0;
        id2exe_inst_xes_fault      <= 1'b0;
        id2exe_tlb_flush_req       <= 1'b0;
        id2exe_tlb_flush_all_vaddr <= 1'b0;
        id2exe_tlb_flush_all_asid  <= 1'b0;
        id2exe_fence_i             <= 1'b0;
        id2exe_attach              <= 1'b0;
        id2exe_ext_csr_wr          <= 1'b0;
        id2exe_ext_csr_wdata       <= 32'b0;
    end
    else begin
        if ((~exe_stall & ~stall_wfi) | id_flush_force) begin
            id2exe_pc                  <= if2id_pc;
            id2exe_inst                <= if2id_inst;
            id2exe_inst_valid          <= ~id_flush & if2id_inst_valid;
            id2exe_rd_addr             <= id_rd_addr;
            id2exe_rs1_addr            <= id_rs1_addr;
            id2exe_rs2_addr            <= id_rs2_addr;
            id2exe_rs1_data            <= id_rs1_data;
            id2exe_rs2_data            <= id_rs2_data;
            id2exe_csr_waddr           <= id_csr_addr;
            id2exe_csr_rdata           <= id_csr_rdata;
            id2exe_imm                 <= id_imm;
            id2exe_alu_op              <= id_alu_op;
            id2exe_rs1_zero_sel        <= id_rs1_zero_sel;
            id2exe_rs2_imm_sel         <= id_rs2_imm_sel;
            id2exe_pc_imm_sel          <= id_pc_imm_sel;
            id2exe_jump_alu            <= id_jump_alu;
            id2exe_branch              <= id_branch;
            id2exe_branch_zcmp         <= id_branch_zcmp;
            id2exe_csr_op              <= id_csr_op;
            id2exe_uimm_rs1_sel        <= id_uimm_rs1_sel;
            id2exe_csr_rd              <= ~id_flush & id_csr_rd;
            id2exe_pmu_csr_wr          <= ~id_flush & id_pmu_csr_wr;
            id2exe_fpu_csr_wr          <= ~id_flush & id_fpu_csr_wr;
            id2exe_dbg_csr_wr          <= ~id_flush & id_dbg_csr_wr;
            id2exe_mmu_csr_wr          <= ~id_flush & id_mmu_csr_wr;
            id2exe_mpu_csr_wr          <= ~id_flush & id_mpu_csr_wr;
            id2exe_sru_csr_wr          <= ~id_flush & id_sru_csr_wr;
            id2exe_pc_alu_sel          <= id_pc_alu_sel;
            id2exe_csr_alu_sel         <= id_csr_alu_sel;
            id2exe_mem_req             <= ~id_flush & id_mem_req;
            id2exe_mem_wr              <= ~id_flush & id_mem_wr;
            id2exe_mem_byte            <= id_mem_byte;
            id2exe_mem_sign_ext        <= id_mem_sign_ext;
            id2exe_mem_cal_sel         <= id_mem_cal_sel;
            id2exe_rd_wr               <= ~id_flush & id_rd_wr;
            id2exe_wfi                 <= ~id_flush & id_wfi;
            id2exe_ecall               <= ~id_flush & id_ecall;
            id2exe_ebreak              <= ~id_flush & id_ebreak;
            id2exe_sret                <= ~id_flush & id_sret;
            id2exe_mret                <= ~id_flush & id_mret;
            id2exe_ill_inst            <= ~id_flush & id_ill_inst;
            id2exe_prv_req             <= id_prv_req;
            id2exe_inst_misaligned     <= if_pc_jump_en & |if_pc_jump[1];
            id2exe_inst_page_fault     <= if2id_inst_page_fault;
            id2exe_inst_xes_fault      <= if2id_inst_xes_fault;
            id2exe_tlb_flush_req       <= ~id_flush & id_tlb_flush_req;
            id2exe_tlb_flush_all_vaddr <= id_tlb_flush_all_vaddr;
            id2exe_tlb_flush_all_asid  <= id_tlb_flush_all_asid;
            id2exe_fence_i             <= ~id_flush & id_fence_i;
            id2exe_attach              <= if2id_attach;
            id2exe_ext_csr_wr          <= dbg_csr_wr;
            id2exe_ext_csr_wdata       <= dbg_wdata;
        end
        else begin
            id2exe_rs1_data            <= exe_rs1_data;
            id2exe_rs2_data            <= exe_rs2_data;
        end
    end
end

// EXE stage
// RS1 Forward
assign fwd_ma2exe_rd_rs1 = exe2ma_rd_wr    & (id2exe_rs1_addr == exe2ma_rd_addr) &
                          ~(exe2ma_mem_req & ~exe2ma_mem_wr & exe2ma_mem_cal_sel);
assign fwd_mr2exe_rd_rs1 = ma2mr_rd_wr     & (id2exe_rs1_addr == ma2mr_rd_addr ) &
                          ~(ma2mr_mem_req & ~ma2mr_mem_wr & ma2mr_mem_cal_sel);
assign fwd_wb2exe_rd_rs1 = mr2wb_rd_wr     & (id2exe_rs1_addr == mr2wb_rd_addr );
assign exe_rs1_data       = fwd_ma2exe_rd_rs1 ? ma_rd_data    :
                            fwd_mr2exe_rd_rs1 ? ma2mr_rd_data :
                            fwd_wb2exe_rd_rs1 ? wb_rd_data    :
                                                id2exe_rs1_data;

// RS2 Forward
assign fwd_ma2exe_rd_rs2 = exe2ma_rd_wr    & (id2exe_rs2_addr == exe2ma_rd_addr) &
                          ~(exe2ma_mem_req & ~exe2ma_mem_wr & exe2ma_mem_cal_sel);
assign fwd_mr2exe_rd_rs2 = ma2mr_rd_wr     & (id2exe_rs2_addr == ma2mr_rd_addr ) &
                          ~(ma2mr_mem_req & ~ma2mr_mem_wr & ma2mr_mem_cal_sel);
assign fwd_wb2exe_rd_rs2 = mr2wb_rd_wr     & (id2exe_rs2_addr == mr2wb_rd_addr);
assign exe_rs2_data       = fwd_ma2exe_rd_rs2 ? ma_rd_data    :
                            fwd_mr2exe_rd_rs2 ? ma2mr_rd_data :
                            fwd_wb2exe_rd_rs2 ? wb_rd_data    :
                                                id2exe_rs2_data;

assign exe_hazard   = (exe2ma_mem_req & ~exe2ma_mem_wr & exe2ma_mem_cal_sel) &
                      (exe2ma_rd_wr & (id2exe_rs1_addr == exe2ma_rd_addr) |
                       exe2ma_rd_wr & (id2exe_rs2_addr == exe2ma_rd_addr)) ||
                      (ma2mr_mem_req & ~ma2mr_mem_wr & ma2mr_mem_cal_sel) &
                      (ma2mr_rd_wr & (id2exe_rs1_addr == ma2mr_rd_addr) |
                       ma2mr_rd_wr & (id2exe_rs2_addr == ma2mr_rd_addr)) ||
                      (exe2ma_mem_req   & (id2exe_pmu_csr_wr | id2exe_fpu_csr_wr | id2exe_dbg_csr_wr | 
                       id2exe_mmu_csr_wr | id2exe_mpu_csr_wr | id2exe_sru_csr_wr | id2exe_branch |
                       id2exe_sret | id2exe_mret)) ||
                       ma_pipe_restart;

assign exe_pc_imm   = {{(`XLEN - `IM_ADDR_LEN){id2exe_pc[`IM_ADDR_LEN - 1]}}, id2exe_pc} + id2exe_imm;
assign exe_pc_add_4 = {{(`XLEN - `IM_ADDR_LEN){id2exe_pc[`IM_ADDR_LEN - 1]}}, id2exe_pc} + `XLEN'h4;
assign exe_pc2rd    = id2exe_pc_imm_sel   ? exe_pc_imm : exe_pc_add_4;

assign exe_alu_src1 = id2exe_rs1_zero_sel ? exe_rs1_data : `XLEN'b0;
assign exe_alu_src2 = id2exe_rs2_imm_sel  ? exe_rs2_data : id2exe_imm;

alu u_alu (
   .alu_op    ( id2exe_alu_op ),
   .src1      ( exe_alu_src1  ),
   .src2      ( exe_alu_src2  ),
   .out       ( exe_alu_out   ),
   .zero_flag ( exe_alu_zero  )
);

assign exe_pmu_csr_wr = id2exe_pmu_csr_wr & ~exe_flush_force & ~exe_stall & ~exe_trap_en & ~stall_wfi;
assign exe_fpu_csr_wr = id2exe_fpu_csr_wr & ~exe_flush_force & ~exe_stall & ~exe_trap_en & ~stall_wfi;
assign exe_dbg_csr_wr = id2exe_dbg_csr_wr & ~exe_flush_force & ~exe_stall & ~exe_trap_en & ~stall_wfi;
assign exe_mmu_csr_wr = id2exe_mmu_csr_wr & ~exe_flush_force & ~exe_stall & ~exe_trap_en & ~stall_wfi;
assign exe_mpu_csr_wr = id2exe_mpu_csr_wr & ~exe_flush_force & ~exe_stall & ~exe_trap_en & ~stall_wfi;
assign exe_sru_csr_wr = id2exe_sru_csr_wr & ~exe_flush_force & ~exe_stall & ~exe_trap_en & ~stall_wfi;
assign exe_sret       = id2exe_sret       & ~exe_flush_force & ~exe_stall & ~exe_trap_en & ~stall_wfi;
assign exe_mret       = id2exe_mret       & ~exe_flush_force & ~exe_stall & ~exe_trap_en & ~stall_wfi;

assign exe_csr_src1 = id2exe_uimm_rs1_sel ? {{(`XLEN-5){1'b0}}, id2exe_rs1_addr} : exe_rs1_data;
assign exe_csr_src2 = id2exe_csr_rdata;

sru u_sru (
    .clk         ( clk_wfi           ),
    .clk_free    ( clk               ),
    .rstn        ( rstn_sync         ),
    .sleep       ( sleep             ),
    .prv         ( exe_prv           ),
    .tvm         ( exe_mstatus_tvm   ),
    .tsr         ( exe_mstatus_tsr   ),
    .sum         ( sum               ),
    .mprv        ( mprv              ),
    .mpp         ( mpp               ),

    // IRQ signal
    .ext_msip    ( msip              ),
    .ext_mtip    ( mtip              ),
    .ext_meip    ( meip              ),
    .wakeup      ( wakeup_event      ),
    .irq_trigger ( exe_irq_en        ),
    .cause       ( exe_cause         ),
    .tval        ( exe_tval          ),

    // PC control
    .trap_vec    ( irq_vec           ),
    .ret_epc     ( ret_epc           ),

    // Trap signal
    .trap_epc    ( exe_trap_epc      ),
    .trap_en     ( exe_trap_en       ),
    .trap_cause  ( exe_trap_cause    ),
    .trap_val    ( exe_trap_val      ),
    .sret        ( exe_sret          ),
    .mret        ( exe_mret          ),
    .eret_en     ( exe_eret_en       ),
    
    // CSR interface
    .csr_wr      ( exe_sru_csr_wr    ),
    .csr_waddr   ( id2exe_csr_waddr  ),
    .csr_raddr   ( id_csr_addr       ),
    .csr_wdata   ( exe_csr_wdata     ),
    .csr_rdata   ( id_sru_csr_rdata  )
);

mmu_csr u_mmu_csr (
    .clk       ( clk_wfi          ),
    .rstn      ( rstn_sync        ),

    .satp_ppn  ( exe_satp_ppn     ),
    .satp_asid ( exe_satp_asid    ),
    .satp_mode ( exe_satp_mode    ),

    // CSR interface
    .csr_wr    ( exe_mmu_csr_wr   ),
    .csr_waddr ( id2exe_csr_waddr ),
    .csr_raddr ( id_csr_addr      ),
    .csr_wdata ( exe_csr_wdata    ),
    .csr_rdata ( id_mmu_csr_rdata )
);

mpu_csr u_mpu_csr (
    .clk       ( clk_wfi          ),
    .rstn      ( rstn_sync        ),
    .pmpcfg    ( pmpcfg           ),
    .pmpaddr   ( pmpaddr          ),
    .pmacfg    ( pmacfg           ),
    .pmaaddr   ( pmaaddr          ),

    // CSR interface
    .csr_wr    ( exe_mpu_csr_wr   ),
    .csr_waddr ( id2exe_csr_waddr ),
    .csr_raddr ( id_csr_addr      ),
    .csr_wdata ( exe_csr_wdata    ),
    .csr_rdata ( id_mpu_csr_rdata )

);
assign exe_satp_upd = (id2exe_mmu_csr_wr | id2exe_csr_rd) &
                      ~exe_stall & ~stall_wfi && id2exe_csr_waddr == `CSR_SATP_ADDR;
assign exe_inst_misaligned         = id2exe_inst_misaligned | (if_pc_alu_en & |if_pc_alu[1]);
assign exe_inst_misaligned_badaddr[`XLEN-1:1] = id2exe_inst_misaligned ? (id2exe_imm[`XLEN-1:1] + id2exe_pc[`XLEN-1:1]):
                                                                          if_pc_alu[`XLEN-1:1];
assign exe_inst_misaligned_badaddr[0]         = 1'b0;

tpu u_tpu (
    .inst_valid       ( id2exe_inst_valid & ~exe_stall & ~stall_wfi),
    .inst             ( id2exe_inst                 ),
    .exe_pc           ( id2exe_pc                   ),
    .mem_pc           ( ma_dpu_pc                   ),
    .ldst_badaddr     ( ma_bad_dxes_val             ),
    .inst_badaddr     ( exe_inst_misaligned_badaddr ),
    .prv_cur          ( exe_prv                     ),
    .prv_req          ( id2exe_prv_req              ),
    .satp_upd         ( exe_satp_upd                ),
    .tsr              ( exe_mstatus_tsr             ),
    .tvm              ( exe_mstatus_tvm             ),
    .sret             ( id2exe_sret                 ),
    .ecall            ( id2exe_ecall                ),
    .ebreak           ( id2exe_ebreak               ),
    .tlb_flush_req    ( id2exe_tlb_flush_req        ),
    .ill_inst         ( id2exe_ill_inst             ),
    .inst_misaligned  ( exe_inst_misaligned         ),
    .inst_pg_fault    ( id2exe_inst_page_fault      ),
    .inst_xes_fault   ( id2exe_inst_xes_fault       ),
    .load_misaligned  ( ma_load_misaligned          ),
    .load_pg_fault    ( ma_load_page_fault          ),
    .load_xes_fault   ( ma_load_xes_fault           ),
    .store_misaligned ( ma_store_misaligned         ),
    .store_pg_fault   ( ma_store_page_fault         ),
    .store_xes_fault  ( ma_store_xes_fault          ),
    .trap_en          ( exe_trap_en                 ),
    .trap_cause       ( exe_trap_cause              ),
    .trap_val         ( exe_trap_val                ),
    .trap_epc         ( exe_trap_epc                )
);

assign satp_ppn    = exe_satp_ppn;
assign satp_asid   = exe_satp_asid;
assign satp_mode   = exe_satp_mode;
assign prv         = exe_prv;

always_comb begin
    if (id2exe_ext_csr_wr) begin
        exe_csr_wdata = id2exe_ext_csr_wdata;
    end
    else begin
        exe_csr_wdata = `XLEN'b0;
        case (id2exe_csr_op)
            CSR_OP_NONE: exe_csr_wdata = exe_csr_src1;
            CSR_OP_SET : exe_csr_wdata = exe_csr_src2 |  exe_csr_src1;
            CSR_OP_CLR : exe_csr_wdata = exe_csr_src2 & ~exe_csr_src1;
        endcase
    end
end

// EXE/MA pipeline
always_ff @(posedge clk_wfi or negedge rstn_sync) begin
    if (~rstn_sync) begin
        exe2ma_pc                  <= `IM_ADDR_LEN'b0;
        exe2ma_inst                <= `IM_DATA_LEN'b0;
        exe2ma_inst_valid          <= 1'b0;
        exe2ma_mem_req             <= 1'b0;
        exe2ma_mem_wr              <= 1'b0;
        exe2ma_mem_byte            <= {(`DM_DATA_LEN >> 3){1'b0}};
        exe2ma_mem_sign_ext        <= 1'b0;
        exe2ma_pc_alu_sel          <= 1'b0;
        exe2ma_csr_rdata           <= `XLEN'b0;
        exe2ma_csr_alu_sel         <= 1'b0;
        exe2ma_mem_cal_sel         <= 1'b0;
        exe2ma_rd_wr               <= 1'b0;
        exe2ma_rd_addr             <= 5'b0;
        exe2ma_rs1_addr            <= 5'b0;
        exe2ma_rs2_addr            <= 5'b0;
        exe2ma_alu_out             <= `XLEN'b0;
        exe2ma_pc2rd               <= `XLEN'b0;
        exe2ma_rs1_data            <= `XLEN'b0;
        exe2ma_rs2_data            <= `XLEN'b0;
        exe2ma_csr_wr              <= 1'b0;
        exe2ma_csr_waddr           <= 12'b0;
        exe2ma_csr_wdata           <= `XLEN'b0;
        exe2ma_wfi                 <= 1'b0;
        exe2ma_prv                 <= 2'b0;
        exe2ma_trap_en             <= 1'b0;
        exe2ma_cause               <= `XLEN'b0;
        exe2ma_tval                <= `XLEN'b0;
        exe2ma_epc                 <= `IM_DATA_LEN'b0;
        exe2ma_tlb_flush_req       <= 1'b0;
        exe2ma_tlb_flush_all_vaddr <= 1'b0;
        exe2ma_tlb_flush_all_asid  <= 1'b0;
        exe2ma_fence_i             <= 1'b0;
        exe2ma_attach              <= 1'b0;
    end
    else begin
        if (~ma_stall | exe_flush_force) begin
            exe2ma_pc                  <= id2exe_pc;
            exe2ma_inst                <= id2exe_inst;
            exe2ma_inst_valid          <= ~exe_flush & ~exe_irq_en & ~((exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event) & id2exe_inst_valid;
            exe2ma_mem_req             <= ~exe_flush & ~exe_irq_en & ~((exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event) & id2exe_mem_req;
            exe2ma_mem_wr              <= ~exe_flush & ~exe_irq_en & ~((exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event) & id2exe_mem_wr;
            exe2ma_mem_byte            <= id2exe_mem_byte;
            exe2ma_mem_sign_ext        <= id2exe_mem_sign_ext;
            exe2ma_pc_alu_sel          <= id2exe_pc_alu_sel;
            exe2ma_csr_rdata           <= id2exe_csr_rdata;
            exe2ma_csr_alu_sel         <= id2exe_csr_alu_sel;
            exe2ma_mem_cal_sel         <= id2exe_mem_cal_sel;
            exe2ma_rd_wr               <= ~exe_flush & ~exe_irq_en & ~((exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event) & id2exe_rd_wr;
            exe2ma_rd_addr             <= id2exe_rd_addr;
            exe2ma_rs1_addr            <= id2exe_rs1_addr;
            exe2ma_rs2_addr            <= id2exe_rs2_addr;
            exe2ma_alu_out             <= exe_alu_out;
            exe2ma_pc2rd               <= exe_pc2rd;
            exe2ma_rs1_data            <= exe_rs1_data;
            exe2ma_rs2_data            <= exe_rs2_data;
            exe2ma_csr_wr              <= ~exe_flush & ~exe_irq_en & ~((exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event) &
                                           (exe_pmu_csr_wr|
                                            exe_fpu_csr_wr|
                                            exe_dbg_csr_wr|
                                            exe_mmu_csr_wr|
                                            exe_mpu_csr_wr|
                                            exe_sru_csr_wr);
            exe2ma_csr_waddr           <= id2exe_csr_waddr;
            exe2ma_csr_wdata           <= exe_csr_wdata;
            exe2ma_wfi                 <= ~exe_flush & ~exe_irq_en & ~exe2ma_wfi & ~wakeup_event & id2exe_wfi;
            exe2ma_prv                 <= exe_prv;
            exe2ma_trap_en             <= exe_irq_en | exe_trap_en;
            exe2ma_cause               <= exe_cause;
            exe2ma_tval                <= exe_tval;
            exe2ma_epc                 <= exe_trap_epc;
            exe2ma_tlb_flush_req       <= ~exe_flush & id2exe_tlb_flush_req;
            exe2ma_tlb_flush_all_vaddr <= id2exe_tlb_flush_all_vaddr;
            exe2ma_tlb_flush_all_asid  <= id2exe_tlb_flush_all_asid;
            exe2ma_fence_i             <= ~exe_flush & id2exe_fence_i;
            exe2ma_attach              <= id2exe_attach;
        end
        else begin
            exe2ma_rs1_data            <= ma_rs1_data;
            exe2ma_rs2_data            <= ma_dpu_wdata;
        end
    end
end

// MEMORY ACCESS stage
// MEM_ADDR Forward
assign fwd_mr2ma_rd_rs1  = ma2mr_rd_wr & (exe2ma_rs1_addr == ma2mr_rd_addr) &
                          ~(ma2mr_mem_req & ~ma2mr_mem_wr & ma2mr_mem_cal_sel);
assign fwd_wb2ma_rd_rs1  = mr2wb_rd_wr & (exe2ma_rs1_addr == mr2wb_rd_addr);

assign fwd_mr2ma_rd_rs2  = ma2mr_rd_wr & (exe2ma_rs2_addr == ma2mr_rd_addr) &
                          ~(ma2mr_mem_req & ~ma2mr_mem_wr & ma2mr_mem_cal_sel);
assign fwd_wb2ma_rd_rs2  = mr2wb_rd_wr & (exe2ma_rs2_addr == mr2wb_rd_addr);

assign ma_dpu_req   = ~ma_flush & exe2ma_mem_req;
assign ma_dpu_wr    = exe2ma_mem_wr;
assign ma_dpu_byte  = exe2ma_mem_byte;
assign ma_dpu_addr  = exe2ma_alu_out;
assign ma_rs1_data  = fwd_mr2ma_rd_rs1 ? ma2mr_rd_data :
                      fwd_wb2ma_rd_rs1 ? wb_rd_data :
                                         exe2ma_rs1_data;
assign ma_dpu_wdata = fwd_mr2ma_rd_rs2 ? ma2mr_rd_data :
                      fwd_wb2ma_rd_rs2 ? wb_rd_data :
                                         exe2ma_rs2_data;

assign ma_pipe_restart = exe2ma_tlb_flush_req || exe2ma_fence_i;

dpu u_dpu (
    .clk              ( clk_wfi              ),
    .rstn             ( rstn                 ),

    .pc_i             ( exe2ma_pc            ),
    .sign_ext_i       ( exe2ma_mem_sign_ext  ),
    .req_i            ( ma_dpu_req           ),
    .wr_i             ( ma_dpu_wr            ),
    .byte_i           ( ma_dpu_byte          ),
    .addr_i           ( ma_dpu_addr          ),
    .wdata_i          ( ma_dpu_wdata         ),
    .rdata_o          ( ma_dpu_rdata         ),
    .hazard_o         ( ma_dpu_hazard        ),

    .bad_dxes_val     ( ma_bad_dxes_val      ),
    .fault            ( ma_dpu_fault         ),
    .load_misaligned  ( ma_load_misaligned   ),
    .load_pg_fault    ( ma_load_page_fault   ),
    .load_xes_fault   ( ma_load_xes_fault    ),
    .store_misaligned ( ma_store_misaligned  ),
    .store_pg_fault   ( ma_store_page_fault  ),
    .store_xes_fault  ( ma_store_xes_fault   ),
    .fault_pc         ( ma_dpu_pc            ),
                              
    .dmem_req         ( dmem_en              ),
    .dmem_addr        ( dmem_addr            ),
    .dmem_wr          ( dmem_write           ),
    .dmem_byte        ( dmem_strb            ),
    .dmem_wdata       ( dmem_wdata           ),
    .dmem_rdata       ( dmem_rdata           ),
    .dmem_bad         ( dmem_bad             ),
    .dmem_busy        ( dmem_busy            )
);

assign ma_rd_data = exe2ma_pc_alu_sel  ? exe2ma_pc2rd :
                    exe2ma_csr_alu_sel ? exe2ma_csr_rdata :
                                         exe2ma_alu_out;

// MA/WR pipeline
always_ff @(posedge clk_wfi or negedge rstn_sync) begin
    if (~rstn_sync) begin
        ma2mr_pc                  <= `IM_ADDR_LEN'b0;
        ma2mr_inst                <= `IM_DATA_LEN'b0;
        ma2mr_inst_valid          <= 1'b0;
        ma2mr_rd_wr               <= 1'b0;
        ma2mr_rd_addr             <= 5'b0;
        ma2mr_mem_byte            <= {(`DM_DATA_LEN >> 3){1'b0}};
        ma2mr_mem_sign_ext        <= 1'b0;
        ma2mr_mem_cal_sel         <= 1'b0;
        ma2mr_rd_data             <= `XLEN'b0;
        ma2mr_pc2rd               <= `XLEN'b0;
        ma2mr_mem_addr            <= `DM_ADDR_LEN'b0;
        ma2mr_mem_wdata           <= `DM_DATA_LEN'b0;
        ma2mr_mem_req             <= 1'b0;
        ma2mr_mem_wr              <= 1'b0;
        ma2mr_csr_wr              <= 1'b0;
        ma2mr_csr_waddr           <= 12'b0;
        ma2mr_csr_wdata           <= `XLEN'b0;
        ma2mr_wfi                 <= 1'b0;
        ma2mr_prv                 <= 2'b0;
        ma2mr_trap_en             <= 1'b0;
        ma2mr_cause               <= `XLEN'b0;
        ma2mr_tval                <= `XLEN'b0;
        ma2mr_epc                 <= `IM_ADDR_LEN'b0;
        ma2mr_attach              <= 1'b0;
        ma2mr_tlb_flush_req       <= 1'b0;
        ma2mr_tlb_flush_all_vaddr <= 1'b0;
        ma2mr_tlb_flush_all_asid  <= 1'b0;
        ma2mr_tlb_flush_vaddr     <= `XLEN'b0;
        ma2mr_tlb_flush_asid      <= `XLEN'b0;
        ma2mr_fence_i             <= 1'b0;
        ma2mr_pipe_restart        <= 1'b0;
    end
    else begin
        if (~mr_stall | ma_flush_force) begin
            ma2mr_pc                  <= exe2ma_pc;
            ma2mr_inst                <= exe2ma_inst;
            ma2mr_inst_valid          <= ~ma_flush & ~(ma2mr_wfi & ~wakeup_event) & exe2ma_inst_valid;
            ma2mr_rd_wr               <= ~ma_flush & ~(ma2mr_wfi & ~wakeup_event) & exe2ma_rd_wr;
            ma2mr_rd_addr             <= exe2ma_rd_addr;
            ma2mr_pc2rd               <= exe2ma_pc2rd;
            ma2mr_mem_byte            <= dmem_strb;
            ma2mr_mem_sign_ext        <= exe2ma_mem_sign_ext;
            ma2mr_mem_cal_sel         <= exe2ma_mem_cal_sel;
            ma2mr_rd_data             <= ma_rd_data;
            ma2mr_mem_addr            <= ma_dpu_addr;
            ma2mr_mem_wdata           <= dmem_wdata;
            ma2mr_mem_req             <= ~ma_flush & ~(ma2mr_wfi & ~wakeup_event) & exe2ma_mem_req;
            ma2mr_mem_wr              <= ~ma_flush & ~(ma2mr_wfi & ~wakeup_event) & exe2ma_mem_wr;
            ma2mr_csr_wr              <= exe2ma_csr_wr;
            ma2mr_csr_waddr           <= exe2ma_csr_waddr;
            ma2mr_csr_wdata           <= exe2ma_csr_wdata;
            ma2mr_wfi                 <= ~ma_flush & ~ma2mr_wfi & ~wakeup_event & exe2ma_wfi;
            ma2mr_prv                 <= exe2ma_prv;
            ma2mr_trap_en             <= exe2ma_trap_en;
            ma2mr_cause               <= exe2ma_cause;
            ma2mr_tval                <= exe2ma_tval;
            ma2mr_epc                 <= exe2ma_epc;
            ma2mr_attach              <= exe2ma_attach;
            ma2mr_tlb_flush_req       <= ~ma_flush & ~(ma2mr_wfi & ~wakeup_event) & exe2ma_tlb_flush_req;
            ma2mr_tlb_flush_all_vaddr <= exe2ma_tlb_flush_all_vaddr;
            ma2mr_tlb_flush_all_asid  <= exe2ma_tlb_flush_all_asid;
            ma2mr_tlb_flush_vaddr     <= ma_rs1_data;
            ma2mr_tlb_flush_asid      <= ma_dpu_wdata;
            ma2mr_fence_i             <= ~ma_flush & ~(ma2mr_wfi & ~wakeup_event) & exe2ma_fence_i;
            ma2mr_pipe_restart        <= ~ma_flush & ~(ma2mr_wfi & ~wakeup_event) & ma_pipe_restart;
        end
    end
end

// MEMORY RECEIVE stage
assign mr_rd_data    = ma2mr_mem_cal_sel ?  ma_dpu_rdata : ma2mr_rd_data;

assign tlb_flush_req       = ma2mr_tlb_flush_req;
assign tlb_flush_all_vaddr = ma2mr_tlb_flush_all_vaddr;
assign tlb_flush_all_asid  = ma2mr_tlb_flush_all_asid;
assign tlb_flush_vaddr     = ma2mr_tlb_flush_vaddr;
assign tlb_flush_asid      = ma2mr_tlb_flush_asid;

assign ic_flush            = ma2mr_fence_i;
assign mr_pipe_restart     = ~mr_stall && (ma2mr_tlb_flush_req | ma2mr_fence_i);


// MR/WB pipeline
always_ff @(posedge clk_wfi or negedge rstn_sync) begin
    if (~rstn_sync) begin
        mr2wb_pc           <= `IM_ADDR_LEN'b0;
        mr2wb_inst         <= `IM_DATA_LEN'b0;
        mr2wb_inst_valid   <= 1'b0;
        mr2wb_rd_wr        <= 1'b0;
        mr2wb_rd_addr      <= 5'b0;
        mr2wb_mem_byte     <= {(`DM_DATA_LEN >> 3){1'b0}};
        mr2wb_mem_sign_ext <= 1'b0;
        mr2wb_rd_data      <= `XLEN'b0;
        mr2wb_mem_addr     <= `DM_ADDR_LEN'b0;
        mr2wb_mem_wdata    <= `DM_DATA_LEN'b0;
        mr2wb_mem_req      <= 1'b0;
        mr2wb_mem_wr       <= 1'b0;
        mr2wb_csr_wr       <= 1'b0;
        mr2wb_csr_waddr    <= 12'b0;
        mr2wb_csr_wdata    <= `XLEN'b0;
        mr2wb_wfi          <= 1'b0;
        mr2wb_prv          <= 2'b0;
        mr2wb_trap_en      <= 1'b0;
        mr2wb_cause        <= `XLEN'b0;
        mr2wb_tval         <= `XLEN'b0;
        mr2wb_epc          <= `IM_ADDR_LEN'b0;
        mr2wb_attach       <= 1'b0;
    end
    else begin
        if (~wb_stall | mr_flush_force) begin
            mr2wb_pc           <= ma2mr_pc;
            mr2wb_inst         <= ma2mr_inst;
            mr2wb_inst_valid   <= ~mr_flush & ~(mr2wb_wfi & ~wakeup_event) & ma2mr_inst_valid;
            mr2wb_rd_wr        <= ~mr_flush & ~(mr2wb_wfi & ~wakeup_event) & ma2mr_rd_wr;
            mr2wb_rd_addr      <= ma2mr_rd_addr;
            mr2wb_mem_byte     <= ma2mr_mem_byte;
            mr2wb_mem_sign_ext <= ma2mr_mem_sign_ext;
            mr2wb_rd_data      <= mr_rd_data;
            mr2wb_mem_addr     <= ma2mr_mem_addr;
            mr2wb_mem_wdata    <= ma2mr_mem_wdata;
            mr2wb_mem_req      <= ~mr_flush & ~(mr2wb_wfi & ~wakeup_event) & ma2mr_mem_req;
            mr2wb_mem_wr       <= ~mr_flush & ~(mr2wb_wfi & ~wakeup_event) & ma2mr_mem_wr;
            mr2wb_csr_wr       <= ma2mr_csr_wr;
            mr2wb_csr_waddr    <= ma2mr_csr_waddr;
            mr2wb_csr_wdata    <= ma2mr_csr_wdata;
            mr2wb_wfi          <= ~mr_flush & ~mr2wb_wfi & ~wakeup_event & ma2mr_wfi;
            mr2wb_prv          <= ma2mr_prv;
            mr2wb_trap_en      <= ma2mr_trap_en;
            mr2wb_cause        <= ma2mr_cause;
            mr2wb_tval         <= ma2mr_tval;
            mr2wb_epc          <= ma2mr_epc;
            mr2wb_attach       <= ma2mr_attach;
        end
    end
end

// WB stage
assign wb_rd_data    = mr2wb_rd_data;
assign wb_rd_wr      = ~wb_flush & mr2wb_rd_wr;
assign wb_inst_valid = ~wb_flush & mr2wb_inst_valid;
assign wb_wfi        = ~wb_flush & mr2wb_wfi;

assign dbg_pc_out    = mr2wb_pc;
assign halted        = mr2wb_attach;

// PMU
pmu u_pmu (
    .clk_free   ( clk               ),
    .rstn       ( rstn_sync         ),
    .cpu_id     ( cpu_id            ),
    .inst_valid ( wb_inst_valid     ),

    .csr_wr     ( exe_pmu_csr_wr    ),
    .csr_raddr  ( id_csr_addr       ),
    .csr_waddr  ( id2exe_csr_waddr  ),
    .csr_wdata  ( exe_csr_wdata     ),
    .csr_rdata  ( id_pmu_csr_rdata  )
);

`ifdef CPULOG
// Tracer
cpu_tracer u_cpu_tracer (
    .clk       ( clk_wfi         ),
    .valid     ( wb_inst_valid   ),
    .pc        ( mr2wb_pc        ),
    .epc       ( mr2wb_epc       ),
    .inst      ( mr2wb_inst      ),
    .prv       ( mr2wb_prv       ),
    .rd_wr     ( wb_rd_wr        ),
    .rd_addr   ( mr2wb_rd_addr   ),
    .rd_data   ( mr2wb_rd_data   ),
    .csr_wr    ( mr2wb_csr_wr    ),
    .csr_waddr ( mr2wb_csr_waddr ),
    .csr_wdata ( mr2wb_csr_wdata ),
    .mem_addr  ( mr2wb_mem_addr  ),
    .mem_req   ( mr2wb_mem_req   ),
    .mem_wr    ( mr2wb_mem_wr    ),
    .mem_byte  ( mr2wb_mem_byte  ),
    .mem_rdata ( mr2wb_rd_data   ),
    .mem_wdata ( mr2wb_mem_wdata ),
    .trap_en   ( mr2wb_trap_en   ),
    .mcause    ( mr2wb_cause     ),
    .mtval     ( mr2wb_tval      ),
    .halted    ( halted          )
);
`endif

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/clkmnt.sv
/*--------------------------------------*/

module clkmnt (
    input        clk_free,
    input        rstn,
    input        wfi,
    input        wakeup,
    output logic clk_ret,
    output logic sleep
);

always_ff @(posedge clk_free or negedge rstn) begin
    if (~rstn)       sleep <= 1'b0;
    else if (wakeup) sleep <= 1'b0;
    else if (wfi)    sleep <= 1'b1;
end

CG u_cg(
    .CK   ( clk_free ),
    .EN   ( ~sleep   ),
    .CKEN ( clk_ret  )
);


endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/hzu.sv
/*--------------------------------------*/

module hzu (
    input  [4:0] inst_valid,
    input        pc_jump_en,
    input        pc_alu_en,
    input        irq_en,
    input        trap_en,
    input        eret_en,
    input        pipe_restart_en,
    input        id_hazard,
    input        exe_hazard,
    input        dpu_hazard,
    input        dpu_fault,
    output       if_stall,
    output       id_stall,
    output       exe_stall,
    output       ma_stall,
    output       mr_stall,
    output       wb_stall,
    output       if_flush,
    output       id_flush,
    output       exe_flush,
    output       ma_flush,
    output       mr_flush,
    output       wb_flush,
    output       if_flush_force,
    output       id_flush_force,
    output       exe_flush_force,
    output       ma_flush_force,
    output       mr_flush_force,
    output       wb_flush_force
);

logic [5:0] stall_all;
logic [5:0] flush_all;
logic [5:0] flush_force_all;
logic [5:0] flush_trap_all;

assign {wb_stall, mr_stall, ma_stall, exe_stall, id_stall, if_stall} = stall_all/* & inst_valid*/;
assign {wb_flush, mr_flush, ma_flush, exe_flush, id_flush, if_flush} = flush_all | flush_trap_all | flush_force_all;
assign {wb_flush_force, mr_flush_force, ma_flush_force, exe_flush_force, id_flush_force, if_flush_force} = flush_force_all;

assign stall_all = dpu_hazard ? 6'b011111:
                   exe_hazard ? 6'b000111:
                   id_hazard  ? 6'b000011:
                                6'b000000;

assign flush_all = dpu_fault  ? 6'b011111:
                   dpu_hazard ? 6'b010000:
                   exe_hazard ? 6'b000100:
                   id_hazard  ? 6'b000010:
                                6'b000000;

assign flush_force_all = pipe_restart_en                             ? 6'b001111:
                         (pc_alu_en || eret_en || irq_en || trap_en) ? 6'b000011:
                                                                       6'b000000;

assign flush_trap_all = (irq_en || trap_en) ? 6'b000100 : 6'b000000;

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/ifu.sv
/*--------------------------------------*/

module ifu (
    input                             clk,
    input                             rstn,
    input                             irq_en,
    input        [`IM_ADDR_LEN - 1:0] irq_vec,
    input                             eret_en,
    input        [`IM_ADDR_LEN - 1:0] ret_epc,
    input                             pc_jump_en,
    input        [`IM_ADDR_LEN - 1:0] pc_jump,
    input                             pc_alu_en,
    input        [`IM_ADDR_LEN - 1:0] pc_alu,
    input                             pipe_restart_en,
    input        [`IM_ADDR_LEN - 1:0] pipe_restart,
    output                            imem_req,
    output logic [`IM_ADDR_LEN - 1:0] imem_addr,
    input        [`IM_DATA_LEN - 1:0] imem_rdata,
    input        [               1:0] imem_bad,
    input                             imem_busy,
    output logic [`IM_ADDR_LEN - 1:0] pc,
    output logic [`IM_DATA_LEN - 1:0] inst,
    output logic                      inst_valid,
    output logic                      misaligned,
    output logic                      page_fault,
    output logic                      xes_fault,
    input                             flush,
    input                             stall,
    input                             attach,
    input                             dbg_exec,
    input        [`IM_ADDR_LEN - 1:0] dbg_inst
);

logic                      jump;
logic [`IM_ADDR_LEN - 1:0] jump_addr;
logic [`IM_ADDR_LEN - 1:0] pc_nxt;
logic [`IM_ADDR_LEN - 1:0] pc_d1;
logic [`IM_ADDR_LEN - 1:0] pc_d2;
logic                      inst_latch_valid;
logic [`IM_DATA_LEN - 1:0] inst_latch;
logic [               1:0] bad_latch;
logic                      imem_req_latch;
logic                      imem_req_tmp;
logic                      misaligned_tmp;


assign jump      = irq_en | pc_jump_en | pc_alu_en | eret_en | pipe_restart_en;
assign jump_addr = pipe_restart_en ? pipe_restart:
                   eret_en         ? ret_epc:
                   irq_en          ? irq_vec:
                   pc_alu_en       ? pc_alu:
                                     pc_jump;
assign pc_nxt    = jump   ? jump_addr:
                   attach ? pc:
                            (pc_d1 + `IM_ADDR_LEN'h4);

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        pc_d1 <= {`IM_ADDR_LEN{1'b0}};
    end
    else if (imem_req | jump) begin
        pc_d1 <= {pc_nxt[`IM_ADDR_LEN - 1:1], 1'b0};
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        pc_d2 <= {`IM_ADDR_LEN{1'b0}};
    end
    else if (jump) begin
        pc_d2 <= {jump_addr[`IM_ADDR_LEN - 1:1], 1'b0};
    end
    else if (inst_valid) begin
        pc_d2 <= pc_d1;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        inst_latch_valid <= 1'b0;
    end
    else if (inst_valid | jump) begin
        inst_latch_valid <= 1'b0;
    end
    else if (imem_req_latch & stall & ~imem_busy) begin
        inst_latch_valid <= 1'b1;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        inst_latch <= `IM_DATA_LEN'b0;
    end
    else if (~imem_busy & ~inst_latch_valid ) begin
        inst_latch <= imem_rdata;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        bad_latch <= 2'b0;
    end
    else if (~imem_busy & ~inst_latch_valid ) begin
        bad_latch <= imem_bad;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        imem_req_latch <= 1'b0;
    end
    else if (imem_req) begin
        imem_req_latch <= 1'b1;
    end
    else if (inst_valid | jump) begin
        imem_req_latch <= 1'b0;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        misaligned <= 1'b0;
    end
    else if (imem_req_tmp) begin
        misaligned <= misaligned_tmp;
    end
    else if (inst_valid | jump) begin
        misaligned <= 1'b0;
    end
end

assign misaligned_tmp = |pc_d1[1];

assign imem_addr      = pc_d1;
assign imem_req_tmp   = ~imem_busy & ~jump & (inst_valid | ~imem_req_latch);
assign imem_req       = imem_req_tmp & ~misaligned_tmp;

assign inst_valid = attach ? dbg_exec :
                            ((imem_req_latch & ~imem_busy) | inst_latch_valid | misaligned) &
                            ~stall & ~jump;

assign inst       = attach           ? dbg_inst:
                    inst_latch_valid ? inst_latch: 
                    ~imem_busy       ? imem_rdata:
                                       `IM_DATA_LEN'b0;
assign {xes_fault, page_fault} = inst_latch_valid ? bad_latch: 
                                 ~imem_busy       ? imem_bad:
                                                    2'b0;
assign pc         = pc_d2;

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/idu.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif


`define ALU_OP_LEN 4
`define CSR_OP_LEN 2

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       `XLEN'h0
`define CAUSE_INSTRUCTION_ACCESS     `XLEN'h1
`define CAUSE_ILLEGAL_INSTRUCTION    `XLEN'h2
`define CAUSE_BREAKPOINT             `XLEN'h3
`define CAUSE_MISALIGNED_LOAD        `XLEN'h4
`define CAUSE_LOAD_ACCESS            `XLEN'h5
`define CAUSE_MISALIGNED_STORE       `XLEN'h6
`define CAUSE_STORE_ACCESS           `XLEN'h7
`define CAUSE_USER_ECALL             `XLEN'h8
`define CAUSE_SUPERVISOR_ECALL       `XLEN'h9
`define CAUSE_HYPERVISOR_ECALL       `XLEN'ha
`define CAUSE_MACHINE_ECALL          `XLEN'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT `XLEN'hc
`define CAUSE_LOAD_PAGE_FAULT        `XLEN'hd
`define CAUSE_STORE_PAGE_FAULT       `XLEN'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`ifdef RV32
  `define SATP_PPN_WIDTH  22
  `define SATP_ASID_WIDTH  9
  `define SATP_MODE_WIDTH  1
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   22+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   31+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 31

`else
  `define SATP_PPN_WIDTH  44
  `define SATP_ASID_WIDTH 16
  `define SATP_MODE_WIDTH  4
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   44+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   60+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 63
`endif

`define PADDR_LEN       (`SATP_PPN_WIDTH + 12)

`endif

module idu (
    input                                    clk,
    input                                    rstn,
    input        [       `IM_DATA_LEN - 1:0] inst,
    input                                    inst_valid,
    input        [       `IM_ADDR_LEN - 1:0] pc,
    input                                    rd_wr_i,
    input        [                      4:0] rd_addr_i,
    input        [              `XLEN - 1:0] rd_data,
    output       [                      4:0] rd_addr_o,
    output logic [                      4:0] rs1_addr,
    output logic [                      4:0] rs2_addr,
    output logic [                     11:0] csr_addr,
    output logic [              `XLEN - 1:0] rs1_data,
    output logic [              `XLEN - 1:0] rs2_data,
    output logic [              `XLEN - 1:0] imm,
    // Control
    output logic [                      1:0] prv_req,
    output logic                             ill_inst,
    output logic                             fence,
    output logic                             fence_i,
    output logic                             ecall,
    output logic                             ebreak,
    output logic                             wfi,
    output logic                             sret,
    output logic                             mret,
    output logic                             jump,
    output logic                             jump_alu,
    // EXE stage
    output logic [        `ALU_OP_LEN - 1:0] alu_op,
    output logic                             rs1_zero_sel,
    output logic                             rs2_imm_sel,
    output logic                             pc_imm_sel,
    output logic                             branch,
    output logic                             branch_zcmp,
    output logic [        `CSR_OP_LEN - 1:0] csr_op,
    output logic                             uimm_rs1_sel,
    output logic                             csr_rd,
    output logic                             csr_wr,
    // MEM stage
    output logic                             pc_alu_sel,
    output logic                             csr_alu_sel,
    output logic                             mem_req,
    output logic                             mem_wr,
    output logic [(`DM_DATA_LEN >> 3) - 1:0] mem_byte,
    output logic                             mem_sign_ext,
    output logic                             tlb_flush_req,
    output logic                             tlb_flush_all_vaddr,
    output logic                             tlb_flush_all_asid,
    // WB stage
    output logic                             mem_cal_sel,
    output logic                             rd_wr_o,
    
    input                                    halted,
    input        [                     11:0] dbg_addr,
    input        [                     31:0] dbg_wdata,
    input                                    dbg_gpr_rd,
    input                                    dbg_gpr_wr,
    output logic [                     31:0] dbg_gpr_out,
    input                                    dbg_csr_rd,
    input                                    dbg_csr_wr
);

logic csr_rd_tmp;
logic csr_wr_tmp;

assign rd_addr_o = inst[11: 7];
assign rs1_addr  = inst[19:15];
assign rs2_addr  = inst[24:20];
assign csr_addr  = (halted && (dbg_csr_rd || dbg_csr_wr)) ? dbg_addr : inst[31:20];

assign csr_rd    = csr_rd_tmp || (halted && dbg_csr_rd);
assign csr_wr    = csr_wr_tmp || (halted && dbg_csr_wr);

rfu u_rfu (
    .clk          ( clk           ),
    .rstn         ( rstn          ),
    .rs1_addr     ( rs1_addr      ),
    .rs2_addr     ( rs2_addr      ),
    .rs1_data     ( rs1_data      ),
    .rs2_data     ( rs2_data      ),
    .wen          ( rd_wr_i       ),
    .rd_addr      ( rd_addr_i     ),
    .rd_data      ( rd_data       ),
    .halted       ( halted        ),
    .dbg_gpr_addr ( dbg_addr[4:0] ),
    .dbg_gpr_in   ( dbg_wdata     ),
    .dbg_gpr_rd   ( dbg_gpr_rd    ),
    .dbg_gpr_wr   ( dbg_gpr_wr    ),
    .dbg_gpr_out  ( dbg_gpr_out   )
);

dec u_dec (
    .inst                ( inst                ),
    .inst_valid          ( inst_valid          ),
    // Date
    .imm                 ( imm                 ),
    // Control
    .prv_req             ( prv_req             ),
    .ill_inst            ( ill_inst            ),
    .fence               ( fence               ),
    .fence_i             ( fence_i             ),
    .ecall               ( ecall               ),
    .ebreak              ( ebreak              ),
    .wfi                 ( wfi                 ),
    .sret                ( sret                ),
    .mret                ( mret                ),
    .jump                ( jump                ),
    .jump_alu            ( jump_alu            ),
    // EXE stage
    .alu_op              ( alu_op              ),
    .rs1_zero_sel        ( rs1_zero_sel        ),
    .rs2_imm_sel         ( rs2_imm_sel         ),
    .pc_imm_sel          ( pc_imm_sel          ),
    .branch              ( branch              ),
    .branch_zcmp         ( branch_zcmp         ),
    .csr_op              ( csr_op              ),
    .uimm_rs1_sel        ( uimm_rs1_sel        ),
    .csr_rd              ( csr_rd_tmp          ),
    .csr_wr              ( csr_wr_tmp          ),
    // MEM stage
    .pc_alu_sel          ( pc_alu_sel          ),
    .csr_alu_sel         ( csr_alu_sel         ),
    .mem_req             ( mem_req             ),
    .mem_wr              ( mem_wr              ),
    .mem_byte            ( mem_byte            ),
    .mem_sign_ext        ( mem_sign_ext        ),
    .tlb_flush_req       ( tlb_flush_req       ),
    .tlb_flush_all_vaddr ( tlb_flush_all_vaddr ),
    .tlb_flush_all_asid  ( tlb_flush_all_asid  ),
    // WB stage
    .mem_cal_sel         ( mem_cal_sel         ),
    .reg_wr              ( rd_wr_o             )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/dec.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif


`define ALU_OP_LEN 4
`define CSR_OP_LEN 2

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       `XLEN'h0
`define CAUSE_INSTRUCTION_ACCESS     `XLEN'h1
`define CAUSE_ILLEGAL_INSTRUCTION    `XLEN'h2
`define CAUSE_BREAKPOINT             `XLEN'h3
`define CAUSE_MISALIGNED_LOAD        `XLEN'h4
`define CAUSE_LOAD_ACCESS            `XLEN'h5
`define CAUSE_MISALIGNED_STORE       `XLEN'h6
`define CAUSE_STORE_ACCESS           `XLEN'h7
`define CAUSE_USER_ECALL             `XLEN'h8
`define CAUSE_SUPERVISOR_ECALL       `XLEN'h9
`define CAUSE_HYPERVISOR_ECALL       `XLEN'ha
`define CAUSE_MACHINE_ECALL          `XLEN'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT `XLEN'hc
`define CAUSE_LOAD_PAGE_FAULT        `XLEN'hd
`define CAUSE_STORE_PAGE_FAULT       `XLEN'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`ifdef RV32
  `define SATP_PPN_WIDTH  22
  `define SATP_ASID_WIDTH  9
  `define SATP_MODE_WIDTH  1
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   22+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   31+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 31

`else
  `define SATP_PPN_WIDTH  44
  `define SATP_ASID_WIDTH 16
  `define SATP_MODE_WIDTH  4
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   44+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   60+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 63
`endif

`define PADDR_LEN       (`SATP_PPN_WIDTH + 12)

`endif

module dec (
    input        [       `IM_DATA_LEN - 1:0] inst,
    input                                    inst_valid,
    // Data
    output logic [              `XLEN - 1:0] imm,
    // Control
    output logic [                      1:0] prv_req,
    output logic                             ill_inst,
    output logic                             fence,
    output logic                             fence_i,
    output logic                             ecall,
    output logic                             ebreak,
    output logic                             wfi,
    output logic                             sret,
    output logic                             mret,
    output logic                             jump,
    output logic                             jump_alu,
    // EXE stage
    output logic [        `ALU_OP_LEN - 1:0] alu_op,
    output logic                             rs1_zero_sel,
    output logic                             rs2_imm_sel,
    output logic                             pc_imm_sel,
    output logic                             branch,
    output logic                             branch_zcmp,
    output logic [        `CSR_OP_LEN - 1:0] csr_op,
    output logic                             uimm_rs1_sel,
    output logic                             csr_rd,
    output logic                             csr_wr,
    // MEM stage
    output logic                             pc_alu_sel,
    output logic                             csr_alu_sel,
    output logic                             mem_req,
    output logic                             mem_wr,
    output logic [(`DM_DATA_LEN >> 3) - 1:0] mem_byte,
    output logic                             mem_sign_ext,
    output logic                             tlb_flush_req,
    output logic                             tlb_flush_all_vaddr,
    output logic                             tlb_flush_all_asid,
    // WB stage
    output logic                             mem_cal_sel,
    output logic                             reg_wr
);

parameter [`ALU_OP_LEN - 1:0] ALU_AND  = `ALU_OP_LEN'b0000,
                              ALU_OR   = `ALU_OP_LEN'b0001,
                              ALU_XOR  = `ALU_OP_LEN'b0010,
                              ALU_ADD  = `ALU_OP_LEN'b0011,
                              ALU_SUB  = `ALU_OP_LEN'b0100,
                              ALU_SLT  = `ALU_OP_LEN'b0101,
                              ALU_SLL  = `ALU_OP_LEN'b0110,
                              ALU_SRL  = `ALU_OP_LEN'b0111,
                              ALU_SLTU = `ALU_OP_LEN'b1000,
                              ALU_SRA  = `ALU_OP_LEN'b1001;
parameter [`CSR_OP_LEN - 1:0] CSR_OP_NONE = `CSR_OP_LEN'b00,
                              CSR_OP_SET  = `CSR_OP_LEN'b01,
                              CSR_OP_CLR  = `CSR_OP_LEN'b10;
parameter [4:0] OP_LOAD      = 5'b00_000,
                OP_LOAD_FP   = 5'b00_001,
                OP_CUST_0    = 5'b00_010,
                OP_MISC_MEM  = 5'b00_011,
                OP_OP_IMM    = 5'b00_100,
                OP_AUIPC     = 5'b00_101,
                OP_OP_IMM_32 = 5'b00_110,
                OP_STORE     = 5'b01_000,
                OP_STORE_FP  = 5'b01_001,
                OP_CUST_1    = 5'b01_010,
                OP_AMO       = 5'b01_011,
                OP_OP        = 5'b01_100,
                OP_LUI       = 5'b01_101,
                OP_OP_32     = 5'b01_110,
                OP_MADD      = 5'b10_000,
                OP_MSUB      = 5'b10_001,
                OP_NMSUB     = 5'b10_010,
                OP_NMADD     = 5'b10_011,
                OP_OP_FP     = 5'b10_100,
                OP_RSV_0     = 5'b10_101,
                OP_CUST_2    = 5'b10_110,
                OP_BRANCH    = 5'b11_000,
                OP_JALR      = 5'b11_001,
                OP_RSV_1     = 5'b11_010,
                OP_JAL       = 5'b11_011,
                OP_SYSTEM    = 5'b11_100,
                OP_RSV_2     = 5'b11_101,
                OP_CUST_3    = 5'b11_110;
parameter [2:0] FUNCT3_JALR    = 3'b000,
                FUNCT3_BEQ     = 3'b000,
                FUNCT3_BNE     = 3'b001,
                FUNCT3_BLT     = 3'b100,
                FUNCT3_BGE     = 3'b101,
                FUNCT3_BLTU    = 3'b110,
                FUNCT3_BGEU    = 3'b111,
                FUNCT3_LB      = 3'b000,
                FUNCT3_LH      = 3'b001,
                FUNCT3_LW      = 3'b010,
                FUNCT3_LBU     = 3'b100,
                FUNCT3_LHU     = 3'b101,
                FUNCT3_SB      = 3'b000,
                FUNCT3_SH      = 3'b001,
                FUNCT3_SW      = 3'b010,
                FUNCT3_ADDI    = 3'b000,
                FUNCT3_SLTI    = 3'b010,
                FUNCT3_SLTIU   = 3'b011,
                FUNCT3_XORI    = 3'b100,
                FUNCT3_ORI     = 3'b110,
                FUNCT3_ANDI    = 3'b111,
                FUNCT3_SLLI    = 3'b001,
                FUNCT3_SRLI    = 3'b101,
                FUNCT3_SRAI    = 3'b101,
                FUNCT3_ADD     = 3'b000,
                FUNCT3_SUB     = 3'b000,
                FUNCT3_SLL     = 3'b001,
                FUNCT3_SLT     = 3'b010,
                FUNCT3_SLTU    = 3'b011,
                FUNCT3_XOR     = 3'b100,
                FUNCT3_SRL     = 3'b101,
                FUNCT3_SRA     = 3'b101,
                FUNCT3_OR      = 3'b110,
                FUNCT3_AND     = 3'b111,
                FUNCT3_FENCE   = 3'b000,
                FUNCT3_FENCE_I = 3'b001,
                FUNCT3_PRIV    = 3'b000,
                FUNCT3_CSRRW   = 3'b001,
                FUNCT3_CSRRS   = 3'b010,
                FUNCT3_CSRRC   = 3'b011,
                FUNCT3_CSRRWI  = 3'b101,
                FUNCT3_CSRRSI  = 3'b110,
                FUNCT3_CSRRCI  = 3'b111;

parameter [6:0] FUNCT7_SLLI       = 7'b0000000,
                FUNCT7_SRLI       = 7'b0000000,
                FUNCT7_SRAI       = 7'b0100000,
                FUNCT7_ADD        = 7'b0000000,
                FUNCT7_SUB        = 7'b0100000,
                FUNCT7_SLL        = 7'b0000000,
                FUNCT7_SLT        = 7'b0000000,
                FUNCT7_SLTU       = 7'b0000000,
                FUNCT7_XOR        = 7'b0000000,
                FUNCT7_SRL        = 7'b0000000,
                FUNCT7_SRA        = 7'b0100000,
                FUNCT7_OR         = 7'b0000000,
                FUNCT7_AND        = 7'b0000000,
                FUNCT7_SFENCE_VMA = 7'b0001001;

parameter [11:0] FUNCT12_ECALL  = 12'h000,
                 FUNCT12_EBREAK = 12'h001,
                 FUNCT12_WFI    = 12'h105,
                 FUNCT12_SRET   = 12'h102,
                 FUNCT12_MRET   = 12'h302;

logic [        4:0] rs1_addr;
logic [        4:0] rs2_addr;
logic [        4:0] rd_addr;

assign rs1_addr = inst[19:15];
assign rs2_addr = inst[24:20];
assign rd_addr  = inst[11: 7];


logic [`XLEN - 1:0] imm_i;
logic [`XLEN - 1:0] imm_s;
logic [`XLEN - 1:0] imm_b;
logic [`XLEN - 1:0] imm_u;
logic [`XLEN - 1:0] imm_j;

assign imm_i = {{(`XLEN-11){inst[31]}}, inst[30:25], inst[24:21], inst[20]};
assign imm_s = {{(`XLEN-11){inst[31]}}, inst[30:25], inst[11:8],  inst[7]};
assign imm_b = {{(`XLEN-12){inst[31]}}, inst[7],     inst[30:25], inst[11:8], 1'b0};
assign imm_u = {{(`XLEN-31){inst[31]}}, inst[30:20], inst[19:12], 12'b0};
assign imm_j = {{(`XLEN-20){inst[31]}}, inst[19:12], inst[20],    inst[30:25], inst[24:21], 1'b0};

logic [       14:12] funct3;
logic [       31:25] funct7;

assign funct3 = inst[14:12];
assign funct7 = inst[31:25];

logic [        6: 2] opcode;

assign opcode = inst[6:2];
always_comb begin
    imm                 = `XLEN'b0;
    alu_op              = `ALU_OP_LEN'b0;
    rs1_zero_sel        = 1'b0;
    rs2_imm_sel         = 1'b0;
    pc_imm_sel          = 1'b0;
    branch              = 1'b0;
    branch_zcmp         = 1'b0;
    pc_alu_sel          = 1'b0;
    mem_req             = 1'b0;
    mem_wr              = 1'b0;
    mem_byte            = {(`DM_DATA_LEN >> 3){1'b0}};
    mem_sign_ext        = 1'b0;
    mem_cal_sel         = 1'b0;
    reg_wr              = 1'b0;
    fence               = 1'b0;
    fence_i             = 1'b0;
    ecall               = 1'b0;
    ebreak              = 1'b0;
    wfi                 = 1'b0;
    sret                = 1'b0;
    mret                = 1'b0;
    jump                = 1'b0;
    jump_alu            = 1'b0;
    csr_op              = `CSR_OP_LEN'b0;
    uimm_rs1_sel        = 1'b0;
    csr_rd              = 1'b0;
    csr_wr              = 1'b0;
    csr_alu_sel         = 1'b0;
    ill_inst            = inst_valid & (inst[1:0] != 2'b11);
    prv_req             = 2'b0;
    tlb_flush_req       = 1'b0;
    tlb_flush_all_vaddr = 1'b0;
    tlb_flush_all_asid  = 1'b0;
    if (inst_valid) begin
        case (opcode)
            OP_LOAD     : begin
                imm          = imm_i;
                alu_op       = ALU_ADD;
                rs1_zero_sel = 1'b1;
                rs2_imm_sel  = 1'b0;
                mem_req      = 1'b1;
                mem_wr       = 1'b0;
                reg_wr       = |rd_addr;
                mem_cal_sel  = 1'b1;
                case (funct3)
                    FUNCT3_LB : begin
                        mem_byte     = {{((`DM_DATA_LEN >> 3) - 1){1'b0}}, 1'b1   };
                        mem_sign_ext = 1'b1;
                    end
                    FUNCT3_LH : begin
                        mem_byte     = {{((`DM_DATA_LEN >> 3) - 2){1'b0}}, 2'b11  };
                        mem_sign_ext = 1'b1;
                    end
                    FUNCT3_LW : begin
                        mem_byte     = {{((`DM_DATA_LEN >> 3) - 4){1'b0}}, 4'b1111};
                        mem_sign_ext = 1'b1;
                    end
                    FUNCT3_LBU: begin
                        mem_byte     = {{((`DM_DATA_LEN >> 3) - 1){1'b0}}, 1'b1   };
                        mem_sign_ext = 1'b0;
                    end
                    FUNCT3_LHU: begin
                        mem_byte     = {{((`DM_DATA_LEN >> 3) - 2){1'b0}}, 2'b11  };
                        mem_sign_ext = 1'b0;
                    end
                    default   : begin
                        ill_inst     = 1'b1;
                    end
                endcase
            end
            OP_LOAD_FP  : begin
            end
            OP_CUST_0   : begin
            end
            OP_MISC_MEM : begin
                case ({funct3, inst[11:7], inst[19:15], inst[31:28]})
                    {FUNCT3_FENCE  , 5'b0, 5'b0, 4'b0}: begin
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        reg_wr       = 1'b0;
                        fence        = 1'b1;
                    end
                    {FUNCT3_FENCE_I, 5'b0, 5'b0, 4'b0}: begin
                        if (inst[27:20] == 8'b0) begin
                            mem_req      = 1'b0;
                            mem_wr       = 1'b0;
                            reg_wr       = 1'b0;
                            fence_i      = 1'b1;
                            pc_imm_sel   = 1'b0;
                        end
                        else ill_inst     = 1'b1;
                    end
                    default       : begin
                        ill_inst     = 1'b1;
                    end
                endcase
            end
            OP_OP_IMM   : begin
                imm          = imm_i;
                rs1_zero_sel = 1'b1;
                rs2_imm_sel  = 1'b0;
                pc_alu_sel   = 1'b0;
                mem_req      = 1'b0;
                mem_wr       = 1'b0;
                mem_cal_sel  = 1'b0;
                reg_wr       = |rd_addr;
                case (funct3)
                    FUNCT3_ADDI : begin
                        alu_op       = ALU_ADD;
                    end
                    FUNCT3_SLTI : begin
                        alu_op       = ALU_SLT;
                    end
                    FUNCT3_SLTIU: begin
                        alu_op       = ALU_SLTU;
                    end
                    FUNCT3_XORI : begin
                        alu_op       = ALU_XOR;
                    end
                    FUNCT3_ORI  : begin
                        alu_op       = ALU_OR;
                    end
                    FUNCT3_ANDI : begin
                        alu_op       = ALU_AND;
                    end
                    FUNCT3_SLLI : begin
                        case (funct7)
                            FUNCT7_SLLI: begin
                                alu_op       = ALU_SLL;
                            end
                            default    : begin
                                ill_inst     = 1'b1;
                            end
                        endcase
                    end
                    FUNCT3_SRLI : begin
                        case (funct7)
                            FUNCT7_SRLI: begin
                                alu_op       = ALU_SRL;
                            end
                            FUNCT7_SRAI: begin
                                alu_op       = ALU_SRA;
                            end
                            default    : begin
                                ill_inst     = 1'b1;
                            end
                        endcase
                    end
                endcase
            end
            OP_AUIPC    : begin
                imm          = imm_u;
                alu_op       = ALU_ADD;
                rs1_zero_sel = 1'b1;
                pc_imm_sel   = 1'b1;
                pc_alu_sel   = 1'b1;
                mem_req      = 1'b0;
                mem_wr       = 1'b0;
                mem_cal_sel  = 1'b0;
                reg_wr       = |rd_addr;
            end
            OP_OP_IMM_32: begin
            end
            OP_STORE    : begin
                imm          = imm_s;
                alu_op       = ALU_ADD;
                rs1_zero_sel = 1'b1;
                rs2_imm_sel  = 1'b0;
                mem_req      = 1'b1;
                mem_wr       = 1'b1;
                reg_wr       = 1'b0;
                case (funct3)
                    FUNCT3_SB: begin
                        mem_byte     = {{((`DM_DATA_LEN >> 3) - 1){1'b0}}, 1'b1   };
                    end
                    FUNCT3_SH: begin
                        mem_byte     = {{((`DM_DATA_LEN >> 3) - 2){1'b0}}, 2'b11  };
                    end
                    FUNCT3_SW: begin
                        mem_byte     = {{((`DM_DATA_LEN >> 3) - 4){1'b0}}, 4'b1111};
                    end
                    default  : begin
                        ill_inst     = 1'b1;
                    end
                endcase
            end
            OP_STORE_FP : begin
            end
            OP_CUST_1   : begin
            end
            OP_AMO      : begin
            end
            OP_OP       : begin
                rs1_zero_sel = 1'b1;
                rs2_imm_sel  = 1'b1;
                pc_alu_sel   = 1'b0;
                mem_req      = 1'b0;
                mem_wr       = 1'b0;
                mem_cal_sel  = 1'b0;
                reg_wr       = |rd_addr;
                case (funct3)
                    FUNCT3_ADD : begin
                        case (funct7)
                            FUNCT7_ADD: begin
                                alu_op       = ALU_ADD;
                            end
                            FUNCT7_SUB: begin
                                alu_op       = ALU_SUB;
                            end
                            default   : begin
                                ill_inst     = 1'b1;
                            end
                        endcase
                    end
                    FUNCT3_SLL : begin
                        case (funct7)
                            FUNCT7_SLL: begin
                                alu_op       = ALU_SLL;
                            end
                            default   : begin
                                ill_inst     = 1'b1;
                            end
                        endcase
                    end
                    FUNCT3_SLT : begin
                        case (funct7)
                            FUNCT7_SLT: begin
                                alu_op       = ALU_SLT;
                            end
                            default   : begin
                                ill_inst     = 1'b1;
                            end
                        endcase
                    end
                    FUNCT3_SLTU: begin
                        case (funct7)
                            FUNCT7_SLTU: begin
                                alu_op       = ALU_SLTU;
                            end
                            default    : begin
                                ill_inst     = 1'b1;
                            end
                        endcase
                    end
                    FUNCT3_XOR : begin
                        case (funct7)
                            FUNCT7_XOR: begin
                                alu_op       = ALU_XOR;
                            end
                            default   : begin
                                ill_inst     = 1'b1;
                            end
                        endcase
                    end
                    FUNCT3_SRL : begin
                        case (funct7)
                            FUNCT7_SRL: begin
                                alu_op       = ALU_SRL;
                            end
                            FUNCT7_SRA: begin
                                alu_op       = ALU_SRA;
                            end
                            default   : begin
                                ill_inst     = 1'b1;
                            end
                        endcase
                    end
                    FUNCT3_OR  : begin
                        case (funct7)
                            FUNCT7_OR: begin
                                alu_op       = ALU_OR;
                            end
                            default  : begin
                                ill_inst     = 1'b1;
                            end
                        endcase
                    end
                    FUNCT3_AND : begin
                        case (funct7)
                            FUNCT7_AND: begin
                                alu_op       = ALU_AND;
                            end
                            default    : begin
                                ill_inst     = 1'b1;
                            end
                        endcase
                    end
                endcase
            end
            OP_LUI      : begin
                imm          = imm_u;
                alu_op       = ALU_OR;
                rs1_zero_sel = 1'b0;
                rs2_imm_sel  = 1'b0;
                pc_alu_sel   = 1'b0;
                mem_req      = 1'b0;
                mem_wr       = 1'b0;
                mem_cal_sel  = 1'b0;
                reg_wr       = |rd_addr;
            end
            OP_OP_32    : begin
            end
            OP_MADD     : begin
            end
            OP_MSUB     : begin
            end
            OP_NMSUB    : begin
            end
            OP_NMADD    : begin
            end
            OP_OP_FP    : begin
            end
            OP_CUST_2   : begin
            end
            OP_BRANCH   : begin
                imm          = imm_b;
                rs1_zero_sel = 1'b1;
                rs2_imm_sel  = 1'b1;
                mem_req      = 1'b0;
                mem_wr       = 1'b0;
                reg_wr       = 1'b0;
                branch       = 1'b1;
                case (funct3)
                    FUNCT3_BEQ : begin
                        alu_op       = ALU_SUB;
                        branch_zcmp  = 1'b1;
                    end
                    FUNCT3_BNE : begin
                        alu_op       = ALU_SUB;
                        branch_zcmp  = 1'b0;
                    end
                    FUNCT3_BLT : begin
                        alu_op       = ALU_SLT;
                        branch_zcmp  = 1'b0;
                    end
                    FUNCT3_BGE : begin
                        alu_op       = ALU_SLT;
                        branch_zcmp  = 1'b1;
                    end
                    FUNCT3_BLTU: begin
                        alu_op       = ALU_SLTU;
                        branch_zcmp  = 1'b0;
                    end
                    FUNCT3_BGEU: begin
                        alu_op       = ALU_SLTU;
                        branch_zcmp  = 1'b1;
                    end
                    default    : begin
                        ill_inst     = 1'b1;
                    end
                endcase
            end
            OP_JALR     : begin
                imm          = imm_i;
                alu_op       = ALU_ADD;
                rs1_zero_sel = 1'b1;
                rs2_imm_sel  = 1'b0;
                pc_imm_sel   = 1'b0;
                pc_alu_sel   = 1'b1;
                mem_req      = 1'b0;
                mem_wr       = 1'b0;
                mem_cal_sel  = 1'b0;
                reg_wr       = |rd_addr;
                jump_alu     = 1'b1;
            end
            OP_JAL      : begin
                imm          = imm_j;
                rs1_zero_sel = 1'b1;
                rs2_imm_sel  = 1'b1;
                pc_imm_sel   = 1'b0;
                pc_alu_sel   = 1'b1;
                mem_req      = 1'b0;
                mem_wr       = 1'b0;
                mem_cal_sel  = 1'b0;
                reg_wr       = |rd_addr;
                jump         = 1'b1;
            end
            OP_SYSTEM   : begin
                case (funct3)
                    FUNCT3_PRIV  : begin
                        if (funct7 == FUNCT7_SFENCE_VMA) begin
                            tlb_flush_req       = 1'b1;
                            tlb_flush_all_vaddr = ~|inst[19:15];
                            tlb_flush_all_asid  = ~|inst[24:20];
                            pc_imm_sel   = 1'b0;
                        end
                        else if ({inst[11:7], inst[19:15]} == {5'b0, 5'b0}) begin
                            case (inst[31:20])
                                FUNCT12_ECALL: begin
                                    mem_req      = 1'b0;
                                    mem_wr       = 1'b0;
                                    reg_wr       = 1'b0;
                                    ecall        = 1'b1;
                                end
                                FUNCT12_EBREAK: begin
                                    mem_req      = 1'b0;
                                    mem_wr       = 1'b0;
                                    reg_wr       = 1'b0;
                                    ebreak       = 1'b1;
                                end
                                FUNCT12_WFI   : begin
                                    wfi          = 1'b1;
                                end
                                FUNCT12_SRET  : begin
                                    sret         = 1'b1;
                                    prv_req      = inst[29:28];
                                end
                                FUNCT12_MRET  : begin
                                    mret         = 1'b1;
                                    prv_req      = inst[29:28];
                                end
                                default       : begin
                                    ill_inst     = 1'b1;
                                end
                            endcase
                        end
                        else begin
                            ill_inst     = 1'b1;
                        end
                    end
                    FUNCT3_CSRRW : begin
                        imm          = imm_i;
                        csr_op       = CSR_OP_NONE;
                        rs1_zero_sel = 1'b0;
                        rs2_imm_sel  = 1'b0;
                        pc_alu_sel   = 1'b0;
                        reg_wr       = |rd_addr;
                        uimm_rs1_sel = 1'b0;
                        csr_rd       = |rd_addr;
                        csr_wr       = 1'b1;
                        csr_alu_sel  = 1'b1;
                        prv_req      = inst[29:28];
                    end
                    FUNCT3_CSRRS : begin
                        imm          = imm_i;
                        csr_op       = CSR_OP_SET;
                        rs1_zero_sel = 1'b0;
                        rs2_imm_sel  = 1'b0;
                        pc_alu_sel   = 1'b0;
                        reg_wr       = |rd_addr;
                        uimm_rs1_sel = 1'b0;
                        csr_rd       = |rd_addr;
                        csr_wr       = |rs1_addr;
                        csr_alu_sel  = 1'b1;
                        prv_req      = inst[29:28];
                    end
                    FUNCT3_CSRRC : begin
                        imm          = imm_i;
                        csr_op       = CSR_OP_CLR;
                        rs1_zero_sel = 1'b0;
                        rs2_imm_sel  = 1'b0;
                        pc_alu_sel   = 1'b0;
                        reg_wr       = |rd_addr;
                        uimm_rs1_sel = 1'b0;
                        csr_rd       = |rd_addr;
                        csr_wr       = |rs1_addr;
                        csr_alu_sel  = 1'b1;
                        prv_req      = inst[29:28];
                    end
                    FUNCT3_CSRRWI: begin
                        imm          = imm_i;
                        csr_op       = CSR_OP_NONE;
                        rs1_zero_sel = 1'b0;
                        rs2_imm_sel  = 1'b0;
                        pc_alu_sel   = 1'b0;
                        reg_wr       = |rd_addr;
                        uimm_rs1_sel = 1'b1;
                        csr_rd       = |rd_addr;
                        csr_wr       = 1'b1;
                        csr_alu_sel  = 1'b1;
                        prv_req      = inst[29:28];
                    end
                    FUNCT3_CSRRSI: begin
                        imm          = imm_i;
                        csr_op       = CSR_OP_SET;
                        rs1_zero_sel = 1'b0;
                        rs2_imm_sel  = 1'b0;
                        pc_alu_sel   = 1'b0;
                        reg_wr       = |rd_addr;
                        uimm_rs1_sel = 1'b1;
                        csr_rd       = |rd_addr;
                        csr_wr       = |rs1_addr;
                        csr_alu_sel  = 1'b1;
                        prv_req      = inst[29:28];
                    end
                    FUNCT3_CSRRCI: begin
                        imm          = imm_i;
                        csr_op       = CSR_OP_CLR;
                        rs1_zero_sel = 1'b0;
                        rs2_imm_sel  = 1'b0;
                        pc_alu_sel   = 1'b0;
                        reg_wr       = |rd_addr;
                        uimm_rs1_sel = 1'b1;
                        csr_rd       = |rd_addr;
                        csr_wr       = |rs1_addr;
                        csr_alu_sel  = 1'b1;
                        prv_req      = inst[29:28];
                    end
                    default       : begin
                        ill_inst     = 1'b1;
                    end
                endcase
            end
            OP_CUST_3   : begin
            end
            default     : begin
                ill_inst = 1'b1;
            end
        endcase
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/rfu.sv
/*--------------------------------------*/

module rfu (
    input                      clk,
    input                      rstn,
    input        [        4:0] rs1_addr,
    input        [        4:0] rs2_addr,
    output logic [`XLEN - 1:0] rs1_data,
    output logic [`XLEN - 1:0] rs2_data,
    input                      wen,
    input        [        4:0] rd_addr,
    input        [`XLEN - 1:0] rd_data,

    input                      halted,
    input        [        4:0] dbg_gpr_addr,
    input        [       31:0] dbg_gpr_in,
    input                      dbg_gpr_rd,
    input                      dbg_gpr_wr,
    output logic [       31:0] dbg_gpr_out
);

logic               rstn_sync;
logic [`XLEN - 1:0] gpr [0:31];
integer             i;

logic [        4:0] rd_addr_dbg;
logic               wen_dbg;
logic [       31:0] rd_data_dbg;

assign rd_addr_dbg = (halted && dbg_gpr_wr) ? dbg_gpr_addr : rd_addr;
assign wen_dbg     = wen || (halted && dbg_gpr_wr);
assign rd_data_dbg = (halted && dbg_gpr_wr) ? dbg_gpr_in : rd_data;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        for (i = 0; i < 32; i = i + 1) begin
            gpr[i] <= {`XLEN{1'b0}};
        end
    end
    else begin
        if (wen_dbg & |rd_addr_dbg) begin
            gpr[rd_addr_dbg] <= rd_data_dbg;
        end
    end
end

assign rs1_data = gpr[rs1_addr];
assign rs2_data = gpr[rs2_addr];

assign dbg_gpr_out = gpr[dbg_gpr_addr];

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/csr.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif


`define ALU_OP_LEN 4
`define CSR_OP_LEN 2

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       `XLEN'h0
`define CAUSE_INSTRUCTION_ACCESS     `XLEN'h1
`define CAUSE_ILLEGAL_INSTRUCTION    `XLEN'h2
`define CAUSE_BREAKPOINT             `XLEN'h3
`define CAUSE_MISALIGNED_LOAD        `XLEN'h4
`define CAUSE_LOAD_ACCESS            `XLEN'h5
`define CAUSE_MISALIGNED_STORE       `XLEN'h6
`define CAUSE_STORE_ACCESS           `XLEN'h7
`define CAUSE_USER_ECALL             `XLEN'h8
`define CAUSE_SUPERVISOR_ECALL       `XLEN'h9
`define CAUSE_HYPERVISOR_ECALL       `XLEN'ha
`define CAUSE_MACHINE_ECALL          `XLEN'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT `XLEN'hc
`define CAUSE_LOAD_PAGE_FAULT        `XLEN'hd
`define CAUSE_STORE_PAGE_FAULT       `XLEN'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`ifdef RV32
  `define SATP_PPN_WIDTH  22
  `define SATP_ASID_WIDTH  9
  `define SATP_MODE_WIDTH  1
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   22+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   31+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 31

`else
  `define SATP_PPN_WIDTH  44
  `define SATP_ASID_WIDTH 16
  `define SATP_MODE_WIDTH  4
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   44+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   60+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 63
`endif

`define PADDR_LEN       (`SATP_PPN_WIDTH + 12)

`endif

module csr (
    input                       clk,
    input                       rstn,
    input                       rd,
    input                       wr,
    input        [       11: 0] raddr,
    output logic [`XLEN - 1: 0] rdata,
    output logic                pmu_csr_wr,
    output logic                fpu_csr_wr,
    output logic                dbg_csr_wr,
    output logic                mmu_csr_wr,
    output logic                mpu_csr_wr,
    output logic                sru_csr_wr,
    input        [`XLEN - 1: 0] pmu_csr_rdata,
    input        [`XLEN - 1: 0] fpu_csr_rdata,
    input        [`XLEN - 1: 0] dbg_csr_rdata,
    input        [`XLEN - 1: 0] mmu_csr_rdata,
    input        [`XLEN - 1: 0] mpu_csr_rdata,
    input        [`XLEN - 1: 0] sru_csr_rdata

);

logic pmu_csr_sel;
logic dbg_csr_sel;
logic mmu_csr_sel;
logic mpu_csr_sel;
logic sru_csr_sel;
logic fpu_csr_sel;

assign pmu_csr_sel = raddr[11] || {raddr[11:10], raddr[7:5]} == 5'b00_001;
assign dbg_csr_sel = raddr[11:10] == 2'b01;
assign mmu_csr_sel = raddr == 12'h180;
assign mpu_csr_sel = {raddr[11:10], raddr[7]} == 3'b00_1 && ~mmu_csr_sel;
assign sru_csr_sel = ({raddr[11:10], raddr[7:6]} == 4'b00_00 && ~fpu_csr_sel) ||
                      {raddr[11:10], raddr[7:6]} == 4'b00_01;
assign fpu_csr_sel = raddr[11:2] == 10'b0000_0000_00 && raddr[1:0] != 2'b00;

assign pmu_csr_wr = pmu_csr_sel & wr;
assign fpu_csr_wr = fpu_csr_sel & wr;
assign dbg_csr_wr = dbg_csr_sel & wr;
assign mmu_csr_wr = mmu_csr_sel & wr;
assign mpu_csr_wr = mpu_csr_sel & wr;
assign sru_csr_wr = sru_csr_sel & wr;

assign rdata = ({`XLEN{pmu_csr_sel}} & pmu_csr_rdata) |
               ({`XLEN{dbg_csr_sel}} & dbg_csr_rdata) |
               ({`XLEN{mmu_csr_sel}} & mmu_csr_rdata) |
               ({`XLEN{mpu_csr_sel}} & mpu_csr_rdata) |
               ({`XLEN{sru_csr_sel}} & sru_csr_rdata) |
               ({`XLEN{fpu_csr_sel}} & fpu_csr_rdata);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/sru.sv
/*--------------------------------------*/

/* CSR information */
// User Trap Setup
// 0x000 URW ustatus User status register.
// 0x004 URW uie User interrupt-enable register.
// 0x005 URW utvec User trap handler base address.
// User Trap Handling
// 0x040 URW uscratch Scratch register for user trap handlers.
// 0x041 URW uepc User exception program counter.
// 0x042 URW ucause User trap cause.
// 0x043 URW utval User bad address or instruction.
// 0x044 URW uip User interrupt pending.
// Supervisor Trap Setup
// 0x100 SRW sstatus Supervisor status register.
// 0x102 SRW sedeleg Supervisor exception delegation register.
// 0x103 SRW sideleg Supervisor interrupt delegation register.
// 0x104 SRW sie Supervisor interrupt-enable register.
// 0x105 SRW stvec Supervisor trap handler base address.
// 0x106 SRW scounteren Supervisor counter enable.
// Supervisor Trap Handling
// 0x140 SRW sscratch Scratch register for supervisor trap handlers.
// 0x141 SRW sepc Supervisor exception program counter.
// 0x142 SRW scause Supervisor trap cause.
// 0x143 SRW stval Supervisor bad address or instruction.
// 0x144 SRW sip Supervisor interrupt pending
// Machine Trap Setup
// 0x300 MRW mstatus Machine status register.
// 0x301 MRW misa ISA and extensions
// 0x302 MRW medeleg Machine exception delegation register.
// 0x303 MRW mideleg Machine interrupt delegation register.
// 0x304 MRW mie Machine interrupt-enable register.
// 0x305 MRW mtvec Machine trap-handler base address.
// 0x306 MRW mcounteren Machine counter enable.
// Machine Trap Handling
// 0x340 MRW mscratch Scratch register for machine trap handlers.
// 0x341 MRW mepc Machine exception program counter.
// 0x342 MRW mcause Machine trap cause.
// 0x343 MRW mtval Machine bad address or instruction.
// 0x344 MRW mip Machine interrupt pending.

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif


`define ALU_OP_LEN 4
`define CSR_OP_LEN 2

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       `XLEN'h0
`define CAUSE_INSTRUCTION_ACCESS     `XLEN'h1
`define CAUSE_ILLEGAL_INSTRUCTION    `XLEN'h2
`define CAUSE_BREAKPOINT             `XLEN'h3
`define CAUSE_MISALIGNED_LOAD        `XLEN'h4
`define CAUSE_LOAD_ACCESS            `XLEN'h5
`define CAUSE_MISALIGNED_STORE       `XLEN'h6
`define CAUSE_STORE_ACCESS           `XLEN'h7
`define CAUSE_USER_ECALL             `XLEN'h8
`define CAUSE_SUPERVISOR_ECALL       `XLEN'h9
`define CAUSE_HYPERVISOR_ECALL       `XLEN'ha
`define CAUSE_MACHINE_ECALL          `XLEN'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT `XLEN'hc
`define CAUSE_LOAD_PAGE_FAULT        `XLEN'hd
`define CAUSE_STORE_PAGE_FAULT       `XLEN'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`ifdef RV32
  `define SATP_PPN_WIDTH  22
  `define SATP_ASID_WIDTH  9
  `define SATP_MODE_WIDTH  1
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   22+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   31+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 31

`else
  `define SATP_PPN_WIDTH  44
  `define SATP_ASID_WIDTH 16
  `define SATP_MODE_WIDTH  4
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   44+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   60+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 63
`endif

`define PADDR_LEN       (`SATP_PPN_WIDTH + 12)

`endif

module sru (
    input                           clk,
    input                           clk_free,
    input                           rstn,
    input                           sleep,
    output logic [             1:0] prv,
    output logic                    tsr,
    output logic                    tvm,
    output logic                    sum,
    output logic                    mprv,
    output logic [             1:0] mpp,

    // IRQ signal
    input                           ext_msip,
    input                           ext_mtip,
    input                           ext_meip,
    output logic                    wakeup,
    output logic                    irq_trigger,
    output logic [       `XLEN-1:0] cause,
    output logic [       `XLEN-1:0] tval,

    // PC control
    output logic [`IM_ADDR_LEN-1:0] trap_vec,
    output logic [`IM_ADDR_LEN-1:0] ret_epc,

    // Trap signal
    input        [`IM_ADDR_LEN-1:0] trap_epc,
    input                           trap_en,
    input        [       `XLEN-1:0] trap_cause,
    input        [       `XLEN-1:0] trap_val,
    input                           sret,
    input                           mret,
    output logic                    eret_en,
    
    // CSR interface
    input                           csr_wr,
    input        [            11:0] csr_waddr,
    input        [            11:0] csr_raddr,
    input        [       `XLEN-1:0] csr_wdata,
    output logic [       `XLEN-1:0] csr_rdata
);

logic                    trap_m_mode;
logic                    trap_s_mode;
logic                    ints_m_mode;
logic                    ints_s_mode;
logic [`IM_ADDR_LEN-1:0] vec_offset;
logic                    msip_d1;
logic                    mtip_d1;
logic                    meip_d1;

logic [       `XLEN-1:0] sstatus;
// logic [       `XLEN-1:0] sedeleg;
// logic [       `XLEN-1:0] sideleg;
logic [       `XLEN-1:0] sie;
logic [       `XLEN-1:0] sip;
logic [       `XLEN-1:0] stvec;
logic [       `XLEN-1:0] sscratch;
logic [       `XLEN-1:0] sepc;
logic [       `XLEN-1:0] scause;
logic [       `XLEN-1:0] stval;
logic [       `XLEN-1:0] mstatus;
logic [       `XLEN-1:0] misa;
logic [       `XLEN-1:0] medeleg;
logic [       `XLEN-1:0] mideleg;
logic [       `XLEN-1:0] mie;
logic [       `XLEN-1:0] mtvec;
logic [       `XLEN-1:0] mscratch;
logic [       `XLEN-1:0] mepc;
logic [       `XLEN-1:0] mcause;
logic [       `XLEN-1:0] mtval;
logic [       `XLEN-1:0] mip;

logic                    mstatus_sie;
logic                    mstatus_mie;
logic                    mstatus_spie;
logic                    mstatus_mpie;
logic                    mstatus_spp;
logic [             1:0] mstatus_mpp;
logic [             1:0] mstatus_fs;
logic [             1:0] mstatus_xs;
logic                    mstatus_mprv;
logic                    mstatus_sum;
logic                    mstatus_mxr;
logic                    mstatus_tvm;
logic                    mstatus_tw;
logic                    mstatus_tsr;
logic [             1:0] mstatus_uxl;
logic [             1:0] mstatus_sxl;
logic                    mstatus_sd;

logic                    medeleg_imisalign;
logic                    medeleg_bp;
logic                    medeleg_uecall;
logic                    medeleg_instpgfault;
logic                    medeleg_ldpgfault;
logic                    medeleg_stpgfault;

logic                    mideleg_ssip;
logic                    mideleg_stip;
logic                    mideleg_seip;

logic                    mie_ssie;
logic                    mie_msie;
logic                    mie_stie;
logic                    mie_mtie;
logic                    mie_seie;
logic                    mie_meie;

logic                    mip_ssip;
logic                    mip_msip;
logic                    mip_stip;
logic                    mip_mtip;
logic                    mip_seip;
logic                    mip_meip;

logic [             1:0] misa_mxl;
logic [            25:0] misa_ext;


logic [       `XLEN-2:0] mcause_code;
logic                    mcause_int;

logic [       `XLEN-2:0] scause_code;
logic                    scause_int;

logic [       `XLEN-1:0] ints_en;
logic [       `XLEN-1:0] ints_m_en;
logic [       `XLEN-1:0] ints_s_en;

assign ints_en     = mie & mip;
assign ints_m_en   = mie & mip & ~mideleg;
assign ints_s_en   = mie & mip &  mideleg;

assign wakeup      = |ints_en;
assign irq_trigger = ~trap_en && (ints_m_mode || ints_s_mode);
assign ret_epc     = sret ? sepc : mepc;
assign eret_en     = ~trap_en && (sret || mret);

assign trap_m_mode = ~trap_s_mode;
assign trap_s_mode = prv <= `PRV_S && |(medeleg & (`XLEN'b1 << trap_cause[`XLEN-2:0]));
assign ints_m_mode = ((prv == `PRV_M && mstatus_mie) || prv < `PRV_M) && |(~mideleg & mip & mie);
assign ints_s_mode = ((prv == `PRV_S && mstatus_sie) || prv < `PRV_S) && |( mideleg & mip & mie) && !ints_m_mode;

assign trap_vec    = ((trap_en ? (trap_m_mode ? mtvec : stvec):
                                 (ints_m_mode ? mtvec : stvec)) & ~`IM_ADDR_LEN'h3) + vec_offset;

assign vec_offset  = trap_en     ? `IM_ADDR_LEN'd0:
                     ints_s_mode ? ints_s_en[`MIP_MEIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_MEIP_BIT << 2) & {`IM_ADDR_LEN{stvec[0]}}:
                                   ints_s_en[`MIP_MSIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_MSIP_BIT << 2) & {`IM_ADDR_LEN{stvec[0]}}:
                                   ints_s_en[`MIP_MTIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_MTIP_BIT << 2) & {`IM_ADDR_LEN{stvec[0]}}:
                                   ints_s_en[`MIP_SEIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_SEIP_BIT << 2) & {`IM_ADDR_LEN{stvec[0]}}:
                                   ints_s_en[`MIP_SSIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_SSIP_BIT << 2) & {`IM_ADDR_LEN{stvec[0]}}:
                                   /*ints_s_en[`MIP_STIP_BIT] ? */ (`IM_ADDR_LEN'd`MIP_STIP_BIT << 2) & {`IM_ADDR_LEN{stvec[0]}}:
                     ints_m_mode ? ints_m_en[`MIP_MEIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_MEIP_BIT << 2) & {`IM_ADDR_LEN{mtvec[0]}}:
                                   ints_m_en[`MIP_MSIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_MSIP_BIT << 2) & {`IM_ADDR_LEN{mtvec[0]}}:
                                   ints_m_en[`MIP_MTIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_MTIP_BIT << 2) & {`IM_ADDR_LEN{mtvec[0]}}:
                                   ints_m_en[`MIP_SEIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_SEIP_BIT << 2) & {`IM_ADDR_LEN{mtvec[0]}}:
                                   ints_m_en[`MIP_SSIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_SSIP_BIT << 2) & {`IM_ADDR_LEN{mtvec[0]}}:
                                   /*ints_m_en[`MIP_STIP_BIT] ? */ (`IM_ADDR_LEN'd`MIP_STIP_BIT << 2) & {`IM_ADDR_LEN{mtvec[0]}}:
                                   `IM_ADDR_LEN'd0;


assign cause       = trap_en     ? trap_cause : 
                     ints_s_mode ? ints_s_en[`MIP_MEIP_BIT]      ? (`XLEN'd`MIP_MEIP_BIT | (`XLEN'd1 << 31)):
                                   ints_s_en[`MIP_MSIP_BIT]      ? (`XLEN'd`MIP_MSIP_BIT | (`XLEN'd1 << 31)):
                                   ints_s_en[`MIP_MTIP_BIT]      ? (`XLEN'd`MIP_MTIP_BIT | (`XLEN'd1 << 31)):
                                   ints_s_en[`MIP_SEIP_BIT]      ? (`XLEN'd`MIP_SEIP_BIT | (`XLEN'd1 << 31)):
                                   ints_s_en[`MIP_SSIP_BIT]      ? (`XLEN'd`MIP_SSIP_BIT | (`XLEN'd1 << 31)):
                                   /*ints_s_en[`MIP_STIP_BIT] ? */ (`XLEN'd`MIP_STIP_BIT | (`XLEN'd1 << 31)):
                     ints_m_mode ? ints_m_en[`MIP_MEIP_BIT]      ? (`XLEN'd`MIP_MEIP_BIT | (`XLEN'd1 << 31)):
                                   ints_m_en[`MIP_MSIP_BIT]      ? (`XLEN'd`MIP_MSIP_BIT | (`XLEN'd1 << 31)):
                                   ints_m_en[`MIP_MTIP_BIT]      ? (`XLEN'd`MIP_MTIP_BIT | (`XLEN'd1 << 31)):
                                   ints_m_en[`MIP_SEIP_BIT]      ? (`XLEN'd`MIP_SEIP_BIT | (`XLEN'd1 << 31)):
                                   ints_m_en[`MIP_SSIP_BIT]      ? (`XLEN'd`MIP_SSIP_BIT | (`XLEN'd1 << 31)):
                                   /*ints_m_en[`MIP_STIP_BIT] ? */ (`XLEN'd`MIP_STIP_BIT | (`XLEN'd1 << 31)):
                                   `XLEN'd0;

assign tval         = trap_en ? trap_val : `XLEN'd0;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) prv <= `PRV_M;
    else if (trap_en) begin
        if (trap_s_mode) begin
            prv <= `PRV_S;
        end
        else begin
            prv <= `PRV_M;
        end
    end
    else if (ints_m_mode) begin
        prv <= `PRV_M;
    end
    else if (ints_s_mode) begin
        prv <= `PRV_S;
    end
    else if (sret) begin
        prv <= {1'b0, mstatus_spp};
    end
    else if (mret) begin
        prv <= mstatus_mpp;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)                                       stvec <= `XLEN'b0;
    else if (csr_wr && csr_waddr == `CSR_STVEC_ADDR) stvec <= (~`XLEN'h2  & csr_wdata);
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)                                          sscratch <= `XLEN'b0;
    else if (csr_wr && csr_waddr == `CSR_SSCRATCH_ADDR) sscratch <= csr_wdata;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        sepc <= `XLEN'b0;
    end
    else if (trap_en && trap_s_mode) begin
        sepc <= trap_epc;
    end
    else if (ints_s_mode) begin
        sepc <= trap_epc;
    end
    else if (csr_wr && csr_waddr == `CSR_SEPC_ADDR) begin
        sepc <= (~`XLEN'h3  & csr_wdata);
    end
end

assign scause = {scause_int, scause_code};

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        scause_int  <= 1'b0;
        scause_code <= {`XLEN-1{1'b0}};
    end
    else if (trap_en && trap_s_mode) begin
        scause_code <= trap_cause[0+:`XLEN-1];
        scause_int  <= trap_cause[`XLEN-1];
    end
    else if (ints_s_mode) begin
        scause_int  <= 1'b1;
        scause_code <= ints_s_en[`MIP_MEIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_MEIP_BIT:
                       ints_s_en[`MIP_MSIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_MSIP_BIT:
                       ints_s_en[`MIP_MTIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_MTIP_BIT:
                       ints_s_en[`MIP_SEIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_SEIP_BIT:
                       ints_s_en[`MIP_SSIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_SSIP_BIT:
                       ints_s_en[`MIP_STIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_STIP_BIT:
                                                  {(`XLEN-1){1'b1}};
    end
    else if (csr_wr && csr_waddr == `CSR_SCAUSE_ADDR) begin
        scause_code <= csr_wdata[0+:`XLEN-1];
        scause_int  <= csr_wdata[`XLEN-1];
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        stval <= `XLEN'b0;
    end
    else if (trap_en && trap_s_mode) begin
        stval <= trap_val;
    end
    else if (ints_s_mode) begin
        stval <= `XLEN'b0;
    end
    else if (csr_wr && csr_waddr == `CSR_STVAL_ADDR) stval <= csr_wdata;
end

assign mstatus = {mstatus_sd, 8'b0, mstatus_tsr, /*mstatus_tw*/1'b0, mstatus_tvm,
                  mstatus_mxr, mstatus_sum, mstatus_mprv, mstatus_xs,
                  mstatus_fs, mstatus_mpp, 2'b0, mstatus_spp,
                  mstatus_mpie, 1'b0, mstatus_spie, 1'b0,
                  mstatus_mie, 1'b0, mstatus_sie, 1'b0};


assign sstatus = {1'b0, 8'b0, 1'b0, 1'b0, 1'b0,
                  mstatus_mxr, mstatus_sum, 1'b0, mstatus_xs,
                  mstatus_fs, 2'b0, 2'b0, mstatus_spp,
                  1'b0, 1'b0, mstatus_spie, 1'b0,
                  1'b0, 1'b0, mstatus_sie, 1'b0};

assign tvm     = mstatus_tvm;
assign tsr     = mstatus_tsr;
assign sum     = mstatus_sum;
assign mprv    = mstatus_mprv;
assign mpp     = mstatus_mpp;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        mstatus_sie  <= 1'b0;
        mstatus_mie  <= 1'b0;
        mstatus_spie <= 1'b0;
        mstatus_mpie <= 1'b0;
        mstatus_spp  <= 1'b0;
        mstatus_mpp  <= 2'b0;
        mstatus_fs   <= 2'b0;
        mstatus_xs   <= 2'b0;
        mstatus_mprv <= 1'b0;
        mstatus_sum  <= 1'b0;
        mstatus_mxr  <= 1'b0;
        mstatus_tvm  <= 1'b0;
        mstatus_tw   <= 1'b0;
        mstatus_tsr  <= 1'b0;
        mstatus_uxl  <= 2'b0;
        mstatus_sxl  <= 2'b0;
        mstatus_sd   <= 1'b0;
    end
    else if (trap_en) begin
        if (trap_s_mode) begin
            mstatus_spp  <= prv[0];
            mstatus_spie <= mstatus_sie;
            mstatus_sie  <= 1'b0;
        end
        else begin
            mstatus_mpp  <= prv;
            mstatus_mpie <= mstatus_mie;
            mstatus_mie  <= 1'b0;
        end
    end
    else if (ints_m_mode) begin
        mstatus_mpp  <= prv;
        mstatus_mpie <= mstatus_mie;
        mstatus_mie  <= 1'b0;
    end
    else if (ints_s_mode) begin
        mstatus_spp  <= prv[0];
        mstatus_spie <= mstatus_sie;
        mstatus_sie  <= 1'b0;
    end
    else if (sret) begin
        mstatus_spp  <= 1'b0;
        mstatus_sie  <= mstatus_spie;
        mstatus_spie <= 1'b1;
    end
    else if (mret) begin
        mstatus_mpp  <= `PRV_U;
        mstatus_mie  <= mstatus_mpie;
        mstatus_mpie <= 1'b1;
    end
    else if (csr_wr && csr_waddr == `CSR_SSTATUS_ADDR) begin
        mstatus_sie  <= csr_wdata[`MSTATUS_SIE_BIT  ];
        mstatus_spie <= csr_wdata[`MSTATUS_SPIE_BIT ];
        mstatus_spp  <= csr_wdata[`MSTATUS_SPP_BIT  ];
        // mstatus_fs   <= csr_wdata[`MSTATUS_FS_BIT   ];
        // mstatus_xs   <= csr_wdata[`MSTATUS_XS_BIT   ];
        mstatus_sum  <= csr_wdata[`MSTATUS_SUM_BIT  ];
        mstatus_mxr  <= csr_wdata[`MSTATUS_MXR_BIT  ];
    end
    else if (csr_wr && csr_waddr == `CSR_MSTATUS_ADDR) begin
        mstatus_sie  <= csr_wdata[`MSTATUS_SIE_BIT  ];
        mstatus_mie  <= csr_wdata[`MSTATUS_MIE_BIT  ];
        mstatus_spie <= csr_wdata[`MSTATUS_SPIE_BIT ];
        mstatus_mpie <= csr_wdata[`MSTATUS_MPIE_BIT ];
        mstatus_spp  <= csr_wdata[`MSTATUS_SPP_BIT  ];
        mstatus_mpp  <= csr_wdata[`MSTATUS_MPP_BIT  ];
        // mstatus_fs   <= csr_wdata[`MSTATUS_FS_BIT   ];
        // mstatus_xs   <= csr_wdata[`MSTATUS_XS_BIT   ];
        mstatus_mprv <= csr_wdata[`MSTATUS_MPRV_BIT ];
        mstatus_sum  <= csr_wdata[`MSTATUS_SUM_BIT  ];
        mstatus_mxr  <= csr_wdata[`MSTATUS_MXR_BIT  ];
        mstatus_tvm  <= csr_wdata[`MSTATUS_TVM_BIT  ];
        mstatus_tw   <= csr_wdata[`MSTATUS_TW_BIT   ];
        mstatus_tsr  <= csr_wdata[`MSTATUS_TSR_BIT  ];
        mstatus_sd   <= csr_wdata[`MSTATUS_32_SD_BIT];
    end
end

assign misa = misa_mxl == 2'h1 ? {{`XLEN-32{1'b0}}, misa_mxl, 4'b0, misa_ext}:
              misa_mxl == 2'h2 ? {misa_mxl, {`XLEN-28{1'b0}}, misa_ext}:
                                 `XLEN'b0;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
`ifdef RV32
        misa_mxl <= 2'h1;
`else
        misa_mxl <= 2'h2;
`endif
        misa_ext <= 26'b0;
    end
end

assign medeleg = {{(`XLEN-16){1'b0}}, medeleg_stpgfault, 1'b0, medeleg_ldpgfault,
                  medeleg_instpgfault, 1'b0, 1'b0, 1'b0, medeleg_uecall, 1'b0, 1'b0,
                  1'b0, 1'b0, medeleg_bp, 1'b0, 1'b0, medeleg_imisalign};

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        medeleg_imisalign   <= 1'b0;
        medeleg_bp          <= 1'b0;
        medeleg_uecall      <= 1'b0;
        medeleg_instpgfault <= 1'b0;
        medeleg_ldpgfault   <= 1'b0;
        medeleg_stpgfault   <= 1'b0;
    end
    else if (csr_wr && csr_waddr == `CSR_MEDELEG_ADDR) begin
        medeleg_imisalign   <= csr_wdata[`CAUSE_MISALIGNED_FETCH      ];
        medeleg_bp          <= csr_wdata[`CAUSE_BREAKPOINT            ];
        medeleg_uecall      <= csr_wdata[`CAUSE_USER_ECALL            ];
        medeleg_instpgfault <= csr_wdata[`CAUSE_INSTRUCTION_PAGE_FAULT];
        medeleg_ldpgfault   <= csr_wdata[`CAUSE_LOAD_PAGE_FAULT       ];
        medeleg_stpgfault   <= csr_wdata[`CAUSE_STORE_PAGE_FAULT      ];
    end
end

assign mideleg = {{(`XLEN-10){1'b0}}, mideleg_seip, 3'b0, mideleg_stip, 3'b0, mideleg_ssip, 1'b0};

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        mideleg_ssip <= 1'b0;
        mideleg_stip <= 1'b0;
        mideleg_seip <= 1'b0;
    end
    else if (csr_wr && csr_waddr == `CSR_MIDELEG_ADDR) begin
        mideleg_ssip <= csr_wdata[1];
        mideleg_stip <= csr_wdata[5];
        mideleg_seip <= csr_wdata[9];
    end
end

assign mie = {{(`XLEN-12){1'b0}}, mie_meie, 1'b0, mie_seie, 1'b0, mie_mtie, 1'b0,
              mie_stie, 1'b0, mie_msie, 1'b0, mie_ssie, 1'b0};

assign sie = {{(`XLEN-10){1'b0}}, mie_seie, 3'b0, mie_stie, 3'b0, mie_ssie, 1'b0};

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        mie_ssie <= 1'b0;
        mie_msie <= 1'b0;
        mie_stie <= 1'b0;
        mie_mtie <= 1'b0;
        mie_seie <= 1'b0;
        mie_meie <= 1'b0;
    end
    else if (csr_wr && csr_waddr == `CSR_SIE_ADDR) begin
        mie_ssie <= csr_wdata[1];
        mie_stie <= csr_wdata[5];
        mie_seie <= csr_wdata[9];
    end
    else if (csr_wr && csr_waddr == `CSR_MIE_ADDR) begin
        mie_ssie <= csr_wdata[ 1];
        mie_msie <= csr_wdata[ 3];
        mie_stie <= csr_wdata[ 5];
        mie_mtie <= csr_wdata[ 7];
        mie_seie <= csr_wdata[ 9];
        mie_meie <= csr_wdata[11];
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)                                       mtvec <= `XLEN'b0;
    else if (csr_wr && csr_waddr == `CSR_MTVEC_ADDR) mtvec <= (~`XLEN'h2  & csr_wdata);
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)                                          mscratch <= `XLEN'b0;
    else if (csr_wr && csr_waddr == `CSR_MSCRATCH_ADDR) mscratch <= csr_wdata;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        mepc <= `XLEN'b0;
    end
    else if (trap_en && ~trap_s_mode) begin
        mepc <= trap_epc;
    end
    else if (ints_m_mode) begin
        mepc <= trap_epc;
    end
    else if (csr_wr && csr_waddr == `CSR_MEPC_ADDR) begin
        mepc <= (~`XLEN'h3  & csr_wdata);
    end
end

assign mcause = {mcause_int, mcause_code};

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        mcause_code <= {`XLEN-1{1'b0}};
        mcause_int  <= 1'b0;
    end
    else if (trap_en && ~trap_s_mode) begin
        mcause_code <= trap_cause[0+:`XLEN-1];
        mcause_int  <= trap_cause[`XLEN-1];
    end
    else if (ints_m_mode) begin
        mcause_int  <= 1'b1;
        mcause_code <= ints_m_en[`MIP_MEIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_MEIP_BIT:
                       ints_m_en[`MIP_MSIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_MSIP_BIT:
                       ints_m_en[`MIP_MTIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_MTIP_BIT:
                       ints_m_en[`MIP_SEIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_SEIP_BIT:
                       ints_m_en[`MIP_SSIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_SSIP_BIT:
                       ints_m_en[`MIP_STIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_STIP_BIT:
                                                  {(`XLEN-1){1'b1}};
    end
    else if (csr_wr && csr_waddr == `CSR_MCAUSE_ADDR) begin
        mcause_code <= csr_wdata[0+:`XLEN-1];
        mcause_int  <= csr_wdata[`XLEN-1];
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        mtval <= `XLEN'b0;
    end
    else if (trap_en && ~trap_s_mode) begin
        mtval <= trap_val;
    end
    else if (ints_m_mode) begin
        mtval <= `XLEN'b0;
    end
    else if (csr_wr && csr_waddr == `CSR_MTVAL_ADDR) begin
        mtval <= csr_wdata;
    end
end

assign mip = {{(`XLEN-12){1'b0}}, mip_meip, 1'b0, mip_seip, 1'b0, mip_mtip, 1'b0,
              mip_stip, 1'b0, mip_msip, 1'b0, mip_ssip, 1'b0};

assign sip = {{(`XLEN-2){1'b0}}, mip_ssip, 1'b0};

always_ff @(posedge clk_free or negedge rstn) begin
    if (~rstn) begin
        msip_d1  <= 1'b0;
        mtip_d1  <= 1'b0;
        meip_d1  <= 1'b0;
        mip_msip <= 1'b0;
        mip_mtip <= 1'b0;
        mip_meip <= 1'b0;
    end
    else begin
        msip_d1  <= ext_msip;
        mtip_d1  <= ext_mtip;
        meip_d1  <= ext_meip;
        mip_msip <= msip_d1;
        mip_mtip <= mtip_d1;
        mip_meip <= meip_d1;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        mip_ssip <= 1'b0;
        mip_stip <= 1'b0;
        mip_seip <= 1'b0;
    end
    else if (~sleep) begin
        if (csr_wr && csr_waddr == `CSR_SIP_ADDR)  begin
            mip_ssip <= csr_wdata[1] & mideleg_ssip;
        end
        else if (csr_wr && csr_waddr == `CSR_MIP_ADDR) begin
            mip_ssip <= csr_wdata[1];
            mip_stip <= csr_wdata[5];
            mip_seip <= csr_wdata[9];
        end
    end
end

always_comb begin
    csr_rdata = `XLEN'b0;
    case (csr_raddr) 
        `CSR_SSTATUS_ADDR   : csr_rdata = sstatus;
        `CSR_SEDELEG_ADDR   : csr_rdata = `XLEN'b0;
        `CSR_SIDELEG_ADDR   : csr_rdata = `XLEN'b0;
        `CSR_SIE_ADDR       : csr_rdata = sie & mideleg;
        `CSR_STVEC_ADDR     : csr_rdata = stvec;
        `CSR_SCOUNTEREN_ADDR: csr_rdata = `XLEN'b0;
        `CSR_SSCRATCH_ADDR  : csr_rdata = sscratch;
        `CSR_SEPC_ADDR      : csr_rdata = sepc;
        `CSR_SCAUSE_ADDR    : csr_rdata = scause;
        `CSR_STVAL_ADDR     : csr_rdata = stval;
        `CSR_SIP_ADDR       : csr_rdata = sip & mideleg;
        `CSR_MSTATUS_ADDR   : csr_rdata = mstatus;
        `CSR_MISA_ADDR      : csr_rdata = misa;
        `CSR_MEDELEG_ADDR   : csr_rdata = medeleg;
        `CSR_MIDELEG_ADDR   : csr_rdata = mideleg;
        `CSR_MIE_ADDR       : csr_rdata = mie;
        `CSR_MTVEC_ADDR     : csr_rdata = mtvec;
        `CSR_MCOUNTEREN_ADDR: csr_rdata = `XLEN'b0;
        `CSR_MSCRATCH_ADDR  : csr_rdata = mscratch;
        `CSR_MEPC_ADDR      : csr_rdata = mepc;
        `CSR_MCAUSE_ADDR    : csr_rdata = mcause;
        `CSR_MTVAL_ADDR     : csr_rdata = mtval;
        `CSR_MIP_ADDR       : csr_rdata = mip;
    endcase
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/alu.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif


`define ALU_OP_LEN 4
`define CSR_OP_LEN 2

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       `XLEN'h0
`define CAUSE_INSTRUCTION_ACCESS     `XLEN'h1
`define CAUSE_ILLEGAL_INSTRUCTION    `XLEN'h2
`define CAUSE_BREAKPOINT             `XLEN'h3
`define CAUSE_MISALIGNED_LOAD        `XLEN'h4
`define CAUSE_LOAD_ACCESS            `XLEN'h5
`define CAUSE_MISALIGNED_STORE       `XLEN'h6
`define CAUSE_STORE_ACCESS           `XLEN'h7
`define CAUSE_USER_ECALL             `XLEN'h8
`define CAUSE_SUPERVISOR_ECALL       `XLEN'h9
`define CAUSE_HYPERVISOR_ECALL       `XLEN'ha
`define CAUSE_MACHINE_ECALL          `XLEN'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT `XLEN'hc
`define CAUSE_LOAD_PAGE_FAULT        `XLEN'hd
`define CAUSE_STORE_PAGE_FAULT       `XLEN'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`ifdef RV32
  `define SATP_PPN_WIDTH  22
  `define SATP_ASID_WIDTH  9
  `define SATP_MODE_WIDTH  1
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   22+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   31+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 31

`else
  `define SATP_PPN_WIDTH  44
  `define SATP_ASID_WIDTH 16
  `define SATP_MODE_WIDTH  4
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   44+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   60+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 63
`endif

`define PADDR_LEN       (`SATP_PPN_WIDTH + 12)

`endif

module alu (
    input        [`ALU_OP_LEN - 1:0] alu_op,
    input        [      `XLEN - 1:0] src1,
    input        [      `XLEN - 1:0] src2,
    output logic [      `XLEN - 1:0] out,
    output logic                     zero_flag
);

parameter [`ALU_OP_LEN - 1:0] ALU_AND  = `ALU_OP_LEN'b0000,
                              ALU_OR   = `ALU_OP_LEN'b0001,
                              ALU_XOR  = `ALU_OP_LEN'b0010,
                              ALU_ADD  = `ALU_OP_LEN'b0011,
                              ALU_SUB  = `ALU_OP_LEN'b0100,
                              ALU_SLT  = `ALU_OP_LEN'b0101,
                              ALU_SLL  = `ALU_OP_LEN'b0110,
                              ALU_SRL  = `ALU_OP_LEN'b0111,
                              ALU_SLTU = `ALU_OP_LEN'b1000,
                              ALU_SRA  = `ALU_OP_LEN'b1001;

logic signed [`XLEN - 1:0] signed_src1;
logic signed [`XLEN - 1:0] signed_src2;

assign signed_src1 = src1;
assign signed_src2 = src2;
assign zero_flag   = ~|out;

always_comb begin
    out = `XLEN'b0;
    case (alu_op)
        ALU_AND : begin
            out = src1 & src2;
        end
        ALU_OR  : begin
            out = src1 | src2;
        end
        ALU_XOR : begin
            out = src1 ^ src2;
        end
        ALU_ADD : begin
            out = src1 + src2;
        end
        ALU_SUB : begin
            out = src1 - src2;
        end
        ALU_SLT : begin
            out = (signed_src1 < signed_src2) ? `XLEN'b1 : `XLEN'b0;
        end
        ALU_SLL : begin
            out = src1 << src2[$clog2(`XLEN) - 1:0];
        end
        ALU_SRL : begin
            out = src1 >> src2[$clog2(`XLEN) - 1:0];
        end
        ALU_SLTU: begin
            out = (src1 < src2) ? `XLEN'b1 : `XLEN'b0;
        end
        ALU_SRA : begin
            out = signed_src1 >>> src2[$clog2(`XLEN) - 1:0];
        end
    endcase
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/tpu.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif


`define ALU_OP_LEN 4
`define CSR_OP_LEN 2

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       `XLEN'h0
`define CAUSE_INSTRUCTION_ACCESS     `XLEN'h1
`define CAUSE_ILLEGAL_INSTRUCTION    `XLEN'h2
`define CAUSE_BREAKPOINT             `XLEN'h3
`define CAUSE_MISALIGNED_LOAD        `XLEN'h4
`define CAUSE_LOAD_ACCESS            `XLEN'h5
`define CAUSE_MISALIGNED_STORE       `XLEN'h6
`define CAUSE_STORE_ACCESS           `XLEN'h7
`define CAUSE_USER_ECALL             `XLEN'h8
`define CAUSE_SUPERVISOR_ECALL       `XLEN'h9
`define CAUSE_HYPERVISOR_ECALL       `XLEN'ha
`define CAUSE_MACHINE_ECALL          `XLEN'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT `XLEN'hc
`define CAUSE_LOAD_PAGE_FAULT        `XLEN'hd
`define CAUSE_STORE_PAGE_FAULT       `XLEN'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`ifdef RV32
  `define SATP_PPN_WIDTH  22
  `define SATP_ASID_WIDTH  9
  `define SATP_MODE_WIDTH  1
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   22+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   31+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 31

`else
  `define SATP_PPN_WIDTH  44
  `define SATP_ASID_WIDTH 16
  `define SATP_MODE_WIDTH  4
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   44+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   60+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 63
`endif

`define PADDR_LEN       (`SATP_PPN_WIDTH + 12)

`endif

module tpu (
    input                           inst_valid,
    input        [`IM_DATA_LEN-1:0] inst,
    input        [`IM_ADDR_LEN-1:0] exe_pc,
    input        [`IM_ADDR_LEN-1:0] mem_pc,
    input        [`DM_ADDR_LEN-1:0] ldst_badaddr,
    input        [`IM_ADDR_LEN-1:0] inst_badaddr,
    input        [             1:0] prv_cur,
    input        [             1:0] prv_req,
    input                           satp_upd,
    input                           tvm,
    input                           tsr,
    input                           sret,
    input                           ecall,
    input                           ebreak,
    input                           tlb_flush_req,
    input                           ill_inst,
    input                           inst_misaligned,
    input                           inst_pg_fault,
    input                           inst_xes_fault,
    input                           load_misaligned,
    input                           load_pg_fault,
    input                           load_xes_fault,
    input                           store_misaligned,
    input                           store_pg_fault,
    input                           store_xes_fault,
    output logic                    trap_en,
    output logic [       `XLEN-1:0] trap_cause,
    output logic [`IM_ADDR_LEN-1:0] trap_epc,
    output logic [       `XLEN-1:0] trap_val
);

logic trap_inst_misaligned;
logic trap_inst_access_fault;
logic trap_ill_inst;
logic trap_inst_addr_break_point;
logic trap_ldst_addr_break_point;
logic trap_env_break_point;
logic trap_load_misaligned;
logic trap_load_access_fault;
logic trap_store_misaligned;
logic trap_store_access_fault;
logic trap_u_ecall;
logic trap_s_ecall;
logic trap_h_ecall;
logic trap_m_ecall;
logic trap_inst_pg_fault;
logic trap_load_pg_fault;
logic trap_store_pg_fault;

logic if_trap_en;
logic exe_trap_en;
logic mem_trap_en;

assign trap_inst_misaligned       = inst_misaligned;
assign trap_inst_access_fault     = inst_xes_fault;
assign trap_ill_inst              = ill_inst || prv_cur < prv_req ||
                                    ((satp_upd || tlb_flush_req) && tvm && prv_cur < `PRV_M) ||
                                    (sret && tsr && prv_cur < `PRV_M);
assign trap_inst_addr_break_point = 1'b0;
assign trap_ldst_addr_break_point = 1'b0;
assign trap_env_break_point       = ebreak;
assign trap_load_misaligned       = load_misaligned;
assign trap_load_access_fault     = load_xes_fault;
assign trap_store_misaligned      = store_misaligned;
assign trap_store_access_fault    = store_xes_fault;
assign trap_u_ecall               = ecall && prv_cur == `PRV_U;
assign trap_s_ecall               = ecall && prv_cur == `PRV_S;
assign trap_h_ecall               = ecall && prv_cur == `PRV_H;
assign trap_m_ecall               = ecall && prv_cur == `PRV_M;
assign trap_inst_pg_fault         = inst_pg_fault;
assign trap_load_pg_fault         = load_pg_fault;
assign trap_store_pg_fault        = store_pg_fault;

assign trap_en = (inst_valid && (if_trap_en | exe_trap_en)) || mem_trap_en;

assign if_trap_en  = trap_inst_misaligned | trap_inst_access_fault |
                     trap_inst_pg_fault | trap_inst_addr_break_point;

assign exe_trap_en = trap_ill_inst |
                     trap_env_break_point |
                     trap_u_ecall | trap_s_ecall |
                     trap_h_ecall | trap_m_ecall;

assign mem_trap_en = trap_load_misaligned   | trap_store_misaligned |
                     trap_load_access_fault | trap_store_access_fault |
                     trap_load_pg_fault     | trap_store_pg_fault |
                     trap_ldst_addr_break_point;

assign trap_cause = mem_trap_en ?
                    (({`XLEN{trap_store_misaligned      }} & `XLEN'd6) |
                     ({`XLEN{trap_load_misaligned       }} & `XLEN'd4) |
                     ({`XLEN{trap_store_pg_fault        }} & `XLEN'd15) |
                     ({`XLEN{trap_load_pg_fault         }} & `XLEN'd13) |
                     ({`XLEN{trap_store_access_fault    }} & `XLEN'd7) |
                     ({`XLEN{trap_load_access_fault     }} & `XLEN'd5) |
                     ({`XLEN{trap_ldst_addr_break_point }} & `XLEN'd3)):
                    if_trap_en ?
                    (({`XLEN{trap_inst_addr_break_point }} & `XLEN'd3) |
                     ({`XLEN{trap_inst_pg_fault         }} & `XLEN'd12) |
                     ({`XLEN{trap_inst_access_fault     }} & `XLEN'd1) |
                     ({`XLEN{trap_inst_misaligned       }} & `XLEN'd0)):
                    exe_trap_en ?
                    (({`XLEN{trap_ill_inst              }} & `XLEN'd2) |
                     ({`XLEN{trap_u_ecall               }} & `XLEN'd8) |
                     ({`XLEN{trap_s_ecall               }} & `XLEN'd9) |
                     ({`XLEN{trap_m_ecall               }} & `XLEN'd11) |
                     ({`XLEN{trap_env_break_point       }} & `XLEN'd3)):
                                                             `XLEN'd0;

assign trap_val   = mem_trap_en          ? ldst_badaddr:
                    trap_inst_misaligned ? inst_badaddr:
                    if_trap_en           ? exe_pc:
                    trap_ill_inst        ? inst:
                                           `XLEN'd0;

assign trap_epc   = mem_trap_en ? mem_pc : exe_pc;

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/dpu.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif


`define ALU_OP_LEN 4
`define CSR_OP_LEN 2

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       `XLEN'h0
`define CAUSE_INSTRUCTION_ACCESS     `XLEN'h1
`define CAUSE_ILLEGAL_INSTRUCTION    `XLEN'h2
`define CAUSE_BREAKPOINT             `XLEN'h3
`define CAUSE_MISALIGNED_LOAD        `XLEN'h4
`define CAUSE_LOAD_ACCESS            `XLEN'h5
`define CAUSE_MISALIGNED_STORE       `XLEN'h6
`define CAUSE_STORE_ACCESS           `XLEN'h7
`define CAUSE_USER_ECALL             `XLEN'h8
`define CAUSE_SUPERVISOR_ECALL       `XLEN'h9
`define CAUSE_HYPERVISOR_ECALL       `XLEN'ha
`define CAUSE_MACHINE_ECALL          `XLEN'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT `XLEN'hc
`define CAUSE_LOAD_PAGE_FAULT        `XLEN'hd
`define CAUSE_STORE_PAGE_FAULT       `XLEN'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`ifdef RV32
  `define SATP_PPN_WIDTH  22
  `define SATP_ASID_WIDTH  9
  `define SATP_MODE_WIDTH  1
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   22+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   31+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 31

`else
  `define SATP_PPN_WIDTH  44
  `define SATP_ASID_WIDTH 16
  `define SATP_MODE_WIDTH  4
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   44+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   60+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 63
`endif

`define PADDR_LEN       (`SATP_PPN_WIDTH + 12)

`endif

module dpu (
    input                                    clk,
    input                                    rstn,
    
    input        [       `IM_ADDR_LEN - 1:0] pc_i,
    input                                    sign_ext_i,
    input                                    req_i,
    input                                    wr_i,
    input        [(`DM_DATA_LEN >> 3) - 1:0] byte_i,
    input        [       `DM_ADDR_LEN - 1:0] addr_i,
    input        [       `DM_DATA_LEN - 1:0] wdata_i,

    output logic [       `DM_DATA_LEN - 1:0] rdata_o,
    output logic                             hazard_o,

    output logic [       `DM_ADDR_LEN - 1:0] bad_dxes_val,
    output logic                             fault,
    output logic                             load_misaligned,
    output logic                             store_misaligned,
    output logic                             load_pg_fault,
    output logic                             store_pg_fault,
    output logic                             load_xes_fault,
    output logic                             store_xes_fault,
    output logic [       `IM_ADDR_LEN - 1:0] fault_pc,

    output logic                             dmem_req,
    output logic [       `DM_ADDR_LEN - 1:0] dmem_addr,
    output logic                             dmem_wr,
    output logic [(`DM_DATA_LEN >> 3) - 1:0] dmem_byte,
    output logic [       `DM_DATA_LEN - 1:0] dmem_wdata,
    input        [       `DM_DATA_LEN - 1:0] dmem_rdata,
    input        [                      1:0] dmem_bad,
    input                                    dmem_busy
);

logic                              misaligned;
logic                              dmem_req_done;
logic                              dmem_req_latch;
logic                              data_latch_valid;
logic  [       `DM_DATA_LEN - 1:0] data_latch;
logic  [       `DM_DATA_LEN - 1:0] dmem_rdata_shft;
logic  [       `DM_DATA_LEN - 1:0] dmem_rdata_ext;
logic  [                      1:0] addr_latch;
logic                              sign_ext_latch;
logic  [(`DM_DATA_LEN >> 3) - 1:0] byte_latch;
logic                              load_latch;
logic                              store_latch;


assign dmem_req_done = dmem_req_latch & ~dmem_busy;

assign dmem_req      = req_i & ~misaligned & ~dmem_busy;
assign dmem_addr     = addr_i;
assign dmem_wr       = wr_i;

assign rdata_o       = data_latch_valid ? data_latch : dmem_rdata_ext;
assign hazard_o      = (dmem_req_latch & ~dmem_req_done) | (req_i & ~misaligned & dmem_busy);

assign misaligned      = ((addr_i[1:0] == 2'd1) && byte_i[1]) ||
                         ((addr_i[1:0] == 2'd2) && byte_i[2]) ||
                         ((addr_i[1:0] == 2'd3) && byte_i[1]);
assign load_pg_fault   = ~dmem_busy & dmem_bad[0] & load_latch;
assign store_pg_fault  = ~dmem_busy & dmem_bad[0] & store_latch;
assign load_xes_fault  = ~dmem_busy & dmem_bad[1] & load_latch;
assign store_xes_fault = ~dmem_busy & dmem_bad[1] & store_latch;
assign fault           = (~dmem_busy & |dmem_bad) || load_misaligned || store_misaligned;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        load_misaligned  <= 1'b0;
        store_misaligned <= 1'b0;
    end
    else begin
        load_misaligned  <= req_i & misaligned & ~wr_i;
        store_misaligned <= req_i & misaligned &  wr_i;
    end
end

always_comb begin
    case (dmem_addr[0+:2])
        2'h0: begin
            dmem_byte  = byte_i;
            dmem_wdata = wdata_i;
        end
        2'h1: begin
            dmem_byte  = {byte_i [ 2:0], byte_i [3]};
            dmem_wdata = {wdata_i[23:0], wdata_i[31:24]};
        end
        2'h2: begin
            dmem_byte  = {byte_i [ 1:0], byte_i [3:2]};
            dmem_wdata = {wdata_i[15:0], wdata_i[31:16]};
        end
        2'h3: begin
            dmem_byte  = {byte_i [0],   byte_i [3:1]};
            dmem_wdata = {wdata_i[7:0], wdata_i[31:8]};
        end
    endcase
end

always_comb begin
    case (addr_latch[0+:2])
        2'h0: begin
            dmem_rdata_shft = dmem_rdata;
        end
        2'h1: begin
            dmem_rdata_shft = {dmem_rdata[ 7:0], dmem_rdata[31: 8]};
        end
        2'h2: begin
            dmem_rdata_shft = {dmem_rdata[15:0], dmem_rdata[31:16]};
        end
        2'h3: begin
            dmem_rdata_shft = {dmem_rdata[23:0], dmem_rdata[31:24]};
        end
    endcase
end
always_comb begin
    if (byte_latch[3])      dmem_rdata_ext = dmem_rdata_shft[31:0];
    else if (byte_latch[1]) dmem_rdata_ext = {{16{sign_ext_latch & dmem_rdata_shft[15]}}, dmem_rdata_shft[15:0]};
    else if (byte_latch[0]) dmem_rdata_ext = {{24{sign_ext_latch & dmem_rdata_shft[ 7]}}, dmem_rdata_shft[ 7:0]};
    else                    dmem_rdata_ext = `XLEN'b0;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        data_latch_valid <= 1'b0;
    end
    else if (dmem_req_done) begin
        data_latch_valid <= 1'b0;
    end
    else if (~dmem_busy & dmem_req_latch) begin
        data_latch_valid <= 1'b1;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        data_latch <= `DM_DATA_LEN'b0;
    end
    else if (~dmem_busy & dmem_req_latch) begin
        data_latch <= dmem_rdata_ext;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        load_latch  <= 1'b0;
        store_latch <= 1'b0;
    end
    else if (dmem_req) begin
        load_latch  <= ~wr_i;
        store_latch <=  wr_i;
    end
    else if (~dmem_busy) begin
        load_latch  <= 1'b0;
        store_latch <= 1'b0;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        bad_dxes_val <= `DM_ADDR_LEN'b0;
        fault_pc     <= `IM_ADDR_LEN'b0;
    end
    else if (dmem_req || misaligned) begin
        bad_dxes_val <= addr_i;
        fault_pc     <= pc_i;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        dmem_req_latch <= 1'b0;
    end
    else if (dmem_req) begin
        dmem_req_latch <= 1'b1;
    end
    else if (dmem_req_done) begin
        dmem_req_latch <= 1'b0;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        addr_latch     <= 2'b0;
        sign_ext_latch <= 1'b0;
        byte_latch     <= 4'b0;
    end
    else if (dmem_req) begin
        addr_latch     <= addr_i[1:0];
        sign_ext_latch <= sign_ext_i;
        byte_latch     <= byte_i;
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/pmu.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif


`define ALU_OP_LEN 4
`define CSR_OP_LEN 2

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       `XLEN'h0
`define CAUSE_INSTRUCTION_ACCESS     `XLEN'h1
`define CAUSE_ILLEGAL_INSTRUCTION    `XLEN'h2
`define CAUSE_BREAKPOINT             `XLEN'h3
`define CAUSE_MISALIGNED_LOAD        `XLEN'h4
`define CAUSE_LOAD_ACCESS            `XLEN'h5
`define CAUSE_MISALIGNED_STORE       `XLEN'h6
`define CAUSE_STORE_ACCESS           `XLEN'h7
`define CAUSE_USER_ECALL             `XLEN'h8
`define CAUSE_SUPERVISOR_ECALL       `XLEN'h9
`define CAUSE_HYPERVISOR_ECALL       `XLEN'ha
`define CAUSE_MACHINE_ECALL          `XLEN'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT `XLEN'hc
`define CAUSE_LOAD_PAGE_FAULT        `XLEN'hd
`define CAUSE_STORE_PAGE_FAULT       `XLEN'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`ifdef RV32
  `define SATP_PPN_WIDTH  22
  `define SATP_ASID_WIDTH  9
  `define SATP_MODE_WIDTH  1
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   22+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   31+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 31

`else
  `define SATP_PPN_WIDTH  44
  `define SATP_ASID_WIDTH 16
  `define SATP_MODE_WIDTH  4
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   44+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   60+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 63
`endif

`define PADDR_LEN       (`SATP_PPN_WIDTH + 12)

`endif

module pmu (
    input                    clk_free,
    input                    rstn,
    input        [`XLEN-1:0] cpu_id,
    input                    inst_valid,
    
    // CSR interface
    input                    csr_wr,
    input        [     11:0] csr_waddr,
    input        [     11:0] csr_raddr,
    input        [`XLEN-1:0] csr_wdata,
    output logic [`XLEN-1:0] csr_rdata
);

logic [`XLEN-1:0] mhartid;
logic [     63:0] mcycle;
logic [     63:0] minstret;


always_ff @(posedge clk_free or negedge rstn) begin
    if (~rstn)                                        mcycle            <= 64'b0;
    else if (csr_wr && csr_waddr == `CSR_MCYCLE_ADDR)  mcycle[ 0+:`XLEN] <= csr_wdata;
    else if (csr_wr && csr_waddr == `CSR_MCYCLEH_ADDR) mcycle[32+:   32] <= csr_wdata;
    else                                              mcycle            <= mcycle + 64'b1;
end

always_ff @(posedge clk_free or negedge rstn) begin
    if (~rstn)                                          minstret            <= 64'b0;
    else if (csr_wr && csr_waddr == `CSR_MINSTRET_ADDR)  minstret[ 0+:`XLEN] <= csr_wdata;
    else if (csr_wr && csr_waddr == `CSR_MINSTRETH_ADDR) minstret[32+:   32] <= csr_wdata;
    else                                                minstret            <= minstret + {63'b0, inst_valid};
end

always_ff @(posedge clk_free or negedge rstn) begin
    if (~rstn) mhartid <= `XLEN'b0;
    else       mhartid <= cpu_id;
end

always_comb begin
    csr_rdata = `XLEN'b0;
    case (csr_raddr) 
        `CSR_MCYCLE_ADDR:    csr_rdata = mcycle[ 0+:`XLEN];
        `CSR_MCYCLEH_ADDR:   csr_rdata = mcycle[32+:   32];
        `CSR_MINSTRET_ADDR:  csr_rdata = minstret[ 0+:`XLEN];
        `CSR_MINSTRETH_ADDR: csr_rdata = minstret[32+:   32];
        `CSR_MHARTID_ADDR:   csr_rdata = mhartid;
    endcase
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/mpu_csr.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif


`define ALU_OP_LEN 4
`define CSR_OP_LEN 2

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       `XLEN'h0
`define CAUSE_INSTRUCTION_ACCESS     `XLEN'h1
`define CAUSE_ILLEGAL_INSTRUCTION    `XLEN'h2
`define CAUSE_BREAKPOINT             `XLEN'h3
`define CAUSE_MISALIGNED_LOAD        `XLEN'h4
`define CAUSE_LOAD_ACCESS            `XLEN'h5
`define CAUSE_MISALIGNED_STORE       `XLEN'h6
`define CAUSE_STORE_ACCESS           `XLEN'h7
`define CAUSE_USER_ECALL             `XLEN'h8
`define CAUSE_SUPERVISOR_ECALL       `XLEN'h9
`define CAUSE_HYPERVISOR_ECALL       `XLEN'ha
`define CAUSE_MACHINE_ECALL          `XLEN'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT `XLEN'hc
`define CAUSE_LOAD_PAGE_FAULT        `XLEN'hd
`define CAUSE_STORE_PAGE_FAULT       `XLEN'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`ifdef RV32
  `define SATP_PPN_WIDTH  22
  `define SATP_ASID_WIDTH  9
  `define SATP_MODE_WIDTH  1
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   22+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   31+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 31

`else
  `define SATP_PPN_WIDTH  44
  `define SATP_ASID_WIDTH 16
  `define SATP_MODE_WIDTH  4
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   44+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   60+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 63
`endif

`define PADDR_LEN       (`SATP_PPN_WIDTH + 12)

`endif

// Machine Memory Protection
// 0x3A0 MRW pmpcfg0 Physical memory protection configuration.
// 0x3A1 MRW pmpcfg1 Physical memory protection configuration, RV32 only.
// 0x3A2 MRW pmpcfg2 Physical memory protection configuration.
// 0x3A3 MRW pmpcfg3 Physical memory protection configuration, RV32 only.
// 0x3B0 MRW pmpaddr0 Physical memory protection address register.
// 0x3B1 MRW pmpaddr1 Physical memory protection address register.
// .
// .
// .
// 0x3BF MRW pmpaddr15 Physical memory protection address register.
// 0x3C0 MRW pmacfg0 Physical memory protection configuration.
// 0x3C1 MRW pmacfg1 Physical memory protection configuration, RV32 only.
// 0x3C2 MRW pmacfg2 Physical memory protection configuration.
// 0x3C3 MRW pmacfg3 Physical memory protection configuration, RV32 only.
// 0x3D0 MRW pmaaddr0 Physical memory protection address register.
// 0x3D1 MRW pmaaddr1 Physical memory protection address register.
// .
// .
// .
// 0x3DF MRW pmaaddr15 Physical memory protection address register.

module mpu_csr (
    input                    clk,
    input                    rstn,
    output logic [    8-1:0] pmpcfg  [16],
    output logic [`XLEN-1:0] pmpaddr [16],
    output logic [    8-1:0] pmacfg  [16],
    output logic [`XLEN-1:0] pmaaddr [16],

    // CSR interface
    input                    csr_wr,
    input        [     11:0] csr_waddr,
    input        [     11:0] csr_raddr,
    input        [`XLEN-1:0] csr_wdata,
    output logic [`XLEN-1:0] csr_rdata

);

parameter [11:0] CSR_PMPADDR_ADDR [0:15] = {
    `CSR_PMPADDR0_ADDR ,
    `CSR_PMPADDR1_ADDR ,
    `CSR_PMPADDR2_ADDR ,
    `CSR_PMPADDR3_ADDR ,
    `CSR_PMPADDR4_ADDR ,
    `CSR_PMPADDR5_ADDR ,
    `CSR_PMPADDR6_ADDR ,
    `CSR_PMPADDR7_ADDR ,
    `CSR_PMPADDR8_ADDR ,
    `CSR_PMPADDR9_ADDR ,
    `CSR_PMPADDR10_ADDR,
    `CSR_PMPADDR11_ADDR,
    `CSR_PMPADDR12_ADDR,
    `CSR_PMPADDR13_ADDR,
    `CSR_PMPADDR14_ADDR,
    `CSR_PMPADDR15_ADDR
};

logic [     63:0] pmpcfg0;
logic [     63:0] pmpcfg2;

logic [     15:0] pmpcfg_l;
logic [      1:0] pmpcfg_a [16];
logic [     15:0] pmpcfg_x;
logic [     15:0] pmpcfg_w;
logic [     15:0] pmpcfg_r;

always_comb begin
    integer i;
    for (i = 0; i < 16; i = i + 1) begin
        pmpcfg[i] = {pmpcfg_l[i], 2'b0, pmpcfg_a[i], pmpcfg_x[i], pmpcfg_w[i], pmpcfg_r[i]};
    end

    for (i = 0; i < 8; i = i + 1) begin
        pmpcfg0[i*8+:8] = pmpcfg[i  ];
        pmpcfg2[i*8+:8] = pmpcfg[i+8];
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 0; i < 16; i = i + 1) begin
            pmpcfg_l[i] <= 1'b0;
            pmpcfg_a[i] <= 2'b0;
            pmpcfg_x[i] <= 1'b0;
            pmpcfg_w[i] <= 1'b0;
            pmpcfg_r[i] <= 1'b0;
        end
    end
    else if (csr_wr && csr_waddr == `CSR_PMPCFG0_ADDR) begin
        for (i = 0; i < 4; i = i + 1) begin
            if (~pmpcfg_l[i]) begin
                pmpcfg_l[i] <= csr_wdata[(i*8)+`PMPCFG_L_BIT];
                pmpcfg_a[i] <= csr_wdata[(i*8)+`PMPCFG_A_BIT];
                pmpcfg_x[i] <= csr_wdata[(i*8)+`PMPCFG_X_BIT];
                pmpcfg_w[i] <= csr_wdata[(i*8)+`PMPCFG_W_BIT] & csr_wdata[(i*8)+`PMPCFG_R_BIT]; // if R=0 => W=0
                pmpcfg_r[i] <= csr_wdata[(i*8)+`PMPCFG_R_BIT];
            end
        end
    end
    else if (csr_wr && csr_waddr == `CSR_PMPCFG1_ADDR) begin
        for (i = 0; i < 4; i = i + 1) begin
            if (~pmpcfg_l[i+4]) begin
                pmpcfg_l[i+4] <= csr_wdata[(i*8)+`PMPCFG_L_BIT];
                pmpcfg_a[i+4] <= csr_wdata[(i*8)+`PMPCFG_A_BIT];
                pmpcfg_x[i+4] <= csr_wdata[(i*8)+`PMPCFG_X_BIT];
                pmpcfg_w[i+4] <= csr_wdata[(i*8)+`PMPCFG_W_BIT] & csr_wdata[(i*8)+`PMPCFG_R_BIT]; // if R=0 => W=0
                pmpcfg_r[i+4] <= csr_wdata[(i*8)+`PMPCFG_R_BIT];
            end
        end
    end
    else if (csr_wr && csr_waddr == `CSR_PMPCFG0_ADDR) begin
        for (i = 0; i < 4; i = i + 1) begin
            if (~pmpcfg_l[i+8]) begin
                pmpcfg_l[i+8] <= csr_wdata[(i*8)+`PMPCFG_L_BIT];
                pmpcfg_a[i+8] <= csr_wdata[(i*8)+`PMPCFG_A_BIT];
                pmpcfg_x[i+8] <= csr_wdata[(i*8)+`PMPCFG_X_BIT];
                pmpcfg_w[i+8] <= csr_wdata[(i*8)+`PMPCFG_W_BIT] & csr_wdata[(i*8)+`PMPCFG_R_BIT]; // if R=0 => W=0
                pmpcfg_r[i+8] <= csr_wdata[(i*8)+`PMPCFG_R_BIT];
            end
        end
    end
    else if (csr_wr && csr_waddr == `CSR_PMPCFG0_ADDR) begin
        for (i = 0; i < 4; i = i + 1) begin
            if (~pmpcfg_l[i+12]) begin
                pmpcfg_l[i+12] <= csr_wdata[(i*8)+`PMPCFG_L_BIT];
                pmpcfg_a[i+12] <= csr_wdata[(i*8)+`PMPCFG_A_BIT];
                pmpcfg_x[i+12] <= csr_wdata[(i*8)+`PMPCFG_X_BIT];
                pmpcfg_w[i+12] <= csr_wdata[(i*8)+`PMPCFG_W_BIT] & csr_wdata[(i*8)+`PMPCFG_R_BIT]; // if R=0 => W=0
                pmpcfg_r[i+12] <= csr_wdata[(i*8)+`PMPCFG_R_BIT];
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 0; i < 16; i = i + 1) begin
            pmpaddr[i] <= `XLEN'b0;
        end
    end
    else begin
        for (i = 0; i < 15; i = i + 1) begin
            if (csr_wr && csr_waddr == CSR_PMPADDR_ADDR[i] &&
                !pmpcfg_l[i] && !(pmpcfg_l[i+1] && pmpcfg_a[i+1] == `PMPCFG_A_TOR)) begin
                pmpaddr[i] <= csr_wdata & ((`XLEN'b1 << (`PADDR_LEN-2)) - `XLEN'b1);
            end
        end
        if (csr_wr && csr_waddr == CSR_PMPADDR_ADDR[15] && !pmpcfg_l[15]) begin
            pmpaddr[15] <= csr_wdata & ((`XLEN'b1 << (`PADDR_LEN-2)) - `XLEN'b1);
        end
    end
end

parameter [11:0] CSR_PMAADDR_ADDR [0:15] = {
    `CSR_PMAADDR0_ADDR ,
    `CSR_PMAADDR1_ADDR ,
    `CSR_PMAADDR2_ADDR ,
    `CSR_PMAADDR3_ADDR ,
    `CSR_PMAADDR4_ADDR ,
    `CSR_PMAADDR5_ADDR ,
    `CSR_PMAADDR6_ADDR ,
    `CSR_PMAADDR7_ADDR ,
    `CSR_PMAADDR8_ADDR ,
    `CSR_PMAADDR9_ADDR ,
    `CSR_PMAADDR10_ADDR,
    `CSR_PMAADDR11_ADDR,
    `CSR_PMAADDR12_ADDR,
    `CSR_PMAADDR13_ADDR,
    `CSR_PMAADDR14_ADDR,
    `CSR_PMAADDR15_ADDR
};

logic [     63:0] pmacfg0;
logic [     63:0] pmacfg2;

logic [     15:0] pmacfg_l;
logic [      1:0] pmacfg_a [16];
logic [     15:0] pmacfg_c;
logic [     15:0] pmacfg_e;

always_comb begin
    integer i;
    for (i = 0; i < 16; i = i + 1) begin
        pmacfg[i] = {pmacfg_l[i], 2'b0, pmacfg_a[i], 1'b0, pmacfg_c[i], pmacfg_e[i]};
    end

    for (i = 0; i < 8; i = i + 1) begin
        pmacfg0[i*8+:8] = pmacfg[i  ];
        pmacfg2[i*8+:8] = pmacfg[i+8];
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 2; i < 16; i = i + 1) begin
            pmacfg_l[i] <= 1'b0;
            pmacfg_a[i] <= 2'b0;
            pmacfg_c[i] <= 1'b0;
            pmacfg_e[i] <= 1'b0;
        end
        pmacfg_l[0] <= 1'b1;
        pmacfg_a[0] <= `PMACFG_A_TOR;
        pmacfg_c[0] <= 1'b1;
        pmacfg_e[0] <= 1'b0;
        pmacfg_l[1] <= 1'b1;
        pmacfg_a[1] <= `PMACFG_A_TOR;
        pmacfg_c[1] <= 1'b0;
        pmacfg_e[1] <= 1'b0;
    end
    else if (csr_wr && csr_waddr == `CSR_PMACFG0_ADDR) begin
        for (i = 0; i < 4; i = i + 1) begin
            if (~pmacfg_l[i]) begin
                pmacfg_l[i] <= csr_wdata[(i*8)+`PMACFG_L_BIT];
                pmacfg_a[i] <= csr_wdata[(i*8)+`PMACFG_A_BIT];
                pmacfg_c[i] <= csr_wdata[(i*8)+`PMACFG_C_BIT];
                pmacfg_e[i] <= csr_wdata[(i*8)+`PMACFG_E_BIT];
            end
        end
    end
    else if (csr_wr && csr_waddr == `CSR_PMACFG1_ADDR) begin
        for (i = 0; i < 4; i = i + 1) begin
            if (~pmacfg_l[i+4]) begin
                pmacfg_l[i+4] <= csr_wdata[(i*8)+`PMACFG_L_BIT];
                pmacfg_a[i+4] <= csr_wdata[(i*8)+`PMACFG_A_BIT];
                pmacfg_c[i+4] <= csr_wdata[(i*8)+`PMACFG_C_BIT];
                pmacfg_e[i+4] <= csr_wdata[(i*8)+`PMACFG_E_BIT];
            end
        end
    end
    else if (csr_wr && csr_waddr == `CSR_PMACFG0_ADDR) begin
        for (i = 0; i < 4; i = i + 1) begin
            if (~pmacfg_l[i+8]) begin
                pmacfg_l[i+8] <= csr_wdata[(i*8)+`PMACFG_L_BIT];
                pmacfg_a[i+8] <= csr_wdata[(i*8)+`PMACFG_A_BIT];
                pmacfg_c[i+8] <= csr_wdata[(i*8)+`PMACFG_C_BIT];
                pmacfg_e[i+8] <= csr_wdata[(i*8)+`PMACFG_E_BIT];
            end
        end
    end
    else if (csr_wr && csr_waddr == `CSR_PMACFG0_ADDR) begin
        for (i = 0; i < 4; i = i + 1) begin
            if (~pmacfg_l[i+12]) begin
                pmacfg_l[i+12] <= csr_wdata[(i*8)+`PMACFG_L_BIT];
                pmacfg_a[i+12] <= csr_wdata[(i*8)+`PMACFG_A_BIT];
                pmacfg_c[i+12] <= csr_wdata[(i*8)+`PMACFG_C_BIT];
                pmacfg_e[i+12] <= csr_wdata[(i*8)+`PMACFG_E_BIT];
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 2; i < 16; i = i + 1) begin
            pmaaddr[i] <= `XLEN'b0;
        end
        pmaaddr[0] <= `XLEN'h0100_0000;
        pmaaddr[1] <= `XLEN'h1000_0000;
    end
    else begin
        for (i = 0; i < 16; i = i + 1) begin
            if (csr_wr && csr_waddr == CSR_PMAADDR_ADDR[i] &&
                !pmacfg_l[i] && !(pmacfg_l[i+1] && pmacfg_a[i+1] == `PMACFG_A_TOR)) begin
                pmaaddr[i] <= csr_wdata & ((`XLEN'b1 << (`PADDR_LEN-2)) - `XLEN'b1);
            end
        end
        if (csr_wr && csr_waddr == CSR_PMAADDR_ADDR[15] && !pmacfg_l[15]) begin
            pmaaddr[15] <= csr_wdata & ((`XLEN'b1 << (`PADDR_LEN-2)) - `XLEN'b1);
        end
    end
end

always_comb begin
    csr_rdata = `XLEN'b0;
    case (csr_raddr) 
        `CSR_PMPCFG0_ADDR  : csr_rdata = pmpcfg0[0+:`XLEN];
        `CSR_PMPCFG1_ADDR  : csr_rdata = pmpcfg0[63:32];
        `CSR_PMPCFG2_ADDR  : csr_rdata = pmpcfg2[0+:`XLEN];
        `CSR_PMPCFG3_ADDR  : csr_rdata = pmpcfg2[63:32];
        `CSR_PMPADDR0_ADDR : csr_rdata = pmpaddr[0 ] & ({`XLEN{pmpcfg_a[0 ][1]}} | ~(pmpaddr[0 ] & ~(pmpaddr[0 ] + `XLEN'b1)));
        `CSR_PMPADDR1_ADDR : csr_rdata = pmpaddr[1 ] & ({`XLEN{pmpcfg_a[1 ][1]}} | ~(pmpaddr[1 ] & ~(pmpaddr[1 ] + `XLEN'b1)));
        `CSR_PMPADDR2_ADDR : csr_rdata = pmpaddr[2 ] & ({`XLEN{pmpcfg_a[2 ][1]}} | ~(pmpaddr[2 ] & ~(pmpaddr[2 ] + `XLEN'b1)));
        `CSR_PMPADDR3_ADDR : csr_rdata = pmpaddr[3 ] & ({`XLEN{pmpcfg_a[3 ][1]}} | ~(pmpaddr[3 ] & ~(pmpaddr[3 ] + `XLEN'b1)));
        `CSR_PMPADDR4_ADDR : csr_rdata = pmpaddr[4 ] & ({`XLEN{pmpcfg_a[4 ][1]}} | ~(pmpaddr[4 ] & ~(pmpaddr[4 ] + `XLEN'b1)));
        `CSR_PMPADDR5_ADDR : csr_rdata = pmpaddr[5 ] & ({`XLEN{pmpcfg_a[5 ][1]}} | ~(pmpaddr[5 ] & ~(pmpaddr[5 ] + `XLEN'b1)));
        `CSR_PMPADDR6_ADDR : csr_rdata = pmpaddr[6 ] & ({`XLEN{pmpcfg_a[6 ][1]}} | ~(pmpaddr[6 ] & ~(pmpaddr[6 ] + `XLEN'b1)));
        `CSR_PMPADDR7_ADDR : csr_rdata = pmpaddr[7 ] & ({`XLEN{pmpcfg_a[7 ][1]}} | ~(pmpaddr[7 ] & ~(pmpaddr[7 ] + `XLEN'b1)));
        `CSR_PMPADDR8_ADDR : csr_rdata = pmpaddr[8 ] & ({`XLEN{pmpcfg_a[8 ][1]}} | ~(pmpaddr[8 ] & ~(pmpaddr[8 ] + `XLEN'b1)));
        `CSR_PMPADDR9_ADDR : csr_rdata = pmpaddr[9 ] & ({`XLEN{pmpcfg_a[9 ][1]}} | ~(pmpaddr[9 ] & ~(pmpaddr[9 ] + `XLEN'b1)));
        `CSR_PMPADDR10_ADDR: csr_rdata = pmpaddr[10] & ({`XLEN{pmpcfg_a[10][1]}} | ~(pmpaddr[10] & ~(pmpaddr[10] + `XLEN'b1)));
        `CSR_PMPADDR11_ADDR: csr_rdata = pmpaddr[11] & ({`XLEN{pmpcfg_a[11][1]}} | ~(pmpaddr[11] & ~(pmpaddr[11] + `XLEN'b1)));
        `CSR_PMPADDR12_ADDR: csr_rdata = pmpaddr[12] & ({`XLEN{pmpcfg_a[12][1]}} | ~(pmpaddr[12] & ~(pmpaddr[12] + `XLEN'b1)));
        `CSR_PMPADDR13_ADDR: csr_rdata = pmpaddr[13] & ({`XLEN{pmpcfg_a[13][1]}} | ~(pmpaddr[13] & ~(pmpaddr[13] + `XLEN'b1)));
        `CSR_PMPADDR14_ADDR: csr_rdata = pmpaddr[14] & ({`XLEN{pmpcfg_a[14][1]}} | ~(pmpaddr[14] & ~(pmpaddr[14] + `XLEN'b1)));
        `CSR_PMPADDR15_ADDR: csr_rdata = pmpaddr[15] & ({`XLEN{pmpcfg_a[15][1]}} | ~(pmpaddr[15] & ~(pmpaddr[15] + `XLEN'b1)));
        `CSR_PMACFG0_ADDR  : csr_rdata = pmacfg0[0+:`XLEN];
        `CSR_PMACFG1_ADDR  : csr_rdata = pmacfg0[63:32];
        `CSR_PMACFG2_ADDR  : csr_rdata = pmacfg2[0+:`XLEN];
        `CSR_PMACFG3_ADDR  : csr_rdata = pmacfg2[63:32];
        `CSR_PMAADDR0_ADDR : csr_rdata = pmaaddr[0 ] & ({`XLEN{pmacfg_a[0 ][1]}} | ~(pmaaddr[0 ] & ~(pmaaddr[0 ] + `XLEN'b1)));
        `CSR_PMAADDR1_ADDR : csr_rdata = pmaaddr[1 ] & ({`XLEN{pmacfg_a[1 ][1]}} | ~(pmaaddr[1 ] & ~(pmaaddr[1 ] + `XLEN'b1)));
        `CSR_PMAADDR2_ADDR : csr_rdata = pmaaddr[2 ] & ({`XLEN{pmacfg_a[2 ][1]}} | ~(pmaaddr[2 ] & ~(pmaaddr[2 ] + `XLEN'b1)));
        `CSR_PMAADDR3_ADDR : csr_rdata = pmaaddr[3 ] & ({`XLEN{pmacfg_a[3 ][1]}} | ~(pmaaddr[3 ] & ~(pmaaddr[3 ] + `XLEN'b1)));
        `CSR_PMAADDR4_ADDR : csr_rdata = pmaaddr[4 ] & ({`XLEN{pmacfg_a[4 ][1]}} | ~(pmaaddr[4 ] & ~(pmaaddr[4 ] + `XLEN'b1)));
        `CSR_PMAADDR5_ADDR : csr_rdata = pmaaddr[5 ] & ({`XLEN{pmacfg_a[5 ][1]}} | ~(pmaaddr[5 ] & ~(pmaaddr[5 ] + `XLEN'b1)));
        `CSR_PMAADDR6_ADDR : csr_rdata = pmaaddr[6 ] & ({`XLEN{pmacfg_a[6 ][1]}} | ~(pmaaddr[6 ] & ~(pmaaddr[6 ] + `XLEN'b1)));
        `CSR_PMAADDR7_ADDR : csr_rdata = pmaaddr[7 ] & ({`XLEN{pmacfg_a[7 ][1]}} | ~(pmaaddr[7 ] & ~(pmaaddr[7 ] + `XLEN'b1)));
        `CSR_PMAADDR8_ADDR : csr_rdata = pmaaddr[8 ] & ({`XLEN{pmacfg_a[8 ][1]}} | ~(pmaaddr[8 ] & ~(pmaaddr[8 ] + `XLEN'b1)));
        `CSR_PMAADDR9_ADDR : csr_rdata = pmaaddr[9 ] & ({`XLEN{pmacfg_a[9 ][1]}} | ~(pmaaddr[9 ] & ~(pmaaddr[9 ] + `XLEN'b1)));
        `CSR_PMAADDR10_ADDR: csr_rdata = pmaaddr[10] & ({`XLEN{pmacfg_a[10][1]}} | ~(pmaaddr[10] & ~(pmaaddr[10] + `XLEN'b1)));
        `CSR_PMAADDR11_ADDR: csr_rdata = pmaaddr[11] & ({`XLEN{pmacfg_a[11][1]}} | ~(pmaaddr[11] & ~(pmaaddr[11] + `XLEN'b1)));
        `CSR_PMAADDR12_ADDR: csr_rdata = pmaaddr[12] & ({`XLEN{pmacfg_a[12][1]}} | ~(pmaaddr[12] & ~(pmaaddr[12] + `XLEN'b1)));
        `CSR_PMAADDR13_ADDR: csr_rdata = pmaaddr[13] & ({`XLEN{pmacfg_a[13][1]}} | ~(pmaaddr[13] & ~(pmaaddr[13] + `XLEN'b1)));
        `CSR_PMAADDR14_ADDR: csr_rdata = pmaaddr[14] & ({`XLEN{pmacfg_a[14][1]}} | ~(pmaaddr[14] & ~(pmaaddr[14] + `XLEN'b1)));
        `CSR_PMAADDR15_ADDR: csr_rdata = pmaaddr[15] & ({`XLEN{pmacfg_a[15][1]}} | ~(pmaaddr[15] & ~(pmaaddr[15] + `XLEN'b1)));
    endcase
end


endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/mpu.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif


`define ALU_OP_LEN 4
`define CSR_OP_LEN 2

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       `XLEN'h0
`define CAUSE_INSTRUCTION_ACCESS     `XLEN'h1
`define CAUSE_ILLEGAL_INSTRUCTION    `XLEN'h2
`define CAUSE_BREAKPOINT             `XLEN'h3
`define CAUSE_MISALIGNED_LOAD        `XLEN'h4
`define CAUSE_LOAD_ACCESS            `XLEN'h5
`define CAUSE_MISALIGNED_STORE       `XLEN'h6
`define CAUSE_STORE_ACCESS           `XLEN'h7
`define CAUSE_USER_ECALL             `XLEN'h8
`define CAUSE_SUPERVISOR_ECALL       `XLEN'h9
`define CAUSE_HYPERVISOR_ECALL       `XLEN'ha
`define CAUSE_MACHINE_ECALL          `XLEN'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT `XLEN'hc
`define CAUSE_LOAD_PAGE_FAULT        `XLEN'hd
`define CAUSE_STORE_PAGE_FAULT       `XLEN'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`ifdef RV32
  `define SATP_PPN_WIDTH  22
  `define SATP_ASID_WIDTH  9
  `define SATP_MODE_WIDTH  1
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   22+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   31+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 31

`else
  `define SATP_PPN_WIDTH  44
  `define SATP_ASID_WIDTH 16
  `define SATP_MODE_WIDTH  4
  `define SATP_PPN_BIT     0+:`SATP_PPN_WIDTH
  `define SATP_ASID_BIT   44+:`SATP_ASID_WIDTH
  `define SATP_MODE_BIT   60+:`SATP_MODE_WIDTH

  `define MCAUSE_CODE_WIDTH 63
`endif

`define PADDR_LEN       (`SATP_PPN_WIDTH + 12)

`endif

module mpu (
    input                         clk,
    input                         rstn,
    input        [           7:0] pmpcfg  [16],
    input        [     `XLEN-1:0] pmpaddr [16],
    input        [           7:0] pmacfg  [16],
    input        [     `XLEN-1:0] pmaaddr [16],
    input        [`PADDR_LEN-1:0] paddr,

    output logic                  pmp_v,
    output logic                  pmp_l,
    output logic                  pmp_x,
    output logic                  pmp_w,
    output logic                  pmp_r,

    output logic                  pma_v,
    output logic                  pma_l,
    output logic                  pma_c,
    output logic                  pma_e
        
);

logic [     15:0] pmp_match;
logic             pmp_v_tmp;
logic             pmp_l_tmp;
logic             pmp_x_tmp;
logic             pmp_w_tmp;
logic             pmp_r_tmp;

genvar g;
generate
    for (g = 0; g < 16; g = g + 1) begin: g_pmp
        logic [  `XLEN:0] mask_tmp;
        logic [`XLEN+2:0] mask;
        logic             napot_match;
        logic             tor_match;

        assign mask_tmp = {pmpaddr[g], pmpcfg[g][`PMPCFG_A_BIT] != `PMPCFG_A_NA4};
        assign mask     = {~(mask_tmp & ~(mask_tmp + {`XLEN'b0, 1'b1})), 2'b0};

        assign napot_match = ~|(({pmpaddr[g][0+:`PADDR_LEN-2], 2'b0} ^ paddr) & mask[0+:`PADDR_LEN]);
        if (g == 0) begin: g_first
            assign tor_match = {`PADDR_LEN{1'b0}} <= paddr && paddr < {pmpaddr[g][0+:`PADDR_LEN-2], 2'b0};
        end
        else begin: g_non_first
            assign tor_match = {pmpaddr[g-1][0+:`PADDR_LEN-2], 2'b0} <= paddr &&
                               paddr < {pmpaddr[g][0+:`PADDR_LEN-2], 2'b0};
        end
        
        assign pmp_match[g] = (pmpcfg[g][`PMPCFG_A_BIT] == `PMPCFG_A_TOR   && tor_match) |
                              (pmpcfg[g][`PMPCFG_A_BIT] == `PMPCFG_A_NA4   && napot_match) |
                              (pmpcfg[g][`PMPCFG_A_BIT] == `PMPCFG_A_NAPOT && napot_match);
    end
endgenerate

assign pmp_v_tmp = |pmp_match;

always_comb begin
    integer i;
    pmp_l_tmp = 1'b0;
    pmp_x_tmp = 1'b0;
    pmp_w_tmp = 1'b0;
    pmp_r_tmp = 1'b0;
    for (i = 0; i < 16; i = i + 1) begin
        pmp_l_tmp = pmp_l_tmp | (pmp_match[i] & pmpcfg[i][`PMPCFG_L_BIT]);
        pmp_x_tmp = pmp_x_tmp | (pmp_match[i] & pmpcfg[i][`PMPCFG_X_BIT]);
        pmp_w_tmp = pmp_w_tmp | (pmp_match[i] & pmpcfg[i][`PMPCFG_W_BIT]);
        pmp_r_tmp = pmp_r_tmp | (pmp_match[i] & pmpcfg[i][`PMPCFG_R_BIT]);
    end
end

// assign pmp_v = pmp_v_tmp;
// assign pmp_l = pmp_l_tmp;
// assign pmp_x = pmp_x_tmp;
// assign pmp_w = pmp_w_tmp;
// assign pmp_r = pmp_r_tmp;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        pmp_v <= 1'b0;
        pmp_l <= 1'b0;
        pmp_x <= 1'b0;
        pmp_w <= 1'b0;
        pmp_r <= 1'b0;
    end
    else begin
        pmp_v <= pmp_v_tmp;
        pmp_l <= pmp_l_tmp;
        pmp_x <= pmp_x_tmp;
        pmp_w <= pmp_w_tmp;
        pmp_r <= pmp_r_tmp;
    end
end

logic [     15:0] pma_match;
logic             pma_v_tmp;
logic             pma_l_tmp;
logic             pma_c_tmp;
logic             pma_e_tmp;

generate
    for (g = 0; g < 16; g = g + 1) begin: g_pma
        logic [  `XLEN:0] mask_tmp;
        logic [`XLEN+2:0] mask;
        logic             napot_match;
        logic             tor_match;

        assign mask_tmp = {pmaaddr[g], pmacfg[g][`PMACFG_A_BIT] != `PMACFG_A_NA4};
        assign mask     = {~(mask_tmp & ~(mask_tmp + {`XLEN'b0, 1'b1})), 2'b0};

        assign napot_match = ~|(({pmaaddr[g][0+:`PADDR_LEN-2], 2'b0} ^ paddr) & mask[0+:`PADDR_LEN]);
        if (g == 0) begin: g_first
            assign tor_match = {`PADDR_LEN{1'b0}} <= paddr && paddr < {pmaaddr[g][0+:`PADDR_LEN-2], 2'b0};
        end
        else begin: g_non_first
            assign tor_match = {pmaaddr[g-1][0+:`PADDR_LEN-2], 2'b0} <= paddr &&
                               paddr < {pmaaddr[g][0+:`PADDR_LEN-2], 2'b0};
        end
        
        assign pma_match[g] = (pmacfg[g][`PMACFG_A_BIT] == `PMACFG_A_TOR   && tor_match) |
                              (pmacfg[g][`PMACFG_A_BIT] == `PMACFG_A_NA4   && napot_match) |
                              (pmacfg[g][`PMACFG_A_BIT] == `PMACFG_A_NAPOT && napot_match);
    end
endgenerate

assign pma_v_tmp = |pma_match;

always_comb begin
    integer i;
    pma_l_tmp = 1'b0;
    pma_c_tmp = 1'b0;
    pma_e_tmp = 1'b0;
    for (i = 0; i < 16; i = i + 1) begin
        pma_l_tmp = pma_l_tmp | (pma_match[i] & pmacfg[i][`PMACFG_L_BIT]);
        pma_c_tmp = pma_c_tmp | (pma_match[i] & pmacfg[i][`PMACFG_C_BIT]);
        pma_e_tmp = pma_e_tmp | (pma_match[i] & pmacfg[i][`PMACFG_E_BIT]);
    end
    for (i = 0; i < 16; i = i + 1) begin
        pma_c_tmp = pma_c_tmp & ~(pma_match[i] & ~pmacfg[i][`PMACFG_C_BIT]);
        pma_e_tmp = pma_e_tmp & ~(pma_match[i] & ~pmacfg[i][`PMACFG_E_BIT]);
    end
end

// assign pma_v = pma_v_tmp;
// assign pma_l = pma_l_tmp;
// assign pma_c = pma_c_tmp;
// assign pma_e = pma_e_tmp;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        pma_v <= 1'b0;
        pma_l <= 1'b0;
        pma_c <= 1'b0;
        pma_e <= 1'b0;
    end
    else begin
        pma_v <= pma_v_tmp;
        pma_l <= pma_l_tmp;
        pma_c <= pma_c_tmp;
        pma_e <= pma_e_tmp;
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/mmu_csr.sv
/*--------------------------------------*/

module mmu_csr (
    input                               clk,
    input                               rstn,

    output logic [ `SATP_PPN_WIDTH-1:0] satp_ppn,
    output logic [`SATP_ASID_WIDTH-1:0] satp_asid,
    output logic [`SATP_MODE_WIDTH-1:0] satp_mode,
    // CSR interface
    input                               csr_wr,
    input        [                11:0] csr_waddr,
    input        [                11:0] csr_raddr,
    input        [           `XLEN-1:0] csr_wdata,
    output logic [           `XLEN-1:0] csr_rdata
);

logic [           `XLEN-1:0] satp;

assign satp = {satp_mode, satp_asid, satp_ppn};

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        satp_ppn  <= `SATP_PPN_WIDTH'b0;
        satp_asid <= `SATP_ASID_WIDTH'b0;
        satp_mode <= `SATP_MODE_WIDTH'b0;
    end
    else if (csr_wr && csr_waddr == `CSR_SATP_ADDR) begin
        satp_ppn  <= csr_wdata[ `SATP_PPN_BIT];
        satp_asid <= csr_wdata[`SATP_ASID_BIT];
        satp_mode <= csr_wdata[`SATP_MODE_BIT];
    end
end

always_comb begin
    csr_rdata = `XLEN'b0;
    case (csr_raddr) 
        `CSR_SATP_ADDR   : csr_rdata = satp;
    endcase
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/mmu.sv
/*--------------------------------------*/

`ifndef __INTF_DEFINE__
`define __INTF_DEFINE__

`define AXI_INTF_CONNECT(PORT, WIRE) \
    .``PORT``_awburst ( WIRE``_awburst ), \
    .``PORT``_awid    ( WIRE``_awid    ), \
    .``PORT``_awaddr  ( WIRE``_awaddr  ), \
    .``PORT``_awsize  ( WIRE``_awsize  ), \
    .``PORT``_awlen   ( WIRE``_awlen   ), \
    .``PORT``_awvalid ( WIRE``_awvalid ), \
    .``PORT``_awready ( WIRE``_awready ), \
    .``PORT``_wstrb   ( WIRE``_wstrb   ), \
    .``PORT``_wid     ( WIRE``_wid     ), \
    .``PORT``_wdata   ( WIRE``_wdata   ), \
    .``PORT``_wlast   ( WIRE``_wlast   ), \
    .``PORT``_wvalid  ( WIRE``_wvalid  ), \
    .``PORT``_wready  ( WIRE``_wready  ), \
    .``PORT``_bid     ( WIRE``_bid     ), \
    .``PORT``_bresp   ( WIRE``_bresp   ), \
    .``PORT``_bvalid  ( WIRE``_bvalid  ), \
    .``PORT``_bready  ( WIRE``_bready  ), \
    .``PORT``_araddr  ( WIRE``_araddr  ), \
    .``PORT``_arburst ( WIRE``_arburst ), \
    .``PORT``_arsize  ( WIRE``_arsize  ), \
    .``PORT``_arid    ( WIRE``_arid    ), \
    .``PORT``_arlen   ( WIRE``_arlen   ), \
    .``PORT``_arvalid ( WIRE``_arvalid ), \
    .``PORT``_arready ( WIRE``_arready ), \
    .``PORT``_rdata   ( WIRE``_rdata   ), \
    .``PORT``_rresp   ( WIRE``_rresp   ), \
    .``PORT``_rid     ( WIRE``_rid     ), \
    .``PORT``_rlast   ( WIRE``_rlast   ), \
    .``PORT``_rvalid  ( WIRE``_rvalid  ), \
    .``PORT``_rready  ( WIRE``_rready  )

`define AXI_INTF_SLV_DEF(NAME, ID) \
    input         [     1: 0] NAME``_awburst, \
    input         [ID - 1: 0] NAME``_awid,    \
    input         [    31: 0] NAME``_awaddr,  \
    input         [     2: 0] NAME``_awsize,  \
    input         [     7: 0] NAME``_awlen,   \
    input                     NAME``_awvalid, \
    output logic              NAME``_awready, \
    input         [     3: 0] NAME``_wstrb,   \
    input         [ID - 1: 0] NAME``_wid,     \
    input         [    31: 0] NAME``_wdata,   \
    input                     NAME``_wlast,   \
    input                     NAME``_wvalid,  \
    output logic              NAME``_wready,  \
    output logic  [ID - 1: 0] NAME``_bid,     \
    output logic  [     1: 0] NAME``_bresp,   \
    output logic              NAME``_bvalid,  \
    input                     NAME``_bready,  \
    input         [    31: 0] NAME``_araddr,  \
    input         [     1: 0] NAME``_arburst, \
    input         [     2: 0] NAME``_arsize,  \
    input         [ID - 1: 0] NAME``_arid,    \
    input         [     7: 0] NAME``_arlen,   \
    input                     NAME``_arvalid, \
    output logic              NAME``_arready, \
    output logic  [    31: 0] NAME``_rdata,   \
    output logic  [     1: 0] NAME``_rresp,   \
    output logic  [ID - 1: 0] NAME``_rid,     \
    output logic              NAME``_rlast,   \
    output logic              NAME``_rvalid,  \
    input                     NAME``_rready

`define AXI_INTF_MST_DEF(NAME, ID) \
    output logic  [     1: 0] NAME``_awburst, \
    output logic  [ID - 1: 0] NAME``_awid,    \
    output logic  [    31: 0] NAME``_awaddr,  \
    output logic  [     2: 0] NAME``_awsize,  \
    output logic  [     7: 0] NAME``_awlen,   \
    output logic              NAME``_awvalid, \
    input                     NAME``_awready, \
    output logic  [     3: 0] NAME``_wstrb,   \
    output logic  [ID - 1: 0] NAME``_wid,     \
    output logic  [    31: 0] NAME``_wdata,   \
    output logic              NAME``_wlast,   \
    output logic              NAME``_wvalid,  \
    input                     NAME``_wready,  \
    input         [ID - 1: 0] NAME``_bid,     \
    input         [     1: 0] NAME``_bresp,   \
    input                     NAME``_bvalid,  \
    output logic              NAME``_bready,  \
    output logic  [    31: 0] NAME``_araddr,  \
    output logic  [     1: 0] NAME``_arburst, \
    output logic  [     2: 0] NAME``_arsize,  \
    output logic  [ID - 1: 0] NAME``_arid,    \
    output logic  [     7: 0] NAME``_arlen,   \
    output logic              NAME``_arvalid, \
    input                     NAME``_arready, \
    input         [    31: 0] NAME``_rdata,   \
    input         [     1: 0] NAME``_rresp,   \
    input         [ID - 1: 0] NAME``_rid,     \
    input                     NAME``_rlast,   \
    input                     NAME``_rvalid,  \
    output logic              NAME``_rready

`define AXI_INTF_DEF(NAME, ID) \
    logic  [     1: 0] NAME``_awburst; \
    logic  [ID - 1: 0] NAME``_awid;    \
    logic  [    31: 0] NAME``_awaddr;  \
    logic  [     2: 0] NAME``_awsize;  \
    logic  [     7: 0] NAME``_awlen;   \
    logic              NAME``_awvalid; \
    logic              NAME``_awready; \
    logic  [     3: 0] NAME``_wstrb;   \
    logic  [ID - 1: 0] NAME``_wid;     \
    logic  [    31: 0] NAME``_wdata;   \
    logic              NAME``_wlast;   \
    logic              NAME``_wvalid;  \
    logic              NAME``_wready;  \
    logic  [ID - 1: 0] NAME``_bid;     \
    logic  [     1: 0] NAME``_bresp;   \
    logic              NAME``_bvalid;  \
    logic              NAME``_bready;  \
    logic  [    31: 0] NAME``_araddr;  \
    logic  [     1: 0] NAME``_arburst; \
    logic  [     2: 0] NAME``_arsize;  \
    logic  [ID - 1: 0] NAME``_arid;    \
    logic  [     7: 0] NAME``_arlen;   \
    logic              NAME``_arvalid; \
    logic              NAME``_arready; \
    logic  [    31: 0] NAME``_rdata;   \
    logic  [     1: 0] NAME``_rresp;   \
    logic  [ID - 1: 0] NAME``_rid;     \
    logic              NAME``_rlast;   \
    logic              NAME``_rvalid;  \
    logic              NAME``_rready;

`endif
`ifndef __AXI_DEFINE__
`define __AXI_DEFINE__

`define AXI_BURST_FIXED 2'b00
`define AXI_BURST_INCR  2'b01
`define AXI_BURST_WRAP  2'b10

`define AXI_RESP_OKAY   2'b00
`define AXI_RESP_EXOKAY 2'b01
`define AXI_RESP_SLVERR 2'b10
`define AXI_RESP_DECERR 2'b11

`endif
`ifndef __TLB_DEFINE__
`define __TLB_DEFINE__

`define TLB_WAY_NUM   4
`define TLB_IDX_WIDTH 5
`define TLB_DEPTH     (2 ** `TLB_IDX_WIDTH)
`define TLB_VPN_WIDTH 36
`define TLB_PTE_WIDTH 64
`define TLB_TAG_WIDTH (`TLB_VPN_WIDTH - `TLB_IDX_WIDTH)

`endif

module mmu (
    input                                    clk,
    input                                    rstn,
    
    // access type
    input                                    access_w,
    input                                    access_x,

    // mpu csr
    input                                    pmp_v,
    input                                    pmp_l,
    input                                    pmp_x,
    input                                    pmp_w,
    input                                    pmp_r,

    input                                    pma_v,
    input                                    pma_l,
    input                                    pma_c,
    input                                    pma_e,

    // TLB control
    input                                    tlb_flush_req,
    input                                    tlb_flush_all_vaddr,
    input                                    tlb_flush_all_asid,
    input        [              `XLEN - 1:0] tlb_flush_vaddr,
    input        [              `XLEN - 1:0] tlb_flush_asid,

    // mmu csr
    input        [    `SATP_PPN_WIDTH - 1:0] satp_ppn,
    input        [   `SATP_ASID_WIDTH - 1:0] satp_asid,
    input        [   `SATP_MODE_WIDTH - 1:0] satp_mode,
    input        [                      1:0] prv,
    input                                    sum,
    input                                    mprv,
    input        [                      1:0] mpp,

    // virtual address
    input                                    va_valid,
    input        [                     47:0] va,

    // Cache ctrl
    output logic                             cache_bypass,

    // physical address
    output logic                             pa_valid,
    output logic [                      1:0] pa_bad,
    output logic [                     55:0] pa,
    output logic [                     55:0] pa_pre,
    
    // AXI interface
    `AXI_INTF_MST_DEF(m, 10)
);

parameter [1:0] STATE_IDLE  = 2'b00,
                STATE_CHECK = 2'b01,
                STATE_MREQ  = 2'b10,
                STATE_PTE   = 2'b11;

logic [               2:0] cur_state;
logic [               2:0] nxt_state;

logic                      va_en;
logic [              55:0] va_latch;
logic [              19:0] vpn_latch;
logic [              21:0] ppn_latch;
logic                      busy;
logic                      leaf;
logic                      access_r_latch;
logic                      access_w_latch;
logic                      access_x_latch;
logic [              63:0] pte_latch;
logic [              21:0] pte_ppn, tlb_pte_ppn;
logic [               1:0] pte_rsw, tlb_pte_rsw;
logic                      pte_d,   tlb_pte_d;
logic                      pte_a,   tlb_pte_a;
logic                      pte_g,   tlb_pte_g;
logic                      pte_u,   tlb_pte_u;
logic                      pte_x,   tlb_pte_x;
logic                      pte_w,   tlb_pte_w;
logic                      pte_r,   tlb_pte_r;
logic                      pte_v,   tlb_pte_v;
logic                      tlb_data_sel;
logic [               1:0] level;
logic                      pa_valid_tmp;
logic                      pmp_err;
logic                      pg_fault;
logic                      pg_fault_tlb;
logic                      pg_fault_pte;
logic                      bus_err;
logic                      ar_done;
logic [               1:0] prv_post;
logic [               1:0] prv_latch;

logic                      tlb_cs;
logic                      tlb_we;
logic                      tlb_hit;
logic [`TLB_VPN_WIDTH-1:0] tlb_vpn;
logic [`TLB_PTE_WIDTH-1:0] tlb_pte_in;
logic [`TLB_PTE_WIDTH-1:0] tlb_pte_out;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) cur_state <= STATE_IDLE;
    else       cur_state <= nxt_state;
end

always_comb begin
    nxt_state = cur_state;
    case (cur_state)
        STATE_IDLE : begin
            nxt_state = va_en && va_valid ? STATE_CHECK : STATE_IDLE;
        end
        STATE_CHECK: begin
            nxt_state = ~tlb_hit ? STATE_MREQ:
                                   STATE_IDLE;
        end
        STATE_MREQ : begin
            nxt_state = m_rvalid && m_rresp[1] ? STATE_IDLE:
                        m_rvalid && m_rlast    ? STATE_PTE :
                                                 STATE_MREQ;
        end
        STATE_PTE  : begin
            nxt_state = leaf || pg_fault_pte ? STATE_IDLE:
                                               STATE_MREQ;
        end
    endcase
end

always_comb begin
    tlb_cs       = 1'b0;
    tlb_we       = 1'b0;
    pa_valid_tmp = 1'b0;
    busy         = 1'b0;
    m_arvalid    = 1'b0;
    tlb_data_sel = 1'b0;
    case (cur_state)
        STATE_IDLE : begin
            tlb_cs       = va_valid &&  va_en;
            pa_valid_tmp = va_valid && ~va_en;
            busy         = 1'b0;
        end
        STATE_CHECK: begin
            pa_valid_tmp = tlb_hit;
            busy         = 1'b1;
            tlb_data_sel = 1'b1;
        end
        STATE_MREQ : begin
            busy         = 1'b1;
            m_arvalid    = ~ar_done;
        end
        STATE_PTE  : begin
            pa_valid_tmp = leaf ||  pg_fault_pte;
            tlb_cs       = leaf && ~pg_fault_pte;
            tlb_we       = 1'b1;
            busy         = 1'b1;
        end
    endcase
end

assign prv_post     = ~access_x && mprv ? mpp : prv;
assign leaf         = pte_v && (pte_r || pte_x);
assign pg_fault_pte = !pte_v || (!pte_r && pte_w) ||
                      (~leaf && ~|level) ||
                      ( leaf && |level && |pte_ppn[9:0]) ||
                      ( leaf && access_x_latch      && ~pte_x) ||
                      ( leaf && access_r_latch      && ~pte_r) ||
                      ( leaf && access_w_latch      && ~pte_w) ||
                      ( leaf && prv_latch == `PRV_U && ~pte_u) ||
                      ( leaf && prv_latch == `PRV_S &&  pte_u && (~sum || access_x_latch)) ||
                      ( leaf && access_w_latch      && ~pte_d) ||
                      ( leaf                        && ~pte_a);

assign pg_fault_tlb = (access_x_latch      && ~tlb_pte_x) ||
                      (access_r_latch      && ~tlb_pte_r) ||
                      (access_w_latch      && ~tlb_pte_w) ||
                      (prv_latch == `PRV_U && ~tlb_pte_u) ||
                      (prv_latch == `PRV_S &&  tlb_pte_u && (~sum || access_x_latch)) ||
                      (access_w_latch      && ~tlb_pte_d) ||
                      (                       ~tlb_pte_a);

assign pmp_err      = (!pmp_v && prv_latch != `PRV_M) ||
                      (( pmp_l || prv_latch != `PRV_M) &&
                      ((!pmp_x && access_x_latch) ||
                       (!pmp_w && access_w_latch) ||
                       (!pmp_r && access_r_latch)));
                    
assign tlb_vpn    = {16'b0, busy ? va_latch[12+:20] : va[12+:20]};
assign tlb_pte_in = pte_latch;
assign {pte_ppn, pte_rsw, pte_d, pte_a, pte_g, pte_u, pte_x, pte_w, pte_r, pte_v} = pte_latch[31:0];
assign {tlb_pte_ppn, tlb_pte_rsw, tlb_pte_d, tlb_pte_a, tlb_pte_g,
        tlb_pte_u,   tlb_pte_x,   tlb_pte_w, tlb_pte_r, tlb_pte_v} = tlb_pte_out[31:0];

assign m_awid     = 10'b0;
assign m_awaddr   = 32'b0;
assign m_awburst  = `AXI_BURST_FIXED;
assign m_awsize   = 3'h0;
assign m_awlen    = 8'b0;
assign m_awvalid  = 1'b0;
assign m_wid      = 10'b0;
assign m_wstrb    = 4'b0;
assign m_wlast    = 1'b0;
assign m_wdata    = 32'b0;
assign m_wvalid   = 1'b0;
assign m_bready   = 1'b1;

assign m_arid     = 10'b0;
assign m_araddr   = {ppn_latch[19:0], vpn_latch[10+:10], 2'b0};
assign m_arburst  = `AXI_BURST_INCR;
assign m_arsize   = 3'h2;
assign m_arlen    = 8'h0;
assign m_rready   = 1'b1;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        level <= 2'b0;
    end
    else if (va_valid) begin
        level <= 2'd2;
    end
    else if (m_rvalid && m_rlast) begin
        level <= level - 2'd1;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        ar_done <= 1'b0;
    end
    else if (cur_state == STATE_CHECK || cur_state == STATE_PTE) begin
        ar_done <= 1'b0;
    end
    else if (m_arready) begin
        ar_done <= 1'b1;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        vpn_latch <= 20'b0;
    end
    else if (cur_state == STATE_CHECK) begin
        vpn_latch <= va_latch[12+:20];
    end
    else if (m_rvalid && m_rlast) begin
        vpn_latch <= {vpn_latch[9:0], 10'b0};
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        ppn_latch <= 22'b0;
    end
    else if (cur_state == STATE_IDLE) begin
        ppn_latch <= va[33:12];
    end
    else if (cur_state == STATE_CHECK) begin
        ppn_latch <= satp_ppn;
    end
    else if (cur_state == STATE_PTE) begin
        ppn_latch <= pte_ppn;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        pte_latch <= 64'b0;
    end
    else if (m_rvalid) begin
        pte_latch <= {pte_latch[31:0], m_rdata};
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)         va_latch <= 56'b0;
    else if (va_valid) va_latch <= {8'b0, va};
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)             pa <= 56'b0;
    else if (pa_valid_tmp) pa <= pa_pre;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        prv_latch      <= 2'b0;
        access_r_latch <= 1'b0;
        access_w_latch <= 1'b0;
        access_x_latch <= 1'b0;
    end
    else if (va_valid) begin
        prv_latch      <= prv_post;
        access_r_latch <= ~access_x & ~access_w;
        access_w_latch <= ~access_x &  access_w;
        access_x_latch <=  access_x;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        pa_valid <= 1'b0;
    end
    else begin
        pa_valid <= pa_valid_tmp;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        pg_fault <= 1'b0;
    end
    else if (cur_state == STATE_IDLE) begin
        pg_fault <= 1'b0;
    end
    else if (cur_state == STATE_PTE) begin
        pg_fault <= pg_fault_pte;
    end
    else if (tlb_hit) begin
        pg_fault <= pg_fault_tlb;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        bus_err <= 1'b0;
    end
    else begin
        bus_err <= m_rvalid && m_rresp[1];
    end
end

assign cache_bypass = ~pma_c;
assign pa_bad       = {(bus_err | pmp_err) & ~pg_fault, pg_fault};

assign pa_pre       = tlb_data_sel ? {{22{tlb_pte_ppn[21]}}, tlb_pte_ppn, va_latch[11:0]}:
                      va_en        ? {{22{pte_ppn[21]}}, pte_ppn[21:10], |level ? va_latch[21:12] : pte_ppn[9:0], va_latch[11:0]} :
                                     {8'b0, va};

assign va_en        = prv_post < `PRV_M && satp_mode != `SATP_MODE_WIDTH'b0;

tlb u_tlb(
    .clk                 ( clk                 ),
    .rstn                ( rstn                ),

    .cs                  ( tlb_cs              ),
    .vpn                 ( tlb_vpn             ),
    .we                  ( tlb_we              ),
    .spage               ( level[0]            ),
    .pte_hit             ( tlb_hit             ),
    .pte_in              ( tlb_pte_in          ),
    .pte_out             ( tlb_pte_out         ),

    .tlb_flush_req       ( tlb_flush_req       ),
    .tlb_flush_all_vaddr ( tlb_flush_all_vaddr ),
    .tlb_flush_all_asid  ( tlb_flush_all_asid  ),
    .tlb_flush_vaddr     ( tlb_flush_vaddr     ),
    .tlb_flush_asid      ( tlb_flush_asid      )

);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/tlb.sv
/*--------------------------------------*/

`ifndef __TLB_DEFINE__
`define __TLB_DEFINE__

`define TLB_WAY_NUM   4
`define TLB_IDX_WIDTH 5
`define TLB_DEPTH     (2 ** `TLB_IDX_WIDTH)
`define TLB_VPN_WIDTH 36
`define TLB_PTE_WIDTH 64
`define TLB_TAG_WIDTH (`TLB_VPN_WIDTH - `TLB_IDX_WIDTH)

`endif

module tlb (
    input                             clk,
    input                             rstn,

    input                             cs,
    input        [`TLB_VPN_WIDTH-1:0] vpn,
    input                             we,
    input                             spage,
    output logic                      pte_hit,
    input        [`TLB_PTE_WIDTH-1:0] pte_in,
    output logic [`TLB_PTE_WIDTH-1:0] pte_out,
    
    input                             tlb_flush_req,
    input                             tlb_flush_all_vaddr,
    input                             tlb_flush_all_asid,
    input        [       `XLEN - 1:0] tlb_flush_vaddr,
    input        [       `XLEN - 1:0] tlb_flush_asid

);

logic [      `TLB_IDX_WIDTH-1:0] idx;
logic [          `TLB_DEPTH-1:0] valid [`TLB_WAY_NUM];
logic [          `TLB_DEPTH-1:0] spg_bit [`TLB_WAY_NUM];
logic [$clog2(`TLB_WAY_NUM)-1:0] order [`TLB_WAY_NUM][`TLB_DEPTH];
logic [$clog2(`TLB_WAY_NUM)-1:0] victim_order;
logic [$clog2(`TLB_WAY_NUM)-1:0] hit_order;
logic [        `TLB_WAY_NUM-1:0] hit;
logic [      `TLB_TAG_WIDTH-1:0] tag;
logic [      `TLB_TAG_WIDTH-1:0] tag_latch;
logic                            cs_latch;
logic [                     9:0] vpn0_latch;
logic [        `TLB_WAY_NUM-1:0] spg_latch;
logic [        `TLB_WAY_NUM-1:0] victim;
logic [      `TLB_PTE_WIDTH-1:0] pte_out_arr [`TLB_WAY_NUM];

assign pte_hit = |hit;

assign idx     = vpn[10+:`TLB_IDX_WIDTH];
assign tag     = {vpn[`TLB_VPN_WIDTH-1:`TLB_IDX_WIDTH+10], vpn[9:0] & {10{~spage}}};

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) tag_latch <= {`TLB_TAG_WIDTH{1'b0}};
    else       tag_latch <= tag;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) cs_latch <= 1'b0;
    else       cs_latch <= cs && ~we;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) vpn0_latch <= 10'b0;
    else       vpn0_latch <= vpn[9:0];
end

always_comb begin
    integer i;

    victim_order = {$clog2(`TLB_WAY_NUM){1'b0}};
    for (i = 0; i < `TLB_WAY_NUM; i = i + 1) begin
        victim_order = victim_order | {$clog2(`TLB_WAY_NUM){victim[i]}} & order[i][idx];
    end

    hit_order    = {$clog2(`TLB_WAY_NUM){1'b0}};
    for (i = 0; i < `TLB_WAY_NUM; i = i + 1) begin
        hit_order    = hit_order    | {$clog2(`TLB_WAY_NUM){hit[i]}}    & order[i][idx];
    end
end

always_comb begin
    integer i;

    // pte_out = `TLB_PTE_WIDTH'b0;
    pte_out = {{`TLB_PTE_WIDTH-10-10{1'b0}}, vpn0_latch & {10{|(hit & spg_latch)}}, 10'b0};
    for (i = 0; i < `TLB_WAY_NUM; i = i + 1) begin
        pte_out = pte_out | ({`TLB_PTE_WIDTH{hit[i]}} & pte_out_arr[i]);
    end
end

genvar g;
generate
    for (g = 0; g < `TLB_WAY_NUM; g = g + 1) begin: g_tlb_array
        logic                            valid_latch;
        logic [      `TLB_TAG_WIDTH-1:0] tag_out;

        parameter [$clog2(`TLB_WAY_NUM)-1:0] DEFAULT_ORDER = {$clog2(`TLB_WAY_NUM){1'b0}} - {{($clog2(`TLB_WAY_NUM)-1){1'b0}}, 1'b1};

        always_ff @(posedge clk or negedge rstn) begin
            integer i;
            if (~rstn) begin
                for (i = 0; i < `TLB_DEPTH; i = i + 1) begin
                    valid[g][i]   <= 1'b0;
                    spg_bit[g][i] <= 1'b0;
                    order[g][i]   <= g[$clog2(`TLB_WAY_NUM)-1:0];
                end
            end
            else if (tlb_flush_req) begin
                for (i = 0; i < `TLB_DEPTH; i = i + 1) begin
                    valid[g][i]   <= 1'b0;
                    order[g][i]   <= g[$clog2(`TLB_WAY_NUM)-1:0];
                end
            end
            else if (cs && we) begin
                if (victim[g]) begin
                    valid[g][idx]   <= 1'b1;
                    spg_bit[g][idx] <= spage;
                    order[g][idx]   <= DEFAULT_ORDER;
                end
                else if (order[g][idx] > victim_order) begin
                    order[g][idx] <= order[g][idx] - {{($clog2(`TLB_WAY_NUM)-1){1'b0}}, 1'b1};
                end
            end
            else if (cs_latch && pte_hit) begin
                if (hit[g]) begin
                    order[g][idx] <= DEFAULT_ORDER;
                end
                else if (order[g][idx] > hit_order) begin
                    order[g][idx] <= order[g][idx] - {{($clog2(`TLB_WAY_NUM)-1){1'b0}}, 1'b1};
                end
            end
        end

        always_ff @(posedge clk or negedge rstn) begin
            if (~rstn) valid_latch <= 1'b0;
            else       valid_latch <= valid[g][idx] && ~tlb_flush_req;
        end

        always_ff @(posedge clk or negedge rstn) begin
            if (~rstn) spg_latch[g] <= 1'b0;
            else       spg_latch[g] <= spg_bit[g][idx];
        end

        assign victim[g] = cs && we && ~|(order[g][idx]);
        assign hit[g]    = valid_latch &&
                           tag_out == {tag_latch[`TLB_TAG_WIDTH-1:10], tag_latch[9:0] & {10{~spg_latch[g]}}};

        sram32x31 u_tag_array (
            .CK ( clk            ),
            .CS ( cs             ),
            .WE ( we & victim[g] ),
            .A  ( idx            ),
            .DI ( tag            ),
            .DO ( tag_out        )
        );

        sram32x64 u_pte_array (
            .CK ( clk            ),
            .CS ( cs             ),
            .WE ( we & victim[g] ),
            .A  ( idx            ),
            .DI ( pte_in         ),
            .DO ( pte_out_arr[g] )
        );
    end
endgenerate

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/l1c.sv
/*--------------------------------------*/

`ifndef __AXI_DEFINE__
`define __AXI_DEFINE__

`define AXI_BURST_FIXED 2'b00
`define AXI_BURST_INCR  2'b01
`define AXI_BURST_WRAP  2'b10

`define AXI_RESP_OKAY   2'b00
`define AXI_RESP_EXOKAY 2'b01
`define AXI_RESP_SLVERR 2'b10
`define AXI_RESP_DECERR 2'b11

`endif
`ifndef __CACHE_DEFINE__
`define __CACHE_DEFINE__

`define CACHE_DATA_WIDTH 32
`define CACHE_ADDR_WIDTH 32
`define CACHE_BLK_WIDTH  4
`define CACHE_IDX_WIDTH  6
`define CACHE_TAG_WIDTH  (`CACHE_ADDR_WIDTH - `CACHE_BLK_WIDTH - `CACHE_IDX_WIDTH)
`define CACHE_TAG_REGION (`CACHE_BLK_WIDTH + `CACHE_IDX_WIDTH)+:`CACHE_TAG_WIDTH
`define CACHE_BLK_SIZE   2 ** (`CACHE_BLK_WIDTH + 3)

`endif

module l1c (
    input                                    clk,
    input                                    rstn,
    // Core side
    input                                    core_req,
    input                                    core_pa_vld,
    input        [                      1:0] core_pa_bad, // [0]: pg_fault, [1]: bus_err
    input        [  `CACHE_ADDR_WIDTH - 1:0] core_paddr,
    input                                    core_bypass,
    input                                    core_flush,
    input                                    core_wr,
    input        [  `CACHE_ADDR_WIDTH - 1:0] core_vaddr,
    input        [  `CACHE_DATA_WIDTH - 1:0] core_wdata,
    input        [`CACHE_DATA_WIDTH/8 - 1:0] core_byte,
    output logic [  `CACHE_DATA_WIDTH - 1:0] core_rdata,
    output logic [                      1:0] core_bad,    // [0]: pg_fault, [1]: bus_err
    output logic                             core_busy,

    // external
    output logic [                      1:0] m_awburst,
    output logic [                      9:0] m_awid,
    output logic [                     31:0] m_awaddr,
    output logic [                      2:0] m_awsize,
    output logic [                      7:0] m_awlen,
    output logic                             m_awvalid,
    input                                    m_awready,
    output logic [                      3:0] m_wstrb,
    output logic [                      9:0] m_wid,
    output logic [                     31:0] m_wdata,
    output logic                             m_wlast,
    output logic                             m_wvalid,
    input                                    m_wready,
    input        [                      9:0] m_bid,
    input        [                      1:0] m_bresp,
    input                                    m_bvalid,
    output logic                             m_bready,
    output logic [                     31:0] m_araddr,
    output logic [                      1:0] m_arburst,
    output logic [                      2:0] m_arsize,
    output logic [                      9:0] m_arid,
    output logic [                      7:0] m_arlen,
    output logic                             m_arvalid,
    input                                    m_arready,
    input        [                     31:0] m_rdata,
    input        [                      1:0] m_rresp,
    input        [                      9:0] m_rid,
    input                                    m_rlast,
    input                                    m_rvalid,
    output logic                             m_rready
);

parameter [2:0] STATE_IDLE   = 3'b000,
                STATE_CMP    = 3'b001,
                STATE_MREQ   = 3'b010,
                STATE_REFILL = 3'b011,
                STATE_WRITE  = 3'b100,
                STATE_READ   = 3'b101;

logic [                     2:0] cur_state;
logic [                     2:0] nxt_state;
logic [                     2:0] state_latch;
logic                            hit;

logic                            valid_wr;
logic [                    63:0] valid;
logic [  `CACHE_IDX_WIDTH - 1:0] idx;

logic [ `CACHE_ADDR_WIDTH - 1:0] core_vaddr_latch;
logic [ `CACHE_ADDR_WIDTH - 1:0] core_paddr_latch;
logic [                     1:0] word_cnt;
logic [ `CACHE_DATA_WIDTH - 1:0] core_rdata_tmp;
logic [  `CACHE_BLK_SIZE/8 -1:0] refill_mask;
logic                            valid_latch;
logic                            tag_cs;
logic                            tag_we;
logic [  `CACHE_IDX_WIDTH - 1:0] tag_addr;
logic [  `CACHE_TAG_WIDTH - 1:0] tag_in;
logic [  `CACHE_TAG_WIDTH - 1:0] tag_out;

logic                            data_cs;
logic                            data_we;
logic [  `CACHE_IDX_WIDTH - 1:0] data_addr;
logic [  `CACHE_BLK_SIZE/8 -1:0] data_byte;
logic [    `CACHE_BLK_SIZE -1:0] data_in;
logic [    `CACHE_BLK_SIZE -1:0] data_out;

logic                            rdata_tmp_wr;
logic                            core_bypass_latch;
logic                            arvalid_tmp;
logic                            awvalid_tmp;
logic                            wvalid_tmp;


always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) cur_state <= STATE_IDLE;
    else       cur_state <= nxt_state;
end

always_comb begin
    nxt_state = cur_state;
    case (cur_state)
        STATE_IDLE  : begin
            nxt_state = core_req ? core_wr     ? STATE_WRITE:
                                                 STATE_CMP:
                                   STATE_IDLE;
        end
        STATE_CMP   : begin
            nxt_state = ~core_pa_vld ? STATE_CMP :
                        |core_pa_bad ? STATE_IDLE:
                         core_bypass ? STATE_READ:
                        hit ? core_req ? core_wr     ? STATE_WRITE:
                                                       STATE_CMP:
                                       STATE_IDLE:
                                       STATE_MREQ;
        end
        STATE_MREQ  : begin
            nxt_state = m_arready ? STATE_REFILL : STATE_MREQ;
        end
        STATE_REFILL: begin
            nxt_state = (m_rlast && m_rvalid) ? STATE_IDLE : STATE_REFILL;
        end
        STATE_WRITE : begin
            nxt_state = m_bvalid || (core_pa_vld && |core_pa_bad) ? STATE_IDLE : STATE_WRITE;
        end
        STATE_READ  : begin
            nxt_state = (m_rlast && m_rvalid) || (core_pa_vld && |core_pa_bad) ? STATE_IDLE : STATE_READ;
        end
    endcase
end

always_comb begin
    rdata_tmp_wr = 1'b0;
    valid_wr     = 1'b0;
    core_busy    = 1'b0;
    m_awvalid    = 1'b0;
    m_wvalid     = 1'b0;
    m_arvalid    = 1'b0;
    tag_cs       = 1'b0;
    tag_we       = 1'b0;
    data_cs      = 1'b0;
    data_we      = 1'b0;
    data_byte    = 16'b0;
    data_in      = 128'b0;
    case (cur_state)
        STATE_IDLE  : begin
            core_busy    = 1'b0;
            tag_cs       = core_req;
            data_cs      = core_req;
        end
        STATE_CMP   : begin
            core_busy    = ~hit || |core_pa_bad;
            tag_cs       = ~core_pa_vld || (hit && core_req);
            data_cs      = ~core_pa_vld || (hit && core_req);
        end
        STATE_MREQ  : begin
            core_busy    = 1'b1;
            m_arvalid    = 1'b1;
        end
        STATE_REFILL: begin
            core_busy    = 1'b1;
            data_cs      = m_rvalid;
            data_we      = m_rvalid;
            data_byte    = refill_mask;
            data_in      = {4{m_rdata}};
            tag_cs       = m_rlast && m_rvalid;
            tag_we       = m_rlast && m_rvalid;
            valid_wr     = m_rlast && m_rvalid && ~m_rresp[1] && ~core_pa_bad[1];
            rdata_tmp_wr = m_rvalid && word_cnt == core_vaddr_latch[2+:2];
        end
        STATE_WRITE : begin
            core_busy    = 1'b1;
            m_awvalid    = awvalid_tmp;
            m_wvalid     = wvalid_tmp;
            tag_cs       = 1'b1;
            data_cs      = hit && core_pa_vld && ~|core_pa_bad && ~core_bypass_latch;
            data_we      = 1'b1;
            data_byte    = {12'b0, {m_wstrb}} << {core_vaddr_latch[3:2], 2'b0};
            data_in      = {4{m_wdata}};
        end
        STATE_READ  : begin
            core_busy    = 1'b1;
            rdata_tmp_wr = m_rvalid;
            m_arvalid    = arvalid_tmp;
        end
    endcase
end

assign idx        = core_vaddr[`CACHE_BLK_WIDTH+:`CACHE_IDX_WIDTH];
assign tag_addr   = core_busy ? core_vaddr_latch[`CACHE_BLK_WIDTH+:`CACHE_IDX_WIDTH]:
                                core_vaddr      [`CACHE_BLK_WIDTH+:`CACHE_IDX_WIDTH];
assign data_addr  = core_busy ? core_vaddr_latch[`CACHE_BLK_WIDTH+:`CACHE_IDX_WIDTH]:
                                core_vaddr      [`CACHE_BLK_WIDTH+:`CACHE_IDX_WIDTH];
assign tag_in     = core_paddr_latch[`CACHE_TAG_REGION];
assign hit        = valid_latch && core_pa_vld && (tag_out == core_paddr[`CACHE_TAG_REGION]);
assign core_rdata = cur_state == STATE_IDLE ? core_rdata_tmp : data_out[{core_vaddr_latch[2+:2], 5'b0}+:32];
assign m_awid     = 10'b0;
assign m_awaddr   = core_paddr_latch;
assign m_awburst  = `AXI_BURST_INCR;
assign m_awsize   = 3'h2;
assign m_awlen    = 8'b0;
assign m_wid      = 10'b0;
assign m_wlast    = 1'b1;
assign m_bready   = 1'b1;
assign m_arid     = 10'b0;
assign m_araddr   = cur_state == STATE_READ ? core_paddr_latch :
                        {core_paddr_latch[`CACHE_ADDR_WIDTH-1:`CACHE_BLK_WIDTH], {`CACHE_BLK_WIDTH{1'b0}}};
assign m_arburst  = `AXI_BURST_INCR;
assign m_arsize   = 3'h2;
assign m_arlen    = cur_state == STATE_MREQ ? 8'h3 : 8'h0;
assign m_rready   = 1'b1;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) state_latch <= STATE_IDLE;
    else       state_latch <= cur_state; 
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)                        core_bad <= 2'b00;
    else if (cur_state == STATE_IDLE) core_bad <= 2'b00;
    else if (m_bresp[1] && m_bvalid)  core_bad <= 2'b10;
    else if (m_rresp[1] && m_rvalid)  core_bad <= 2'b10;
    else if (core_pa_vld)             core_bad <= core_pa_bad;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)            core_bypass_latch <= 1'b0;
    else if (core_pa_vld) core_bypass_latch <= core_bypass;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)           core_vaddr_latch <= `CACHE_ADDR_WIDTH'b0;
    else if (~core_busy) core_vaddr_latch <= core_vaddr;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)            core_paddr_latch <= `CACHE_ADDR_WIDTH'b0;
    else if (core_pa_vld) core_paddr_latch <= core_paddr;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)           valid_latch <= 1'b0;
    else if (~core_busy) valid_latch <= ~core_flush && valid[idx] && core_req;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)         refill_mask <= {12'b0, 4'hf};
    else if (m_rvalid) refill_mask <= {refill_mask[11:0], refill_mask[15:12]};
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)         word_cnt <= 2'b0;
    else if (m_rvalid) word_cnt <= word_cnt + 2'b1;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        core_rdata_tmp <= `CACHE_DATA_WIDTH'b0;
    end
    else if (rdata_tmp_wr) begin
        core_rdata_tmp <= m_rdata;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        valid <= 64'b0;
    end
    else begin
        if (core_flush)    valid <= 64'b0;
        else if (valid_wr) valid[core_vaddr_latch[`CACHE_BLK_WIDTH+:`CACHE_IDX_WIDTH]] <= 1'b1;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        m_wdata <= `CACHE_DATA_WIDTH'b0;
        m_wstrb <= {`CACHE_DATA_WIDTH/8{1'b0}};
    end
    else if (~core_busy) begin
        m_wdata <= core_wdata;
        m_wstrb <= core_byte;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        arvalid_tmp <= 1'b0;
        awvalid_tmp <= 1'b0;
        wvalid_tmp  <= 1'b0;
    end
    else begin
        if (core_pa_vld) begin
            arvalid_tmp <= 1'b1;
            awvalid_tmp <= cur_state == STATE_WRITE;
            wvalid_tmp  <= cur_state == STATE_WRITE;
        end
        else begin
            if (m_arready || cur_state == STATE_IDLE) arvalid_tmp <= 1'b0;
            if (m_awready || cur_state == STATE_IDLE) awvalid_tmp <= 1'b0;
            if (m_wready  || cur_state == STATE_IDLE) wvalid_tmp  <= 1'b0;
        end
    end
end

sram64x22 u_tagram(
    .CK   ( clk      ),
    .CS   ( tag_cs   ),
    .WE   ( tag_we   ),
    .A    ( tag_addr ),
    .DI   ( tag_in   ),
    .DO   ( tag_out  )
);

sram64x128 u_dataram(
    .CK   ( clk       ),
    .CS   ( data_cs   ),
    .WE   ( data_we   ),
    .A    ( data_addr ),
    .BYTE ( data_byte ),
    .DI   ( data_in   ),
    .DO   ( data_out  )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/cfgreg.sv
/*--------------------------------------*/

`ifndef __CFGREG_MMAP__
`define __CFGREG_MMAP__

`define CFGREG_RSTN    12'h000
`define CFGREG_RSVREG0 12'h004
`define CFGREG_RSVREG1 12'h088

`endif

module cfgreg (
    input                 pclk,
    input                 presetn,
    input                 psel,
    input                 penable,
    input        [ 31: 0] paddr,
    input                 pwrite,
    input        [  3: 0] pstrb,
    input        [ 31: 0] pwdata,
    output logic [ 31: 0] prdata,
    output logic          pslverr,
    output logic          pready,

    output logic          core_rstn
);


logic [31:0] reserve_reg0;
logic [31:0] reserve_reg1;

logic [31:0] prdata_t;
logic        apb_wr;

assign apb_wr = ~penable && psel && pwrite;

always_ff @(posedge pclk or negedge presetn) begin
    if (~presetn) begin
        core_rstn <= 1'b0;
    end
    else if (apb_wr && paddr[11:0] == `CFGREG_RSTN) begin
        core_rstn <= pwdata[0];
    end
end

always_ff @(posedge pclk or negedge presetn) begin
    if (~presetn) begin
        reserve_reg0 <= 32'b0;
    end
    else if (apb_wr && paddr[11:0] == `CFGREG_RSVREG0) begin
        reserve_reg0 <= pwdata;
    end
end

always_ff @(posedge pclk or negedge presetn) begin
    if (~presetn) begin
        reserve_reg1 <= 32'b0;
    end
    else if (apb_wr && paddr[11:0] == `CFGREG_RSVREG1) begin
        reserve_reg1 <= pwdata;
    end
end

always_comb begin
    prdata_t = 32'b0;
    case (paddr[11:0])
        `CFGREG_RSTN:    prdata_t = {31'b0, core_rstn};
        `CFGREG_RSVREG0: prdata_t = reserve_reg0;
        `CFGREG_RSVREG1: prdata_t = reserve_reg1;
    endcase
end

always_ff @(posedge pclk or negedge presetn) begin
    if (~presetn) begin
        prdata <= 32'b0;
    end
    else begin
        prdata <= prdata_t;
    end
end

assign pslverr = 1'b0;
assign pready  = 1'b1;

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/intc.sv
/*--------------------------------------*/

`ifndef __SOC_DEFINE__
`define __SOC_DEFINE__

`define CPU_NUM 1
`define INT_NUM 32

`endif

module intc (
    input                        clk,
    input                        rstn,
    input                        psel,
    input                        penable,
    input        [        31: 0] paddr,
    input                        pwrite,
    input        [         3: 0] pstrb,
    input        [        31: 0] pwdata,
    output logic [        31: 0] prdata,
    output logic                 pslverr,
    output logic                 pready,

    output logic [`CPU_NUM-1: 0] msip,
    output logic [`CPU_NUM-1: 0] mtip,
    output logic [`CPU_NUM-1: 0] meip,
    input        [`INT_NUM-1: 0] ints
);

logic                 clint_psel;
logic                 clint_penable;
logic [        31: 0] clint_paddr;
logic                 clint_pwrite;
logic [         3: 0] clint_pstrb;
logic [        31: 0] clint_pwdata;
logic [        31: 0] clint_prdata;
logic                 clint_pslverr;
logic                 clint_pready;

logic                 plic_psel;
logic                 plic_penable;
logic [        31: 0] plic_paddr;
logic                 plic_pwrite;
logic [         3: 0] plic_pstrb;
logic [        31: 0] plic_pwdata;
logic [        31: 0] plic_prdata;
logic                 plic_pslverr;
logic                 plic_pready;

assign clint_psel    = ~paddr[26] & psel;
assign clint_penable = clint_psel & penable;
assign clint_paddr   = paddr;
assign clint_pwrite  = pwrite;
assign clint_pstrb   = pstrb;
assign clint_pwdata  = pwdata;

assign plic_psel     = paddr[26] & psel;
assign plic_penable  = plic_psel & penable;
assign plic_paddr    = paddr;
assign plic_pwrite   = pwrite;
assign plic_pstrb    = pstrb;
assign plic_pwdata   = pwdata;

assign prdata        = clint_prdata  | plic_prdata;
assign pslverr       = clint_pslverr | plic_pslverr;
assign pready        = (clint_psel & clint_pready) | (plic_psel & plic_pready);

clint u_clint (
    .clk     ( clk           ),
    .rstn    ( rstn          ),
    .psel    ( clint_psel    ),
    .penable ( clint_penable ),
    .paddr   ( clint_paddr   ),
    .pwrite  ( clint_pwrite  ),
    .pstrb   ( clint_pstrb   ),
    .pwdata  ( clint_pwdata  ),
    .prdata  ( clint_prdata  ),
    .pslverr ( clint_pslverr ),
    .pready  ( clint_pready  ),

    .msip    ( msip          ),
    .mtip    ( mtip          )
);

plic u_plic(
    .clk     ( clk          ),
    .rstn    ( rstn         ),
    .psel    ( plic_psel    ),
    .penable ( plic_penable ),
    .paddr   ( plic_paddr   ),
    .pwrite  ( plic_pwrite  ),
    .pstrb   ( plic_pstrb   ),
    .pwdata  ( plic_pwdata  ),
    .prdata  ( plic_prdata  ),
    .pslverr ( plic_pslverr ),
    .pready  ( plic_pready  ),

    .meip    ( meip         ),
    .ints    ( ints         )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/clint.sv
/*--------------------------------------*/

`ifndef __SOC_DEFINE__
`define __SOC_DEFINE__

`define CPU_NUM 1
`define INT_NUM 32

`endif
`ifndef __CLINT_MMAP__
`define __CLINT_MMAP__

`define CLINT_MSIP    16'h0000
`define CLINT_TIMECMP 16'h4000
`define CLINT_TIME    16'hbff8

`endif

module clint (
    input                        clk,
    input                        rstn,
    input                        psel,
    input                        penable,
    input        [        31: 0] paddr,
    input                        pwrite,
    input        [         3: 0] pstrb,
    input        [        31: 0] pwdata,
    output logic [        31: 0] prdata,
    output logic                 pslverr,
    output logic                 pready,

    output logic [`CPU_NUM-1: 0] msip,
    output logic [`CPU_NUM-1: 0] mtip
);

logic [31:0] prdata_msip;
logic [31:0] prdata_timecmp;
logic [31:0] prdata_time;
logic [31:0] prdata_t;
logic [63:0] mtimecmp [`CPU_NUM];
logic [63:0] mtime;

genvar g;
generate
    for (g = 0; g < `CPU_NUM; g = g + 1) begin: g_apb_reg
        always_ff @(posedge clk or negedge rstn) begin
            if (~rstn) begin
                msip[g] <= 1'b0;
            end
            else if (penable && psel && pwrite && paddr[15:0] == `CLINT_MSIP + 16'h4 * g[15:0]) begin
                msip[g] <= pwdata[0];
            end
        end
        always_ff @(posedge clk or negedge rstn) begin
            if (~rstn) begin
                mtimecmp[g] <= 64'b0;
            end
            else if (penable && psel && pwrite && paddr[15:0] == `CLINT_TIMECMP + 16'h8 * g[15:0]) begin
                mtimecmp[g][31:0] <= pwdata;
            end
            else if (penable && psel && pwrite && paddr[15:0] == `CLINT_TIMECMP + 16'h8 * g[15:0] + 16'h4) begin
                mtimecmp[g][63:32] <= pwdata;
            end
        end
        always_ff @(posedge clk or negedge rstn) begin
            if (~rstn) begin
                mtip[g] <= 1'b0;
            end
            else begin
                mtip[g] <= mtime >= mtimecmp[g];
            end
        end
    end
endgenerate

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        mtime <= 64'b0;
    end
    else if (penable && psel && pwrite && paddr[15:0] == `CLINT_TIME) begin
        mtime[31:0] <= pwdata;
    end
    else if (penable && psel && pwrite && paddr[15:0] == `CLINT_TIME + 16'h4) begin
        mtime[63:32] <= pwdata;
    end
    else begin
        mtime <= mtime + 64'b1;
    end
end

always_comb begin
    integer i;
    prdata_msip = 32'b0;
    for (i = 0; i < `CPU_NUM; i = i + 1) begin
        prdata_msip = prdata_msip | {31'b0, msip[i] & (paddr[7:2] == i[5:0])};
    end
    prdata_msip = prdata_msip & {32{paddr[15:12] == 4'h0}};
end

always_comb begin
    integer i;
    prdata_timecmp = 32'b0;
    for (i = 0; i < `CPU_NUM; i = i + 1) begin
        prdata_timecmp = prdata_timecmp |
                         (mtimecmp[i][31: 0] & {32{paddr[8:3] == i[5:0] && !paddr[2]}})|
                         (mtimecmp[i][63:32] & {32{paddr[8:3] == i[5:0] &&  paddr[2]}});
    end
    prdata_timecmp = prdata_timecmp & {32{paddr[15:12] == 4'h4}};
end

assign prdata_time = (mtime[31: 0] & {32{paddr[15:0] == `CLINT_TIME}})|
                     (mtime[63:32] & {32{paddr[15:0] == `CLINT_TIME + 16'h4}});

assign prdata_t = prdata_msip | prdata_timecmp | prdata_time;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        prdata <= 32'b0;
    end
    else begin
        prdata <= prdata_t;
    end
end

assign pslverr = 1'b0;
assign pready  = 1'b1;


endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/plic.sv
/*--------------------------------------*/

`ifndef __SOC_DEFINE__
`define __SOC_DEFINE__

`define CPU_NUM 1
`define INT_NUM 32

`endif
`ifndef __PLIC_MMAP__
`define __PLIC_MMAP__

`define PLIC_INT_PRIOR   26'h000_0000
`define PLIC_INT_PEND    26'h000_1000
`define PLIC_INT_TYPE    26'h000_1080
`define PLIC_INT_POL     26'h000_1100
`define PLIC_INT_EN      26'h000_2000
`define PLIC_PRIOR_TH    26'h020_0000

`endif

module plic (
    input                        clk,
    input                        rstn,
    input                        psel,
    input                        penable,
    input        [        31: 0] paddr,
    input                        pwrite,
    input        [         3: 0] pstrb,
    input        [        31: 0] pwdata,
    output logic [        31: 0] prdata,
    output logic                 pslverr,
    output logic                 pready,

    output logic [`CPU_NUM-1: 0] meip,
    input        [`INT_NUM-1: 0] ints
);

logic [        31:0] claim_id    [`CPU_NUM];
logic [        31:0] cmplet_id   [`CPU_NUM];

logic [`INT_NUM-1:1] claim;
logic [`INT_NUM-1:1] cmplet;

logic [`INT_NUM-1:0] int_pend;
logic [`INT_NUM-1:0] int_type;
logic [`INT_NUM-1:0] int_pol;
logic [        31:0] int_prior   [`INT_NUM];
logic [`INT_NUM-1:0] int_en      [`CPU_NUM];
logic [        31:0] int_id      [`CPU_NUM];
logic [        31:0] threshold   [`CPU_NUM];

logic [        31:0] int_id_tmp  [`CPU_NUM];
logic [        31:0] int_max_pri [`CPU_NUM];

logic                apb_wr;

logic [        31:0] prdata_t;
logic [        31:0] prdata_pri;
logic [        31:0] prdata_ip;
logic [        31:0] prdata_ityp;
logic [        31:0] prdata_ipol;
logic [        31:0] prdata_ie;
logic [        31:0] prdata_id;
logic [        31:0] prdata_th;

`define CMP_TREE_L0_NUM  (`INT_NUM)                                  // MAX: 1024
`define CMP_TREE_L1_NUM  (`CMP_TREE_L0_NUM/2 + `CMP_TREE_L0_NUM%2)   // MAX:  512
`define CMP_TREE_L2_NUM  (`CMP_TREE_L1_NUM/2 + `CMP_TREE_L1_NUM%2)   // MAX:  256
`define CMP_TREE_L3_NUM  (`CMP_TREE_L2_NUM/2 + `CMP_TREE_L2_NUM%2)   // MAX:  128
`define CMP_TREE_L4_NUM  (`CMP_TREE_L3_NUM/2 + `CMP_TREE_L3_NUM%2)   // MAX:   64
`define CMP_TREE_L5_NUM  (`CMP_TREE_L4_NUM/2 + `CMP_TREE_L4_NUM%2)   // MAX:   32
`define CMP_TREE_L6_NUM  (`CMP_TREE_L5_NUM/2 + `CMP_TREE_L5_NUM%2)   // MAX:   16
`define CMP_TREE_L7_NUM  (`CMP_TREE_L6_NUM/2 + `CMP_TREE_L6_NUM%2)   // MAX:    8
`define CMP_TREE_L8_NUM  (`CMP_TREE_L7_NUM/2 + `CMP_TREE_L7_NUM%2)   // MAX:    4
`define CMP_TREE_L9_NUM  (`CMP_TREE_L8_NUM/2 + `CMP_TREE_L8_NUM%2)   // MAX:    2
`define CMP_TREE_L10_NUM (`CMP_TREE_L9_NUM/2 + `CMP_TREE_L9_NUM%2)   // MAX:    1

parameter int CMP_TREE_NUM [0:10] = {
    `CMP_TREE_L0_NUM, 
    `CMP_TREE_L1_NUM, 
    `CMP_TREE_L2_NUM, 
    `CMP_TREE_L3_NUM, 
    `CMP_TREE_L4_NUM, 
    `CMP_TREE_L5_NUM, 
    `CMP_TREE_L6_NUM, 
    `CMP_TREE_L7_NUM, 
    `CMP_TREE_L8_NUM, 
    `CMP_TREE_L9_NUM, 
    `CMP_TREE_L10_NUM
};

genvar gvar_i;
genvar gvar_j;
genvar gvar_k;
generate
    for (gvar_i = 1; gvar_i < `INT_NUM; gvar_i = gvar_i + 1) begin: g_gateway

        always_comb begin
            integer i;
            claim [gvar_i] = 1'b0;
            cmplet[gvar_i] = 1'b0;
            for (i = 0; i < `CPU_NUM; i = i + 1) begin
                claim [gvar_i] = claim [gvar_i] | (claim_id [i][0+:$clog2(`INT_NUM)] == gvar_i[0+:$clog2(`INT_NUM)]);
                cmplet[gvar_i] = cmplet[gvar_i] | (cmplet_id[i][0+:$clog2(`INT_NUM)] == gvar_i[0+:$clog2(`INT_NUM)]);
            end
        end

        gateway u_gateway(
            .clk      ( clk              ),
            .rstn     ( rstn             ),
            .src      ( ints    [gvar_i] ),
            .src_type ( int_type[gvar_i] ), // 0: edge, 1: level
            .src_pol  ( int_pol [gvar_i] ), // 0: high, 1: low
            .claim    ( claim   [gvar_i] ),
            .cmplet   ( cmplet  [gvar_i] ),
            .pend     ( int_pend[gvar_i] )
        );
    end

    assign int_pend[0] = 1'b0;

    for (gvar_i = 0; gvar_i < `CPU_NUM; gvar_i = gvar_i + 1) begin: g_target
        logic [`INT_NUM-1:0] ip_ie_ints;
        logic [        31:0] en_ints_pri [11][`CMP_TREE_L0_NUM];
        logic [         9:0] id_sel      [11][`CMP_TREE_L0_NUM];
        
        assign ip_ie_ints = int_pend & int_en[gvar_i];

        always_comb begin
            integer i;
            for (i = 0; i < `INT_NUM; i = i + 1) begin
                en_ints_pri[0][i] = {32{ip_ie_ints[i]}} & int_prior[i];
            end
        end

        for (gvar_j = 0; gvar_j < 10; gvar_j = gvar_j + 1) begin: g_cmp_tree_lvl
            if (gvar_j % 3 == 2) begin: g_pipelining
                for (gvar_k = 0; gvar_k <= CMP_TREE_NUM[gvar_j] - 1; gvar_k = gvar_k + 2) begin: g_cmp
                    if (gvar_k == CMP_TREE_NUM[gvar_j] - 1) begin: g_remainder
                        always_ff @(posedge clk or negedge rstn) begin
                            if (~rstn) begin
                                en_ints_pri[gvar_j+1][gvar_k>>1]     <= 32'b0;
                                id_sel[gvar_j+1][gvar_k>>1][gvar_j]  <= 1'b0;
                            end
                            else begin
                                en_ints_pri[gvar_j+1][gvar_k>>1]     <= en_ints_pri[gvar_j][gvar_k];
                                id_sel[gvar_j+1][gvar_k>>1][gvar_j]  <= 1'b0;
                            end
                        end
                        if (gvar_j > 0) begin: g_non_first
                            always_ff @(posedge clk or negedge rstn) begin
                                if (~rstn) begin
                                    id_sel[gvar_j+1][gvar_k>>1][0+:gvar_j] <= {gvar_j{1'b0}};
                                end
                                else begin
                                    id_sel[gvar_j+1][gvar_k>>1][0+:gvar_j] <= id_sel[gvar_j][gvar_k][0+:gvar_j];
                                end
                            end
                        end
                    end
                    else begin: g_cmp
                        always_ff @(posedge clk or negedge rstn) begin
                            if (~rstn) begin
                                en_ints_pri[gvar_j+1][gvar_k>>1]     <= 32'b0;
                                id_sel[gvar_j+1][gvar_k>>1][gvar_j]  <= 1'b0;
                            end
                            else begin
                                if (en_ints_pri[gvar_j][gvar_k] < en_ints_pri[gvar_j][gvar_k + 1]) begin
                                    en_ints_pri[gvar_j+1][gvar_k>>1]     <= en_ints_pri[gvar_j][gvar_k + 1];
                                    id_sel[gvar_j+1][gvar_k>>1][gvar_j]  <= 1'b1;
                                end
                                else begin
                                    en_ints_pri[gvar_j+1][gvar_k>>1]     <= en_ints_pri[gvar_j][gvar_k];
                                    id_sel[gvar_j+1][gvar_k>>1][gvar_j]  <= 1'b0;
                                end
                            end
                        end
                        if (gvar_j > 0) begin: g_non_first
                            always_ff @(posedge clk or negedge rstn) begin
                                if (~rstn) begin
                                    id_sel[gvar_j+1][gvar_k>>1][0+:gvar_j] <= {gvar_j{1'b0}};
                                end
                                else begin
                                    if (en_ints_pri[gvar_j][gvar_k] < en_ints_pri[gvar_j][gvar_k + 1]) begin
                                        id_sel[gvar_j+1][gvar_k>>1][0+:gvar_j] <= id_sel[gvar_j][gvar_k+1][0+:gvar_j];
                                    end
                                    else begin
                                        id_sel[gvar_j+1][gvar_k>>1][0+:gvar_j] <= id_sel[gvar_j][gvar_k][0+:gvar_j];
                                    end
                                end
                            end
                        end
                    end
                end
            end
            else begin: g_non_pipelining
                for (gvar_k = 0; gvar_k <= CMP_TREE_NUM[gvar_j] - 1; gvar_k = gvar_k + 2) begin: g_cmp
                    if (gvar_k == CMP_TREE_NUM[gvar_j] - 1) begin: g_remainder
                        assign en_ints_pri[gvar_j+1][gvar_k>>1]     = en_ints_pri[gvar_j][gvar_k];
                        assign id_sel[gvar_j+1][gvar_k>>1][gvar_j]  = 1'b0;
                        if (gvar_j > 0) begin: g_non_first
                            assign id_sel[gvar_j+1][gvar_k>>1][0+:gvar_j] = id_sel[gvar_j][gvar_k][0+:gvar_j];
                        end
                    end
                    else begin: g_cmp
                        always_comb begin
                            if (en_ints_pri[gvar_j][gvar_k] < en_ints_pri[gvar_j][gvar_k + 1]) begin
                                en_ints_pri[gvar_j+1][gvar_k>>1]     = en_ints_pri[gvar_j][gvar_k + 1];
                                id_sel[gvar_j+1][gvar_k>>1][gvar_j]  = 1'b1;
                            end
                            else begin
                                en_ints_pri[gvar_j+1][gvar_k>>1]     = en_ints_pri[gvar_j][gvar_k];
                                id_sel[gvar_j+1][gvar_k>>1][gvar_j]  = 1'b0;
                            end
                        end
                        if (gvar_j > 0) begin: g_non_first
                            always_comb begin
                                if (en_ints_pri[gvar_j][gvar_k] < en_ints_pri[gvar_j][gvar_k + 1]) begin
                                    id_sel[gvar_j+1][gvar_k>>1][0+:gvar_j] = id_sel[gvar_j][gvar_k+1][0+:gvar_j];
                                end
                                else begin
                                    id_sel[gvar_j+1][gvar_k>>1][0+:gvar_j] = id_sel[gvar_j][gvar_k][0+:gvar_j];
                                end
                            end
                        end
                    end
                end
            end
        end
        
        assign int_id_tmp[gvar_i]  = {22'b0, id_sel[10][0][9:0]};
        assign int_max_pri[gvar_i] = en_ints_pri[10][0];
    end
endgenerate

// always_ff @(posedge clk or negedge rstn) begin
//     integer i;
//     if (~rstn) begin
//         for (i = 0; i < `CPU_NUM; i = i + 1) begin
//             meip[i] <= 1'b0;
//         end
//     end
//     else begin
//         for (i = 0; i < `CPU_NUM; i = i + 1) begin
//             meip[i] <= int_max_pri[i] > threshold[i];
//         end
//     end
// end

always_comb begin
    integer i;
    for (i = 0; i < `CPU_NUM; i = i + 1) begin
        meip[i] <= claim_id[i] != int_id[i];
    end
end

assign apb_wr = ~penable & psel & pwrite;

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 0; i < `INT_NUM; i = i + 1) begin
            int_prior[i] <= 32'b0;
        end
    end
    else if (apb_wr) begin
        for (i = 1; i < `INT_NUM; i = i + 1) begin
            if (paddr[25:0] == `PLIC_INT_PRIOR + 26'h4 * i[25:0]) begin
                int_prior[i] <= pwdata;
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        int_type <= `INT_NUM'b0;
    end
    else if (apb_wr) begin
        for (i = 0; i < `INT_NUM; i = i + 32) begin
            if (paddr[25:0] == `PLIC_INT_TYPE + i[28:3]) begin
                int_type[i+:32] <= pwdata;
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        int_pol <= `INT_NUM'b0;
    end
    else if (apb_wr) begin
        for (i = 0; i < `INT_NUM; i = i + 32) begin
            if (paddr[25:0] == `PLIC_INT_POL + i[28:3]) begin
                int_pol[i+:32] <= pwdata;
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i, j;
    if (~rstn) begin
        for (j = 0; j < `CPU_NUM; j = j + 1) begin
            int_en[j] <= `INT_NUM'b0;
        end
    end
    else if (apb_wr) begin
        for (j = 0; j < `CPU_NUM; j = j + 1) begin
            for (i = 0; i < `INT_NUM; i = i + 32) begin
                if (paddr[25:0] == `PLIC_INT_EN + i[28:3] + 26'h80 * j[25:0]) begin
                    int_en[j][i+:32] <= pwdata;
                end
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 0; i < `CPU_NUM; i = i + 1) begin
            threshold[i] <= 32'b0;
        end
    end
    else if (apb_wr) begin
        for (i = 0; i < `CPU_NUM; i = i + 1) begin
            if (paddr[25:0] == `PLIC_PRIOR_TH + 26'h1000 * i[25:0]) begin
                threshold[i] <= pwdata;
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 0; i < `CPU_NUM; i = i + 1) begin
            int_id   [i] <= 32'b0;
        end
    end
    else begin
        for (i = 0; i < `CPU_NUM; i = i + 1) begin
            if (!(~penable && psel && paddr[25:0] == `PLIC_PRIOR_TH + 26'h1000 * i[25:0] + 26'h4)) begin
                if (~|claim_id[i]) begin // non-preemptive
                    int_id   [i] <= int_max_pri[i] > threshold[i] ? int_id_tmp[i] : 32'b0;
                end
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 0; i < `CPU_NUM; i = i + 1) begin
            claim_id [i] <= 32'b0;
        end
    end
    else begin
        for (i = 0; i < `CPU_NUM; i = i + 1) begin
            if (~penable && psel && paddr[25:0] == `PLIC_PRIOR_TH + 26'h1000 * i[25:0] + 26'h4) begin
                claim_id [i] <= pwrite ? 32'b0 : int_id[i];
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 0; i < `CPU_NUM; i = i + 1) begin
            cmplet_id[i] <= 32'b0;
        end
    end
    else begin
        for (i = 0; i < `CPU_NUM; i = i + 1) begin
            if (apb_wr && paddr[25:0] == `PLIC_PRIOR_TH + 26'h1000 * i[25:0] + 26'h4) begin
                cmplet_id[i] <= claim_id[i];
            end
            else begin
                cmplet_id[i] <= 32'b0;
            end
        end
    end
end

always_comb begin
    integer i;
    prdata_pri = 32'b0;
    for (i = 0; i < `INT_NUM; i = i + 1) begin
        prdata_pri = prdata_pri | (int_prior[i] & {32{paddr[25:0] == `PLIC_INT_PRIOR + 26'h4 * i[25:0]}});
    end
end

always_comb begin
    integer i;
    prdata_ip = 32'b0;
    for (i = 0; i < `INT_NUM; i = i + 32) begin
        prdata_ip = prdata_ip | (int_pend[i+:32] & {32{paddr[25:0] == `PLIC_INT_PEND + i[28:3]}});
    end
end

always_comb begin
    integer i;
    prdata_ityp = 32'b0;
    for (i = 0; i < `INT_NUM; i = i + 32) begin
        prdata_ityp = prdata_ityp | (int_type[i+:32] & {32{paddr[25:0] == `PLIC_INT_TYPE + i[28:3]}});
    end
end

always_comb begin
    integer i;
    prdata_ipol = 32'b0;
    for (i = 0; i < `INT_NUM; i = i + 32) begin
        prdata_ipol = prdata_ipol | (int_pol[i+:32] & {32{paddr[25:0] == `PLIC_INT_POL + i[28:3]}});
    end
end

always_comb begin
    integer i, j;
    prdata_ie = 32'b0;
    for (j = 0; j < `CPU_NUM; j = j + 1) begin
        for (i = 0; i < `INT_NUM; i = i + 32) begin
            prdata_ie = prdata_ie | (int_en[j][i+:32] & {32{paddr[25:0] == `PLIC_INT_EN + i[28:3] + 26'h80 * j[25:0]}});
        end
    end
end

always_comb begin
    integer i;
    prdata_th = 32'b0;
    for (i = 0; i < `CPU_NUM; i = i + 1) begin
        prdata_th = prdata_th | (threshold[i] & {32{paddr[25:0] == `PLIC_PRIOR_TH + 26'h1000 * i[25:0]}});
    end
end

always_comb begin
    integer i;
    prdata_id = 32'b0;
    for (i = 0; i < `CPU_NUM; i = i + 1) begin
        prdata_id = prdata_id | (int_id[i] & {32{paddr[25:0] == `PLIC_PRIOR_TH + 26'h1000 * i[25:0] + 26'h4}});
    end
end

assign prdata_t = prdata_pri | prdata_ip | prdata_ityp | prdata_ipol | prdata_ie | prdata_id | prdata_th;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        prdata <= 32'b0;
    end
    else begin
        prdata <= prdata_t;
    end
end

assign pslverr = 1'b0;
assign pready  = 1'b1;

endmodule


module gateway (
    input        clk,
    input        rstn,
    input        src,
    input        src_type, // 0: edge, 1: level
    input        src_pol,  // 0: high, 1: low
    input        claim,
    input        cmplet,
    output logic pend
);

parameter [1:0] STATE_IDLE  = 2'b00,
                STATE_PEND  = 2'b01,
                STATE_CLAIM = 2'b10;

logic [1:0] cur_state;
logic [1:0] nxt_state;

logic       src_pol_dly;
logic       src_lvl;
logic       src_edge;
logic       is_pend;
logic       is_claim;
logic       is_cancel;
logic       is_cmplet;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        cur_state <= STATE_IDLE;
    end
    else begin
        cur_state <= nxt_state;
    end
end

always_comb begin
    nxt_state = cur_state;
    case (cur_state)
        STATE_IDLE : nxt_state = is_pend   ? STATE_PEND  : STATE_IDLE;
        STATE_PEND : nxt_state = is_claim  ? STATE_CLAIM :
                                 is_cancel ? STATE_IDLE  : STATE_PEND;
        STATE_CLAIM: nxt_state = is_cmplet ? STATE_IDLE  : STATE_CLAIM;
    endcase
end

assign src_tmp = src ^ src_pol;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        src_pol_dly  <= 1'b0;
    end
    else begin
        src_pol_dly  <= src_pol;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        src_lvl <= 1'b0;
    end
    else begin
        src_lvl <= src_tmp;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        src_edge <= 1'b0;
    end
    else begin
        src_edge <= ~src_lvl & src_tmp;
    end
end

assign is_pend   = src_type ?  src_lvl : src_edge;
assign is_claim  = claim;
assign is_cancel = (src_type ? ~src_lvl : 1'b0) | (src_pol ^ src_pol_dly);
assign is_cmplet = cmplet;

assign pend      = cur_state == STATE_PEND;

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/dbgapb.sv
/*--------------------------------------*/

`ifndef __DBGAPB_DEFINE__
`define __DBGAPB_DEFINE__

`define INST_ATTACH     12'h000
`define INST_RESUME     12'h001

`define INST_INSTREG_WR 12'h002
`define INST_EXECUTE    12'h003
`define INST_STATUS_RD  12'h004
`define INST_PC_RD      12'h005
`define INST_GPR_RD     12'h006
`define INST_CSR_RD     12'h007
`define INST_GPR_WR     12'h008
`define INST_CSR_WR     12'h009

`endif
`ifndef __DBGAPB_MMAP__
`define __DBGAPB_MMAP__

`define DBGAPB_DBG_EN     12'h000
`define DBGAPB_INST       12'h004
`define DBGAPB_INST_WR    12'h008
`define DBGAPB_WDATA      12'h00C
`define DBGAPB_WDATA_WR   12'h010
`define DBGAPB_RDATA      12'h014

`endif

module dbgapb (
    input                 pclk,
    input                 presetn,
    input                 psel,
    input                 penable,
    input        [ 31: 0] paddr,
    input                 pwrite,
    input        [  3: 0] pstrb,
    input        [ 31: 0] pwdata,
    output logic [ 31: 0] prdata,
    output logic          pslverr,
    output logic          pready,

    output logic [ 11: 0] addr_out,
    output logic [ 31: 0] wdata_out,
    output logic          gpr_rd,
    output logic          gpr_wr,
    input        [ 31: 0] gpr_in,
    output logic          csr_rd,
    output logic          csr_wr,
    input        [ 31: 0] csr_in,
    input        [ 31: 0] pc,
    output logic [ 31: 0] inst_out,
    output logic          exec,
    input                 halted,
    output logic          attach
);

logic        dbg_en;
logic [31:0] dbg_inst;
logic        dbg_inst_wr;
logic [31:0] dbg_wdata;
logic        dbg_wdata_wr;
logic [31:0] dbg_rdata;

logic [31:0] wdata_reg;
logic [31:0] rdata_reg;
logic [31:0] status_reg;

logic        rdata_sel;
logic        pc_rd;

logic        nxt_attach;
logic [31:0] nxt_inst_out;
logic        nxt_exec;
logic        nxt_rdata_sel;
logic        nxt_pc_rd;
logic [12:0] nxt_addr_out;
logic        nxt_gpr_rd;
logic        nxt_csr_rd;
logic        nxt_gpr_wr;
logic        nxt_csr_wr;

logic [ 9:0] nxt_ready_cnt;
logic [ 9:0] ready_cnt;

assign status_reg = {30'b0, halted, attach};

always_ff @(posedge pclk or negedge presetn) begin
    if (~presetn) begin
        rdata_reg <= 32'b0;
    end
    else if (pc_rd) begin
        rdata_reg <= pc;
    end
    else if (gpr_rd) begin
        rdata_reg <= gpr_in;
    end
    else if (csr_rd) begin
        rdata_reg <= csr_in;
    end
end

assign dbg_rdata = rdata_sel ? status_reg : rdata_reg;

always_ff @(posedge pclk or negedge presetn) begin
    if (~presetn) begin
        wdata_reg <= 32'b0;
    end
    else if (dbg_wdata_wr) begin
        wdata_reg <= dbg_wdata;
    end
end

assign wdata_out = wdata_reg;

always_ff @(posedge pclk or negedge presetn) begin
    if (~presetn) begin
        attach     <= 1'b0;
        inst_out   <= 32'b0;
        exec       <= 1'b0;
        rdata_sel  <= 1'b0;
        pc_rd      <= 1'b0;
        addr_out   <= 12'b0;
        gpr_rd     <= 1'b0;
        csr_rd     <= 1'b0;
        gpr_wr     <= 1'b0;
        csr_wr     <= 1'b0;
    end
    else if (dbg_inst_wr) begin
        attach     <= nxt_attach;
        inst_out   <= nxt_inst_out;
        exec       <= nxt_exec;
        rdata_sel  <= nxt_rdata_sel;
        pc_rd      <= nxt_pc_rd;
        addr_out   <= nxt_addr_out;
        gpr_rd     <= nxt_gpr_rd;
        csr_rd     <= nxt_csr_rd;
        gpr_wr     <= nxt_gpr_wr;
        csr_wr     <= nxt_csr_wr;
    end
    else begin
        exec       <= 1'b0;
        pc_rd      <= 1'b0;
        gpr_rd     <= 1'b0;
        csr_rd     <= 1'b0;
        gpr_wr     <= 1'b0;
        csr_wr     <= 1'b0;
    end
end

always_comb begin
    nxt_attach    = attach;
    nxt_inst_out  = inst_out;
    nxt_exec      = 1'b0;
    nxt_rdata_sel = rdata_sel;
    nxt_pc_rd     = 1'b0;
    nxt_addr_out  = addr_out;
    nxt_gpr_rd    = 1'b0;
    nxt_csr_rd    = 1'b0;
    nxt_gpr_wr    = 1'b0;
    nxt_csr_wr    = 1'b0;
    case (dbg_inst[11:0])
        `INST_ATTACH: begin
            nxt_attach    = 1'b1;
        end
        `INST_RESUME: begin
            nxt_attach    = 1'b0;
        end
        `INST_INSTREG_WR: begin
            nxt_inst_out  = wdata_reg;
        end
        `INST_EXECUTE: begin
            nxt_exec      = 1'b1;
        end
        `INST_STATUS_RD: begin
            nxt_rdata_sel = 1'b1;
        end
        `INST_PC_RD: begin
            nxt_rdata_sel = 1'b0;
            nxt_pc_rd     = 1'b1;
        end
        `INST_GPR_RD: begin
            nxt_rdata_sel = 1'b0;
            nxt_addr_out  = {4'b0, dbg_inst[23:16]};
            nxt_gpr_rd    = 1'b1;
        end
        `INST_CSR_RD: begin
            nxt_rdata_sel = 1'b0;
            nxt_addr_out  = dbg_inst[27:16];
            nxt_csr_rd    = 1'b1;
        end
        `INST_GPR_WR: begin
            nxt_addr_out  = {7'b0, dbg_inst[20:16]};
            nxt_gpr_wr    = 1'b1;
        end
        `INST_CSR_WR: begin
            nxt_addr_out  = dbg_inst[27:16];
            nxt_csr_wr    = 1'b1;
        end
    endcase
end

logic        apb_wr;
logic        dbgapb_wr;

assign apb_wr    = ~penable && psel && pwrite;
assign dbgapb_wr = dbg_en && apb_wr;

always_ff @(posedge pclk or negedge presetn) begin
    if (~presetn) begin
        dbg_en <= 1'b0;
    end
    else if (apb_wr && paddr[11:0] == `DBGAPB_DBG_EN) begin
        dbg_en <= pwdata[0];
    end
end

always_ff @(posedge pclk or negedge presetn) begin
    if (~presetn) begin
        dbg_inst <= 32'b0;
    end
    else if (dbgapb_wr && paddr[11:0] == `DBGAPB_INST) begin
        dbg_inst <= pwdata;
    end
end

always_ff @(posedge pclk or negedge presetn) begin
    if (~presetn) begin
        dbg_inst_wr <= 1'b0;
    end
    else if (dbgapb_wr && paddr[11:0] == `DBGAPB_INST_WR) begin
        dbg_inst_wr <= 1'b1;
    end
    else begin
        dbg_inst_wr <= 1'b0;
    end
end

always_ff @(posedge pclk or negedge presetn) begin
    if (~presetn) begin
        dbg_wdata <= 32'b0;
    end
    else if (dbgapb_wr && paddr[11:0] == `DBGAPB_WDATA) begin
        dbg_wdata <= pwdata;
    end
end

always_ff @(posedge pclk or negedge presetn) begin
    if (~presetn) begin
        dbg_wdata_wr <= 1'b0;
    end
    else if (dbgapb_wr && paddr[11:0] == `DBGAPB_WDATA_WR) begin
        dbg_wdata_wr <= 1'b1;
    end
    else begin
        dbg_wdata_wr <= 1'b0;
    end
end

logic [31:0] prdata_t;

always_comb begin
    prdata_t = 32'b0;
    case (paddr[11:0])
        `DBGAPB_DBG_EN  : prdata_t = {31'b0, dbg_en};
        `DBGAPB_INST    : prdata_t = dbg_inst;
        `DBGAPB_INST_WR : prdata_t = {31'b0, dbg_inst_wr};
        `DBGAPB_WDATA   : prdata_t = dbg_wdata;
        `DBGAPB_WDATA_WR: prdata_t = {31'b0, dbg_wdata_wr};
        `DBGAPB_RDATA   : prdata_t = dbg_rdata;
    endcase
end

always_ff @(posedge pclk or negedge presetn) begin
    if (~presetn) begin
        prdata <= 32'b0;
    end
    else begin
        prdata <= dbg_en ? prdata_t : 32'b0;
    end
end

always_comb begin
    nxt_ready_cnt = 10'b0;
    case (paddr[11:0])
        `DBGAPB_INST_WR: begin
            case (dbg_inst[11:0])
                `INST_EXECUTE   : nxt_ready_cnt = 10'h5;
                `INST_STATUS_RD : nxt_ready_cnt = 10'h1;
                `INST_PC_RD     : nxt_ready_cnt = 10'h1;
                `INST_GPR_RD    : nxt_ready_cnt = 10'h1;
                `INST_CSR_RD    : nxt_ready_cnt = 10'h1;
                `INST_GPR_WR    : nxt_ready_cnt = 10'h1;
                `INST_CSR_WR    : nxt_ready_cnt = 10'h2;
            endcase
        end
    endcase
end

always_ff @(posedge pclk or negedge presetn) begin
    if (~presetn) begin
        ready_cnt <= 10'b0;
    end
    else if (apb_wr) begin
        ready_cnt <= nxt_ready_cnt;
    end
    else if (|ready_cnt) begin
        ready_cnt <= ready_cnt - 10'b1;
    end
end

assign pslverr = 1'b0;
assign pready  = ~|ready_cnt;
// assign pready  = 1'b1;

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/util.sv
/*--------------------------------------*/

module CG (
    input  CK,
    input  EN,
    output CKEN
);

logic en_latch;

always_latch begin
    if (~CK) en_latch <= EN;
end

assign CKEN = CK & en_latch;

endmodule

module resetn_synchronizer (
    input  clk,
    input  rstn_async,
    output rstn_sync
);

logic rstn_async_d1;
logic rstn_async_d2;

always @(posedge clk or negedge rstn_async) begin
    if (~rstn_async) rstn_async_d1 <= 1'b0;
    else             rstn_async_d1 <= 1'b1;
end

always @(posedge clk or negedge rstn_async) begin
    if (~rstn_async) rstn_async_d2 <= 1'b0;
    else             rstn_async_d2 <= rstn_async_d1;
end

assign rstn_sync = rstn_async_d2;

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/uart.sv
/*--------------------------------------*/

module uart (
    input                 pclk,
    input                 presetn,
    input                 psel,
    input                 penable,
    input        [ 31: 0] paddr,
    input                 pwrite,
    input        [  3: 0] pstrb,
    input        [ 31: 0] pwdata,
    output logic [ 31: 0] prdata,
    output logic          pslverr,
    output logic          pready,

    input                 uart_rx,
    output logic          uart_tx
);

logic [31:0] prdata_t;
logic [ 7:0] txdata;
logic [ 7:0] rxdata;

assign rxdata = 8'b0;

always_ff @(posedge pclk or negedge presetn) begin
    if (~presetn) begin
        txdata <= 8'b0;
    end
    else if (~penable && psel && pwrite && paddr[11:0] == 12'b0) begin
        $write("%c", pwdata[7:0]);
        txdata <= pwdata[7:0];
    end
end

always_comb begin
    prdata_t = 32'b0;
    case (paddr[11:0])
        12'h0: prdata_t = {24'b0, txdata};
        12'h4: prdata_t = {24'b0, rxdata};
    endcase
end

always_ff @(posedge pclk or negedge presetn) begin
    if (~presetn) begin
        prdata <= 32'b0;
    end
    else begin
        prdata <= prdata_t;
    end
end

assign pslverr = 1'b0;
assign pready  = 1'b1;

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/iommu.sv
/*--------------------------------------*/

module iommu (
    input                  aclk,
    input                  aresetn,
    input         [  1: 0] s_awburst,
    input         [  9: 0] s_awid,
    input         [ 31: 0] s_awaddr,
    input         [  2: 0] s_awsize,
    input         [  7: 0] s_awlen,
    input                  s_awvalid,
    output logic           s_awready,
    input         [  3: 0] s_wstrb,
    input         [  9: 0] s_wid,
    input         [ 31: 0] s_wdata,
    input                  s_wlast,
    input                  s_wvalid,
    output logic           s_wready,
    output logic  [  9: 0] s_bid,
    output logic  [  1: 0] s_bresp,
    output logic           s_bvalid,
    input                  s_bready,
    input         [ 31: 0] s_araddr,
    input         [  1: 0] s_arburst,
    input         [  2: 0] s_arsize,
    input         [  9: 0] s_arid,
    input         [  7: 0] s_arlen,
    input                  s_arvalid,
    output logic           s_arready,
    output logic  [ 31: 0] s_rdata,
    output logic  [  1: 0] s_rresp,
    output logic  [  9: 0] s_rid,
    output logic           s_rlast,
    output logic           s_rvalid,
    input                  s_rready,
    output logic  [  1: 0] m_awburst,
    output logic  [  9: 0] m_awid,
    output logic  [ 31: 0] m_awaddr,
    output logic  [  2: 0] m_awsize,
    output logic  [  7: 0] m_awlen,
    output logic           m_awvalid,
    input                  m_awready,
    output logic  [  3: 0] m_wstrb,
    output logic  [  9: 0] m_wid,
    output logic  [ 31: 0] m_wdata,
    output logic           m_wlast,
    output logic           m_wvalid,
    input                  m_wready,
    input         [  9: 0] m_bid,
    input         [  1: 0] m_bresp,
    input                  m_bvalid,
    output logic           m_bready,
    output logic  [ 31: 0] m_araddr,
    output logic  [  1: 0] m_arburst,
    output logic  [  2: 0] m_arsize,
    output logic  [  9: 0] m_arid,
    output logic  [  7: 0] m_arlen,
    output logic           m_arvalid,
    input                  m_arready,
    input         [ 31: 0] m_rdata,
    input         [  1: 0] m_rresp,
    input         [  9: 0] m_rid,
    input                  m_rlast,
    input                  m_rvalid,
    output logic           m_rready
);

assign s_awready = m_awready;
assign s_wready  = m_wready ;
assign s_bid     = m_bid    ;
assign s_bresp   = m_bresp  ;
assign s_bvalid  = m_bvalid ;
assign s_arready = m_arready;
assign s_rdata   = m_rdata  ;
assign s_rresp   = m_rresp  ;
assign s_rid     = m_rid    ;
assign s_rlast   = m_rlast  ;
assign s_rvalid  = m_rvalid ;

assign m_awburst = s_awburst;
assign m_awid    = s_awid   ;
assign m_awaddr  = {2'b0, s_awaddr[29:0]};
assign m_awsize  = s_awsize ;
assign m_awlen   = s_awlen  ;
assign m_awvalid = s_awvalid;
assign m_wstrb   = s_wstrb  ;
assign m_wid     = s_wid    ;
assign m_wdata   = s_wdata  ;
assign m_wlast   = s_wlast  ;
assign m_wvalid  = s_wvalid ;
assign m_bready  = s_bready ;
assign m_araddr  = {2'b0, s_araddr[29:0]};
assign m_arburst = s_arburst;
assign m_arsize  = s_arsize ;
assign m_arid    = s_arid   ;
assign m_arlen   = s_arlen  ;
assign m_arvalid = s_arvalid;
assign m_rready  = s_rready ;

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/axi2mem_bridge.sv
/*--------------------------------------*/

`ifndef __AXI_DEFINE__
`define __AXI_DEFINE__

`define AXI_BURST_FIXED 2'b00
`define AXI_BURST_INCR  2'b01
`define AXI_BURST_WRAP  2'b10

`define AXI_RESP_OKAY   2'b00
`define AXI_RESP_EXOKAY 2'b01
`define AXI_RESP_SLVERR 2'b10
`define AXI_RESP_DECERR 2'b11

`endif

module axi2mem_bridge (
    input                  aclk,
    input                  aresetn,
    // AXI slave port
    input         [  1: 0] s_awburst,
    input         [ 12: 0] s_awid,
    input         [ 31: 0] s_awaddr,
    input         [  2: 0] s_awsize,
    input         [  7: 0] s_awlen,
    input                  s_awvalid,
    output logic           s_awready,
    input         [  3: 0] s_wstrb,
    input         [ 12: 0] s_wid,
    input         [ 31: 0] s_wdata,
    input                  s_wlast,
    input                  s_wvalid,
    output logic           s_wready,
    output logic  [ 12: 0] s_bid,
    output logic  [  1: 0] s_bresp,
    output logic           s_bvalid,
    input                  s_bready,
    input         [ 31: 0] s_araddr,
    input         [  1: 0] s_arburst,
    input         [  2: 0] s_arsize,
    input         [ 12: 0] s_arid,
    input         [  7: 0] s_arlen,
    input                  s_arvalid,
    output logic           s_arready,
    output logic  [ 31: 0] s_rdata,
    output logic  [  1: 0] s_rresp,
    output logic  [ 12: 0] s_rid,
    output logic           s_rlast,
    output logic           s_rvalid,
    input                  s_rready,

    // Memory intface master port
    output logic           m_cs, 
    output logic           m_we, 
    output logic  [ 31: 0] m_addr,
    output logic  [  3: 0] m_byte,
    output logic  [ 31: 0] m_di,
    input         [ 31: 0] m_do,
    input                  m_busy

);

parameter [1:0] STATE_IDLE = 2'b00,
                STATE_WR   = 2'b01,
                SIATE_RESP = 2'b10,
                STATE_RD   = 2'b11;

logic [  1: 0] cur_state;
logic [  1: 0] nxt_state;

logic          req_latch;
logic          rsend_latch;
logic [ 12: 0] id_latch;
logic [  7: 0] cnt;
logic [ 31: 0] addr_latch;
logic [ 31: 0] addr_mask_latch;
logic [  2: 0] size_latch;
logic          id_upd;
logic          cnt_upd;
logic          addr_upd;
logic          size_upd;
logic          cnt_nxt;
logic          addr_nxt;
logic          rdata_latch_en;
logic [ 31: 0] rdata_latch;


always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        cur_state <= STATE_IDLE;
    end
    else begin
        cur_state <= nxt_state;
    end
end

always_comb begin
    nxt_state = cur_state;
    case (cur_state)
        STATE_IDLE: begin
            nxt_state = s_arvalid ? STATE_RD:
                        s_awvalid ? STATE_WR:
                                    STATE_IDLE;
        end
        STATE_WR  : begin
            nxt_state = ~|cnt & s_wvalid & s_wready ? SIATE_RESP : STATE_WR;
        end
        SIATE_RESP: begin
            nxt_state = s_bready ? STATE_IDLE : SIATE_RESP;
        end
        STATE_RD  : begin
            nxt_state = ~|cnt & s_rready & s_rvalid ? STATE_IDLE : STATE_RD;
        end
    endcase
end

assign s_bid   = id_latch;
assign s_bresp = `AXI_RESP_OKAY;
assign s_rid   = id_latch;
assign s_rdata = rdata_latch_en ? rdata_latch : m_do;
assign s_rresp = `AXI_RESP_OKAY;
assign s_rlast = ~|cnt;
assign m_addr  = addr_latch;
assign m_byte  = s_wstrb;
assign m_di    = s_wdata;

always_comb begin
    s_awready = 1'b0;
    s_wready  = 1'b0;
    s_bvalid  = 1'b0;
    s_arready = 1'b0;
    s_rvalid  = 1'b0;
    m_cs      = 1'b0;
    m_we      = 1'b0;
    id_upd    = 1'b0;
    cnt_upd   = 1'b0;
    addr_upd  = 1'b0;
    size_upd  = 1'b0;
    cnt_nxt   = 1'b0;
    addr_nxt  = 1'b0;
    case (cur_state)
        STATE_IDLE: begin
            s_awready = ~s_arvalid;
            s_arready = 1'b1;
            id_upd    = s_arvalid | s_awvalid;
            cnt_upd   = s_arvalid | s_awvalid;
            addr_upd  = s_arvalid | s_awvalid;
            size_upd  = s_arvalid | s_awvalid;
        end
        STATE_WR  : begin
            s_wready = ~m_busy;
            m_cs     = ~m_busy & s_wvalid;
            m_we     = 1'b1;
            cnt_nxt  = ~m_busy & s_wvalid;
            addr_nxt = ~m_busy & s_wvalid;
        end
        SIATE_RESP: begin
            s_bvalid = 1'b1;
        end
        STATE_RD  : begin
            s_rvalid = (~m_busy & req_latch) | rdata_latch_en;
            m_cs     = ~m_busy & ~(s_rlast & req_latch) & rsend_latch & ~rdata_latch_en;
            cnt_nxt  = ((~m_busy & req_latch) | rdata_latch_en) & s_rready;
            addr_nxt = ~m_busy/* & req_latch*/ & s_rready;
        end
    endcase
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        rsend_latch <= 1'b1;
    end
    else begin
        if (cur_state == STATE_RD) begin
            rsend_latch <= addr_nxt;
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        req_latch   <= 1'b0;
    end
    else begin
        if (cur_state == STATE_RD) begin
            if (~m_busy) req_latch <= m_cs;
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        rdata_latch_en <= 1'b0;
    end
    else begin
        if (cur_state == STATE_RD) begin
            if (s_rvalid & s_rready) begin
                rdata_latch_en <= 1'b0;
            end
            else if (req_latch & ~m_busy) begin
                rdata_latch_en <= 1'b1;
            end
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        rdata_latch <= 32'b0;
    end
    else begin
        if (cur_state == STATE_RD) begin
            if (req_latch & ~m_busy) begin
                rdata_latch <= m_do;
            end
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        id_latch <= 13'b0;
    end
    else begin
        if (id_upd) begin
            id_latch <= s_arvalid ? s_arid : s_awid;
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        cnt <= 8'b0;
    end
    else begin
        if (cnt_upd) begin
            cnt <= s_arvalid ? s_arlen : s_awlen;
        end
        else if (cnt_nxt) begin
            cnt <= cnt - 8'b1;
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        addr_mask_latch <= 32'b0;
    end
    else begin
        if (addr_upd) begin
            if (s_arvalid) begin
                case (s_arburst)
                    `AXI_BURST_FIXED: begin
                        addr_mask_latch <= ~32'b0;
                    end
                    `AXI_BURST_INCR : begin
                        addr_mask_latch <= 32'b0;
                    end
                    `AXI_BURST_WRAP : begin
                        addr_mask_latch <= ~((({{(32-8){1'b0}}, s_arlen} + 32'b1) << s_arsize) - 32'b1);
                    end
                endcase
            end
            else begin
            end
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        addr_latch <= 32'b0;
    end
    else begin
        if (addr_upd) begin
            addr_latch <= s_arvalid ? s_araddr : s_awaddr;
        end
        else if (addr_nxt) begin
            addr_latch <= (addr_latch & addr_mask_latch) | ((addr_latch + (32'b1 << size_latch)) & ~addr_mask_latch);
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        size_latch <= 3'b0;
    end
    else begin
        if (id_upd) begin
            size_latch <= s_arvalid ? s_arsize : s_awsize;
        end
    end
end



endmodule

/*--------------------------------------*/
// FILE: ../src/bus/axi2apb_bridge.sv
/*--------------------------------------*/

`ifndef __AXI_DEFINE__
`define __AXI_DEFINE__

`define AXI_BURST_FIXED 2'b00
`define AXI_BURST_INCR  2'b01
`define AXI_BURST_WRAP  2'b10

`define AXI_RESP_OKAY   2'b00
`define AXI_RESP_EXOKAY 2'b01
`define AXI_RESP_SLVERR 2'b10
`define AXI_RESP_DECERR 2'b11

`endif

module axi2apb_bridge (
    input                  aclk,
    input                  aresetn,
    // AXI slave port
    input         [  1: 0] s_awburst,
    input         [ 12: 0] s_awid,
    input         [ 31: 0] s_awaddr,
    input         [  2: 0] s_awsize,
    input         [  7: 0] s_awlen,
    input                  s_awvalid,
    output logic           s_awready,
    input         [  3: 0] s_wstrb,
    input         [ 12: 0] s_wid,
    input         [ 31: 0] s_wdata,
    input                  s_wlast,
    input                  s_wvalid,
    output logic           s_wready,
    output logic  [ 12: 0] s_bid,
    output logic  [  1: 0] s_bresp,
    output logic           s_bvalid,
    input                  s_bready,
    input         [ 31: 0] s_araddr,
    input         [  1: 0] s_arburst,
    input         [  2: 0] s_arsize,
    input         [ 12: 0] s_arid,
    input         [  7: 0] s_arlen,
    input                  s_arvalid,
    output logic           s_arready,
    output logic  [ 31: 0] s_rdata,
    output logic  [  1: 0] s_rresp,
    output logic  [ 12: 0] s_rid,
    output logic           s_rlast,
    output logic           s_rvalid,
    input                  s_rready,

    // APB master port
    output logic           psel,
    output logic           penable,
    output logic  [ 31: 0] paddr,
    output logic           pwrite,
    output logic  [  3: 0] pstrb,
    output logic  [ 31: 0] pwdata,
    input         [ 31: 0] prdata,
    input                  pslverr,
    input                  pready

);

parameter [2:0] STATE_IDLE  = 3'b000,
                STATE_WR    = 3'b001,
                SIATE_BRESP = 3'b010,
                STATE_RD    = 3'b011,
                STATE_RRESP = 3'b100;

logic [  2: 0] cur_state;
logic [  2: 0] nxt_state;

logic [ 12: 0] id_latch;
logic [  7: 0] cnt;
logic [ 31: 0] addr_latch;
logic [ 31: 0] addr_mask_latch;
logic [  2: 0] size_latch;
logic          id_upd;
logic          cnt_upd;
logic          addr_upd;
logic          size_upd;
logic          cnt_nxt;
logic          addr_nxt;
logic [ 31: 0] rdata_latch;
logic [  1: 0] resp_latch;


always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        cur_state <= STATE_IDLE;
    end
    else begin
        cur_state <= nxt_state;
    end
end

always_comb begin
    nxt_state = cur_state;
    case (cur_state)
        STATE_IDLE: begin
            nxt_state = s_arvalid ? STATE_RD:
                        s_awvalid ? STATE_WR:
                                    STATE_IDLE;
        end
        STATE_WR  : begin
            nxt_state = ~|cnt & s_wvalid & s_wready ? SIATE_BRESP : STATE_WR;
        end
        SIATE_BRESP: begin
            nxt_state = s_bready ? STATE_IDLE : SIATE_BRESP;
        end
        STATE_RD  : begin
            nxt_state = penable & pready ? STATE_RRESP : STATE_RD;
        end
        STATE_RRESP: begin
            nxt_state = ~|cnt & s_rready ? STATE_IDLE:
                        s_rready         ? STATE_RD:
                                           STATE_RRESP;
        end
    endcase
end

assign s_bid   = id_latch;
assign s_bresp = resp_latch;
assign s_rid   = id_latch;
assign s_rdata = rdata_latch;
assign s_rresp = resp_latch;
assign s_rlast = ~|cnt;
assign paddr   = addr_latch;
assign pstrb   = s_wstrb;
assign pwdata  = s_wdata;



always_comb begin
    s_awready = 1'b0;
    s_wready  = 1'b0;
    s_bvalid  = 1'b0;
    s_arready = 1'b0;
    s_rvalid  = 1'b0;
    psel      = 1'b0;
    pwrite    = 1'b0;
    id_upd    = 1'b0;
    cnt_upd   = 1'b0;
    addr_upd  = 1'b0;
    size_upd  = 1'b0;
    cnt_nxt   = 1'b0;
    addr_nxt  = 1'b0;
    case (cur_state)
        STATE_IDLE: begin
            s_awready = ~s_arvalid;
            s_arready = 1'b1;
            id_upd    = s_arvalid | s_awvalid;
            cnt_upd   = s_arvalid | s_awvalid;
            addr_upd  = s_arvalid | s_awvalid;
            size_upd  = s_arvalid | s_awvalid;
        end
        STATE_WR  : begin
            psel     = s_wvalid;
            pwrite   = 1'b1;
            s_wready = pready & penable;
            cnt_nxt  = pready & penable & s_wvalid;
            addr_nxt = pready & penable & s_wvalid;
        end
        SIATE_BRESP: begin
            s_bvalid = 1'b1;
        end
        STATE_RD  : begin
            psel     = 1'b1;
        end
        STATE_RRESP: begin
            s_rvalid = 1'b1;
            cnt_nxt  = s_rready;
            addr_nxt = s_rready;
        end
    endcase
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        resp_latch <= 2'b0;
    end
    else begin
        if (pready & penable & pslverr) begin
            resp_latch <= `AXI_RESP_SLVERR;
        end
        else if ((s_bready & s_bvalid) | (s_rready & s_rvalid)) begin
            resp_latch <= `AXI_RESP_OKAY;
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        penable <= 1'b0;
    end
    else begin
        if (pready & penable) begin
            penable <= 1'b0;
        end
        else if (psel) begin
            penable <= 1'b1;
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        rdata_latch <= 32'b0;
    end
    else begin
        if (cur_state == STATE_RD) begin
            if (pready & penable) begin
                rdata_latch <= prdata;
            end
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        id_latch <= 13'b0;
    end
    else begin
        if (id_upd) begin
            id_latch <= s_arvalid ? s_arid : s_awid;
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        cnt <= 8'b0;
    end
    else begin
        if (cnt_upd) begin
            cnt <= s_arvalid ? s_arlen : s_awlen;
        end
        else if (cnt_nxt) begin
            cnt <= cnt - 8'b1;
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        addr_mask_latch <= 32'b0;
    end
    else begin
        if (addr_upd) begin
            if (s_arvalid) begin
                case (s_arburst)
                    `AXI_BURST_FIXED: begin
                        addr_mask_latch <= ~32'b0;
                    end
                    `AXI_BURST_INCR : begin
                        addr_mask_latch <= 32'b0;
                    end
                    `AXI_BURST_WRAP : begin
                        addr_mask_latch <= ~((({{(32-8){1'b0}}, s_arlen} + 32'b1) << s_arsize) - 32'b1);
                    end
                endcase
            end
            else begin
            end
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        addr_latch <= 32'b0;
    end
    else begin
        if (addr_upd) begin
            addr_latch <= s_arvalid ? s_araddr : s_awaddr;
        end
        else if (addr_nxt) begin
            addr_latch <= (addr_latch & addr_mask_latch) | ((addr_latch + (32'b1 << size_latch)) & ~addr_mask_latch);
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        size_latch <= 3'b0;
    end
    else begin
        if (id_upd) begin
            size_latch <= s_arvalid ? s_arsize : s_awsize;
        end
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/axi_5to4_biu.sv
/*--------------------------------------*/

/*-----------------------------------------------------*/
// axi_5to4_biu.sv is generated by ../../script/gen_axi_biu.sh
//
//                                         2021-12-03
//                                           22:13:59
/*-----------------------------------------------------*/

module axi_5to4_biu (
    input                  aclk,
    input                  aresetn,
    input         [  1: 0] s0_awburst,
    input         [  9: 0] s0_awid,
    input         [ 31: 0] s0_awaddr,
    input         [  2: 0] s0_awsize,
    input         [  7: 0] s0_awlen,
    input                  s0_awvalid,
    output logic           s0_awready,
    input         [  3: 0] s0_wstrb,
    input         [  9: 0] s0_wid,
    input         [ 31: 0] s0_wdata,
    input                  s0_wlast,
    input                  s0_wvalid,
    output logic           s0_wready,
    output logic  [  9: 0] s0_bid,
    output logic  [  1: 0] s0_bresp,
    output logic           s0_bvalid,
    input                  s0_bready,
    input         [ 31: 0] s0_araddr,
    input         [  1: 0] s0_arburst,
    input         [  2: 0] s0_arsize,
    input         [  9: 0] s0_arid,
    input         [  7: 0] s0_arlen,
    input                  s0_arvalid,
    output logic           s0_arready,
    output logic  [ 31: 0] s0_rdata,
    output logic  [  1: 0] s0_rresp,
    output logic  [  9: 0] s0_rid,
    output logic           s0_rlast,
    output logic           s0_rvalid,
    input                  s0_rready,
    input         [  1: 0] s1_awburst,
    input         [  9: 0] s1_awid,
    input         [ 31: 0] s1_awaddr,
    input         [  2: 0] s1_awsize,
    input         [  7: 0] s1_awlen,
    input                  s1_awvalid,
    output logic           s1_awready,
    input         [  3: 0] s1_wstrb,
    input         [  9: 0] s1_wid,
    input         [ 31: 0] s1_wdata,
    input                  s1_wlast,
    input                  s1_wvalid,
    output logic           s1_wready,
    output logic  [  9: 0] s1_bid,
    output logic  [  1: 0] s1_bresp,
    output logic           s1_bvalid,
    input                  s1_bready,
    input         [ 31: 0] s1_araddr,
    input         [  1: 0] s1_arburst,
    input         [  2: 0] s1_arsize,
    input         [  9: 0] s1_arid,
    input         [  7: 0] s1_arlen,
    input                  s1_arvalid,
    output logic           s1_arready,
    output logic  [ 31: 0] s1_rdata,
    output logic  [  1: 0] s1_rresp,
    output logic  [  9: 0] s1_rid,
    output logic           s1_rlast,
    output logic           s1_rvalid,
    input                  s1_rready,
    input         [  1: 0] s2_awburst,
    input         [  9: 0] s2_awid,
    input         [ 31: 0] s2_awaddr,
    input         [  2: 0] s2_awsize,
    input         [  7: 0] s2_awlen,
    input                  s2_awvalid,
    output logic           s2_awready,
    input         [  3: 0] s2_wstrb,
    input         [  9: 0] s2_wid,
    input         [ 31: 0] s2_wdata,
    input                  s2_wlast,
    input                  s2_wvalid,
    output logic           s2_wready,
    output logic  [  9: 0] s2_bid,
    output logic  [  1: 0] s2_bresp,
    output logic           s2_bvalid,
    input                  s2_bready,
    input         [ 31: 0] s2_araddr,
    input         [  1: 0] s2_arburst,
    input         [  2: 0] s2_arsize,
    input         [  9: 0] s2_arid,
    input         [  7: 0] s2_arlen,
    input                  s2_arvalid,
    output logic           s2_arready,
    output logic  [ 31: 0] s2_rdata,
    output logic  [  1: 0] s2_rresp,
    output logic  [  9: 0] s2_rid,
    output logic           s2_rlast,
    output logic           s2_rvalid,
    input                  s2_rready,
    input         [  1: 0] s3_awburst,
    input         [  9: 0] s3_awid,
    input         [ 31: 0] s3_awaddr,
    input         [  2: 0] s3_awsize,
    input         [  7: 0] s3_awlen,
    input                  s3_awvalid,
    output logic           s3_awready,
    input         [  3: 0] s3_wstrb,
    input         [  9: 0] s3_wid,
    input         [ 31: 0] s3_wdata,
    input                  s3_wlast,
    input                  s3_wvalid,
    output logic           s3_wready,
    output logic  [  9: 0] s3_bid,
    output logic  [  1: 0] s3_bresp,
    output logic           s3_bvalid,
    input                  s3_bready,
    input         [ 31: 0] s3_araddr,
    input         [  1: 0] s3_arburst,
    input         [  2: 0] s3_arsize,
    input         [  9: 0] s3_arid,
    input         [  7: 0] s3_arlen,
    input                  s3_arvalid,
    output logic           s3_arready,
    output logic  [ 31: 0] s3_rdata,
    output logic  [  1: 0] s3_rresp,
    output logic  [  9: 0] s3_rid,
    output logic           s3_rlast,
    output logic           s3_rvalid,
    input                  s3_rready,
    input         [  1: 0] s4_awburst,
    input         [  9: 0] s4_awid,
    input         [ 31: 0] s4_awaddr,
    input         [  2: 0] s4_awsize,
    input         [  7: 0] s4_awlen,
    input                  s4_awvalid,
    output logic           s4_awready,
    input         [  3: 0] s4_wstrb,
    input         [  9: 0] s4_wid,
    input         [ 31: 0] s4_wdata,
    input                  s4_wlast,
    input                  s4_wvalid,
    output logic           s4_wready,
    output logic  [  9: 0] s4_bid,
    output logic  [  1: 0] s4_bresp,
    output logic           s4_bvalid,
    input                  s4_bready,
    input         [ 31: 0] s4_araddr,
    input         [  1: 0] s4_arburst,
    input         [  2: 0] s4_arsize,
    input         [  9: 0] s4_arid,
    input         [  7: 0] s4_arlen,
    input                  s4_arvalid,
    output logic           s4_arready,
    output logic  [ 31: 0] s4_rdata,
    output logic  [  1: 0] s4_rresp,
    output logic  [  9: 0] s4_rid,
    output logic           s4_rlast,
    output logic           s4_rvalid,
    input                  s4_rready,
    output logic  [  1: 0] m0_awburst,
    output logic  [ 12: 0] m0_awid,
    output logic  [ 31: 0] m0_awaddr,
    output logic  [  2: 0] m0_awsize,
    output logic  [  7: 0] m0_awlen,
    output logic           m0_awvalid,
    input                  m0_awready,
    output logic  [  3: 0] m0_wstrb,
    output logic  [ 12: 0] m0_wid,
    output logic  [ 31: 0] m0_wdata,
    output logic           m0_wlast,
    output logic           m0_wvalid,
    input                  m0_wready,
    input         [ 12: 0] m0_bid,
    input         [  1: 0] m0_bresp,
    input                  m0_bvalid,
    output logic           m0_bready,
    output logic  [ 31: 0] m0_araddr,
    output logic  [  1: 0] m0_arburst,
    output logic  [  2: 0] m0_arsize,
    output logic  [ 12: 0] m0_arid,
    output logic  [  7: 0] m0_arlen,
    output logic           m0_arvalid,
    input                  m0_arready,
    input         [ 31: 0] m0_rdata,
    input         [  1: 0] m0_rresp,
    input         [ 12: 0] m0_rid,
    input                  m0_rlast,
    input                  m0_rvalid,
    output logic           m0_rready,
    output logic  [  1: 0] m1_awburst,
    output logic  [ 12: 0] m1_awid,
    output logic  [ 31: 0] m1_awaddr,
    output logic  [  2: 0] m1_awsize,
    output logic  [  7: 0] m1_awlen,
    output logic           m1_awvalid,
    input                  m1_awready,
    output logic  [  3: 0] m1_wstrb,
    output logic  [ 12: 0] m1_wid,
    output logic  [ 31: 0] m1_wdata,
    output logic           m1_wlast,
    output logic           m1_wvalid,
    input                  m1_wready,
    input         [ 12: 0] m1_bid,
    input         [  1: 0] m1_bresp,
    input                  m1_bvalid,
    output logic           m1_bready,
    output logic  [ 31: 0] m1_araddr,
    output logic  [  1: 0] m1_arburst,
    output logic  [  2: 0] m1_arsize,
    output logic  [ 12: 0] m1_arid,
    output logic  [  7: 0] m1_arlen,
    output logic           m1_arvalid,
    input                  m1_arready,
    input         [ 31: 0] m1_rdata,
    input         [  1: 0] m1_rresp,
    input         [ 12: 0] m1_rid,
    input                  m1_rlast,
    input                  m1_rvalid,
    output logic           m1_rready,
    output logic  [  1: 0] m2_awburst,
    output logic  [ 12: 0] m2_awid,
    output logic  [ 31: 0] m2_awaddr,
    output logic  [  2: 0] m2_awsize,
    output logic  [  7: 0] m2_awlen,
    output logic           m2_awvalid,
    input                  m2_awready,
    output logic  [  3: 0] m2_wstrb,
    output logic  [ 12: 0] m2_wid,
    output logic  [ 31: 0] m2_wdata,
    output logic           m2_wlast,
    output logic           m2_wvalid,
    input                  m2_wready,
    input         [ 12: 0] m2_bid,
    input         [  1: 0] m2_bresp,
    input                  m2_bvalid,
    output logic           m2_bready,
    output logic  [ 31: 0] m2_araddr,
    output logic  [  1: 0] m2_arburst,
    output logic  [  2: 0] m2_arsize,
    output logic  [ 12: 0] m2_arid,
    output logic  [  7: 0] m2_arlen,
    output logic           m2_arvalid,
    input                  m2_arready,
    input         [ 31: 0] m2_rdata,
    input         [  1: 0] m2_rresp,
    input         [ 12: 0] m2_rid,
    input                  m2_rlast,
    input                  m2_rvalid,
    output logic           m2_rready,
    output logic  [  1: 0] m3_awburst,
    output logic  [ 12: 0] m3_awid,
    output logic  [ 31: 0] m3_awaddr,
    output logic  [  2: 0] m3_awsize,
    output logic  [  7: 0] m3_awlen,
    output logic           m3_awvalid,
    input                  m3_awready,
    output logic  [  3: 0] m3_wstrb,
    output logic  [ 12: 0] m3_wid,
    output logic  [ 31: 0] m3_wdata,
    output logic           m3_wlast,
    output logic           m3_wvalid,
    input                  m3_wready,
    input         [ 12: 0] m3_bid,
    input         [  1: 0] m3_bresp,
    input                  m3_bvalid,
    output logic           m3_bready,
    output logic  [ 31: 0] m3_araddr,
    output logic  [  1: 0] m3_arburst,
    output logic  [  2: 0] m3_arsize,
    output logic  [ 12: 0] m3_arid,
    output logic  [  7: 0] m3_arlen,
    output logic           m3_arvalid,
    input                  m3_arready,
    input         [ 31: 0] m3_rdata,
    input         [  1: 0] m3_rresp,
    input         [ 12: 0] m3_rid,
    input                  m3_rlast,
    input                  m3_rvalid,
    output logic           m3_rready
);

logic [  1: 0] i0_awburst;
logic [ 12: 0] i0_awid;
logic [ 31: 0] i0_awaddr;
logic [  2: 0] i0_awsize;
logic [  7: 0] i0_awlen;
logic          i0_awvalid;
logic          i0_awready;
logic [  3: 0] i0_wstrb;
logic [ 12: 0] i0_wid;
logic [ 31: 0] i0_wdata;
logic          i0_wlast;
logic          i0_wvalid;
logic          i0_wready;
logic [ 12: 0] i0_bid;
logic [  1: 0] i0_bresp;
logic          i0_bvalid;
logic          i0_bready;
logic [ 31: 0] i0_araddr;
logic [  1: 0] i0_arburst;
logic [  2: 0] i0_arsize;
logic [ 12: 0] i0_arid;
logic [  7: 0] i0_arlen;
logic          i0_arvalid;
logic          i0_arready;
logic [ 31: 0] i0_rdata;
logic [  1: 0] i0_rresp;
logic [ 12: 0] i0_rid;
logic          i0_rlast;
logic          i0_rvalid;
logic          i0_rready;
logic [  1: 0] i1_awburst;
logic [ 12: 0] i1_awid;
logic [ 31: 0] i1_awaddr;
logic [  2: 0] i1_awsize;
logic [  7: 0] i1_awlen;
logic          i1_awvalid;
logic          i1_awready;
logic [  3: 0] i1_wstrb;
logic [ 12: 0] i1_wid;
logic [ 31: 0] i1_wdata;
logic          i1_wlast;
logic          i1_wvalid;
logic          i1_wready;
logic [ 12: 0] i1_bid;
logic [  1: 0] i1_bresp;
logic          i1_bvalid;
logic          i1_bready;
logic [ 31: 0] i1_araddr;
logic [  1: 0] i1_arburst;
logic [  2: 0] i1_arsize;
logic [ 12: 0] i1_arid;
logic [  7: 0] i1_arlen;
logic          i1_arvalid;
logic          i1_arready;
logic [ 31: 0] i1_rdata;
logic [  1: 0] i1_rresp;
logic [ 12: 0] i1_rid;
logic          i1_rlast;
logic          i1_rvalid;
logic          i1_rready;

axi_5to1_mux u_mux (
    .aclk          ( aclk       ),
    .aresetn       ( aresetn    ),
    .s0_awburst    ( s0_awburst ),
    .s0_awid       ( s0_awid    ),
    .s0_awaddr     ( s0_awaddr  ),
    .s0_awsize     ( s0_awsize  ),
    .s0_awlen      ( s0_awlen   ),
    .s0_awvalid    ( s0_awvalid ),
    .s0_awready    ( s0_awready ),
    .s0_wstrb      ( s0_wstrb   ),
    .s0_wid        ( s0_wid     ),
    .s0_wdata      ( s0_wdata   ),
    .s0_wlast      ( s0_wlast   ),
    .s0_wvalid     ( s0_wvalid  ),
    .s0_wready     ( s0_wready  ),
    .s0_bid        ( s0_bid     ),
    .s0_bresp      ( s0_bresp   ),
    .s0_bvalid     ( s0_bvalid  ),
    .s0_bready     ( s0_bready  ),
    .s0_araddr     ( s0_araddr  ),
    .s0_arburst    ( s0_arburst ),
    .s0_arsize     ( s0_arsize  ),
    .s0_arid       ( s0_arid    ),
    .s0_arlen      ( s0_arlen   ),
    .s0_arvalid    ( s0_arvalid ),
    .s0_arready    ( s0_arready ),
    .s0_rdata      ( s0_rdata   ),
    .s0_rresp      ( s0_rresp   ),
    .s0_rid        ( s0_rid     ),
    .s0_rlast      ( s0_rlast   ),
    .s0_rvalid     ( s0_rvalid  ),
    .s0_rready     ( s0_rready  ),
    .s1_awburst    ( s1_awburst ),
    .s1_awid       ( s1_awid    ),
    .s1_awaddr     ( s1_awaddr  ),
    .s1_awsize     ( s1_awsize  ),
    .s1_awlen      ( s1_awlen   ),
    .s1_awvalid    ( s1_awvalid ),
    .s1_awready    ( s1_awready ),
    .s1_wstrb      ( s1_wstrb   ),
    .s1_wid        ( s1_wid     ),
    .s1_wdata      ( s1_wdata   ),
    .s1_wlast      ( s1_wlast   ),
    .s1_wvalid     ( s1_wvalid  ),
    .s1_wready     ( s1_wready  ),
    .s1_bid        ( s1_bid     ),
    .s1_bresp      ( s1_bresp   ),
    .s1_bvalid     ( s1_bvalid  ),
    .s1_bready     ( s1_bready  ),
    .s1_araddr     ( s1_araddr  ),
    .s1_arburst    ( s1_arburst ),
    .s1_arsize     ( s1_arsize  ),
    .s1_arid       ( s1_arid    ),
    .s1_arlen      ( s1_arlen   ),
    .s1_arvalid    ( s1_arvalid ),
    .s1_arready    ( s1_arready ),
    .s1_rdata      ( s1_rdata   ),
    .s1_rresp      ( s1_rresp   ),
    .s1_rid        ( s1_rid     ),
    .s1_rlast      ( s1_rlast   ),
    .s1_rvalid     ( s1_rvalid  ),
    .s1_rready     ( s1_rready  ),
    .s2_awburst    ( s2_awburst ),
    .s2_awid       ( s2_awid    ),
    .s2_awaddr     ( s2_awaddr  ),
    .s2_awsize     ( s2_awsize  ),
    .s2_awlen      ( s2_awlen   ),
    .s2_awvalid    ( s2_awvalid ),
    .s2_awready    ( s2_awready ),
    .s2_wstrb      ( s2_wstrb   ),
    .s2_wid        ( s2_wid     ),
    .s2_wdata      ( s2_wdata   ),
    .s2_wlast      ( s2_wlast   ),
    .s2_wvalid     ( s2_wvalid  ),
    .s2_wready     ( s2_wready  ),
    .s2_bid        ( s2_bid     ),
    .s2_bresp      ( s2_bresp   ),
    .s2_bvalid     ( s2_bvalid  ),
    .s2_bready     ( s2_bready  ),
    .s2_araddr     ( s2_araddr  ),
    .s2_arburst    ( s2_arburst ),
    .s2_arsize     ( s2_arsize  ),
    .s2_arid       ( s2_arid    ),
    .s2_arlen      ( s2_arlen   ),
    .s2_arvalid    ( s2_arvalid ),
    .s2_arready    ( s2_arready ),
    .s2_rdata      ( s2_rdata   ),
    .s2_rresp      ( s2_rresp   ),
    .s2_rid        ( s2_rid     ),
    .s2_rlast      ( s2_rlast   ),
    .s2_rvalid     ( s2_rvalid  ),
    .s2_rready     ( s2_rready  ),
    .s3_awburst    ( s3_awburst ),
    .s3_awid       ( s3_awid    ),
    .s3_awaddr     ( s3_awaddr  ),
    .s3_awsize     ( s3_awsize  ),
    .s3_awlen      ( s3_awlen   ),
    .s3_awvalid    ( s3_awvalid ),
    .s3_awready    ( s3_awready ),
    .s3_wstrb      ( s3_wstrb   ),
    .s3_wid        ( s3_wid     ),
    .s3_wdata      ( s3_wdata   ),
    .s3_wlast      ( s3_wlast   ),
    .s3_wvalid     ( s3_wvalid  ),
    .s3_wready     ( s3_wready  ),
    .s3_bid        ( s3_bid     ),
    .s3_bresp      ( s3_bresp   ),
    .s3_bvalid     ( s3_bvalid  ),
    .s3_bready     ( s3_bready  ),
    .s3_araddr     ( s3_araddr  ),
    .s3_arburst    ( s3_arburst ),
    .s3_arsize     ( s3_arsize  ),
    .s3_arid       ( s3_arid    ),
    .s3_arlen      ( s3_arlen   ),
    .s3_arvalid    ( s3_arvalid ),
    .s3_arready    ( s3_arready ),
    .s3_rdata      ( s3_rdata   ),
    .s3_rresp      ( s3_rresp   ),
    .s3_rid        ( s3_rid     ),
    .s3_rlast      ( s3_rlast   ),
    .s3_rvalid     ( s3_rvalid  ),
    .s3_rready     ( s3_rready  ),
    .s4_awburst    ( s4_awburst ),
    .s4_awid       ( s4_awid    ),
    .s4_awaddr     ( s4_awaddr  ),
    .s4_awsize     ( s4_awsize  ),
    .s4_awlen      ( s4_awlen   ),
    .s4_awvalid    ( s4_awvalid ),
    .s4_awready    ( s4_awready ),
    .s4_wstrb      ( s4_wstrb   ),
    .s4_wid        ( s4_wid     ),
    .s4_wdata      ( s4_wdata   ),
    .s4_wlast      ( s4_wlast   ),
    .s4_wvalid     ( s4_wvalid  ),
    .s4_wready     ( s4_wready  ),
    .s4_bid        ( s4_bid     ),
    .s4_bresp      ( s4_bresp   ),
    .s4_bvalid     ( s4_bvalid  ),
    .s4_bready     ( s4_bready  ),
    .s4_araddr     ( s4_araddr  ),
    .s4_arburst    ( s4_arburst ),
    .s4_arsize     ( s4_arsize  ),
    .s4_arid       ( s4_arid    ),
    .s4_arlen      ( s4_arlen   ),
    .s4_arvalid    ( s4_arvalid ),
    .s4_arready    ( s4_arready ),
    .s4_rdata      ( s4_rdata   ),
    .s4_rresp      ( s4_rresp   ),
    .s4_rid        ( s4_rid     ),
    .s4_rlast      ( s4_rlast   ),
    .s4_rvalid     ( s4_rvalid  ),
    .s4_rready     ( s4_rready  ),
    .m_awburst     ( i0_awburst ),
    .m_awid        ( i0_awid    ),
    .m_awaddr      ( i0_awaddr  ),
    .m_awsize      ( i0_awsize  ),
    .m_awlen       ( i0_awlen   ),
    .m_awvalid     ( i0_awvalid ),
    .m_awready     ( i0_awready ),
    .m_wstrb       ( i0_wstrb   ),
    .m_wid         ( i0_wid     ),
    .m_wdata       ( i0_wdata   ),
    .m_wlast       ( i0_wlast   ),
    .m_wvalid      ( i0_wvalid  ),
    .m_wready      ( i0_wready  ),
    .m_bid         ( i0_bid     ),
    .m_bresp       ( i0_bresp   ),
    .m_bvalid      ( i0_bvalid  ),
    .m_bready      ( i0_bready  ),
    .m_araddr      ( i0_araddr  ),
    .m_arburst     ( i0_arburst ),
    .m_arsize      ( i0_arsize  ),
    .m_arid        ( i0_arid    ),
    .m_arlen       ( i0_arlen   ),
    .m_arvalid     ( i0_arvalid ),
    .m_arready     ( i0_arready ),
    .m_rdata       ( i0_rdata   ),
    .m_rresp       ( i0_rresp   ),
    .m_rid         ( i0_rid     ),
    .m_rlast       ( i0_rlast   ),
    .m_rvalid      ( i0_rvalid  ),
    .m_rready      ( i0_rready  )
);

logic [ 57: 0] s_awpayload;
logic [ 49: 0] s_wpayload;
logic [ 14: 0] s_bpayload;
logic [ 57: 0] s_arpayload;
logic [ 47: 0] s_rpayload;
logic [ 57: 0] m_awpayload;
logic [ 49: 0] m_wpayload;
logic [ 14: 0] m_bpayload;
logic [ 57: 0] m_arpayload;
logic [ 47: 0] m_rpayload;

assign s_awpayload = {i0_awburst, i0_awid, i0_awaddr, i0_awsize, i0_awlen};
assign s_wpayload  = {i0_wlast, i0_wstrb, i0_wid, i0_wdata};
assign {i0_bid, i0_bresp} = s_bpayload;
assign s_arpayload = {i0_araddr, i0_arburst, i0_arsize, i0_arid, i0_arlen};
assign {i0_rlast, i0_rdata, i0_rresp, i0_rid} = s_rpayload;

assign {i1_awburst, i1_awid, i1_awaddr, i1_awsize, i1_awlen} = m_awpayload;
assign {i1_wlast, i1_wstrb, i1_wid, i1_wdata} = m_wpayload;
assign m_bpayload = {i1_bid, i1_bresp};
assign {i1_araddr, i1_arburst, i1_arsize, i1_arid, i1_arlen} = m_arpayload;
assign m_rpayload = {i1_rlast, i1_rdata, i1_rresp, i1_rid};

axi_slice u_axi_slice (
    .aclk          ( aclk       ),
    .aresetn       ( aresetn    ),
    .s_awpayload   ( s_awpayload ),
    .s_awvalid     ( i0_awvalid ),
    .s_awready     ( i0_awready ),
    .s_wpayload    ( s_wpayload ),
    .s_wvalid      ( i0_wvalid  ),
    .s_wready      ( i0_wready  ),
    .s_bpayload    ( s_bpayload ),
    .s_bvalid      ( i0_bvalid  ),
    .s_bready      ( i0_bready  ),
    .s_arpayload   ( s_arpayload ),
    .s_arvalid     ( i0_arvalid ),
    .s_arready     ( i0_arready ),
    .s_rpayload    ( s_rpayload ),
    .s_rvalid      ( i0_rvalid  ),
    .s_rready      ( i0_rready  ),
    .m_awpayload   ( m_awpayload ),
    .m_awvalid     ( i1_awvalid ),
    .m_awready     ( i1_awready ),
    .m_wpayload    ( m_wpayload ),
    .m_wvalid      ( i1_wvalid  ),
    .m_wready      ( i1_wready  ),
    .m_bpayload    ( m_bpayload ),
    .m_bvalid      ( i1_bvalid  ),
    .m_bready      ( i1_bready  ),
    .m_arpayload   ( m_arpayload ),
    .m_arvalid     ( i1_arvalid ),
    .m_arready     ( i1_arready ),
    .m_rpayload    ( m_rpayload ),
    .m_rvalid      ( i1_rvalid  ),
    .m_rready      ( i1_rready  )
);

axi_1to4_dec u_dec (
    .aclk          ( aclk       ),
    .aresetn       ( aresetn    ),
    .s_awburst     ( i1_awburst ),
    .s_awid        ( i1_awid    ),
    .s_awaddr      ( i1_awaddr  ),
    .s_awsize      ( i1_awsize  ),
    .s_awlen       ( i1_awlen   ),
    .s_awvalid     ( i1_awvalid ),
    .s_awready     ( i1_awready ),
    .s_wstrb       ( i1_wstrb   ),
    .s_wid         ( i1_wid     ),
    .s_wdata       ( i1_wdata   ),
    .s_wlast       ( i1_wlast   ),
    .s_wvalid      ( i1_wvalid  ),
    .s_wready      ( i1_wready  ),
    .s_bid         ( i1_bid     ),
    .s_bresp       ( i1_bresp   ),
    .s_bvalid      ( i1_bvalid  ),
    .s_bready      ( i1_bready  ),
    .s_araddr      ( i1_araddr  ),
    .s_arburst     ( i1_arburst ),
    .s_arsize      ( i1_arsize  ),
    .s_arid        ( i1_arid    ),
    .s_arlen       ( i1_arlen   ),
    .s_arvalid     ( i1_arvalid ),
    .s_arready     ( i1_arready ),
    .s_rdata       ( i1_rdata   ),
    .s_rresp       ( i1_rresp   ),
    .s_rid         ( i1_rid     ),
    .s_rlast       ( i1_rlast   ),
    .s_rvalid      ( i1_rvalid  ),
    .s_rready      ( i1_rready  ),
    .m0_awburst    ( m0_awburst ),
    .m0_awid       ( m0_awid    ),
    .m0_awaddr     ( m0_awaddr  ),
    .m0_awsize     ( m0_awsize  ),
    .m0_awlen      ( m0_awlen   ),
    .m0_awvalid    ( m0_awvalid ),
    .m0_awready    ( m0_awready ),
    .m0_wstrb      ( m0_wstrb   ),
    .m0_wid        ( m0_wid     ),
    .m0_wdata      ( m0_wdata   ),
    .m0_wlast      ( m0_wlast   ),
    .m0_wvalid     ( m0_wvalid  ),
    .m0_wready     ( m0_wready  ),
    .m0_bid        ( m0_bid     ),
    .m0_bresp      ( m0_bresp   ),
    .m0_bvalid     ( m0_bvalid  ),
    .m0_bready     ( m0_bready  ),
    .m0_araddr     ( m0_araddr  ),
    .m0_arburst    ( m0_arburst ),
    .m0_arsize     ( m0_arsize  ),
    .m0_arid       ( m0_arid    ),
    .m0_arlen      ( m0_arlen   ),
    .m0_arvalid    ( m0_arvalid ),
    .m0_arready    ( m0_arready ),
    .m0_rdata      ( m0_rdata   ),
    .m0_rresp      ( m0_rresp   ),
    .m0_rid        ( m0_rid     ),
    .m0_rlast      ( m0_rlast   ),
    .m0_rvalid     ( m0_rvalid  ),
    .m0_rready     ( m0_rready  ),
    .m1_awburst    ( m1_awburst ),
    .m1_awid       ( m1_awid    ),
    .m1_awaddr     ( m1_awaddr  ),
    .m1_awsize     ( m1_awsize  ),
    .m1_awlen      ( m1_awlen   ),
    .m1_awvalid    ( m1_awvalid ),
    .m1_awready    ( m1_awready ),
    .m1_wstrb      ( m1_wstrb   ),
    .m1_wid        ( m1_wid     ),
    .m1_wdata      ( m1_wdata   ),
    .m1_wlast      ( m1_wlast   ),
    .m1_wvalid     ( m1_wvalid  ),
    .m1_wready     ( m1_wready  ),
    .m1_bid        ( m1_bid     ),
    .m1_bresp      ( m1_bresp   ),
    .m1_bvalid     ( m1_bvalid  ),
    .m1_bready     ( m1_bready  ),
    .m1_araddr     ( m1_araddr  ),
    .m1_arburst    ( m1_arburst ),
    .m1_arsize     ( m1_arsize  ),
    .m1_arid       ( m1_arid    ),
    .m1_arlen      ( m1_arlen   ),
    .m1_arvalid    ( m1_arvalid ),
    .m1_arready    ( m1_arready ),
    .m1_rdata      ( m1_rdata   ),
    .m1_rresp      ( m1_rresp   ),
    .m1_rid        ( m1_rid     ),
    .m1_rlast      ( m1_rlast   ),
    .m1_rvalid     ( m1_rvalid  ),
    .m1_rready     ( m1_rready  ),
    .m2_awburst    ( m2_awburst ),
    .m2_awid       ( m2_awid    ),
    .m2_awaddr     ( m2_awaddr  ),
    .m2_awsize     ( m2_awsize  ),
    .m2_awlen      ( m2_awlen   ),
    .m2_awvalid    ( m2_awvalid ),
    .m2_awready    ( m2_awready ),
    .m2_wstrb      ( m2_wstrb   ),
    .m2_wid        ( m2_wid     ),
    .m2_wdata      ( m2_wdata   ),
    .m2_wlast      ( m2_wlast   ),
    .m2_wvalid     ( m2_wvalid  ),
    .m2_wready     ( m2_wready  ),
    .m2_bid        ( m2_bid     ),
    .m2_bresp      ( m2_bresp   ),
    .m2_bvalid     ( m2_bvalid  ),
    .m2_bready     ( m2_bready  ),
    .m2_araddr     ( m2_araddr  ),
    .m2_arburst    ( m2_arburst ),
    .m2_arsize     ( m2_arsize  ),
    .m2_arid       ( m2_arid    ),
    .m2_arlen      ( m2_arlen   ),
    .m2_arvalid    ( m2_arvalid ),
    .m2_arready    ( m2_arready ),
    .m2_rdata      ( m2_rdata   ),
    .m2_rresp      ( m2_rresp   ),
    .m2_rid        ( m2_rid     ),
    .m2_rlast      ( m2_rlast   ),
    .m2_rvalid     ( m2_rvalid  ),
    .m2_rready     ( m2_rready  ),
    .m3_awburst    ( m3_awburst ),
    .m3_awid       ( m3_awid    ),
    .m3_awaddr     ( m3_awaddr  ),
    .m3_awsize     ( m3_awsize  ),
    .m3_awlen      ( m3_awlen   ),
    .m3_awvalid    ( m3_awvalid ),
    .m3_awready    ( m3_awready ),
    .m3_wstrb      ( m3_wstrb   ),
    .m3_wid        ( m3_wid     ),
    .m3_wdata      ( m3_wdata   ),
    .m3_wlast      ( m3_wlast   ),
    .m3_wvalid     ( m3_wvalid  ),
    .m3_wready     ( m3_wready  ),
    .m3_bid        ( m3_bid     ),
    .m3_bresp      ( m3_bresp   ),
    .m3_bvalid     ( m3_bvalid  ),
    .m3_bready     ( m3_bready  ),
    .m3_araddr     ( m3_araddr  ),
    .m3_arburst    ( m3_arburst ),
    .m3_arsize     ( m3_arsize  ),
    .m3_arid       ( m3_arid    ),
    .m3_arlen      ( m3_arlen   ),
    .m3_arvalid    ( m3_arvalid ),
    .m3_arready    ( m3_arready ),
    .m3_rdata      ( m3_rdata   ),
    .m3_rresp      ( m3_rresp   ),
    .m3_rid        ( m3_rid     ),
    .m3_rlast      ( m3_rlast   ),
    .m3_rvalid     ( m3_rvalid  ),
    .m3_rready     ( m3_rready  )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/axi_5to1_mux.sv
/*--------------------------------------*/

/*-----------------------------------------------------*/
// axi_5to1_mux.sv is generated by gen_axi_mux.sh
//
//                                         2021-12-03
//                                           22:13:56
/*-----------------------------------------------------*/

module axi_5to1_mux (
    input                  aclk,
    input                  aresetn,
    input         [  1: 0] s0_awburst,
    input         [  9: 0] s0_awid,
    input         [ 31: 0] s0_awaddr,
    input         [  2: 0] s0_awsize,
    input         [  7: 0] s0_awlen,
    input                  s0_awvalid,
    output logic           s0_awready,
    input         [  3: 0] s0_wstrb,
    input         [  9: 0] s0_wid,
    input         [ 31: 0] s0_wdata,
    input                  s0_wlast,
    input                  s0_wvalid,
    output logic           s0_wready,
    output logic  [  9: 0] s0_bid,
    output logic  [  1: 0] s0_bresp,
    output logic           s0_bvalid,
    input                  s0_bready,
    input         [ 31: 0] s0_araddr,
    input         [  1: 0] s0_arburst,
    input         [  2: 0] s0_arsize,
    input         [  9: 0] s0_arid,
    input         [  7: 0] s0_arlen,
    input                  s0_arvalid,
    output logic           s0_arready,
    output logic  [ 31: 0] s0_rdata,
    output logic  [  1: 0] s0_rresp,
    output logic  [  9: 0] s0_rid,
    output logic           s0_rlast,
    output logic           s0_rvalid,
    input                  s0_rready,
    input         [  1: 0] s1_awburst,
    input         [  9: 0] s1_awid,
    input         [ 31: 0] s1_awaddr,
    input         [  2: 0] s1_awsize,
    input         [  7: 0] s1_awlen,
    input                  s1_awvalid,
    output logic           s1_awready,
    input         [  3: 0] s1_wstrb,
    input         [  9: 0] s1_wid,
    input         [ 31: 0] s1_wdata,
    input                  s1_wlast,
    input                  s1_wvalid,
    output logic           s1_wready,
    output logic  [  9: 0] s1_bid,
    output logic  [  1: 0] s1_bresp,
    output logic           s1_bvalid,
    input                  s1_bready,
    input         [ 31: 0] s1_araddr,
    input         [  1: 0] s1_arburst,
    input         [  2: 0] s1_arsize,
    input         [  9: 0] s1_arid,
    input         [  7: 0] s1_arlen,
    input                  s1_arvalid,
    output logic           s1_arready,
    output logic  [ 31: 0] s1_rdata,
    output logic  [  1: 0] s1_rresp,
    output logic  [  9: 0] s1_rid,
    output logic           s1_rlast,
    output logic           s1_rvalid,
    input                  s1_rready,
    input         [  1: 0] s2_awburst,
    input         [  9: 0] s2_awid,
    input         [ 31: 0] s2_awaddr,
    input         [  2: 0] s2_awsize,
    input         [  7: 0] s2_awlen,
    input                  s2_awvalid,
    output logic           s2_awready,
    input         [  3: 0] s2_wstrb,
    input         [  9: 0] s2_wid,
    input         [ 31: 0] s2_wdata,
    input                  s2_wlast,
    input                  s2_wvalid,
    output logic           s2_wready,
    output logic  [  9: 0] s2_bid,
    output logic  [  1: 0] s2_bresp,
    output logic           s2_bvalid,
    input                  s2_bready,
    input         [ 31: 0] s2_araddr,
    input         [  1: 0] s2_arburst,
    input         [  2: 0] s2_arsize,
    input         [  9: 0] s2_arid,
    input         [  7: 0] s2_arlen,
    input                  s2_arvalid,
    output logic           s2_arready,
    output logic  [ 31: 0] s2_rdata,
    output logic  [  1: 0] s2_rresp,
    output logic  [  9: 0] s2_rid,
    output logic           s2_rlast,
    output logic           s2_rvalid,
    input                  s2_rready,
    input         [  1: 0] s3_awburst,
    input         [  9: 0] s3_awid,
    input         [ 31: 0] s3_awaddr,
    input         [  2: 0] s3_awsize,
    input         [  7: 0] s3_awlen,
    input                  s3_awvalid,
    output logic           s3_awready,
    input         [  3: 0] s3_wstrb,
    input         [  9: 0] s3_wid,
    input         [ 31: 0] s3_wdata,
    input                  s3_wlast,
    input                  s3_wvalid,
    output logic           s3_wready,
    output logic  [  9: 0] s3_bid,
    output logic  [  1: 0] s3_bresp,
    output logic           s3_bvalid,
    input                  s3_bready,
    input         [ 31: 0] s3_araddr,
    input         [  1: 0] s3_arburst,
    input         [  2: 0] s3_arsize,
    input         [  9: 0] s3_arid,
    input         [  7: 0] s3_arlen,
    input                  s3_arvalid,
    output logic           s3_arready,
    output logic  [ 31: 0] s3_rdata,
    output logic  [  1: 0] s3_rresp,
    output logic  [  9: 0] s3_rid,
    output logic           s3_rlast,
    output logic           s3_rvalid,
    input                  s3_rready,
    input         [  1: 0] s4_awburst,
    input         [  9: 0] s4_awid,
    input         [ 31: 0] s4_awaddr,
    input         [  2: 0] s4_awsize,
    input         [  7: 0] s4_awlen,
    input                  s4_awvalid,
    output logic           s4_awready,
    input         [  3: 0] s4_wstrb,
    input         [  9: 0] s4_wid,
    input         [ 31: 0] s4_wdata,
    input                  s4_wlast,
    input                  s4_wvalid,
    output logic           s4_wready,
    output logic  [  9: 0] s4_bid,
    output logic  [  1: 0] s4_bresp,
    output logic           s4_bvalid,
    input                  s4_bready,
    input         [ 31: 0] s4_araddr,
    input         [  1: 0] s4_arburst,
    input         [  2: 0] s4_arsize,
    input         [  9: 0] s4_arid,
    input         [  7: 0] s4_arlen,
    input                  s4_arvalid,
    output logic           s4_arready,
    output logic  [ 31: 0] s4_rdata,
    output logic  [  1: 0] s4_rresp,
    output logic  [  9: 0] s4_rid,
    output logic           s4_rlast,
    output logic           s4_rvalid,
    input                  s4_rready,
    output logic  [  1: 0] m_awburst,
    output logic  [ 12: 0] m_awid,
    output logic  [ 31: 0] m_awaddr,
    output logic  [  2: 0] m_awsize,
    output logic  [  7: 0] m_awlen,
    output logic           m_awvalid,
    input                  m_awready,
    output logic  [  3: 0] m_wstrb,
    output logic  [ 12: 0] m_wid,
    output logic  [ 31: 0] m_wdata,
    output logic           m_wlast,
    output logic           m_wvalid,
    input                  m_wready,
    input         [ 12: 0] m_bid,
    input         [  1: 0] m_bresp,
    input                  m_bvalid,
    output logic           m_bready,
    output logic  [ 31: 0] m_araddr,
    output logic  [  1: 0] m_arburst,
    output logic  [  2: 0] m_arsize,
    output logic  [ 12: 0] m_arid,
    output logic  [  7: 0] m_arlen,
    output logic           m_arvalid,
    input                  m_arready,
    input         [ 31: 0] m_rdata,
    input         [  1: 0] m_rresp,
    input         [ 12: 0] m_rid,
    input                  m_rlast,
    input                  m_rvalid,
    output logic           m_rready
);

logic [  1: 0] s_awburst  [0:   4];
logic [  9: 0] s_awid     [0:   4];
logic [ 31: 0] s_awaddr   [0:   4];
logic [  2: 0] s_awsize   [0:   4];
logic [  7: 0] s_awlen    [0:   4];
logic [  3: 0] s_wstrb    [0:   4];
logic [  9: 0] s_wid      [0:   4];
logic [ 31: 0] s_wdata    [0:   4];
logic [  9: 0] s_bid      [0:   4];
logic [  1: 0] s_bresp    [0:   4];
logic [ 31: 0] s_araddr   [0:   4];
logic [  1: 0] s_arburst  [0:   4];
logic [  2: 0] s_arsize   [0:   4];
logic [  9: 0] s_arid     [0:   4];
logic [  7: 0] s_arlen    [0:   4];
logic [ 31: 0] s_rdata    [0:   4];
logic [  1: 0] s_rresp    [0:   4];
logic [  9: 0] s_rid      [0:   4];

logic [  4: 0] s_arsel;
logic [  4: 0] s_awsel;
logic [  4: 0] s_wsel;

logic [  4: 0] s_arvalid;
logic [  4: 0] s_arready;
logic [  4: 0] s_rlast;
logic [  4: 0] s_rvalid;
logic [  4: 0] s_rready;
logic [  4: 0] s_awvalid;
logic [  4: 0] s_awready;
logic [  4: 0] s_wlast;
logic [  4: 0] s_wvalid;
logic [  4: 0] s_wready;
logic [  4: 0] s_bvalid;
logic [  4: 0] s_bready;

assign s_awburst [0] = s0_awburst;
assign s_awid    [0] = s0_awid;
assign s_awaddr  [0] = s0_awaddr;
assign s_awsize  [0] = s0_awsize;
assign s_awlen   [0] = s0_awlen;
assign s_wstrb   [0] = s0_wstrb;
assign s_wid     [0] = s0_wid;
assign s_wdata   [0] = s0_wdata;
assign s_araddr  [0] = s0_araddr;
assign s_arburst [0] = s0_arburst;
assign s_arsize  [0] = s0_arsize;
assign s_arid    [0] = s0_arid;
assign s_arlen   [0] = s0_arlen;
assign s_awburst [1] = s1_awburst;
assign s_awid    [1] = s1_awid;
assign s_awaddr  [1] = s1_awaddr;
assign s_awsize  [1] = s1_awsize;
assign s_awlen   [1] = s1_awlen;
assign s_wstrb   [1] = s1_wstrb;
assign s_wid     [1] = s1_wid;
assign s_wdata   [1] = s1_wdata;
assign s_araddr  [1] = s1_araddr;
assign s_arburst [1] = s1_arburst;
assign s_arsize  [1] = s1_arsize;
assign s_arid    [1] = s1_arid;
assign s_arlen   [1] = s1_arlen;
assign s_awburst [2] = s2_awburst;
assign s_awid    [2] = s2_awid;
assign s_awaddr  [2] = s2_awaddr;
assign s_awsize  [2] = s2_awsize;
assign s_awlen   [2] = s2_awlen;
assign s_wstrb   [2] = s2_wstrb;
assign s_wid     [2] = s2_wid;
assign s_wdata   [2] = s2_wdata;
assign s_araddr  [2] = s2_araddr;
assign s_arburst [2] = s2_arburst;
assign s_arsize  [2] = s2_arsize;
assign s_arid    [2] = s2_arid;
assign s_arlen   [2] = s2_arlen;
assign s_awburst [3] = s3_awburst;
assign s_awid    [3] = s3_awid;
assign s_awaddr  [3] = s3_awaddr;
assign s_awsize  [3] = s3_awsize;
assign s_awlen   [3] = s3_awlen;
assign s_wstrb   [3] = s3_wstrb;
assign s_wid     [3] = s3_wid;
assign s_wdata   [3] = s3_wdata;
assign s_araddr  [3] = s3_araddr;
assign s_arburst [3] = s3_arburst;
assign s_arsize  [3] = s3_arsize;
assign s_arid    [3] = s3_arid;
assign s_arlen   [3] = s3_arlen;
assign s_awburst [4] = s4_awburst;
assign s_awid    [4] = s4_awid;
assign s_awaddr  [4] = s4_awaddr;
assign s_awsize  [4] = s4_awsize;
assign s_awlen   [4] = s4_awlen;
assign s_wstrb   [4] = s4_wstrb;
assign s_wid     [4] = s4_wid;
assign s_wdata   [4] = s4_wdata;
assign s_araddr  [4] = s4_araddr;
assign s_arburst [4] = s4_arburst;
assign s_arsize  [4] = s4_arsize;
assign s_arid    [4] = s4_arid;
assign s_arlen   [4] = s4_arlen;

assign s0_bid     = s_bid     [0];
assign s0_bresp   = s_bresp   [0];
assign s0_rdata   = s_rdata   [0];
assign s0_rresp   = s_rresp   [0];
assign s0_rid     = s_rid     [0];
assign s1_bid     = s_bid     [1];
assign s1_bresp   = s_bresp   [1];
assign s1_rdata   = s_rdata   [1];
assign s1_rresp   = s_rresp   [1];
assign s1_rid     = s_rid     [1];
assign s2_bid     = s_bid     [2];
assign s2_bresp   = s_bresp   [2];
assign s2_rdata   = s_rdata   [2];
assign s2_rresp   = s_rresp   [2];
assign s2_rid     = s_rid     [2];
assign s3_bid     = s_bid     [3];
assign s3_bresp   = s_bresp   [3];
assign s3_rdata   = s_rdata   [3];
assign s3_rresp   = s_rresp   [3];
assign s3_rid     = s_rid     [3];
assign s4_bid     = s_bid     [4];
assign s4_bresp   = s_bresp   [4];
assign s4_rdata   = s_rdata   [4];
assign s4_rresp   = s_rresp   [4];
assign s4_rid     = s_rid     [4];

assign s_arvalid [0] = s0_arvalid;
assign s_awvalid [0] = s0_awvalid;
assign s_wvalid  [0] = s0_wvalid;
assign s_wlast   [0] = s0_wlast;
assign s_bready  [0] = s0_bready;
assign s_rready  [0] = s0_rready;
assign s_arvalid [1] = s1_arvalid;
assign s_awvalid [1] = s1_awvalid;
assign s_wvalid  [1] = s1_wvalid;
assign s_wlast   [1] = s1_wlast;
assign s_bready  [1] = s1_bready;
assign s_rready  [1] = s1_rready;
assign s_arvalid [2] = s2_arvalid;
assign s_awvalid [2] = s2_awvalid;
assign s_wvalid  [2] = s2_wvalid;
assign s_wlast   [2] = s2_wlast;
assign s_bready  [2] = s2_bready;
assign s_rready  [2] = s2_rready;
assign s_arvalid [3] = s3_arvalid;
assign s_awvalid [3] = s3_awvalid;
assign s_wvalid  [3] = s3_wvalid;
assign s_wlast   [3] = s3_wlast;
assign s_bready  [3] = s3_bready;
assign s_rready  [3] = s3_rready;
assign s_arvalid [4] = s4_arvalid;
assign s_awvalid [4] = s4_awvalid;
assign s_wvalid  [4] = s4_wvalid;
assign s_wlast   [4] = s4_wlast;
assign s_bready  [4] = s4_bready;
assign s_rready  [4] = s4_rready;

assign s0_arready = s_arready [0];
assign s0_awready = s_awready [0];
assign s0_wready  = s_wready  [0];
assign s0_bvalid  = s_bvalid  [0];
assign s0_rlast   = s_rlast   [0];
assign s0_rvalid  = s_rvalid  [0];
assign s1_arready = s_arready [1];
assign s1_awready = s_awready [1];
assign s1_wready  = s_wready  [1];
assign s1_bvalid  = s_bvalid  [1];
assign s1_rlast   = s_rlast   [1];
assign s1_rvalid  = s_rvalid  [1];
assign s2_arready = s_arready [2];
assign s2_awready = s_awready [2];
assign s2_wready  = s_wready  [2];
assign s2_bvalid  = s_bvalid  [2];
assign s2_rlast   = s_rlast   [2];
assign s2_rvalid  = s_rvalid  [2];
assign s3_arready = s_arready [3];
assign s3_awready = s_awready [3];
assign s3_wready  = s_wready  [3];
assign s3_bvalid  = s_bvalid  [3];
assign s3_rlast   = s_rlast   [3];
assign s3_rvalid  = s_rvalid  [3];
assign s4_arready = s_arready [4];
assign s4_awready = s_awready [4];
assign s4_wready  = s_wready  [4];
assign s4_bvalid  = s_bvalid  [4];
assign s4_rlast   = s_rlast   [4];
assign s4_rvalid  = s_rvalid  [4];

axi_arbitrator_5s u_axi_arbitrator (
    .aclk          ( aclk       ),
    .aresetn       ( aresetn    ),
    .s_arsel       ( s_arsel    ),
    .s_awsel       ( s_awsel    ),
    .s_wsel        ( s_wsel     ),
    .s_arvalid     ( s_arvalid  ),
    .s_arready     ( s_arready  ),
    .s_awvalid     ( s_awvalid  ),
    .s_awready     ( s_awready  ),
    .s_wlast       ( s_wlast    ),
    .s_wvalid      ( s_wvalid   ),
    .s_wready      ( s_wready   ),
    .m_arvalid     ( m_arvalid  ),
    .m_arready     ( m_arready  ),
    .m_awvalid     ( m_awvalid  ),
    .m_awready     ( m_awready  ),
    .m_wlast       ( m_wlast    ),
    .m_wvalid      ( m_wvalid   ),
    .m_wready      ( m_wready   )
);

always_comb begin
    integer i;

    m_awburst  = {          2{1'b0}};
    m_awid     = {( 10 +   3){1'b0}};
    m_awaddr   = {         32{1'b0}};
    m_awsize   = {          3{1'b0}};
    m_awlen    = {          8{1'b0}};
    for (i = 0; i < 5; i = i + 1) begin
        m_awburst            = m_awburst        | ({  2{s_awsel[i]}} & s_awburst [i]);
        m_awid    [  0+:  3] = m_awid[  0+:  3] | ({  3{s_awsel[i]}} & i[0+:3]      );
        m_awid    [  3+: 10] = m_awid[  3+: 10] | ({ 10{s_awsel[i]}} & s_awid    [i]);
        m_awaddr             = m_awaddr         | ({ 32{s_awsel[i]}} & s_awaddr  [i]);
        m_awsize             = m_awsize         | ({  3{s_awsel[i]}} & s_awsize  [i]);
        m_awlen              = m_awlen          | ({  8{s_awsel[i]}} & s_awlen   [i]);
    end

    m_wstrb    = {          4{1'b0}};
    m_wid      = {( 10 +   3){1'b0}};
    m_wdata    = {         32{1'b0}};
    for (i = 0; i < 5; i = i + 1) begin
        m_wstrb              = m_wstrb          | ({  4{s_wsel[i]}} & s_wstrb   [i]);
        m_wid     [  0+:  3] = m_wid [  0+:  3] | ({  3{s_wsel[i]}} & i[0+:3]      );
        m_wid     [  3+: 10] = m_wid [  3+: 10] | ({ 10{s_wsel[i]}} & s_wid     [i]);
        m_wdata              = m_wdata          | ({ 32{s_wsel[i]}} & s_wdata   [i]);
    end

    m_araddr   = {         32{1'b0}};
    m_arburst  = {          2{1'b0}};
    m_arsize   = {          3{1'b0}};
    m_arid     = {( 10 +   3){1'b0}};
    m_arlen    = {          8{1'b0}};
    for (i = 0; i < 5; i = i + 1) begin
        m_araddr             = m_araddr         | ({ 32{s_arsel[i]}} & s_araddr  [i]);
        m_arburst            = m_arburst        | ({  2{s_arsel[i]}} & s_arburst [i]);
        m_arsize             = m_arsize         | ({  3{s_arsel[i]}} & s_arsize  [i]);
        m_arid    [  0+:  3] = m_arid[  0+:  3] | ({  3{s_arsel[i]}} & i[0+:3]      );
        m_arid    [  3+: 10] = m_arid[  3+: 10] | ({ 10{s_arsel[i]}} & s_arid    [i]);
        m_arlen              = m_arlen          | ({  8{s_arsel[i]}} & s_arlen   [i]);
    end
end

logic [  2: 0] bsel;
logic [  2: 0] rsel;

always_comb begin
    integer i;

    for (i = 0; i < 5; i = i + 1) begin
        s_bid     [i] = { 10{bsel == i[0+:  3]}} & m_bid[  3+: 10];
        s_bresp   [i] = {  2{bsel == i[0+:  3]}} & m_bresp;
        s_bvalid  [i] = {  1{bsel == i[0+:  3]}} & m_bvalid;

        s_rdata   [i] = { 32{rsel == i[0+:  3]}} & m_rdata;
        s_rresp   [i] = {  2{rsel == i[0+:  3]}} & m_rresp;
        s_rid     [i] = { 10{rsel == i[0+:  3]}} & m_rid[  3+: 10];
        s_rlast   [i] = {  1{rsel == i[0+:  3]}} & m_rlast;
        s_rvalid  [i] = {  1{rsel == i[0+:  3]}} & m_rvalid;
    end
end

assign bsel = m_bid[  0+:  3];
assign rsel = m_rid[  0+:  3];

assign m_bready = s_bready[bsel];
assign m_rready = s_rready[rsel];

endmodule

module axi_arbitrator_5s (
    input                  aclk,
    input                  aresetn,
    output logic  [  4: 0] s_arsel,
    output logic  [  4: 0] s_awsel,
    output logic  [  4: 0] s_wsel,
    input         [  4: 0] s_arvalid,
    output logic  [  4: 0] s_arready,
    input         [  4: 0] s_awvalid,
    output logic  [  4: 0] s_awready,
    input         [  4: 0] s_wlast,
    input         [  4: 0] s_wvalid,
    output logic  [  4: 0] s_wready,
    output logic           m_arvalid,
    input                  m_arready,
    output logic           m_awvalid,
    input                  m_awready,
    output logic           m_wlast,
    output logic           m_wvalid,
    input                  m_wready
);

parameter SLV_NUM = 5;

// AR arbitrator
logic [SLV_NUM - 1:0] ar_prior;
logic [SLV_NUM - 1:0] ar_prior_nxt;

assign ar_prior_nxt = {ar_prior[SLV_NUM - 2:0], ar_prior[SLV_NUM - 1]};

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        ar_prior <= {{(SLV_NUM-1){1'b0}}, 1'b1};
    end
    else begin
        if (m_arvalid & m_arready) begin
            ar_prior <= ar_prior_nxt;
        end
    end
end

logic [SLV_NUM - 1:0] ar_grant_matrix [0:SLV_NUM - 1];

always_comb begin
    integer i, j, k;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        ar_grant_matrix[i] = ar_prior;
        for (j = 0; j < SLV_NUM - 1; j = j + 1) begin
            for (k = 1; k < SLV_NUM - j; k = k + 1) begin
                ar_grant_matrix[i][(i + j + 1) % SLV_NUM] = ar_grant_matrix[i][(i + j + 1) % SLV_NUM] &
                                                            ~s_arvalid[(i - k + SLV_NUM) % SLV_NUM];
            end
        end
    end
end

always_comb begin
    integer i;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        s_arready[i]  = s_arvalid[i] & (|ar_grant_matrix[i]) & m_arready;
        s_arsel  [i]  = s_arvalid[i] & (|ar_grant_matrix[i]);
    end
end

assign m_arvalid = |s_arvalid;

// AW arbitrator
logic [SLV_NUM - 1:0] aw_prior;
logic [SLV_NUM - 1:0] aw_prior_nxt;

assign aw_prior_nxt = {aw_prior[SLV_NUM - 2:0], aw_prior[SLV_NUM - 1]};

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        aw_prior <= {{(SLV_NUM-1){1'b0}}, 1'b1};
    end
    else begin
        if (m_wlast & m_wvalid & m_wready) begin
            aw_prior <= aw_prior_nxt;
        end
    end
end
logic [SLV_NUM - 1:0] aw_grant_matrix [0:SLV_NUM - 1];

always_comb begin
    integer i, j, k;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        aw_grant_matrix[i] = aw_prior;
        for (j = 0; j < SLV_NUM - 1; j = j + 1) begin
            for (k = 1; k < SLV_NUM - j; k = k + 1) begin
                aw_grant_matrix[i][(i + j + 1) % SLV_NUM] =  aw_grant_matrix[i][(i + j + 1) % SLV_NUM] &
                                                            ~s_awvalid[(i - k + SLV_NUM) % SLV_NUM];
            end
        end
    end
end

always_comb begin
    integer i;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        s_awready[i]  = s_awvalid[i] & (|aw_grant_matrix[i]) & ~|s_wsel & m_awready;
        s_awsel  [i]  = s_awvalid[i] & (|aw_grant_matrix[i]);
    end
end

assign m_awvalid = |s_awvalid;

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        s_wsel <= {SLV_NUM{1'b0}};
    end
    else begin
        if (m_wready & m_wvalid & m_wlast) begin
            s_wsel <= {SLV_NUM{1'b0}};
        end
        else if (~|s_wsel & m_awvalid & m_awready) begin
            s_wsel <= s_awready;
        end
    end
end

assign s_wready = s_wsel & {SLV_NUM{m_wready}};

assign m_wvalid = |(s_wsel & s_wvalid);
assign m_wlast  = |(s_wsel & s_wlast);

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/axi_1to4_dec.sv
/*--------------------------------------*/

/*-----------------------------------------------------*/
// axi_1to4_dec.sv is generated by ./../../script/gen_axi_dec.sh
//
//                                         2021-12-03
//                                           22:13:57
/*-----------------------------------------------------*/

module axi_1to4_dec (
    input                  aclk,
    input                  aresetn,
    input         [  1: 0] s_awburst,
    input         [ 12: 0] s_awid,
    input         [ 31: 0] s_awaddr,
    input         [  2: 0] s_awsize,
    input         [  7: 0] s_awlen,
    input                  s_awvalid,
    output logic           s_awready,
    input         [  3: 0] s_wstrb,
    input         [ 12: 0] s_wid,
    input         [ 31: 0] s_wdata,
    input                  s_wlast,
    input                  s_wvalid,
    output logic           s_wready,
    output logic  [ 12: 0] s_bid,
    output logic  [  1: 0] s_bresp,
    output logic           s_bvalid,
    input                  s_bready,
    input         [ 31: 0] s_araddr,
    input         [  1: 0] s_arburst,
    input         [  2: 0] s_arsize,
    input         [ 12: 0] s_arid,
    input         [  7: 0] s_arlen,
    input                  s_arvalid,
    output logic           s_arready,
    output logic  [ 31: 0] s_rdata,
    output logic  [  1: 0] s_rresp,
    output logic  [ 12: 0] s_rid,
    output logic           s_rlast,
    output logic           s_rvalid,
    input                  s_rready,
    output logic  [  1: 0] m0_awburst,
    output logic  [ 12: 0] m0_awid,
    output logic  [ 31: 0] m0_awaddr,
    output logic  [  2: 0] m0_awsize,
    output logic  [  7: 0] m0_awlen,
    output logic           m0_awvalid,
    input                  m0_awready,
    output logic  [  3: 0] m0_wstrb,
    output logic  [ 12: 0] m0_wid,
    output logic  [ 31: 0] m0_wdata,
    output logic           m0_wlast,
    output logic           m0_wvalid,
    input                  m0_wready,
    input         [ 12: 0] m0_bid,
    input         [  1: 0] m0_bresp,
    input                  m0_bvalid,
    output logic           m0_bready,
    output logic  [ 31: 0] m0_araddr,
    output logic  [  1: 0] m0_arburst,
    output logic  [  2: 0] m0_arsize,
    output logic  [ 12: 0] m0_arid,
    output logic  [  7: 0] m0_arlen,
    output logic           m0_arvalid,
    input                  m0_arready,
    input         [ 31: 0] m0_rdata,
    input         [  1: 0] m0_rresp,
    input         [ 12: 0] m0_rid,
    input                  m0_rlast,
    input                  m0_rvalid,
    output logic           m0_rready,
    output logic  [  1: 0] m1_awburst,
    output logic  [ 12: 0] m1_awid,
    output logic  [ 31: 0] m1_awaddr,
    output logic  [  2: 0] m1_awsize,
    output logic  [  7: 0] m1_awlen,
    output logic           m1_awvalid,
    input                  m1_awready,
    output logic  [  3: 0] m1_wstrb,
    output logic  [ 12: 0] m1_wid,
    output logic  [ 31: 0] m1_wdata,
    output logic           m1_wlast,
    output logic           m1_wvalid,
    input                  m1_wready,
    input         [ 12: 0] m1_bid,
    input         [  1: 0] m1_bresp,
    input                  m1_bvalid,
    output logic           m1_bready,
    output logic  [ 31: 0] m1_araddr,
    output logic  [  1: 0] m1_arburst,
    output logic  [  2: 0] m1_arsize,
    output logic  [ 12: 0] m1_arid,
    output logic  [  7: 0] m1_arlen,
    output logic           m1_arvalid,
    input                  m1_arready,
    input         [ 31: 0] m1_rdata,
    input         [  1: 0] m1_rresp,
    input         [ 12: 0] m1_rid,
    input                  m1_rlast,
    input                  m1_rvalid,
    output logic           m1_rready,
    output logic  [  1: 0] m2_awburst,
    output logic  [ 12: 0] m2_awid,
    output logic  [ 31: 0] m2_awaddr,
    output logic  [  2: 0] m2_awsize,
    output logic  [  7: 0] m2_awlen,
    output logic           m2_awvalid,
    input                  m2_awready,
    output logic  [  3: 0] m2_wstrb,
    output logic  [ 12: 0] m2_wid,
    output logic  [ 31: 0] m2_wdata,
    output logic           m2_wlast,
    output logic           m2_wvalid,
    input                  m2_wready,
    input         [ 12: 0] m2_bid,
    input         [  1: 0] m2_bresp,
    input                  m2_bvalid,
    output logic           m2_bready,
    output logic  [ 31: 0] m2_araddr,
    output logic  [  1: 0] m2_arburst,
    output logic  [  2: 0] m2_arsize,
    output logic  [ 12: 0] m2_arid,
    output logic  [  7: 0] m2_arlen,
    output logic           m2_arvalid,
    input                  m2_arready,
    input         [ 31: 0] m2_rdata,
    input         [  1: 0] m2_rresp,
    input         [ 12: 0] m2_rid,
    input                  m2_rlast,
    input                  m2_rvalid,
    output logic           m2_rready,
    output logic  [  1: 0] m3_awburst,
    output logic  [ 12: 0] m3_awid,
    output logic  [ 31: 0] m3_awaddr,
    output logic  [  2: 0] m3_awsize,
    output logic  [  7: 0] m3_awlen,
    output logic           m3_awvalid,
    input                  m3_awready,
    output logic  [  3: 0] m3_wstrb,
    output logic  [ 12: 0] m3_wid,
    output logic  [ 31: 0] m3_wdata,
    output logic           m3_wlast,
    output logic           m3_wvalid,
    input                  m3_wready,
    input         [ 12: 0] m3_bid,
    input         [  1: 0] m3_bresp,
    input                  m3_bvalid,
    output logic           m3_bready,
    output logic  [ 31: 0] m3_araddr,
    output logic  [  1: 0] m3_arburst,
    output logic  [  2: 0] m3_arsize,
    output logic  [ 12: 0] m3_arid,
    output logic  [  7: 0] m3_arlen,
    output logic           m3_arvalid,
    input                  m3_arready,
    input         [ 31: 0] m3_rdata,
    input         [  1: 0] m3_rresp,
    input         [ 12: 0] m3_rid,
    input                  m3_rlast,
    input                  m3_rvalid,
    output logic           m3_rready
);

logic [  1: 0] m_awburst  [0:   4];
logic [ 12: 0] m_awid     [0:   4];
logic [ 31: 0] m_awaddr   [0:   4];
logic [  2: 0] m_awsize   [0:   4];
logic [  7: 0] m_awlen    [0:   4];
logic [  3: 0] m_wstrb    [0:   4];
logic [ 12: 0] m_wid      [0:   4];
logic [ 31: 0] m_wdata    [0:   4];
logic [ 12: 0] m_bid      [0:   4];
logic [  1: 0] m_bresp    [0:   4];
logic [ 31: 0] m_araddr   [0:   4];
logic [  1: 0] m_arburst  [0:   4];
logic [  2: 0] m_arsize   [0:   4];
logic [ 12: 0] m_arid     [0:   4];
logic [  7: 0] m_arlen    [0:   4];
logic [ 31: 0] m_rdata    [0:   4];
logic [  1: 0] m_rresp    [0:   4];
logic [ 12: 0] m_rid      [0:   4];

logic [  4: 0] m_arvalid;
logic [  4: 0] m_arready;
logic [  4: 0] m_rlast;
logic [  4: 0] m_rvalid;
logic [  4: 0] m_rready;
logic [  4: 0] m_awvalid;
logic [  4: 0] m_awready;
logic [  4: 0] m_wlast;
logic [  4: 0] m_wvalid;
logic [  4: 0] m_wready;
logic [  4: 0] m_bvalid;
logic [  4: 0] m_bready;

assign m0_awburst = m_awburst [0];
assign m0_awid    = m_awid    [0];
assign m0_awaddr  = m_awaddr  [0];
assign m0_awsize  = m_awsize  [0];
assign m0_awlen   = m_awlen   [0];
assign m0_wstrb   = m_wstrb   [0];
assign m0_wid     = m_wid     [0];
assign m0_wdata   = m_wdata   [0];
assign m0_araddr  = m_araddr  [0];
assign m0_arburst = m_arburst [0];
assign m0_arsize  = m_arsize  [0];
assign m0_arid    = m_arid    [0];
assign m0_arlen   = m_arlen   [0];
assign m1_awburst = m_awburst [1];
assign m1_awid    = m_awid    [1];
assign m1_awaddr  = m_awaddr  [1];
assign m1_awsize  = m_awsize  [1];
assign m1_awlen   = m_awlen   [1];
assign m1_wstrb   = m_wstrb   [1];
assign m1_wid     = m_wid     [1];
assign m1_wdata   = m_wdata   [1];
assign m1_araddr  = m_araddr  [1];
assign m1_arburst = m_arburst [1];
assign m1_arsize  = m_arsize  [1];
assign m1_arid    = m_arid    [1];
assign m1_arlen   = m_arlen   [1];
assign m2_awburst = m_awburst [2];
assign m2_awid    = m_awid    [2];
assign m2_awaddr  = m_awaddr  [2];
assign m2_awsize  = m_awsize  [2];
assign m2_awlen   = m_awlen   [2];
assign m2_wstrb   = m_wstrb   [2];
assign m2_wid     = m_wid     [2];
assign m2_wdata   = m_wdata   [2];
assign m2_araddr  = m_araddr  [2];
assign m2_arburst = m_arburst [2];
assign m2_arsize  = m_arsize  [2];
assign m2_arid    = m_arid    [2];
assign m2_arlen   = m_arlen   [2];
assign m3_awburst = m_awburst [3];
assign m3_awid    = m_awid    [3];
assign m3_awaddr  = m_awaddr  [3];
assign m3_awsize  = m_awsize  [3];
assign m3_awlen   = m_awlen   [3];
assign m3_wstrb   = m_wstrb   [3];
assign m3_wid     = m_wid     [3];
assign m3_wdata   = m_wdata   [3];
assign m3_araddr  = m_araddr  [3];
assign m3_arburst = m_arburst [3];
assign m3_arsize  = m_arsize  [3];
assign m3_arid    = m_arid    [3];
assign m3_arlen   = m_arlen   [3];

assign m_bid     [0] = m0_bid;
assign m_bresp   [0] = m0_bresp;
assign m_rdata   [0] = m0_rdata;
assign m_rresp   [0] = m0_rresp;
assign m_rid     [0] = m0_rid;
assign m_bid     [1] = m1_bid;
assign m_bresp   [1] = m1_bresp;
assign m_rdata   [1] = m1_rdata;
assign m_rresp   [1] = m1_rresp;
assign m_rid     [1] = m1_rid;
assign m_bid     [2] = m2_bid;
assign m_bresp   [2] = m2_bresp;
assign m_rdata   [2] = m2_rdata;
assign m_rresp   [2] = m2_rresp;
assign m_rid     [2] = m2_rid;
assign m_bid     [3] = m3_bid;
assign m_bresp   [3] = m3_bresp;
assign m_rdata   [3] = m3_rdata;
assign m_rresp   [3] = m3_rresp;
assign m_rid     [3] = m3_rid;

assign m0_arvalid = m_arvalid [0];
assign m0_awvalid = m_awvalid [0];
assign m0_wvalid  = m_wvalid  [0];
assign m0_wlast   = m_wlast   [0];
assign m0_bready  = m_bready  [0];
assign m0_rready  = m_rready  [0];
assign m1_arvalid = m_arvalid [1];
assign m1_awvalid = m_awvalid [1];
assign m1_wvalid  = m_wvalid  [1];
assign m1_wlast   = m_wlast   [1];
assign m1_bready  = m_bready  [1];
assign m1_rready  = m_rready  [1];
assign m2_arvalid = m_arvalid [2];
assign m2_awvalid = m_awvalid [2];
assign m2_wvalid  = m_wvalid  [2];
assign m2_wlast   = m_wlast   [2];
assign m2_bready  = m_bready  [2];
assign m2_rready  = m_rready  [2];
assign m3_arvalid = m_arvalid [3];
assign m3_awvalid = m_awvalid [3];
assign m3_wvalid  = m_wvalid  [3];
assign m3_wlast   = m_wlast   [3];
assign m3_bready  = m_bready  [3];
assign m3_rready  = m_rready  [3];

assign m_arready [0] = m0_arready;
assign m_awready [0] = m0_awready;
assign m_wready  [0] = m0_wready;
assign m_bvalid  [0] = m0_bvalid;
assign m_rlast   [0] = m0_rlast;
assign m_rvalid  [0] = m0_rvalid;
assign m_arready [1] = m1_arready;
assign m_awready [1] = m1_awready;
assign m_wready  [1] = m1_wready;
assign m_bvalid  [1] = m1_bvalid;
assign m_rlast   [1] = m1_rlast;
assign m_rvalid  [1] = m1_rvalid;
assign m_arready [2] = m2_arready;
assign m_awready [2] = m2_awready;
assign m_wready  [2] = m2_wready;
assign m_bvalid  [2] = m2_bvalid;
assign m_rlast   [2] = m2_rlast;
assign m_rvalid  [2] = m2_rvalid;
assign m_arready [3] = m3_arready;
assign m_awready [3] = m3_awready;
assign m_wready  [3] = m3_wready;
assign m_bvalid  [3] = m3_bvalid;
assign m_rlast   [3] = m3_rlast;
assign m_rvalid  [3] = m3_rvalid;

logic [  4: 0] awsel;
logic [  4: 0] wsel;
logic [  4: 0] bsel;
logic [  4: 0] arsel;
logic [  4: 0] rsel;

logic          b_fifo_wr;
logic          b_fifo_rd;
logic          b_fifo_empty;
logic          b_fifo_full;
logic          r_fifo_wr;
logic          r_fifo_rd;
logic          r_fifo_empty;
logic          r_fifo_full;

assign awsel[  0] = s_awaddr >= 32'h0000_0000 && s_awaddr < 32'h0000_0000 + 32'h0001_0000;
assign awsel[  1] = s_awaddr >= 32'h0001_0000 && s_awaddr < 32'h0001_0000 + 32'h0001_0000;
assign awsel[  2] = s_awaddr >= 32'h0400_0000 && s_awaddr < 32'h0400_0000 + 32'h0c00_0000;
assign awsel[  3] = s_awaddr >= 32'h1000_0000 && s_awaddr < 32'h1000_0000 + 32'h0000_1000;
assign awsel[  4] = ~|awsel[3:0]; // default slv

assign arsel[  0] = s_araddr >= 32'h0000_0000 && s_araddr < 32'h0000_0000 + 32'h0001_0000;
assign arsel[  1] = s_araddr >= 32'h0001_0000 && s_araddr < 32'h0001_0000 + 32'h0001_0000;
assign arsel[  2] = s_araddr >= 32'h0400_0000 && s_araddr < 32'h0400_0000 + 32'h0c00_0000;
assign arsel[  3] = s_araddr >= 32'h1000_0000 && s_araddr < 32'h1000_0000 + 32'h0000_1000;
assign arsel[  4] = ~|arsel[3:0]; // default slv

assign b_fifo_wr = s_awvalid & s_awready;
assign b_fifo_rd = s_bvalid  & s_bready;

assign r_fifo_wr = s_arvalid & s_arready;
assign r_fifo_rd = s_rlast  & s_rvalid & s_rready;

axi_dec_fifo u_b_fifo (
    .clk           ( aclk       ),
    .rstn          ( aresetn    ),
    .wr            ( b_fifo_wr  ),
    .wdata         ( awsel      ),
    .rd            ( b_fifo_rd  ),
    .rdata         ( bsel       ),
    .empty         ( b_fifo_empty ),
    .full          ( b_fifo_full )
);

axi_dec_fifo u_r_fifo (
    .clk           ( aclk       ),
    .rstn          ( aresetn    ),
    .wr            ( r_fifo_wr  ),
    .wdata         ( arsel      ),
    .rd            ( r_fifo_rd  ),
    .rdata         ( rsel       ),
    .empty         ( r_fifo_empty ),
    .full          ( r_fifo_full )
);

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        wsel <= 5'b0;
    end
    else begin
        if (s_awvalid & s_awready & ~|wsel) begin
            wsel <= awsel;
        end
        else if (s_wlast & s_wvalid & s_wready) begin
            wsel <= 5'b0;
        end
    end
end

always_comb begin
    integer i;

    for (i = 0; i <= 4; i = i + 1) begin
        m_awburst [i] = {    2{awsel[i]}} & s_awburst;
        m_awid    [i] = {   13{awsel[i]}} & s_awid;
        m_awaddr  [i] = {   32{awsel[i]}} & s_awaddr;
        m_awsize  [i] = {    3{awsel[i]}} & s_awsize;
        m_awlen   [i] = {    8{awsel[i]}} & s_awlen;

        m_wstrb   [i] = {    4{ wsel[i]}} & s_wstrb;
        m_wid     [i] = {   13{ wsel[i]}} & s_wid;
        m_wdata   [i] = {   32{ wsel[i]}} & s_wdata;

        m_araddr  [i] = {   32{arsel[i]}} & s_araddr;
        m_arburst [i] = {    2{arsel[i]}} & s_arburst;
        m_arsize  [i] = {    3{arsel[i]}} & s_arsize;
        m_arid    [i] = {   13{arsel[i]}} & s_arid;
        m_arlen   [i] = {    8{arsel[i]}} & s_arlen;
    end
end

always_comb begin
    integer i;

    s_bid      =  13'b0;
    s_bresp    =   2'b0;

    s_rdata    =  32'b0;
    s_rresp    =   2'b0;
    s_rid      =  13'b0;
    for (i = 0; i <= 4; i = i + 1) begin
        s_bid      = s_bid      | ({   13{bsel[i]}} & m_bid     [i]);
        s_bresp    = s_bresp    | ({    2{bsel[i]}} & m_bresp   [i]);

        s_rdata    = s_rdata    | ({   32{rsel[i]}} & m_rdata   [i]);
        s_rresp    = s_rresp    | ({    2{rsel[i]}} & m_rresp   [i]);
        s_rid      = s_rid      | ({   13{rsel[i]}} & m_rid     [i]);
    end
end

assign m_awvalid = awsel & {5{s_awvalid & ~b_fifo_full}};
assign s_awready = |(awsel & m_awready) & ~b_fifo_full;

assign m_wlast   = wsel & {5{s_wlast }};
assign m_wvalid  = wsel & {5{s_wvalid}};
assign s_wready  = |(wsel  & m_wready );

assign s_bvalid  = |(bsel  & m_bvalid) & ~b_fifo_empty;
assign m_bready  = bsel & {5{s_bready}};

assign m_arvalid = arsel & {5{s_arvalid & ~r_fifo_full}};
assign s_arready = |(arsel & m_arready) & ~r_fifo_full;

assign s_rlast   = |(rsel  & m_rlast ) & ~r_fifo_empty;
assign s_rvalid  = |(rsel  & m_rvalid) & ~r_fifo_empty;
assign m_rready  = rsel & {5{s_rready}};

axi_dfslv u_axi_dfslv (
    .aclk          ( aclk       ),
    .aresetn       ( aresetn    ),
    .s_awburst     ( m_awburst[4] ),
    .s_awid        ( m_awid[4]  ),
    .s_awaddr      ( m_awaddr[4] ),
    .s_awsize      ( m_awsize[4] ),
    .s_awlen       ( m_awlen[4] ),
    .s_awvalid     ( m_awvalid[4] ),
    .s_awready     ( m_awready[4] ),
    .s_wstrb       ( m_wstrb[4] ),
    .s_wid         ( m_wid[4]   ),
    .s_wdata       ( m_wdata[4] ),
    .s_wlast       ( m_wlast[4] ),
    .s_wvalid      ( m_wvalid[4] ),
    .s_wready      ( m_wready[4] ),
    .s_bid         ( m_bid[4]   ),
    .s_bresp       ( m_bresp[4] ),
    .s_bvalid      ( m_bvalid[4] ),
    .s_bready      ( m_bready[4] ),
    .s_araddr      ( m_araddr[4] ),
    .s_arburst     ( m_arburst[4] ),
    .s_arsize      ( m_arsize[4] ),
    .s_arid        ( m_arid[4]  ),
    .s_arlen       ( m_arlen[4] ),
    .s_arvalid     ( m_arvalid[4] ),
    .s_arready     ( m_arready[4] ),
    .s_rdata       ( m_rdata[4] ),
    .s_rresp       ( m_rresp[4] ),
    .s_rid         ( m_rid[4]   ),
    .s_rlast       ( m_rlast[4] ),
    .s_rvalid      ( m_rvalid[4] ),
    .s_rready      ( m_rready[4] )
);

endmodule

module axi_dec_fifo (
    input                  clk,
    input                  rstn,
    input                  wr,
    input         [  4: 0] wdata,
    input                  rd,
    output logic  [  4: 0] rdata,
    output logic           empty,
    output logic           full
);

parameter FIFO_DEPTH = 4;

logic [  4: 0] fifo       [0: FIFO_DEPTH - 1];

logic [  2: 0] wptr;
logic [  2: 0] rptr;

assign empty = wptr == rptr;
assign full  = (wptr[2] ^ rptr[2]) && (wptr[0+:2] == rptr[0+:2]);

assign rdata = fifo[rptr[0+:2]];

always_ff @(posedge clk or negedge rstn) begin
    integer i;

    if (~rstn) begin
        wptr <= 3'b0;
        rptr <= 3'b0;
    end
    else begin
        if (wr & ~full)  wptr <= wptr + 3'b1;
        if (rd & ~empty) rptr <= rptr + 3'b1;
    end

    if (~rstn) begin
        for (i = 0; i < FIFO_DEPTH; i = i + 1)
            fifo[i] <= 5'b0;
    end
    else begin
        if (wr & ~full) fifo[wptr[0+:2]] <= wdata;
    end
end
endmodule

module axi_dfslv (
    input                  aclk,
    input                  aresetn,
    input         [  1: 0] s_awburst,
    input         [ 12: 0] s_awid,
    input         [ 31: 0] s_awaddr,
    input         [  2: 0] s_awsize,
    input         [  7: 0] s_awlen,
    input                  s_awvalid,
    output logic           s_awready,
    input         [  3: 0] s_wstrb,
    input         [ 12: 0] s_wid,
    input         [ 31: 0] s_wdata,
    input                  s_wlast,
    input                  s_wvalid,
    output logic           s_wready,
    output logic  [ 12: 0] s_bid,
    output logic  [  1: 0] s_bresp,
    output logic           s_bvalid,
    input                  s_bready,
    input         [ 31: 0] s_araddr,
    input         [  1: 0] s_arburst,
    input         [  2: 0] s_arsize,
    input         [ 12: 0] s_arid,
    input         [  7: 0] s_arlen,
    input                  s_arvalid,
    output logic           s_arready,
    output logic  [ 31: 0] s_rdata,
    output logic  [  1: 0] s_rresp,
    output logic  [ 12: 0] s_rid,
    output logic           s_rlast,
    output logic           s_rvalid,
    input                  s_rready
);

`define AXI_RESP_OKAY   2'b00
`define AXI_RESP_EXOKAY 2'b01
`define AXI_RESP_SLVERR 2'b10
`define AXI_RESP_DECERR 2'b11

// READ
logic [  7: 0] rlen;

assign s_rdata    =  32'b0;
assign s_rresp    = `AXI_RESP_DECERR;
assign s_rlast    = ~|rlen;
assign s_arready  = ~s_rvalid | (s_rlast & s_rvalid & s_rready);

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        s_rid <=  13'b0;
    end
    else begin
        if (s_arvalid & s_arready) begin
            s_rid <= s_arid;
        end
    end

    if (~aresetn) begin
        rlen <= 8'b0;
    end
    else begin
        if (s_arvalid & s_arready) begin
            rlen <= s_arlen;
        end
        else if (~s_rlast & s_rvalid & s_rready) begin
            rlen <= rlen - 8'b1;
        end
    end

    if (~aresetn) begin
        s_rvalid <= 1'b0;
    end
    else begin
        if (s_arvalid & s_arready) begin
            s_rvalid <= 1'b1;
        end
        else if (s_rlast & s_rvalid & s_rready) begin
            s_rvalid <= 1'b0;
        end
    end
end

// WRITE
assign s_bresp    = `AXI_RESP_DECERR;
assign s_awready  = (~s_wready & ~s_bvalid) | (s_bvalid & s_bready);

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        s_wready <= 1'b0;
    end
    else begin
        if (s_awvalid & s_awready) begin
            s_wready <= 1'b1;
        end
        else if (s_wvalid & s_wlast) begin
            s_wready <= 1'b0;
        end
    end

    if (~aresetn) begin
        s_bid <= 13'b0;
    end
    else begin
        if (s_awvalid & s_awready) begin
            s_bid <= s_awid;
        end
    end

    if (~aresetn) begin
        s_bvalid <= 1'b0;
    end
    else begin
        if (s_wvalid & s_wlast & s_wready) begin
            s_bvalid <= 1'b1;
        end
        else if (s_bready) begin
            s_bvalid <= 1'b0;
        end
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/axi_slice.sv
/*--------------------------------------*/

/*-----------------------------------------------------*/
// axi_slice.sv is generated by gen_axi_mux.sh
//
//                                         2021-12-03
//                                           22:13:58
/*-----------------------------------------------------*/

module axi_slice (
    input                  aclk,
    input                  aresetn,
    input         [ 57: 0] s_awpayload,
    input                  s_awvalid,
    output logic           s_awready,
    input         [ 49: 0] s_wpayload,
    input                  s_wvalid,
    output logic           s_wready,
    output logic  [ 14: 0] s_bpayload,
    output logic           s_bvalid,
    input                  s_bready,
    input         [ 57: 0] s_arpayload,
    input                  s_arvalid,
    output logic           s_arready,
    output logic  [ 47: 0] s_rpayload,
    output logic           s_rvalid,
    input                  s_rready,
    output logic  [ 57: 0] m_awpayload,
    output logic           m_awvalid,
    input                  m_awready,
    output logic  [ 49: 0] m_wpayload,
    output logic           m_wvalid,
    input                  m_wready,
    input         [ 14: 0] m_bpayload,
    input                  m_bvalid,
    output logic           m_bready,
    output logic  [ 57: 0] m_arpayload,
    output logic           m_arvalid,
    input                  m_arready,
    input         [ 47: 0] m_rpayload,
    input                  m_rvalid,
    output logic           m_rready
);

logic [ 57: 0] awpayload_latch [0:   1];
logic [ 49: 0] wpayload_latch [0:   1];
logic [ 14: 0] bpayload_latch [0:   1];
logic [ 57: 0] arpayload_latch [0:   1];
logic [ 47: 0] rpayload_latch [0:   1];

logic [  1: 0] aw_wptr;
logic [  1: 0] w_wptr;
logic [  1: 0] b_wptr;
logic [  1: 0] ar_wptr;
logic [  1: 0] r_wptr;

logic [  1: 0] aw_rptr;
logic [  1: 0] w_rptr;
logic [  1: 0] b_rptr;
logic [  1: 0] ar_rptr;
logic [  1: 0] r_rptr;

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        awpayload_latch <= { 58'b0,  58'b0};
        wpayload_latch  <= { 50'b0,  50'b0};
        bpayload_latch  <= { 15'b0,  15'b0};
        arpayload_latch <= { 58'b0,  58'b0};
        rpayload_latch  <= { 48'b0,  48'b0};
    end
    else begin
        if (s_awvalid && s_awready) awpayload_latch[aw_wptr[0]] <= s_awpayload;
        if (s_wvalid  && s_wready)  wpayload_latch[w_wptr[0]]   <= s_wpayload;
        if (m_bvalid  && m_bready)  bpayload_latch[b_wptr[0]]   <= m_bpayload;
        if (s_arvalid && s_arready) arpayload_latch[ar_wptr[0]] <= s_arpayload;
        if (m_rvalid  && m_rready)  rpayload_latch[r_wptr[0]]   <= m_rpayload;
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        aw_wptr <= 2'b0;
        w_wptr  <= 2'b0;
        b_wptr  <= 2'b0;
        ar_wptr <= 2'b0;
        r_wptr  <= 2'b0;
    end
    else begin
        if (s_awvalid && s_awready) aw_wptr <= aw_wptr + 2'b1;
        if (s_wvalid  && s_wready)  w_wptr  <= w_wptr  + 2'b1;
        if (m_bvalid  && m_bready)  b_wptr  <= b_wptr  + 2'b1;
        if (s_arvalid && s_arready) ar_wptr <= ar_wptr + 2'b1;
        if (m_rvalid  && m_rready)  r_wptr  <= r_wptr  + 2'b1;
    end
end

assign s_awready = !((aw_wptr[1] != aw_rptr[1]) && (aw_wptr[0] == aw_rptr[0]));
assign s_wready  = !((w_wptr[1]  != w_rptr[1] ) && (w_wptr[0]  == w_rptr[0] ));
assign m_bready  = !((b_wptr[1]  != b_rptr[1] ) && (b_wptr[0]  == b_rptr[0] ));
assign s_arready = !((ar_wptr[1] != ar_rptr[1]) && (ar_wptr[0] == ar_rptr[0]));
assign m_rready  = !((r_wptr[1]  != r_rptr[1] ) && (r_wptr[0]  == r_rptr[0] ));

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        aw_rptr <= 2'b0;
        w_rptr  <= 2'b0;
        b_rptr  <= 2'b0;
        ar_rptr <= 2'b0;
        r_rptr  <= 2'b0;
    end
    else begin
        if (m_awvalid && m_awready) aw_rptr <= aw_rptr + 2'b1;
        if (m_wvalid  && m_wready)  w_rptr  <= w_rptr  + 2'b1;
        if (s_bvalid  && s_bready)  b_rptr  <= b_rptr  + 2'b1;
        if (m_arvalid && m_arready) ar_rptr <= ar_rptr + 2'b1;
        if (s_rvalid  && s_rready)  r_rptr  <= r_rptr  + 2'b1;
    end
end

assign m_awvalid = aw_wptr != aw_rptr;
assign m_wvalid  = w_wptr  != w_rptr ;
assign s_bvalid  = b_wptr  != b_rptr ;
assign m_arvalid = ar_wptr != ar_rptr;
assign s_rvalid  = r_wptr  != r_rptr ;

assign m_awpayload = awpayload_latch[aw_rptr[0]];
assign m_wpayload  = wpayload_latch [ w_rptr[0]];
assign s_bpayload  = bpayload_latch [ b_rptr[0]];
assign m_arpayload = arpayload_latch[ar_rptr[0]];
assign s_rpayload  = rpayload_latch [ r_rptr[0]];

endmodule

/*--------------------------------------*/
// FILE: ../mdl/sram.sv
/*--------------------------------------*/

module sram (
    input               CK,
    input               CS,
    input               WE,
    input        [13:0] A,
    input        [ 3:0] BYTE,
    input        [31:0] DI,
    output logic [31:0] DO
);

`ifdef DC
SRAM i_SRAM (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( A[6]         ),
    .A7   ( A[7]         ),
    .A8   ( A[8]         ),
    .A9   ( A[9]         ),
    .A10  ( A[10]        ),
    .A11  ( A[11]        ),
    .A12  ( A[12]        ),
    .A13  ( A[13]        ),
    .DO0  ( DO[0]        ),
    .DO1  ( DO[1]        ),
    .DO2  ( DO[2]        ),
    .DO3  ( DO[3]        ),
    .DO4  ( DO[4]        ),
    .DO5  ( DO[5]        ),
    .DO6  ( DO[6]        ),
    .DO7  ( DO[7]        ),
    .DO8  ( DO[8]        ),
    .DO9  ( DO[9]        ),
    .DO10 ( DO[10]       ),
    .DO11 ( DO[11]       ),
    .DO12 ( DO[12]       ),
    .DO13 ( DO[13]       ),
    .DO14 ( DO[14]       ),
    .DO15 ( DO[15]       ),
    .DO16 ( DO[16]       ),
    .DO17 ( DO[17]       ),
    .DO18 ( DO[18]       ),
    .DO19 ( DO[19]       ),
    .DO20 ( DO[20]       ),
    .DO21 ( DO[21]       ),
    .DO22 ( DO[22]       ),
    .DO23 ( DO[23]       ),
    .DO24 ( DO[24]       ),
    .DO25 ( DO[25]       ),
    .DO26 ( DO[26]       ),
    .DO27 ( DO[27]       ),
    .DO28 ( DO[28]       ),
    .DO29 ( DO[29]       ),
    .DO30 ( DO[30]       ),
    .DO31 ( DO[31]       ),
    .DI0  ( DI[0]        ),
    .DI1  ( DI[1]        ),
    .DI2  ( DI[2]        ),
    .DI3  ( DI[3]        ),
    .DI4  ( DI[4]        ),
    .DI5  ( DI[5]        ),
    .DI6  ( DI[6]        ),
    .DI7  ( DI[7]        ),
    .DI8  ( DI[8]        ),
    .DI9  ( DI[9]        ),
    .DI10 ( DI[10]       ),
    .DI11 ( DI[11]       ),
    .DI12 ( DI[12]       ),
    .DI13 ( DI[13]       ),
    .DI14 ( DI[14]       ),
    .DI15 ( DI[15]       ),
    .DI16 ( DI[16]       ),
    .DI17 ( DI[17]       ),
    .DI18 ( DI[18]       ),
    .DI19 ( DI[19]       ),
    .DI20 ( DI[20]       ),
    .DI21 ( DI[21]       ),
    .DI22 ( DI[22]       ),
    .DI23 ( DI[23]       ),
    .DI24 ( DI[24]       ),
    .DI25 ( DI[25]       ),
    .DI26 ( DI[26]       ),
    .DI27 ( DI[27]       ),
    .DI28 ( DI[28]       ),
    .DI29 ( DI[29]       ),
    .DI30 ( DI[30]       ),
    .DI31 ( DI[31]       ),
    .CK   ( CK           ),
    .WEB0 ( ~BYTE[0]     ),
    .WEB1 ( ~BYTE[1]     ),
    .WEB2 ( ~BYTE[2]     ),
    .WEB3 ( ~BYTE[3]     ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
`else
logic [31:0] data_out_pre;
logic [31:0] memory [16384];

assign data_out_pre = CS ? memory[A] : 32'hx;

always_ff @(posedge CK) begin
    if (CS & WE) begin
        if (BYTE[0]) memory[A][ 7: 0] <= DI[ 7: 0];
        if (BYTE[1]) memory[A][15: 8] <= DI[15: 8];
        if (BYTE[2]) memory[A][23:16] <= DI[23:16];
        if (BYTE[3]) memory[A][31:24] <= DI[31:24];
    end
end

always_ff @(posedge CK) begin
    DO <= data_out_pre;
end
`endif

endmodule

/*--------------------------------------*/
// FILE: ../mdl/sram32x31.sv
/*--------------------------------------*/

module sram32x31 (
    input                CK,
    input                CS,
    input                WE,
    input        [  4:0] A,
    input        [ 30:0] DI,
    output logic [ 30:0] DO
);

`ifdef DC
SRAM i_SRAM (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( 1'b0         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[0]        ),
    .DO1  ( DO[1]        ),
    .DO2  ( DO[2]        ),
    .DO3  ( DO[3]        ),
    .DO4  ( DO[4]        ),
    .DO5  ( DO[5]        ),
    .DO6  ( DO[6]        ),
    .DO7  ( DO[7]        ),
    .DO8  ( DO[8]        ),
    .DO9  ( DO[9]        ),
    .DO10 ( DO[10]       ),
    .DO11 ( DO[11]       ),
    .DO12 ( DO[12]       ),
    .DO13 ( DO[13]       ),
    .DO14 ( DO[14]       ),
    .DO15 ( DO[15]       ),
    .DO16 ( DO[16]       ),
    .DO17 ( DO[17]       ),
    .DO18 ( DO[18]       ),
    .DO19 ( DO[19]       ),
    .DO20 ( DO[20]       ),
    .DO21 ( DO[21]       ),
    .DO22 ( DO[22]       ),
    .DO23 ( DO[23]       ),
    .DO24 ( DO[24]       ),
    .DO25 ( DO[25]       ),
    .DO26 ( DO[26]       ),
    .DO27 ( DO[27]       ),
    .DO28 ( DO[28]       ),
    .DO29 ( DO[29]       ),
    .DO30 ( DO[30]       ),
    .DO31 (              ),
    .DI0  ( DI[0]        ),
    .DI1  ( DI[1]        ),
    .DI2  ( DI[2]        ),
    .DI3  ( DI[3]        ),
    .DI4  ( DI[4]        ),
    .DI5  ( DI[5]        ),
    .DI6  ( DI[6]        ),
    .DI7  ( DI[7]        ),
    .DI8  ( DI[8]        ),
    .DI9  ( DI[9]        ),
    .DI10 ( DI[10]       ),
    .DI11 ( DI[11]       ),
    .DI12 ( DI[12]       ),
    .DI13 ( DI[13]       ),
    .DI14 ( DI[14]       ),
    .DI15 ( DI[15]       ),
    .DI16 ( DI[16]       ),
    .DI17 ( DI[17]       ),
    .DI18 ( DI[18]       ),
    .DI19 ( DI[19]       ),
    .DI20 ( DI[20]       ),
    .DI21 ( DI[21]       ),
    .DI22 ( DI[22]       ),
    .DI23 ( DI[23]       ),
    .DI24 ( DI[24]       ),
    .DI25 ( DI[25]       ),
    .DI26 ( DI[26]       ),
    .DI27 ( DI[27]       ),
    .DI28 ( DI[28]       ),
    .DI29 ( DI[29]       ),
    .DI30 ( DI[30]       ),
    .DI31 ( 1'b0         ),
    .CK   ( CK           ),
    .WEB0 ( 1'b0         ),
    .WEB1 ( 1'b0         ),
    .WEB2 ( 1'b0         ),
    .WEB3 ( 1'b0         ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
`else
logic [30:0] data_out_pre;
logic [30:0] memory [32];

assign data_out_pre = CS ? memory[A] : 31'hx;

always_ff @(posedge CK) begin
    integer i;

    if (CS & WE) begin
        memory[A] <= DI;
    end
end

always_ff @(posedge CK) begin
    DO <= data_out_pre;
end
`endif

endmodule

/*--------------------------------------*/
// FILE: ../mdl/sram32x64.sv
/*--------------------------------------*/

module sram32x64 (
    input                CK,
    input                CS,
    input                WE,
    input        [  4:0] A,
    input        [ 63:0] DI,
    output logic [ 63:0] DO
);

`ifdef DC
SRAM i_SRAM_LOW (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( 1'b0         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[0]        ),
    .DO1  ( DO[1]        ),
    .DO2  ( DO[2]        ),
    .DO3  ( DO[3]        ),
    .DO4  ( DO[4]        ),
    .DO5  ( DO[5]        ),
    .DO6  ( DO[6]        ),
    .DO7  ( DO[7]        ),
    .DO8  ( DO[8]        ),
    .DO9  ( DO[9]        ),
    .DO10 ( DO[10]       ),
    .DO11 ( DO[11]       ),
    .DO12 ( DO[12]       ),
    .DO13 ( DO[13]       ),
    .DO14 ( DO[14]       ),
    .DO15 ( DO[15]       ),
    .DO16 ( DO[16]       ),
    .DO17 ( DO[17]       ),
    .DO18 ( DO[18]       ),
    .DO19 ( DO[19]       ),
    .DO20 ( DO[20]       ),
    .DO21 ( DO[21]       ),
    .DO22 ( DO[22]       ),
    .DO23 ( DO[23]       ),
    .DO24 ( DO[24]       ),
    .DO25 ( DO[25]       ),
    .DO26 ( DO[26]       ),
    .DO27 ( DO[27]       ),
    .DO28 ( DO[28]       ),
    .DO29 ( DO[29]       ),
    .DO30 ( DO[30]       ),
    .DO31 ( DO[31]       ),
    .DI0  ( DI[0]        ),
    .DI1  ( DI[1]        ),
    .DI2  ( DI[2]        ),
    .DI3  ( DI[3]        ),
    .DI4  ( DI[4]        ),
    .DI5  ( DI[5]        ),
    .DI6  ( DI[6]        ),
    .DI7  ( DI[7]        ),
    .DI8  ( DI[8]        ),
    .DI9  ( DI[9]        ),
    .DI10 ( DI[10]       ),
    .DI11 ( DI[11]       ),
    .DI12 ( DI[12]       ),
    .DI13 ( DI[13]       ),
    .DI14 ( DI[14]       ),
    .DI15 ( DI[15]       ),
    .DI16 ( DI[16]       ),
    .DI17 ( DI[17]       ),
    .DI18 ( DI[18]       ),
    .DI19 ( DI[19]       ),
    .DI20 ( DI[20]       ),
    .DI21 ( DI[21]       ),
    .DI22 ( DI[22]       ),
    .DI23 ( DI[23]       ),
    .DI24 ( DI[24]       ),
    .DI25 ( DI[25]       ),
    .DI26 ( DI[26]       ),
    .DI27 ( DI[27]       ),
    .DI28 ( DI[28]       ),
    .DI29 ( DI[29]       ),
    .DI30 ( DI[30]       ),
    .DI31 ( DI[31]       ),
    .CK   ( CK           ),
    .WEB0 ( 1'b0         ),
    .WEB1 ( 1'b0         ),
    .WEB2 ( 1'b0         ),
    .WEB3 ( 1'b0         ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
SRAM i_SRAM_HIGH (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( 1'b0         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[32+0]     ),
    .DO1  ( DO[32+1]     ),
    .DO2  ( DO[32+2]     ),
    .DO3  ( DO[32+3]     ),
    .DO4  ( DO[32+4]     ),
    .DO5  ( DO[32+5]     ),
    .DO6  ( DO[32+6]     ),
    .DO7  ( DO[32+7]     ),
    .DO8  ( DO[32+8]     ),
    .DO9  ( DO[32+9]     ),
    .DO10 ( DO[32+10]    ),
    .DO11 ( DO[32+11]    ),
    .DO12 ( DO[32+12]    ),
    .DO13 ( DO[32+13]    ),
    .DO14 ( DO[32+14]    ),
    .DO15 ( DO[32+15]    ),
    .DO16 ( DO[32+16]    ),
    .DO17 ( DO[32+17]    ),
    .DO18 ( DO[32+18]    ),
    .DO19 ( DO[32+19]    ),
    .DO20 ( DO[32+20]    ),
    .DO21 ( DO[32+21]    ),
    .DO22 ( DO[32+22]    ),
    .DO23 ( DO[32+23]    ),
    .DO24 ( DO[32+24]    ),
    .DO25 ( DO[32+25]    ),
    .DO26 ( DO[32+26]    ),
    .DO27 ( DO[32+27]    ),
    .DO28 ( DO[32+28]    ),
    .DO29 ( DO[32+29]    ),
    .DO30 ( DO[32+30]    ),
    .DO31 ( DO[32+31]    ),
    .DI0  ( DI[32+0]     ),
    .DI1  ( DI[32+1]     ),
    .DI2  ( DI[32+2]     ),
    .DI3  ( DI[32+3]     ),
    .DI4  ( DI[32+4]     ),
    .DI5  ( DI[32+5]     ),
    .DI6  ( DI[32+6]     ),
    .DI7  ( DI[32+7]     ),
    .DI8  ( DI[32+8]     ),
    .DI9  ( DI[32+9]     ),
    .DI10 ( DI[32+10]    ),
    .DI11 ( DI[32+11]    ),
    .DI12 ( DI[32+12]    ),
    .DI13 ( DI[32+13]    ),
    .DI14 ( DI[32+14]    ),
    .DI15 ( DI[32+15]    ),
    .DI16 ( DI[32+16]    ),
    .DI17 ( DI[32+17]    ),
    .DI18 ( DI[32+18]    ),
    .DI19 ( DI[32+19]    ),
    .DI20 ( DI[32+20]    ),
    .DI21 ( DI[32+21]    ),
    .DI22 ( DI[32+22]    ),
    .DI23 ( DI[32+23]    ),
    .DI24 ( DI[32+24]    ),
    .DI25 ( DI[32+25]    ),
    .DI26 ( DI[32+26]    ),
    .DI27 ( DI[32+27]    ),
    .DI28 ( DI[32+28]    ),
    .DI29 ( DI[32+29]    ),
    .DI30 ( DI[32+30]    ),
    .DI31 ( DI[32+31]    ),
    .CK   ( CK           ),
    .WEB0 ( 1'b0         ),
    .WEB1 ( 1'b0         ),
    .WEB2 ( 1'b0         ),
    .WEB3 ( 1'b0         ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
`else
logic [63:0] data_out_pre;
logic [63:0] memory [32];

assign data_out_pre = CS ? memory[A] : 64'hx;

always_ff @(posedge CK) begin
    integer i;

    if (CS & WE) begin
        memory[A] <= DI;
    end
end

always_ff @(posedge CK) begin
    DO <= data_out_pre;
end
`endif

endmodule

/*--------------------------------------*/
// FILE: ../mdl/sram64x22.sv
/*--------------------------------------*/

module sram64x22 (
    input               CK,
    input               CS,
    input               WE,
    input        [ 5:0] A,
    input        [21:0] DI,
    output logic [21:0] DO
);

`ifdef DC
SRAM i_SRAM (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[0]        ),
    .DO1  ( DO[1]        ),
    .DO2  ( DO[2]        ),
    .DO3  ( DO[3]        ),
    .DO4  ( DO[4]        ),
    .DO5  ( DO[5]        ),
    .DO6  ( DO[6]        ),
    .DO7  ( DO[7]        ),
    .DO8  ( DO[8]        ),
    .DO9  ( DO[9]        ),
    .DO10 ( DO[10]       ),
    .DO11 ( DO[11]       ),
    .DO12 ( DO[12]       ),
    .DO13 ( DO[13]       ),
    .DO14 ( DO[14]       ),
    .DO15 ( DO[15]       ),
    .DO16 ( DO[16]       ),
    .DO17 ( DO[17]       ),
    .DO18 ( DO[18]       ),
    .DO19 ( DO[19]       ),
    .DO20 ( DO[20]       ),
    .DO21 ( DO[21]       ),
    .DO22 (              ),
    .DO23 (              ),
    .DO24 (              ),
    .DO25 (              ),
    .DO26 (              ),
    .DO27 (              ),
    .DO28 (              ),
    .DO29 (              ),
    .DO30 (              ),
    .DO31 (              ),
    .DI0  ( DI[0]        ),
    .DI1  ( DI[1]        ),
    .DI2  ( DI[2]        ),
    .DI3  ( DI[3]        ),
    .DI4  ( DI[4]        ),
    .DI5  ( DI[5]        ),
    .DI6  ( DI[6]        ),
    .DI7  ( DI[7]        ),
    .DI8  ( DI[8]        ),
    .DI9  ( DI[9]        ),
    .DI10 ( DI[10]       ),
    .DI11 ( DI[11]       ),
    .DI12 ( DI[12]       ),
    .DI13 ( DI[13]       ),
    .DI14 ( DI[14]       ),
    .DI15 ( DI[15]       ),
    .DI16 ( DI[16]       ),
    .DI17 ( DI[17]       ),
    .DI18 ( DI[18]       ),
    .DI19 ( DI[19]       ),
    .DI20 ( DI[20]       ),
    .DI21 ( DI[21]       ),
    .DI22 ( 1'b0         ),
    .DI23 ( 1'b0         ),
    .DI24 ( 1'b0         ),
    .DI25 ( 1'b0         ),
    .DI26 ( 1'b0         ),
    .DI27 ( 1'b0         ),
    .DI28 ( 1'b0         ),
    .DI29 ( 1'b0         ),
    .DI30 ( 1'b0         ),
    .DI31 ( 1'b0         ),
    .CK   ( CK           ),
    .WEB0 ( 1'b0         ),
    .WEB1 ( 1'b0         ),
    .WEB2 ( 1'b0         ),
    .WEB3 ( 1'b0         ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
`else
logic [21:0] data_out_pre;
logic [21:0] memory [64];

assign data_out_pre = CS ? memory[A] : 22'hx;

always_ff @(posedge CK) begin
    if (CS & WE) begin
        memory[A] <= DI;
    end
end

always_ff @(posedge CK) begin
    DO <= data_out_pre;
end
`endif

endmodule

/*--------------------------------------*/
// FILE: ../mdl/sram64x128.sv
/*--------------------------------------*/

module sram64x128 (
    input                CK,
    input                CS,
    input                WE,
    input        [  5:0] A,
    input        [ 15:0] BYTE,
    input        [127:0] DI,
    output logic [127:0] DO
);

`ifdef DC
SRAM i_SRAM_0 (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[0]        ),
    .DO1  ( DO[1]        ),
    .DO2  ( DO[2]        ),
    .DO3  ( DO[3]        ),
    .DO4  ( DO[4]        ),
    .DO5  ( DO[5]        ),
    .DO6  ( DO[6]        ),
    .DO7  ( DO[7]        ),
    .DO8  ( DO[8]        ),
    .DO9  ( DO[9]        ),
    .DO10 ( DO[10]       ),
    .DO11 ( DO[11]       ),
    .DO12 ( DO[12]       ),
    .DO13 ( DO[13]       ),
    .DO14 ( DO[14]       ),
    .DO15 ( DO[15]       ),
    .DO16 ( DO[16]       ),
    .DO17 ( DO[17]       ),
    .DO18 ( DO[18]       ),
    .DO19 ( DO[19]       ),
    .DO20 ( DO[20]       ),
    .DO21 ( DO[21]       ),
    .DO22 ( DO[22]       ),
    .DO23 ( DO[23]       ),
    .DO24 ( DO[24]       ),
    .DO25 ( DO[25]       ),
    .DO26 ( DO[26]       ),
    .DO27 ( DO[27]       ),
    .DO28 ( DO[28]       ),
    .DO29 ( DO[29]       ),
    .DO30 ( DO[30]       ),
    .DO31 ( DO[31]       ),
    .DI0  ( DI[0]        ),
    .DI1  ( DI[1]        ),
    .DI2  ( DI[2]        ),
    .DI3  ( DI[3]        ),
    .DI4  ( DI[4]        ),
    .DI5  ( DI[5]        ),
    .DI6  ( DI[6]        ),
    .DI7  ( DI[7]        ),
    .DI8  ( DI[8]        ),
    .DI9  ( DI[9]        ),
    .DI10 ( DI[10]       ),
    .DI11 ( DI[11]       ),
    .DI12 ( DI[12]       ),
    .DI13 ( DI[13]       ),
    .DI14 ( DI[14]       ),
    .DI15 ( DI[15]       ),
    .DI16 ( DI[16]       ),
    .DI17 ( DI[17]       ),
    .DI18 ( DI[18]       ),
    .DI19 ( DI[19]       ),
    .DI20 ( DI[20]       ),
    .DI21 ( DI[21]       ),
    .DI22 ( DI[22]       ),
    .DI23 ( DI[23]       ),
    .DI24 ( DI[24]       ),
    .DI25 ( DI[25]       ),
    .DI26 ( DI[26]       ),
    .DI27 ( DI[27]       ),
    .DI28 ( DI[28]       ),
    .DI29 ( DI[29]       ),
    .DI30 ( DI[30]       ),
    .DI31 ( DI[31]       ),
    .CK   ( CK           ),
    .WEB0 ( ~BYTE[0]     ),
    .WEB1 ( ~BYTE[1]     ),
    .WEB2 ( ~BYTE[2]     ),
    .WEB3 ( ~BYTE[3]     ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
SRAM i_SRAM_1 (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[32+0]     ),
    .DO1  ( DO[32+1]     ),
    .DO2  ( DO[32+2]     ),
    .DO3  ( DO[32+3]     ),
    .DO4  ( DO[32+4]     ),
    .DO5  ( DO[32+5]     ),
    .DO6  ( DO[32+6]     ),
    .DO7  ( DO[32+7]     ),
    .DO8  ( DO[32+8]     ),
    .DO9  ( DO[32+9]     ),
    .DO10 ( DO[32+10]    ),
    .DO11 ( DO[32+11]    ),
    .DO12 ( DO[32+12]    ),
    .DO13 ( DO[32+13]    ),
    .DO14 ( DO[32+14]    ),
    .DO15 ( DO[32+15]    ),
    .DO16 ( DO[32+16]    ),
    .DO17 ( DO[32+17]    ),
    .DO18 ( DO[32+18]    ),
    .DO19 ( DO[32+19]    ),
    .DO20 ( DO[32+20]    ),
    .DO21 ( DO[32+21]    ),
    .DO22 ( DO[32+22]    ),
    .DO23 ( DO[32+23]    ),
    .DO24 ( DO[32+24]    ),
    .DO25 ( DO[32+25]    ),
    .DO26 ( DO[32+26]    ),
    .DO27 ( DO[32+27]    ),
    .DO28 ( DO[32+28]    ),
    .DO29 ( DO[32+29]    ),
    .DO30 ( DO[32+30]    ),
    .DO31 ( DO[32+31]    ),
    .DI0  ( DI[32+0]     ),
    .DI1  ( DI[32+1]     ),
    .DI2  ( DI[32+2]     ),
    .DI3  ( DI[32+3]     ),
    .DI4  ( DI[32+4]     ),
    .DI5  ( DI[32+5]     ),
    .DI6  ( DI[32+6]     ),
    .DI7  ( DI[32+7]     ),
    .DI8  ( DI[32+8]     ),
    .DI9  ( DI[32+9]     ),
    .DI10 ( DI[32+10]    ),
    .DI11 ( DI[32+11]    ),
    .DI12 ( DI[32+12]    ),
    .DI13 ( DI[32+13]    ),
    .DI14 ( DI[32+14]    ),
    .DI15 ( DI[32+15]    ),
    .DI16 ( DI[32+16]    ),
    .DI17 ( DI[32+17]    ),
    .DI18 ( DI[32+18]    ),
    .DI19 ( DI[32+19]    ),
    .DI20 ( DI[32+20]    ),
    .DI21 ( DI[32+21]    ),
    .DI22 ( DI[32+22]    ),
    .DI23 ( DI[32+23]    ),
    .DI24 ( DI[32+24]    ),
    .DI25 ( DI[32+25]    ),
    .DI26 ( DI[32+26]    ),
    .DI27 ( DI[32+27]    ),
    .DI28 ( DI[32+28]    ),
    .DI29 ( DI[32+29]    ),
    .DI30 ( DI[32+30]    ),
    .DI31 ( DI[32+31]    ),
    .CK   ( CK           ),
    .WEB0 ( ~BYTE[4+0]   ),
    .WEB1 ( ~BYTE[4+1]   ),
    .WEB2 ( ~BYTE[4+2]   ),
    .WEB3 ( ~BYTE[4+3]   ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
SRAM i_SRAM_2 (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[64+0]     ),
    .DO1  ( DO[64+1]     ),
    .DO2  ( DO[64+2]     ),
    .DO3  ( DO[64+3]     ),
    .DO4  ( DO[64+4]     ),
    .DO5  ( DO[64+5]     ),
    .DO6  ( DO[64+6]     ),
    .DO7  ( DO[64+7]     ),
    .DO8  ( DO[64+8]     ),
    .DO9  ( DO[64+9]     ),
    .DO10 ( DO[64+10]    ),
    .DO11 ( DO[64+11]    ),
    .DO12 ( DO[64+12]    ),
    .DO13 ( DO[64+13]    ),
    .DO14 ( DO[64+14]    ),
    .DO15 ( DO[64+15]    ),
    .DO16 ( DO[64+16]    ),
    .DO17 ( DO[64+17]    ),
    .DO18 ( DO[64+18]    ),
    .DO19 ( DO[64+19]    ),
    .DO20 ( DO[64+20]    ),
    .DO21 ( DO[64+21]    ),
    .DO22 ( DO[64+22]    ),
    .DO23 ( DO[64+23]    ),
    .DO24 ( DO[64+24]    ),
    .DO25 ( DO[64+25]    ),
    .DO26 ( DO[64+26]    ),
    .DO27 ( DO[64+27]    ),
    .DO28 ( DO[64+28]    ),
    .DO29 ( DO[64+29]    ),
    .DO30 ( DO[64+30]    ),
    .DO31 ( DO[64+31]    ),
    .DI0  ( DI[64+0]     ),
    .DI1  ( DI[64+1]     ),
    .DI2  ( DI[64+2]     ),
    .DI3  ( DI[64+3]     ),
    .DI4  ( DI[64+4]     ),
    .DI5  ( DI[64+5]     ),
    .DI6  ( DI[64+6]     ),
    .DI7  ( DI[64+7]     ),
    .DI8  ( DI[64+8]     ),
    .DI9  ( DI[64+9]     ),
    .DI10 ( DI[64+10]    ),
    .DI11 ( DI[64+11]    ),
    .DI12 ( DI[64+12]    ),
    .DI13 ( DI[64+13]    ),
    .DI14 ( DI[64+14]    ),
    .DI15 ( DI[64+15]    ),
    .DI16 ( DI[64+16]    ),
    .DI17 ( DI[64+17]    ),
    .DI18 ( DI[64+18]    ),
    .DI19 ( DI[64+19]    ),
    .DI20 ( DI[64+20]    ),
    .DI21 ( DI[64+21]    ),
    .DI22 ( DI[64+22]    ),
    .DI23 ( DI[64+23]    ),
    .DI24 ( DI[64+24]    ),
    .DI25 ( DI[64+25]    ),
    .DI26 ( DI[64+26]    ),
    .DI27 ( DI[64+27]    ),
    .DI28 ( DI[64+28]    ),
    .DI29 ( DI[64+29]    ),
    .DI30 ( DI[64+30]    ),
    .DI31 ( DI[64+31]    ),
    .CK   ( CK           ),
    .WEB0 ( ~BYTE[8+0]   ),
    .WEB1 ( ~BYTE[8+1]   ),
    .WEB2 ( ~BYTE[8+2]   ),
    .WEB3 ( ~BYTE[8+3]   ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
SRAM i_SRAM_3 (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[96+0]     ),
    .DO1  ( DO[96+1]     ),
    .DO2  ( DO[96+2]     ),
    .DO3  ( DO[96+3]     ),
    .DO4  ( DO[96+4]     ),
    .DO5  ( DO[96+5]     ),
    .DO6  ( DO[96+6]     ),
    .DO7  ( DO[96+7]     ),
    .DO8  ( DO[96+8]     ),
    .DO9  ( DO[96+9]     ),
    .DO10 ( DO[96+10]    ),
    .DO11 ( DO[96+11]    ),
    .DO12 ( DO[96+12]    ),
    .DO13 ( DO[96+13]    ),
    .DO14 ( DO[96+14]    ),
    .DO15 ( DO[96+15]    ),
    .DO16 ( DO[96+16]    ),
    .DO17 ( DO[96+17]    ),
    .DO18 ( DO[96+18]    ),
    .DO19 ( DO[96+19]    ),
    .DO20 ( DO[96+20]    ),
    .DO21 ( DO[96+21]    ),
    .DO22 ( DO[96+22]    ),
    .DO23 ( DO[96+23]    ),
    .DO24 ( DO[96+24]    ),
    .DO25 ( DO[96+25]    ),
    .DO26 ( DO[96+26]    ),
    .DO27 ( DO[96+27]    ),
    .DO28 ( DO[96+28]    ),
    .DO29 ( DO[96+29]    ),
    .DO30 ( DO[96+30]    ),
    .DO31 ( DO[96+31]    ),
    .DI0  ( DI[96+0]     ),
    .DI1  ( DI[96+1]     ),
    .DI2  ( DI[96+2]     ),
    .DI3  ( DI[96+3]     ),
    .DI4  ( DI[96+4]     ),
    .DI5  ( DI[96+5]     ),
    .DI6  ( DI[96+6]     ),
    .DI7  ( DI[96+7]     ),
    .DI8  ( DI[96+8]     ),
    .DI9  ( DI[96+9]     ),
    .DI10 ( DI[96+10]    ),
    .DI11 ( DI[96+11]    ),
    .DI12 ( DI[96+12]    ),
    .DI13 ( DI[96+13]    ),
    .DI14 ( DI[96+14]    ),
    .DI15 ( DI[96+15]    ),
    .DI16 ( DI[96+16]    ),
    .DI17 ( DI[96+17]    ),
    .DI18 ( DI[96+18]    ),
    .DI19 ( DI[96+19]    ),
    .DI20 ( DI[96+20]    ),
    .DI21 ( DI[96+21]    ),
    .DI22 ( DI[96+22]    ),
    .DI23 ( DI[96+23]    ),
    .DI24 ( DI[96+24]    ),
    .DI25 ( DI[96+25]    ),
    .DI26 ( DI[96+26]    ),
    .DI27 ( DI[96+27]    ),
    .DI28 ( DI[96+28]    ),
    .DI29 ( DI[96+29]    ),
    .DI30 ( DI[96+30]    ),
    .DI31 ( DI[96+31]    ),
    .CK   ( CK           ),
    .WEB0 ( ~BYTE[12+0]  ),
    .WEB1 ( ~BYTE[12+1]  ),
    .WEB2 ( ~BYTE[12+2]  ),
    .WEB3 ( ~BYTE[12+3]  ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
`else
logic [127:0] data_out_pre;
logic [127:0] memory [64];

assign data_out_pre = CS ? memory[A] : 128'hx;

always_ff @(posedge CK) begin
    integer i;

    if (CS & WE) begin
        for (i = 0; i < 16; i = i + 1) begin
            if (BYTE[i]) memory[A][i*8+:8] <= DI[i*8+:8];
        end
    end
end

always_ff @(posedge CK) begin
    DO <= data_out_pre;
end
`endif

endmodule
