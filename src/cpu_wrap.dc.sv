`define DC
/*-----------------------------------------------------*/
// cpu_wrap.all.sv is generated by /home/fred2/RISCV/./script/merge_sv.sh
//
//                                         2023-03-28
//                                           22:28:22
/*-----------------------------------------------------*/

/*--------------------------------------*/
// FILE: ../src/cpu/cpu_wrap.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

//`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif

`define MDU_OP_LEN 4
`define ALU_OP_LEN 4
`define BPU_OP_LEN 2
`define CSR_OP_LEN 2
`define AMO_OP_LEN 4

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define GPR_ZERO_ADDR 5'b00000
`define GPR_RA_ADDR   5'b00001
`define GPR_SP_ADDR   5'b00010
`define GPR_GP_ADDR   5'b00011
`define GPR_TP_ADDR   5'b00100
`define GPR_T0_ADDR   5'b00101
`define GPR_T1_ADDR   5'b00110
`define GPR_T2_ADDR   5'b00111
`define GPR_S0_ADDR   5'b01000
`define GPR_FP_ADDR   5'b01000
`define GPR_S1_ADDR   5'b01001
`define GPR_A0_ADDR   5'b01010
`define GPR_A1_ADDR   5'b01011
`define GPR_A2_ADDR   5'b01100
`define GPR_A3_ADDR   5'b01101
`define GPR_A4_ADDR   5'b01110
`define GPR_A5_ADDR   5'b01111
`define GPR_A6_ADDR   5'b10000
`define GPR_A7_ADDR   5'b10001
`define GPR_S2_ADDR   5'b10010
`define GPR_S3_ADDR   5'b10011
`define GPR_S4_ADDR   5'b10100
`define GPR_S5_ADDR   5'b10101
`define GPR_S6_ADDR   5'b10110
`define GPR_S7_ADDR   5'b10111
`define GPR_S8_ADDR   5'b11000
`define GPR_S9_ADDR   5'b11001
`define GPR_S10_ADDR  5'b11010
`define GPR_S11_ADDR  5'b11011
`define GPR_T3_ADDR   5'b11100
`define GPR_T4_ADDR   5'b11101
`define GPR_T5_ADDR   5'b11110
`define GPR_T6_ADDR   5'b11111

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       'h0
`define CAUSE_INSTRUCTION_ACCESS     'h1
`define CAUSE_ILLEGAL_INSTRUCTION    'h2
`define CAUSE_BREAKPOINT             'h3
`define CAUSE_MISALIGNED_LOAD        'h4
`define CAUSE_LOAD_ACCESS            'h5
`define CAUSE_MISALIGNED_STORE       'h6
`define CAUSE_STORE_ACCESS           'h7
`define CAUSE_USER_ECALL             'h8
`define CAUSE_SUPERVISOR_ECALL       'h9
`define CAUSE_HYPERVISOR_ECALL       'ha
`define CAUSE_MACHINE_ECALL          'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT 'hc
`define CAUSE_LOAD_PAGE_FAULT        'hd
`define CAUSE_STORE_PAGE_FAULT       'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`define MCAUSE_CODE_WIDTH 6

`define MISA_MXL_XLEN_32  2'b01
`define MISA_MXL_XLEN_64  2'b10
`define MISA_MXL_XLEN_128 2'b11

`define SATP32_PPN_WIDTH  22
`define SATP32_ASID_WIDTH  9
`define SATP32_MODE_WIDTH  1

`define SATP64_PPN_WIDTH  44
`define SATP64_ASID_WIDTH 16
`define SATP64_MODE_WIDTH  4

`define SATP32_PPN_BIT     0+:`SATP32_PPN_WIDTH
`define SATP32_ASID_BIT   22+:`SATP32_ASID_WIDTH
`define SATP32_MODE_BIT   31+:`SATP32_MODE_WIDTH

`define SATP64_PPN_BIT     0+:`SATP64_PPN_WIDTH
`define SATP64_ASID_BIT   44+:`SATP64_ASID_WIDTH
`define SATP64_MODE_BIT   60+:`SATP64_MODE_WIDTH

`ifdef RV32
`define SATP_PPN_WIDTH  `SATP32_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP32_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP32_MODE_WIDTH
`define PADDR_LEN       (`SATP32_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`else
`define SATP_PPN_WIDTH  `SATP64_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP64_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP64_MODE_WIDTH
`define PADDR_LEN       (`SATP64_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`define SATP_MODE_SV39  `SATP_MODE_WIDTH'h8
`define SATP_MODE_SV48  `SATP_MODE_WIDTH'h9
`define SATP_MODE_SV57  `SATP_MODE_WIDTH'ha
`define SATP_MODE_SV64  `SATP_MODE_WIDTH'hb
`endif

`define PTE_V_BIT     0
`define PTE_R_BIT     1
`define PTE_W_BIT     2
`define PTE_X_BIT     3
`define PTE_U_BIT     4
`define PTE_G_BIT     5
`define PTE_A_BIT     6
`define PTE_D_BIT     7
`define PTE_RSW_BIT   8:9
`define PTE_PPN_SHIFT 10

`endif
`ifndef __INTF_DEFINE__
`define __INTF_DEFINE__

`define AXI_INTF_CONNECT(PORT, WIRE) \
    .``PORT``_awburst ( WIRE``_awburst ), \
    .``PORT``_awid    ( WIRE``_awid    ), \
    .``PORT``_awaddr  ( WIRE``_awaddr  ), \
    .``PORT``_awsize  ( WIRE``_awsize  ), \
    .``PORT``_awlen   ( WIRE``_awlen   ), \
    .``PORT``_awlock  ( WIRE``_awlock  ), \
    .``PORT``_awcache ( WIRE``_awcache ), \
    .``PORT``_awprot  ( WIRE``_awprot  ), \
    .``PORT``_awvalid ( WIRE``_awvalid ), \
    .``PORT``_awready ( WIRE``_awready ), \
    .``PORT``_wstrb   ( WIRE``_wstrb   ), \
    .``PORT``_wid     ( WIRE``_wid     ), \
    .``PORT``_wdata   ( WIRE``_wdata   ), \
    .``PORT``_wlast   ( WIRE``_wlast   ), \
    .``PORT``_wvalid  ( WIRE``_wvalid  ), \
    .``PORT``_wready  ( WIRE``_wready  ), \
    .``PORT``_bid     ( WIRE``_bid     ), \
    .``PORT``_bresp   ( WIRE``_bresp   ), \
    .``PORT``_bvalid  ( WIRE``_bvalid  ), \
    .``PORT``_bready  ( WIRE``_bready  ), \
    .``PORT``_araddr  ( WIRE``_araddr  ), \
    .``PORT``_arburst ( WIRE``_arburst ), \
    .``PORT``_arsize  ( WIRE``_arsize  ), \
    .``PORT``_arid    ( WIRE``_arid    ), \
    .``PORT``_arlen   ( WIRE``_arlen   ), \
    .``PORT``_arlock  ( WIRE``_arlock  ), \
    .``PORT``_arcache ( WIRE``_arcache ), \
    .``PORT``_arprot  ( WIRE``_arprot  ), \
    .``PORT``_arvalid ( WIRE``_arvalid ), \
    .``PORT``_arready ( WIRE``_arready ), \
    .``PORT``_rdata   ( WIRE``_rdata   ), \
    .``PORT``_rresp   ( WIRE``_rresp   ), \
    .``PORT``_rid     ( WIRE``_rid     ), \
    .``PORT``_rlast   ( WIRE``_rlast   ), \
    .``PORT``_rvalid  ( WIRE``_rvalid  ), \
    .``PORT``_rready  ( WIRE``_rready  )

`define AXI_INTF_SLV_DEF(NAME, ID) \
    input         [     1: 0] NAME``_awburst, \
    input         [ID - 1: 0] NAME``_awid,    \
    input         [    31: 0] NAME``_awaddr,  \
    input         [     2: 0] NAME``_awsize,  \
    input         [     7: 0] NAME``_awlen,   \
    input         [     1: 0] NAME``_awlock,  \
    input         [     3: 0] NAME``_awcache, \
    input         [     2: 0] NAME``_awprot,  \
    input                     NAME``_awvalid, \
    output logic              NAME``_awready, \
    input         [     3: 0] NAME``_wstrb,   \
    input         [ID - 1: 0] NAME``_wid,     \
    input         [    31: 0] NAME``_wdata,   \
    input                     NAME``_wlast,   \
    input                     NAME``_wvalid,  \
    output logic              NAME``_wready,  \
    output logic  [ID - 1: 0] NAME``_bid,     \
    output logic  [     1: 0] NAME``_bresp,   \
    output logic              NAME``_bvalid,  \
    input                     NAME``_bready,  \
    input         [    31: 0] NAME``_araddr,  \
    input         [     1: 0] NAME``_arburst, \
    input         [     2: 0] NAME``_arsize,  \
    input         [ID - 1: 0] NAME``_arid,    \
    input         [     7: 0] NAME``_arlen,   \
    input         [     1: 0] NAME``_arlock,  \
    input         [     3: 0] NAME``_arcache, \
    input         [     2: 0] NAME``_arprot,  \
    input                     NAME``_arvalid, \
    output logic              NAME``_arready, \
    output logic  [    31: 0] NAME``_rdata,   \
    output logic  [     1: 0] NAME``_rresp,   \
    output logic  [ID - 1: 0] NAME``_rid,     \
    output logic              NAME``_rlast,   \
    output logic              NAME``_rvalid,  \
    input                     NAME``_rready

`define AXI_INTF_MST_DEF(NAME, ID) \
    output logic  [     1: 0] NAME``_awburst, \
    output logic  [ID - 1: 0] NAME``_awid,    \
    output logic  [    31: 0] NAME``_awaddr,  \
    output logic  [     2: 0] NAME``_awsize,  \
    output logic  [     7: 0] NAME``_awlen,   \
    output logic  [     1: 0] NAME``_awlock,  \
    output logic  [     3: 0] NAME``_awcache, \
    output logic  [     2: 0] NAME``_awprot,  \
    output logic              NAME``_awvalid, \
    input                     NAME``_awready, \
    output logic  [     3: 0] NAME``_wstrb,   \
    output logic  [ID - 1: 0] NAME``_wid,     \
    output logic  [    31: 0] NAME``_wdata,   \
    output logic              NAME``_wlast,   \
    output logic              NAME``_wvalid,  \
    input                     NAME``_wready,  \
    input         [ID - 1: 0] NAME``_bid,     \
    input         [     1: 0] NAME``_bresp,   \
    input                     NAME``_bvalid,  \
    output logic              NAME``_bready,  \
    output logic  [    31: 0] NAME``_araddr,  \
    output logic  [     1: 0] NAME``_arburst, \
    output logic  [     2: 0] NAME``_arsize,  \
    output logic  [ID - 1: 0] NAME``_arid,    \
    output logic  [     7: 0] NAME``_arlen,   \
    output logic  [     1: 0] NAME``_arlock,  \
    output logic  [     3: 0] NAME``_arcache, \
    output logic  [     2: 0] NAME``_arprot,  \
    output logic              NAME``_arvalid, \
    input                     NAME``_arready, \
    input         [    31: 0] NAME``_rdata,   \
    input         [     1: 0] NAME``_rresp,   \
    input         [ID - 1: 0] NAME``_rid,     \
    input                     NAME``_rlast,   \
    input                     NAME``_rvalid,  \
    output logic              NAME``_rready

`define AXI_INTF_DEF(NAME, ID) \
    logic  [     1: 0] NAME``_awburst; \
    logic  [ID - 1: 0] NAME``_awid;    \
    logic  [    31: 0] NAME``_awaddr;  \
    logic  [     2: 0] NAME``_awsize;  \
    logic  [     7: 0] NAME``_awlen;   \
    logic  [     1: 0] NAME``_awlock;  \
    logic  [     3: 0] NAME``_awcache; \
    logic  [     2: 0] NAME``_awprot;  \
    logic              NAME``_awvalid; \
    logic              NAME``_awready; \
    logic  [     3: 0] NAME``_wstrb;   \
    logic  [ID - 1: 0] NAME``_wid;     \
    logic  [    31: 0] NAME``_wdata;   \
    logic              NAME``_wlast;   \
    logic              NAME``_wvalid;  \
    logic              NAME``_wready;  \
    logic  [ID - 1: 0] NAME``_bid;     \
    logic  [     1: 0] NAME``_bresp;   \
    logic              NAME``_bvalid;  \
    logic              NAME``_bready;  \
    logic  [    31: 0] NAME``_araddr;  \
    logic  [     1: 0] NAME``_arburst; \
    logic  [     2: 0] NAME``_arsize;  \
    logic  [ID - 1: 0] NAME``_arid;    \
    logic  [     7: 0] NAME``_arlen;   \
    logic  [     1: 0] NAME``_arlock;  \
    logic  [     3: 0] NAME``_arcache; \
    logic  [     2: 0] NAME``_arprot;  \
    logic              NAME``_arvalid; \
    logic              NAME``_arready; \
    logic  [    31: 0] NAME``_rdata;   \
    logic  [     1: 0] NAME``_rresp;   \
    logic  [ID - 1: 0] NAME``_rid;     \
    logic              NAME``_rlast;   \
    logic              NAME``_rvalid;  \
    logic              NAME``_rready;

`define APB_MST_PORT_TO_INTF(PORT, INTF)    \
    assign INTF``.psel    = PORT``_psel;    \
    assign INTF``.penable = PORT``_penable; \
    assign INTF``.paddr   = PORT``_paddr;   \
    assign INTF``.pwrite  = PORT``_pwrite;  \
    assign INTF``.pstrb   = PORT``_pstrb;   \
    assign INTF``.pprot   = PORT``_pprot;   \
    assign INTF``.pwdata  = PORT``_pwdata;  \
    assign PORT``_prdata  = INTF``.prdata;  \
    assign PORT``_pslverr = INTF``.pslverr; \
    assign PORT``_pready  = INTF``.pready;

`define APB_MST_INTF_TO_PORT(INTF, PORT)    \
    assign PORT``_psel    = INTF``.psel;    \
    assign PORT``_penable = INTF``.penable; \
    assign PORT``_paddr   = INTF``.paddr;   \
    assign PORT``_pwrite  = INTF``.pwrite;  \
    assign PORT``_pstrb   = INTF``.pstrb;   \
    assign PORT``_pprot   = INTF``.pprot;   \
    assign PORT``_pwdata  = INTF``.pwdata;  \
    assign INTF``.prdata  = PORT``_prdata;  \
    assign INTF``.pslverr = PORT``_pslverr; \
    assign INTF``.pready  = PORT``_pready;

`define AXI_MST_PORT_TO_INTF(PORT, INTF)    \
    assign INTF``.awid    = PORT``_awid;    \
    assign INTF``.awaddr  = PORT``_awaddr;  \
    assign INTF``.awburst = PORT``_awburst; \
    assign INTF``.awsize  = PORT``_awsize;  \
    assign INTF``.awlen   = PORT``_awlen;   \
    assign INTF``.awlock  = PORT``_awlock;  \
    assign INTF``.awcache = PORT``_awcache; \
    assign INTF``.awprot  = PORT``_awprot;  \
    assign INTF``.awvalid = PORT``_awvalid; \
    assign PORT``_awready = INTF``.awready; \
    assign INTF``.wid     = PORT``_wid;     \
    assign INTF``.wstrb   = PORT``_wstrb;   \
    assign INTF``.wdata   = PORT``_wdata;   \
    assign INTF``.wlast   = PORT``_wlast;   \
    assign INTF``.wvalid  = PORT``_wvalid;  \
    assign PORT``_wready  = INTF``.wready;  \
    assign PORT``_bid     = INTF``.bid;     \
    assign PORT``_bresp   = INTF``.bresp;   \
    assign PORT``_bvalid  = INTF``.bvalid;  \
    assign INTF``.bready  = PORT``_bready;  \
    assign INTF``.arid    = PORT``_arid;    \
    assign INTF``.araddr  = PORT``_araddr;  \
    assign INTF``.arburst = PORT``_arburst; \
    assign INTF``.arsize  = PORT``_arsize;  \
    assign INTF``.arlen   = PORT``_arlen;   \
    assign INTF``.arlock  = PORT``_arlock;  \
    assign INTF``.arcache = PORT``_arcache; \
    assign INTF``.arprot  = PORT``_arprot;  \
    assign INTF``.arvalid = PORT``_arvalid; \
    assign PORT``_arready = INTF``.arready; \
    assign PORT``_rid     = INTF``.rid;     \
    assign PORT``_rdata   = INTF``.rdata;   \
    assign PORT``_rresp   = INTF``.rresp;   \
    assign PORT``_rlast   = INTF``.rlast;   \
    assign PORT``_rvalid  = INTF``.rvalid;  \
    assign INTF``.rready  = PORT``_rready;


`define AXI_MST_INTF_TO_PORT(INTF, PORT)    \
    assign PORT``_awid    = INTF``.awid;    \
    assign PORT``_awaddr  = INTF``.awaddr;  \
    assign PORT``_awburst = INTF``.awburst; \
    assign PORT``_awsize  = INTF``.awsize;  \
    assign PORT``_awlen   = INTF``.awlen;   \
    assign PORT``_awlock  = INTF``.awlock;  \
    assign PORT``_awcache = INTF``.awcache; \
    assign PORT``_awprot  = INTF``.awprot;  \
    assign PORT``_awvalid = INTF``.awvalid; \
    assign INTF``.awready = PORT``_awready; \
    assign PORT``_wid     = INTF``.wid;     \
    assign PORT``_wstrb   = INTF``.wstrb;   \
    assign PORT``_wdata   = INTF``.wdata;   \
    assign PORT``_wlast   = INTF``.wlast;   \
    assign PORT``_wvalid  = INTF``.wvalid;  \
    assign INTF``.wready  = PORT``_wready;  \
    assign INTF``.bid     = PORT``_bid;     \
    assign INTF``.bresp   = PORT``_bresp;   \
    assign INTF``.bvalid  = PORT``_bvalid;  \
    assign PORT``_bready  = INTF``.bready;  \
    assign PORT``_arid    = INTF``.arid;    \
    assign PORT``_araddr  = INTF``.araddr;  \
    assign PORT``_arburst = INTF``.arburst; \
    assign PORT``_arsize  = INTF``.arsize;  \
    assign PORT``_arlen   = INTF``.arlen;   \
    assign PORT``_arlock  = INTF``.arlock;  \
    assign PORT``_arcache = INTF``.arcache; \
    assign PORT``_arprot  = INTF``.arprot;  \
    assign PORT``_arvalid = INTF``.arvalid; \
    assign INTF``.arready = PORT``_arready; \
    assign INTF``.rid     = PORT``_rid;     \
    assign INTF``.rdata   = PORT``_rdata;   \
    assign INTF``.rresp   = PORT``_rresp;   \
    assign INTF``.rlast   = PORT``_rlast;   \
    assign INTF``.rvalid  = PORT``_rvalid;  \
    assign PORT``_rready  = INTF``.rready;

`endif
`ifndef __CACHE_DEFINE__
`define __CACHE_DEFINE__

`ifdef RV32
`define CACHE_DATA_WIDTH 32
`define CACHE_ADDR_WIDTH 32
`else
`define CACHE_DATA_WIDTH 64
`define CACHE_ADDR_WIDTH 32
`endif
`define CACHE_BLK_WIDTH  4
`define CACHE_IDX_WIDTH  6
`define CACHE_TAG_WIDTH  (`CACHE_ADDR_WIDTH - `CACHE_BLK_WIDTH - `CACHE_IDX_WIDTH)
`define CACHE_TAG_REGION (`CACHE_BLK_WIDTH + `CACHE_IDX_WIDTH)+:`CACHE_TAG_WIDTH
`define CACHE_BLK_SIZE   2 ** (`CACHE_BLK_WIDTH + 3)

`endif

module cpu_wrap (
    input                  clk,
    input                  clk_32k,
    input                  rstn,

    // DDR AXI interface
    output logic  [  1: 0] ddr_m_awburst,
    output logic  [  5: 0] ddr_m_awid,
    output logic  [ 31: 0] ddr_m_awaddr,
    output logic  [  2: 0] ddr_m_awsize,
    output logic  [  7: 0] ddr_m_awlen,
    output logic  [  1: 0] ddr_m_awlock,
    output logic  [  3: 0] ddr_m_awcache,
    output logic  [  2: 0] ddr_m_awprot,
    output logic           ddr_m_awvalid,
    input                  ddr_m_awready,
    output logic  [  3: 0] ddr_m_wstrb,
    output logic  [  5: 0] ddr_m_wid,
    output logic  [ 31: 0] ddr_m_wdata,
    output logic           ddr_m_wlast,
    output logic           ddr_m_wvalid,
    input                  ddr_m_wready,
    input         [  5: 0] ddr_m_bid,
    input         [  1: 0] ddr_m_bresp,
    input                  ddr_m_bvalid,
    output logic           ddr_m_bready,
    output logic  [ 31: 0] ddr_m_araddr,
    output logic  [  1: 0] ddr_m_arburst,
    output logic  [  2: 0] ddr_m_arsize,
    output logic  [  5: 0] ddr_m_arid,
    output logic  [  7: 0] ddr_m_arlen,
    output logic  [  1: 0] ddr_m_arlock,
    output logic  [  3: 0] ddr_m_arcache,
    output logic  [  2: 0] ddr_m_arprot,
    output logic           ddr_m_arvalid,
    input                  ddr_m_arready,
    input         [ 31: 0] ddr_m_rdata,
    input         [  1: 0] ddr_m_rresp,
    input         [  5: 0] ddr_m_rid,
    input                  ddr_m_rlast,
    input                  ddr_m_rvalid,
    output logic           ddr_m_rready,

    // external AXI interface
    input         [  1: 0] ext_s_awburst,
    input         [  7: 0] ext_s_awid,
    input         [ 31: 0] ext_s_awaddr,
    input         [  2: 0] ext_s_awsize,
    input         [  7: 0] ext_s_awlen,
    input         [  1: 0] ext_s_awlock,
    input         [  3: 0] ext_s_awcache,
    input         [  2: 0] ext_s_awprot,
    input                  ext_s_awvalid,
    output logic           ext_s_awready,
    input         [  3: 0] ext_s_wstrb,
    input         [  7: 0] ext_s_wid,
    input         [ 31: 0] ext_s_wdata,
    input                  ext_s_wlast,
    input                  ext_s_wvalid,
    output logic           ext_s_wready,
    output logic  [  7: 0] ext_s_bid,
    output logic  [  1: 0] ext_s_bresp,
    output logic           ext_s_bvalid,
    input                  ext_s_bready,
    input         [ 31: 0] ext_s_araddr,
    input         [  1: 0] ext_s_arburst,
    input         [  2: 0] ext_s_arsize,
    input         [  7: 0] ext_s_arid,
    input         [  7: 0] ext_s_arlen,
    input         [  1: 0] ext_s_arlock,
    input         [  3: 0] ext_s_arcache,
    input         [  2: 0] ext_s_arprot,
    input                  ext_s_arvalid,
    output logic           ext_s_arready,
    output logic  [ 31: 0] ext_s_rdata,
    output logic  [  1: 0] ext_s_rresp,
    output logic  [  7: 0] ext_s_rid,
    output logic           ext_s_rlast,
    output logic           ext_s_rvalid,
    input                  ext_s_rready,

    // debug APB interface
    input                  dbg_psel,
    input                  dbg_penable,
    input         [ 31: 0] dbg_paddr,
    input                  dbg_pwrite,
    input         [  3: 0] dbg_pstrb,
    input         [  2: 0] dbg_pprot,
    input         [ 31: 0] dbg_pwdata,
    output logic  [ 31: 0] dbg_prdata,
    output logic           dbg_pslverr,
    output logic           dbg_pready,

    // UART interface
    output logic           uart_tx,
    input                  uart_rx,

    // SPI interface
    // inout                  sclk,
    // inout                  nss,
    // inout                  mosi,
    // inout                  miso
    output                 sclk,
    output                 nss,
    output                 mosi,
    input                  miso,

    // RMII interface
    input                  rmii_refclk,
    input                  rmii_crsdv,
    input         [ 1: 0]  rmii_rxd,
    output                 rmii_txen,
    output        [ 1: 0]  rmii_txd,

    // JTAG interface
    input                  tck,
    input                  tms,
    input                  tdi,
    output                 tdo
);

logic                             core_rstn;
logic                             srstn;
logic                             xrstn;
logic                             rv64_mode;
logic [              `XLEN - 1:0] core_bootvec;
logic [                     31:0] ddr_offset;

logic [                     63:0] systime;

logic                             msip;
logic                             mtip;
logic                             meip;
logic                             seip;

logic                             imem_en;
logic [       `IM_ADDR_LEN - 1:0] imem_addr;
logic [  `CACHE_DATA_WIDTH - 1:0] imem_rdata;
logic [                      1:0] imem_bad;
logic                             imem_busy;

logic                             xmon_xstate;
logic                             dmem_en;
logic [       `IM_ADDR_LEN - 1:0] dmem_addr;
logic                             dmem_write;
logic                             dmem_ex;
logic                             dmem_xstate;
logic [`CACHE_DATA_WIDTH/8 - 1:0] dmem_strb;
logic [  `CACHE_DATA_WIDTH - 1:0] dmem_wdata;
logic [  `CACHE_DATA_WIDTH - 1:0] dmem_rdata;
logic [                      1:0] dmem_bad;
logic                             dmem_busy;

logic [                  8 - 1:0] pmpcfg  [16];
logic [              `XLEN - 1:0] pmpaddr [16];
logic [                  8 - 1:0] pmacfg  [16];
logic [              `XLEN - 1:0] pmaaddr [16];

logic                             ipmp_v;
logic                             ipmp_l;
logic                             ipmp_x;
logic                             ipmp_w;
logic                             ipmp_r;
logic                             ipma_v;
logic                             ipma_l;
logic                             ipma_c;
logic                             ipma_e;

logic                             dpmp_v;
logic                             dpmp_l;
logic                             dpmp_x;
logic                             dpmp_w;
logic                             dpmp_r;
logic                             dpma_v;
logic                             dpma_l;
logic                             dpma_c;
logic                             dpma_e;

logic [    `SATP_PPN_WIDTH - 1:0] satp_ppn;
logic [   `SATP_ASID_WIDTH - 1:0] satp_asid;
logic [   `SATP_MODE_WIDTH - 1:0] satp_mode;
logic [                      1:0] prv;
logic                             sum;
logic                             mprv;
logic [                      1:0] mpp;
logic                             tlb_flush_req;
logic                             tlb_flush_all_vaddr;
logic                             tlb_flush_all_asid;
logic [              `XLEN - 1:0] tlb_flush_vaddr;
logic [              `XLEN - 1:0] tlb_flush_asid;
logic                             ic_flush;

logic          mem_ck_0;
logic          mem_ck_1;

logic          cs_0;
logic          we_0;
logic [ 31: 0] addr_0;
logic [  3: 0] byte_0;
logic [ 31: 0] di_0;
logic [ 31: 0] do_0;
logic          busy_0;
              
logic          cs_1;
logic          we_1;
logic [ 31: 0] addr_1;
logic [  3: 0] byte_1;
logic [ 31: 0] di_1;
logic [ 31: 0] do_1;
logic          busy_1;

logic          icache_bypass;
logic          immu_pa_vld;
logic [  1: 0] immu_pa_bad;
logic [ 55: 0] immu_pa;
logic          immu_pa_pre_vld;
logic [ 63: 0] immu_pa_pre;

logic          dcache_bypass;
logic          dmmu_pa_vld;
logic [  1: 0] dmmu_pa_bad;
logic [ 55: 0] dmmu_pa;
logic          dmmu_pa_pre_vld;
logic          dmmu_pa_pre_wr;
logic          dmmu_pa_pre_rd;
logic          dmmu_pa_pre_ex;
logic [ 63: 0] dmmu_pa_pre;

logic          core_psel;
logic          core_penable;
logic [ 31: 0] core_paddr;
logic          core_pwrite;
logic [  3: 0] core_pstrb;
logic [ 31: 0] core_pwdata;
logic [ 31: 0] core_prdata;
logic          core_pslverr;
logic          core_pready;

logic          intc_psel;
logic          intc_penable;
logic [ 31: 0] intc_paddr;
logic          intc_pwrite;
logic [  3: 0] intc_pstrb;
logic [ 31: 0] intc_pwdata;
logic [ 31: 0] intc_prdata;
logic          intc_pslverr;
logic          intc_pready;
logic [ 31: 0] ints;

logic          cfgreg_psel;
logic          cfgreg_penable;
logic [ 31: 0] cfgreg_paddr;
logic          cfgreg_pwrite;
logic [  3: 0] cfgreg_pstrb;
logic [ 31: 0] cfgreg_pwdata;
logic [ 31: 0] cfgreg_prdata;
logic          cfgreg_pslverr;
logic          cfgreg_pready;

logic [ 31: 0] m0_snp_addr;
logic          m0_snp_valid;
logic          m0_snp_ready;

logic [ 31: 0] m1_snp_addr;
logic          m1_snp_valid;
logic          m1_snp_ready;

logic          uart_irq;
logic          spi_irq;
logic          mac_irq;

logic [`XLEN - 1: 0] dbg_gpr_all [32];
logic [       11: 0] dbg_addr;
logic [`XLEN - 1: 0] dbg_wdata;
logic                dbg_gpr_rd;
logic                dbg_gpr_wr;
logic [`XLEN - 1: 0] dbg_gpr_rdata;
logic                dbg_csr_rd;
logic                dbg_csr_wr;
logic [`XLEN - 1: 0] dbg_csr_rdata;
logic [`XLEN - 1: 0] dbg_pc;
logic [       31: 0] dbg_insn;
logic                dbg_exec;
logic                dbg_halted;
logic                dbg_attach;

logic                cpu_trace_pkg_valid;
logic [      255: 0] cpu_trace_pkg;


`AXI_INTF_DEF(immu, 10)
`AXI_INTF_DEF(dmmu, 10)
`AXI_INTF_DEF(l1ic, 10)
`AXI_INTF_DEF(l1dc, 10)
`AXI_INTF_DEF(ext_s_remap, 9)

`AXI_MST_PORT_TO_INTF(ext_s,         ext_axi);
`AXI_MST_INTF_TO_PORT(ddr_remap_axi, ddr_m);
`APB_MST_PORT_TO_INTF(dbg,           ext_dbg_apb);

apb_intf ext_dbg_apb();
apb_intf dbg_apb();
apb_intf core_apb();
apb_intf cfgreg_apb();
apb_intf dbgmon_apb();
apb_intf intc_apb();
apb_intf peri_apb();
apb_intf dap_apb();
axi_intf#(.ID_WIDTH( 8)) ext_axi();
axi_intf#(.ID_WIDTH( 8)) ext_remap_axi();
axi_intf#(.ID_WIDTH(13)) ddr_axi();
axi_intf#(.ID_WIDTH( 6)) ddr_remap_axi();
axi_intf#(.ID_WIDTH( 9)) dma_axi();
axi_intf#(.ID_WIDTH(10)) immu_axi();
axi_intf#(.ID_WIDTH(10)) dmmu_axi();
axi_intf#(.ID_WIDTH(10)) l1ic_axi();
axi_intf#(.ID_WIDTH(10)) l1dc_axi();
axi_intf#(.ID_WIDTH( 8)) dap_axi();
axi_intf#(.ID_WIDTH( 9)) dbg_axi();
axi_intf#(.ID_WIDTH(10)) peri_axi();
axi_intf#(.ID_WIDTH(10)) peri_scu_axi();

cpu_top u_cpu_top (
    .clk                 ( clk                    ),
    .srstn               ( srstn                  ),
    .xrstn               ( xrstn                  ),
    .cpu_id              ( `XLEN'd0               ),
    .rv64_mode           ( rv64_mode              ),
    .bootvec             ( core_bootvec           ),
    .warm_rst_trigger    ( warm_rst_trigger       ),
    .systime             ( systime                ),

    // mpu csr
    .pmpcfg              ( pmpcfg                 ),
    .pmpaddr             ( pmpaddr                ),
    .pmacfg              ( pmacfg                 ),
    .pmaaddr             ( pmaaddr                ),

    // mmu csr
    .satp_ppn            ( satp_ppn               ),
    .satp_asid           ( satp_asid              ),
    .satp_mode           ( satp_mode              ),
    .prv                 ( prv                    ),
    .sum                 ( sum                    ),
    .mprv                ( mprv                   ),
    .mpp                 ( mpp                    ),

    // TLB control
    .tlb_flush_req       ( tlb_flush_req          ),
    .tlb_flush_all_vaddr ( tlb_flush_all_vaddr    ),
    .tlb_flush_all_asid  ( tlb_flush_all_asid     ),
    .tlb_flush_vaddr     ( tlb_flush_vaddr        ),
    .tlb_flush_asid      ( tlb_flush_asid         ),
   
    // interrupt interface
    .msip                ( msip                   ),
    .mtip                ( mtip                   ),
    .meip                ( meip                   ),
    .seip                ( seip                   ),

    // insn interface
    .imem_en             ( imem_en                ),
    .imem_addr           ( imem_addr              ),
    .imem_rdata          ( imem_rdata             ),
    .imem_bad            ( imem_bad               ),
    .imem_busy           ( imem_busy              ),
    .ic_flush            ( ic_flush               ),

    // data interface
    .dmem_en             ( dmem_en                ),
    .dmem_addr           ( dmem_addr              ),
    .dmem_write          ( dmem_write             ),
    .dmem_ex             ( dmem_ex                ),
    .dmem_strb           ( dmem_strb              ),
    .dmem_wdata          ( dmem_wdata             ),
    .dmem_rdata          ( dmem_rdata             ),
    .dmem_bad            ( dmem_bad               ),
    .dmem_xstate         ( dmem_xstate            ),
    .dmem_busy           ( dmem_busy              ),

    // debug intface
    .dbg_gpr_all         ( dbg_gpr_all            ),
    .dbg_addr            ( dbg_addr               ),
    .dbg_wdata           ( dbg_wdata              ),
    .dbg_gpr_rd          ( dbg_gpr_rd             ),
    .dbg_gpr_wr          ( dbg_gpr_wr             ),
    .dbg_gpr_out         ( dbg_gpr_rdata          ),
    .dbg_csr_rd          ( dbg_csr_rd             ),
    .dbg_csr_wr          ( dbg_csr_wr             ),
    .dbg_csr_out         ( dbg_csr_rdata          ),
    .dbg_pc_out          ( dbg_pc                 ),
    .dbg_exec            ( dbg_exec               ),
    .dbg_insn            ( dbg_insn               ),
    .attach              ( dbg_attach             ),
    .halted              ( dbg_halted             ),

    // CPU tracer
    .trace_pkg_valid     ( cpu_trace_pkg_valid    ),
    .trace_pkg           ( cpu_trace_pkg          )
);

mmu u_immu (
    .clk                 ( clk                 ),
    .rstn                ( srstn               ),
    
    // access type
    .access_w            ( 1'b0                ),
    .access_x            ( 1'b1                ),
    .access_ex           ( 1'b0                ),

    // TLB control
    .tlb_flush_req       ( tlb_flush_req       ),
    .tlb_flush_all_vaddr ( tlb_flush_all_vaddr ),
    .tlb_flush_all_asid  ( tlb_flush_all_asid  ),
    .tlb_flush_vaddr     ( tlb_flush_vaddr     ),
    .tlb_flush_asid      ( tlb_flush_asid      ),

    // mpu csr
    .pmp_v               ( ipmp_v              ),
    .pmp_l               ( ipmp_l              ),
    .pmp_x               ( ipmp_x              ),
    .pmp_w               ( ipmp_w              ),
    .pmp_r               ( ipmp_r              ),

    .pma_v               ( ipma_v              ),
    .pma_l               ( ipma_l              ),
    .pma_c               ( ipma_c              ),
    .pma_e               ( ipma_e              ),

    // mmu csr
    .rv64_mode           ( rv64_mode           ),
    .satp_ppn            ( satp_ppn            ),
    .satp_asid           ( satp_asid           ),
    .satp_mode           ( satp_mode           ),
    .prv                 ( prv                 ),
    .sum                 ( sum                 ),
    .mprv                ( mprv                ),
    .mpp                 ( mpp                 ),

    // virtual address
    .va_valid            ( imem_en             ),
`ifdef RV32
    .va                  ( {{32{imem_addr[31]}}, imem_addr}  ),
`else
    .va                  ( imem_addr           ),
`endif

    // Cache bypass
    .cache_bypass        ( icache_bypass       ),

    // physical address
    .pa_valid            ( immu_pa_vld         ),
    .pa_bad              ( immu_pa_bad         ),
    .pa                  ( immu_pa             ),
    .pa_pre_vld          ( immu_pa_pre_vld     ),
    .pa_pre              ( immu_pa_pre         ),
    
    // AXI interface
    .m_axi_intf          ( immu_axi.master     )
);

mmu u_dmmu (
    .clk                 ( clk                 ),
    .rstn                ( srstn               ),
    
    // access type
    .access_w            ( dmem_write          ),
    .access_x            ( 1'b0                ),
    .access_ex           ( dmem_ex             ),

    // TLB control
    .tlb_flush_req       ( tlb_flush_req       ),
    .tlb_flush_all_vaddr ( tlb_flush_all_vaddr ),
    .tlb_flush_all_asid  ( tlb_flush_all_asid  ),
    .tlb_flush_vaddr     ( tlb_flush_vaddr     ),
    .tlb_flush_asid      ( tlb_flush_asid      ),

    // mpu csr
    .pmp_v               ( dpmp_v              ),
    .pmp_l               ( dpmp_l              ),
    .pmp_x               ( dpmp_x              ),
    .pmp_w               ( dpmp_w              ),
    .pmp_r               ( dpmp_r              ),

    .pma_v               ( dpma_v              ),
    .pma_l               ( dpma_l              ),
    .pma_c               ( dpma_c              ),
    .pma_e               ( dpma_e              ),

    // mmu csr
    .rv64_mode           ( rv64_mode           ),
    .satp_ppn            ( satp_ppn            ),
    .satp_asid           ( satp_asid           ),
    .satp_mode           ( satp_mode           ),
    .prv                 ( prv                 ),
    .sum                 ( sum                 ),
    .mprv                ( mprv                ),
    .mpp                 ( mpp                 ),

    // virtual address
    .va_valid            ( dmem_en             ),
`ifdef RV32
    .va                  ( {{32{dmem_addr[31]}}, dmem_addr}  ),
`else
    .va                  ( dmem_addr           ),
`endif

    // Cache bypass
    .cache_bypass        ( dcache_bypass       ),

    // physical address
    .pa_valid            ( dmmu_pa_vld         ),
    .pa_bad              ( dmmu_pa_bad         ),
    .pa                  ( dmmu_pa             ),
    .pa_pre_vld          ( dmmu_pa_pre_vld     ),
    .pa_pre_wr           ( dmmu_pa_pre_wr      ),
    .pa_pre_rd           ( dmmu_pa_pre_rd      ),
    .pa_pre_ex           ( dmmu_pa_pre_ex      ),
    .pa_pre              ( dmmu_pa_pre         ),
    
    // AXI interface
    .m_axi_intf          ( dmmu_axi.master     )
);

mpu u_impu (
    .clk      ( clk                        ),
    .rstn     ( srstn                      ),
    .pmpcfg   ( pmpcfg                     ),
    .pmpaddr  ( pmpaddr                    ),
    .pmacfg   ( pmacfg                     ),
    .pmaaddr  ( pmaaddr                    ),
    .paddr    ( immu_pa_pre[0+:`PADDR_LEN] ),

    .pmp_v    ( ipmp_v                     ),
    .pmp_l    ( ipmp_l                     ),
    .pmp_x    ( ipmp_x                     ),
    .pmp_w    ( ipmp_w                     ),
    .pmp_r    ( ipmp_r                     ),
        
    .pma_v    ( ipma_v                     ),
    .pma_l    ( ipma_l                     ),
    .pma_c    ( ipma_c                     ),
    .pma_e    ( ipma_e                     )
        
);

mpu u_dmpu (
    .clk      ( clk                        ),
    .rstn     ( srstn                      ),
    .pmpcfg   ( pmpcfg                     ),
    .pmpaddr  ( pmpaddr                    ),
    .pmacfg   ( pmacfg                     ),
    .pmaaddr  ( pmaaddr                    ),
    .paddr    ( dmmu_pa_pre[0+:`PADDR_LEN] ),

    .pmp_v    ( dpmp_v                     ),
    .pmp_l    ( dpmp_l                     ),
    .pmp_x    ( dpmp_x                     ),
    .pmp_w    ( dpmp_w                     ),
    .pmp_r    ( dpmp_r                     ),
        
    .pma_v    ( dpma_v                     ),
    .pma_l    ( dpma_l                     ),
    .pma_c    ( dpma_c                     ),
    .pma_e    ( dpma_e                     )

);

xmon u_xmon(
    .clk    ( clk         ),
    .rstn   ( rstn        ),

    .ac     ( dmmu_pa_pre_vld & dmmu_pa_pre_ex & dmmu_pa_pre_rd),
    .rl     ( dmmu_pa_pre_vld & dmmu_pa_pre_wr),
    .addr   ( dmmu_pa_pre[31:0] ),
    .xstate ( xmon_xstate )
);

l1c u_l1ic (
    .clk         ( clk             ),
    .rstn        ( srstn           ),

    .core_bypass ( icache_bypass   ),
    .core_flush  ( ic_flush        ),
    .core_pa_vld ( immu_pa_vld     ),
    .core_pa_bad ( immu_pa_bad     ),
    .core_paddr  ( immu_pa[31:0]   ),
    .core_req    ( imem_en         ),
    .core_wr     ( 1'b0            ),
    .core_ex     ( 1'b0            ),
    .core_vaddr  ( imem_addr[31:0] ),
    .core_byte   ( {`XLEN/8{1'b1}} ),
    .core_wdata  ( `XLEN'b0        ),
    .core_rdata  ( imem_rdata      ),
    .core_bad    ( imem_bad        ),
    .core_busy   ( imem_busy       ),
    .xmon_xstate ( 1'b0            ),

    .snp_addr    ( m0_snp_addr     ),
    .snp_valid   ( m0_snp_valid    ),
    .snp_ready   ( m0_snp_ready    ),

    .m_axi_intf  ( l1ic_axi.master )
);

l1c u_l1dc (
    .clk         ( clk             ),
    .rstn        ( srstn           ),

    .core_bypass ( dcache_bypass   ),
    .core_flush  ( 1'b0            ),
    .core_pa_vld ( dmmu_pa_vld     ),
    .core_paddr  ( dmmu_pa[31:0]   ),
    .core_pa_bad ( dmmu_pa_bad     ),
    .core_req    ( dmem_en         ),
    .core_wr     ( dmem_write      ),
    .core_ex     ( dmem_ex         ),
    .core_xstate ( dmem_xstate     ),
    .core_vaddr  ( dmem_addr[31:0] ),
    .core_byte   ( dmem_strb       ),
    .core_wdata  ( dmem_wdata      ),
    .core_rdata  ( dmem_rdata      ),
    .core_bad    ( dmem_bad        ),
    .core_busy   ( dmem_busy       ),
    .xmon_xstate ( xmon_xstate     ),

    .snp_addr    ( m1_snp_addr     ),
    .snp_valid   ( m1_snp_valid    ),
    .snp_ready   ( m1_snp_ready    ),

    .m_axi_intf  ( l1dc_axi.master )
);

core_apb_conn u_core_apb_conn (
    .core_apb   ( core_apb.slave    ),
    .cfgreg_apb ( cfgreg_apb.master ),
    .dbgmon_apb ( dbgmon_apb.master ),
    .intc_apb   ( intc_apb.master   )
);

cfgreg u_cfgreg (
    .clk          ( clk              ),
    .rstn         ( rstn             ),
    .apb_intf     ( cfgreg_apb.slave ),

    .ddr_offset   ( ddr_offset       ),
    .core_bootvec ( core_bootvec     ),
    .core_rstn    ( core_rstn        )
);

dbgmon u_dbgmon (
    .clk          ( clk                 ),
    .rstn         ( rstn                ),
    .srstn        ( core_rstn           ),
    .apb_intf     ( dbgmon_apb.slave    ),

    .pc           ( dbg_pc              ),
    .gpr          ( dbg_gpr_all         ),

    .pkg_valid    ( cpu_trace_pkg_valid ),
    .pkg          ( cpu_trace_pkg       )
);

rgu u_rgu (
    .clk              ( clk              ),
    .pwr_rstn         ( core_rstn        ),
    .warm_rst_trigger ( warm_rst_trigger ),
    .xrstn            ( xrstn            ),
    .srstn            ( srstn            )
);

iommu_ext u_iommu_ext (
    .s_axi_intf ( ext_axi.slave        ),
    .m_axi_intf ( ext_remap_axi.master )
);

iommu_ddr u_iommu_ddr (
    .s_axi_intf ( ddr_axi.slave        ),
    .m_axi_intf ( ddr_remap_axi.master ),
    .offset     ( ddr_offset           )
);

dbg_axi_arb_2to1 u_dbg_axi_arb_2to1 (
    .clk         ( clk                 ),
    .rstn        ( rstn                ),

    .s0_axi_intf ( ext_remap_axi.slave ),
    .s1_axi_intf ( dap_axi.slave       ),

    .m_axi_intf  ( dbg_axi.master      )
);

peri_axi_arb_2to1 u_peri_axi_arb_2to1 (
    .clk         ( clk             ),
    .rstn        ( rstn            ),

    .s0_axi_intf ( dma_axi.slave   ),
    .s1_axi_intf ( dbg_axi.slave   ),

    .m_axi_intf  ( peri_axi.master )
);

scu u_scu (
    .clk          ( clk                ),
    .rstn         ( rstn               ),

    .s_axi_intf   ( peri_axi.slave     ),
    .m_axi_intf   ( peri_scu_axi.master),

    .m0_snp_addr  ( m0_snp_addr        ),
    .m0_snp_valid ( m0_snp_valid       ),
    .m0_snp_ready ( m0_snp_ready       ),
                                
    .m1_snp_addr  ( m1_snp_addr        ),
    .m1_snp_valid ( m1_snp_valid       ),
    .m1_snp_ready ( m1_snp_ready       )
);

marb u_marb (
    .clk        ( clk                  ),
    .rstn       ( rstn                 ),


    .s0_axi_intf ( immu_axi.slave      ),
    .s1_axi_intf ( dmmu_axi.slave      ),
    .s2_axi_intf ( l1ic_axi.slave      ),
    .s3_axi_intf ( l1dc_axi.slave      ),
    .s4_axi_intf ( peri_scu_axi.slave  ),

    .m0_cs       ( cs_0                ),
    .m0_we       ( we_0                ),
    .m0_addr     ( addr_0              ),
    .m0_byte     ( byte_0              ),
    .m0_di       ( di_0                ),
    .m0_do       ( do_0                ),
    .m0_busy     ( busy_0              ),

    .m1_cs       ( cs_1                ),
    .m1_we       ( we_1                ),
    .m1_addr     ( addr_1              ),
    .m1_byte     ( byte_1              ),
    .m1_di       ( di_1                ),
    .m1_do       ( do_1                ),
    .m1_busy     ( busy_1              ),

    .m_core_apb  ( core_apb.master     ),
    .m_peri_apb  ( peri_apb.master     ),
    .m_ddr_axi   ( ddr_axi.master      )
);

// assign msip = 1'b0;
// assign mtip = 1'b0;
// assign meip = 1'b0;
// 
// assign core_rstn = rstn;
// assign core_bootvec = 32'b0;
// 
// assign imem_bad  = 2'b0;
// assign imem_busy = 1'b0;
// 
// always_ff @(posedge clk or negedge rstn) begin
//     if (~rstn) begin
//         imem_rdata <= 32'b0;
//     end
//     else begin
//         imem_rdata <= imem_addr[16] ? u_sram_1.memory[imem_addr[15:2]] : u_sram_0.memory[imem_addr[15:2]];
//     end
// end
// 
// assign dmem_bad  = 2'b0;
// assign dmem_busy = 1'b0;
// 
// always_ff @(posedge clk or negedge rstn) begin
//     if (~rstn) begin
//         dmem_rdata <= 32'b0;
//     end
//     else begin
//         dmem_rdata <= dmem_addr[16] ? u_sram_1.memory[dmem_addr[15:2]] : u_sram_0.memory[dmem_addr[15:2]];
//     end
// end
// 
// always_ff @(posedge clk or negedge rstn) begin
//     if (dmem_write & dmem_en) begin
//         if (~dmem_addr[16]) begin
//             if (dmem_strb[0]) u_sram_0.memory[dmem_addr[15:2]][ 0+:8] <= dmem_wdata[ 0+:8];
//             if (dmem_strb[1]) u_sram_0.memory[dmem_addr[15:2]][ 8+:8] <= dmem_wdata[ 8+:8];
//             if (dmem_strb[2]) u_sram_0.memory[dmem_addr[15:2]][16+:8] <= dmem_wdata[16+:8];
//             if (dmem_strb[3]) u_sram_0.memory[dmem_addr[15:2]][24+:8] <= dmem_wdata[24+:8];
//         end
//         else begin
//             if (dmem_strb[0]) u_sram_1.memory[dmem_addr[15:2]][ 0+:8] <= dmem_wdata[ 0+:8];
//             if (dmem_strb[1]) u_sram_1.memory[dmem_addr[15:2]][ 8+:8] <= dmem_wdata[ 8+:8];
//             if (dmem_strb[2]) u_sram_1.memory[dmem_addr[15:2]][16+:8] <= dmem_wdata[16+:8];
//             if (dmem_strb[3]) u_sram_1.memory[dmem_addr[15:2]][24+:8] <= dmem_wdata[24+:8];
//         end
//     end
// end
// 
// assign cs_0 = 1'b0;
// assign cs_1 = 1'b0;

CG u_mem_cg_0 (
    .CK   ( clk      ),
    .EN   ( cs_0     ),
    .CKEN ( mem_ck_0 )
);

CG u_mem_cg_1 (
    .CK   ( clk      ),
    .EN   ( cs_1     ),
    .CKEN ( mem_ck_1 )
);

assign busy_0 = 1'b0;

/*
sram u_sram_0 (
    .CK   ( mem_ck_0      ),
    .CS   ( cs_0          ),
    .A    ( addr_0[2+:14] ),
    .BYTE ( byte_0        ),
    .WE   ( we_0          ),
    .DI   ( di_0          ),
    .DO   ( do_0          )
);
*/
rom32x2048 u_brom (
    // .CK ( mem_ck_0      ),
    .CK   ( clk           ),
    .CS   ( cs_0          ),
    .A    ( addr_0[2+:11] ),
    .BYTE ( byte_0        ),
    .WE   ( we_0          ),
    .DI   ( di_0          ),
    .DO   ( do_0          )
);


assign busy_1 = 1'b0;

sram u_sram (
    // .CK   ( mem_ck_1      ),
    .CK   ( clk           ),
    .CS   ( cs_1          ),
    .A    ( addr_1[2+:15] ),
    .BYTE ( byte_1        ),
    .WE   ( we_1          ),
    .DI   ( di_1          ),
    .DO   ( do_1          )
);

assign ints = {
    28'b0,
    mac_irq,
    spi_irq,
    uart_irq,
    1'b0 // reserve
};

intc u_intc (
    .clk        ( clk            ),
    .rstn       ( srstn          ),
    .s_apb_intf ( intc_apb.slave ),

    .systime    ( systime        ),
    .msip       ( msip           ),
    .mtip       ( mtip           ),
    .meip       ( meip           ),
    .seip       ( seip           ),
    .ints       ( ints           )
);

systimer u_systimer (
    .clk_sys ( clk     ),
    .clk_32k ( clk_32k ),
    .rstn    ( rstn    ),
    .systime ( systime )
);

apb_2to1_mux u_dbg_apb_arb_2to1 (
    .clk         ( clk                ),
    .rstn        ( rstn               ),

    .s0_apb_intf ( ext_dbg_apb.slave  ),
    .s1_apb_intf ( dap_apb.slave      ),

    .m_apb_intf  ( dbg_apb.master     )
);

dbgapb u_dbgapb (
    .clk       ( clk           ),
    .rstn      ( srstn         ),
    .apb_intf  ( dbg_apb.slave ),

    .addr_out  ( dbg_addr      ),
    .wdata_out ( dbg_wdata     ),
    .gpr_rd    ( dbg_gpr_rd    ),
    .gpr_wr    ( dbg_gpr_wr    ),
    .gpr_in    ( dbg_gpr_rdata ),
    .csr_rd    ( dbg_csr_rd    ),
    .csr_wr    ( dbg_csr_wr    ),
    .csr_in    ( dbg_csr_rdata ),
    .pc        ( dbg_pc        ),
    .insn_out  ( dbg_insn      ),
    .exec      ( dbg_exec      ),
    .halted    ( dbg_halted    ),
    .attach    ( dbg_attach    )
);

peri u_peri (
    .clk            ( clk            ),
    .rstn           ( rstn           ),
    .s_apb_intf     ( peri_apb.slave ),

    .uart_rx        ( uart_rx        ),
    .uart_tx        ( uart_tx        ),

    .sclk           ( sclk           ),
    .nss            ( nss            ),
    .mosi           ( mosi           ),
    .miso           ( miso           ),
    .m_dma_axi_intf ( dma_axi.master ),

    .rmii_refclk    ( rmii_refclk    ),
    .rmii_crsdv     ( rmii_crsdv     ),
    .rmii_rxd       ( rmii_rxd       ),
    .rmii_txen      ( rmii_txen      ),
    .rmii_txd       ( rmii_txd       ),

    .uart_irq       ( uart_irq       ),
    .spi_irq        ( spi_irq        ),
    .mac_irq        ( mac_irq        )
);

assign trstn = 1'b1;

dap u_dap (
    // clock and reset
    .clk          ( clk            ),
    .rstn         ( rstn           ),

    // DP port
    .tck          ( tck            ),
    .trstn        ( trstn          ),
    .tms          ( tms            ),
    .tdi          ( tdi            ),
    .tdo          ( tdo            ),

    // Other
    .apb_spiden   ( 1'b1           ),
    .apb_deviceen ( 1'b1           ),
    .axi_spiden   ( 1'b1           ),
    .axi_deviceen ( 1'b1           ),

    // APB_AP port
    .m_apb_intf   ( dap_apb.master ),

    // AXI_AP port
    .m_axi_intf   ( dap_axi.master )

);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/rgu.sv
/*--------------------------------------*/

module rgu (
    input        clk,
    input        pwr_rstn,
    input        warm_rst_trigger,
    output logic xrstn,
    output logic srstn
);

localparam STATE_IDLE   = 2'b00;
localparam STATE_RSTPRE = 2'b01;
localparam STATE_RST    = 2'b10;

logic [1:0] cur_state;
logic [1:0] nxt_state;

logic [9:0] cnt;
logic [9:0] nxt_cnt;
logic       upd_cnt;

always_ff @(posedge clk or negedge pwr_rstn) begin
    if (~pwr_rstn) cur_state <= STATE_IDLE;
    else           cur_state <= nxt_state;
end

always_comb begin
    nxt_state = cur_state;
    case (cur_state)
        STATE_IDLE  : nxt_state = warm_rst_trigger ? STATE_RSTPRE : STATE_IDLE;
        STATE_RSTPRE: nxt_state = ~|cnt            ? STATE_RST    : STATE_RSTPRE;
        STATE_RST   : nxt_state = ~|cnt            ? STATE_IDLE   : STATE_RST;
    endcase
end

always_comb begin
    nxt_cnt       = 10'b0;
    upd_cnt       = 1'b0;
    case (cur_state)
        STATE_IDLE  : begin
            nxt_cnt = 10'h20;
            upd_cnt = warm_rst_trigger;
        end
        STATE_RSTPRE: begin
            nxt_cnt = 10'ha;
            upd_cnt = ~|cnt;
        end
        STATE_RST   : begin
        end
    endcase
end

always_ff @(posedge clk or negedge pwr_rstn) begin
    if (~pwr_rstn) begin
        cnt <= 10'b0;
    end
    else begin
        if (upd_cnt) begin
            cnt <= nxt_cnt;
        end
        else begin
            cnt <= |cnt ? cnt - 10'b1 : cnt;
        end
    end
end

always_ff @(posedge clk or negedge pwr_rstn) begin
    if (~pwr_rstn) begin
        srstn <= 1'b0;
        xrstn <= 1'b0;
    end
    else begin
        srstn <= cur_state != STATE_RST;
        xrstn <= 1'b1;
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/dbg_axi_arb_2to1.sv
/*--------------------------------------*/

`ifndef __INTF_DEFINE__
`define __INTF_DEFINE__

`define AXI_INTF_CONNECT(PORT, WIRE) \
    .``PORT``_awburst ( WIRE``_awburst ), \
    .``PORT``_awid    ( WIRE``_awid    ), \
    .``PORT``_awaddr  ( WIRE``_awaddr  ), \
    .``PORT``_awsize  ( WIRE``_awsize  ), \
    .``PORT``_awlen   ( WIRE``_awlen   ), \
    .``PORT``_awlock  ( WIRE``_awlock  ), \
    .``PORT``_awcache ( WIRE``_awcache ), \
    .``PORT``_awprot  ( WIRE``_awprot  ), \
    .``PORT``_awvalid ( WIRE``_awvalid ), \
    .``PORT``_awready ( WIRE``_awready ), \
    .``PORT``_wstrb   ( WIRE``_wstrb   ), \
    .``PORT``_wid     ( WIRE``_wid     ), \
    .``PORT``_wdata   ( WIRE``_wdata   ), \
    .``PORT``_wlast   ( WIRE``_wlast   ), \
    .``PORT``_wvalid  ( WIRE``_wvalid  ), \
    .``PORT``_wready  ( WIRE``_wready  ), \
    .``PORT``_bid     ( WIRE``_bid     ), \
    .``PORT``_bresp   ( WIRE``_bresp   ), \
    .``PORT``_bvalid  ( WIRE``_bvalid  ), \
    .``PORT``_bready  ( WIRE``_bready  ), \
    .``PORT``_araddr  ( WIRE``_araddr  ), \
    .``PORT``_arburst ( WIRE``_arburst ), \
    .``PORT``_arsize  ( WIRE``_arsize  ), \
    .``PORT``_arid    ( WIRE``_arid    ), \
    .``PORT``_arlen   ( WIRE``_arlen   ), \
    .``PORT``_arlock  ( WIRE``_arlock  ), \
    .``PORT``_arcache ( WIRE``_arcache ), \
    .``PORT``_arprot  ( WIRE``_arprot  ), \
    .``PORT``_arvalid ( WIRE``_arvalid ), \
    .``PORT``_arready ( WIRE``_arready ), \
    .``PORT``_rdata   ( WIRE``_rdata   ), \
    .``PORT``_rresp   ( WIRE``_rresp   ), \
    .``PORT``_rid     ( WIRE``_rid     ), \
    .``PORT``_rlast   ( WIRE``_rlast   ), \
    .``PORT``_rvalid  ( WIRE``_rvalid  ), \
    .``PORT``_rready  ( WIRE``_rready  )

`define AXI_INTF_SLV_DEF(NAME, ID) \
    input         [     1: 0] NAME``_awburst, \
    input         [ID - 1: 0] NAME``_awid,    \
    input         [    31: 0] NAME``_awaddr,  \
    input         [     2: 0] NAME``_awsize,  \
    input         [     7: 0] NAME``_awlen,   \
    input         [     1: 0] NAME``_awlock,  \
    input         [     3: 0] NAME``_awcache, \
    input         [     2: 0] NAME``_awprot,  \
    input                     NAME``_awvalid, \
    output logic              NAME``_awready, \
    input         [     3: 0] NAME``_wstrb,   \
    input         [ID - 1: 0] NAME``_wid,     \
    input         [    31: 0] NAME``_wdata,   \
    input                     NAME``_wlast,   \
    input                     NAME``_wvalid,  \
    output logic              NAME``_wready,  \
    output logic  [ID - 1: 0] NAME``_bid,     \
    output logic  [     1: 0] NAME``_bresp,   \
    output logic              NAME``_bvalid,  \
    input                     NAME``_bready,  \
    input         [    31: 0] NAME``_araddr,  \
    input         [     1: 0] NAME``_arburst, \
    input         [     2: 0] NAME``_arsize,  \
    input         [ID - 1: 0] NAME``_arid,    \
    input         [     7: 0] NAME``_arlen,   \
    input         [     1: 0] NAME``_arlock,  \
    input         [     3: 0] NAME``_arcache, \
    input         [     2: 0] NAME``_arprot,  \
    input                     NAME``_arvalid, \
    output logic              NAME``_arready, \
    output logic  [    31: 0] NAME``_rdata,   \
    output logic  [     1: 0] NAME``_rresp,   \
    output logic  [ID - 1: 0] NAME``_rid,     \
    output logic              NAME``_rlast,   \
    output logic              NAME``_rvalid,  \
    input                     NAME``_rready

`define AXI_INTF_MST_DEF(NAME, ID) \
    output logic  [     1: 0] NAME``_awburst, \
    output logic  [ID - 1: 0] NAME``_awid,    \
    output logic  [    31: 0] NAME``_awaddr,  \
    output logic  [     2: 0] NAME``_awsize,  \
    output logic  [     7: 0] NAME``_awlen,   \
    output logic  [     1: 0] NAME``_awlock,  \
    output logic  [     3: 0] NAME``_awcache, \
    output logic  [     2: 0] NAME``_awprot,  \
    output logic              NAME``_awvalid, \
    input                     NAME``_awready, \
    output logic  [     3: 0] NAME``_wstrb,   \
    output logic  [ID - 1: 0] NAME``_wid,     \
    output logic  [    31: 0] NAME``_wdata,   \
    output logic              NAME``_wlast,   \
    output logic              NAME``_wvalid,  \
    input                     NAME``_wready,  \
    input         [ID - 1: 0] NAME``_bid,     \
    input         [     1: 0] NAME``_bresp,   \
    input                     NAME``_bvalid,  \
    output logic              NAME``_bready,  \
    output logic  [    31: 0] NAME``_araddr,  \
    output logic  [     1: 0] NAME``_arburst, \
    output logic  [     2: 0] NAME``_arsize,  \
    output logic  [ID - 1: 0] NAME``_arid,    \
    output logic  [     7: 0] NAME``_arlen,   \
    output logic  [     1: 0] NAME``_arlock,  \
    output logic  [     3: 0] NAME``_arcache, \
    output logic  [     2: 0] NAME``_arprot,  \
    output logic              NAME``_arvalid, \
    input                     NAME``_arready, \
    input         [    31: 0] NAME``_rdata,   \
    input         [     1: 0] NAME``_rresp,   \
    input         [ID - 1: 0] NAME``_rid,     \
    input                     NAME``_rlast,   \
    input                     NAME``_rvalid,  \
    output logic              NAME``_rready

`define AXI_INTF_DEF(NAME, ID) \
    logic  [     1: 0] NAME``_awburst; \
    logic  [ID - 1: 0] NAME``_awid;    \
    logic  [    31: 0] NAME``_awaddr;  \
    logic  [     2: 0] NAME``_awsize;  \
    logic  [     7: 0] NAME``_awlen;   \
    logic  [     1: 0] NAME``_awlock;  \
    logic  [     3: 0] NAME``_awcache; \
    logic  [     2: 0] NAME``_awprot;  \
    logic              NAME``_awvalid; \
    logic              NAME``_awready; \
    logic  [     3: 0] NAME``_wstrb;   \
    logic  [ID - 1: 0] NAME``_wid;     \
    logic  [    31: 0] NAME``_wdata;   \
    logic              NAME``_wlast;   \
    logic              NAME``_wvalid;  \
    logic              NAME``_wready;  \
    logic  [ID - 1: 0] NAME``_bid;     \
    logic  [     1: 0] NAME``_bresp;   \
    logic              NAME``_bvalid;  \
    logic              NAME``_bready;  \
    logic  [    31: 0] NAME``_araddr;  \
    logic  [     1: 0] NAME``_arburst; \
    logic  [     2: 0] NAME``_arsize;  \
    logic  [ID - 1: 0] NAME``_arid;    \
    logic  [     7: 0] NAME``_arlen;   \
    logic  [     1: 0] NAME``_arlock;  \
    logic  [     3: 0] NAME``_arcache; \
    logic  [     2: 0] NAME``_arprot;  \
    logic              NAME``_arvalid; \
    logic              NAME``_arready; \
    logic  [    31: 0] NAME``_rdata;   \
    logic  [     1: 0] NAME``_rresp;   \
    logic  [ID - 1: 0] NAME``_rid;     \
    logic              NAME``_rlast;   \
    logic              NAME``_rvalid;  \
    logic              NAME``_rready;

`define APB_MST_PORT_TO_INTF(PORT, INTF)    \
    assign INTF``.psel    = PORT``_psel;    \
    assign INTF``.penable = PORT``_penable; \
    assign INTF``.paddr   = PORT``_paddr;   \
    assign INTF``.pwrite  = PORT``_pwrite;  \
    assign INTF``.pstrb   = PORT``_pstrb;   \
    assign INTF``.pprot   = PORT``_pprot;   \
    assign INTF``.pwdata  = PORT``_pwdata;  \
    assign PORT``_prdata  = INTF``.prdata;  \
    assign PORT``_pslverr = INTF``.pslverr; \
    assign PORT``_pready  = INTF``.pready;

`define APB_MST_INTF_TO_PORT(INTF, PORT)    \
    assign PORT``_psel    = INTF``.psel;    \
    assign PORT``_penable = INTF``.penable; \
    assign PORT``_paddr   = INTF``.paddr;   \
    assign PORT``_pwrite  = INTF``.pwrite;  \
    assign PORT``_pstrb   = INTF``.pstrb;   \
    assign PORT``_pprot   = INTF``.pprot;   \
    assign PORT``_pwdata  = INTF``.pwdata;  \
    assign INTF``.prdata  = PORT``_prdata;  \
    assign INTF``.pslverr = PORT``_pslverr; \
    assign INTF``.pready  = PORT``_pready;

`define AXI_MST_PORT_TO_INTF(PORT, INTF)    \
    assign INTF``.awid    = PORT``_awid;    \
    assign INTF``.awaddr  = PORT``_awaddr;  \
    assign INTF``.awburst = PORT``_awburst; \
    assign INTF``.awsize  = PORT``_awsize;  \
    assign INTF``.awlen   = PORT``_awlen;   \
    assign INTF``.awlock  = PORT``_awlock;  \
    assign INTF``.awcache = PORT``_awcache; \
    assign INTF``.awprot  = PORT``_awprot;  \
    assign INTF``.awvalid = PORT``_awvalid; \
    assign PORT``_awready = INTF``.awready; \
    assign INTF``.wid     = PORT``_wid;     \
    assign INTF``.wstrb   = PORT``_wstrb;   \
    assign INTF``.wdata   = PORT``_wdata;   \
    assign INTF``.wlast   = PORT``_wlast;   \
    assign INTF``.wvalid  = PORT``_wvalid;  \
    assign PORT``_wready  = INTF``.wready;  \
    assign PORT``_bid     = INTF``.bid;     \
    assign PORT``_bresp   = INTF``.bresp;   \
    assign PORT``_bvalid  = INTF``.bvalid;  \
    assign INTF``.bready  = PORT``_bready;  \
    assign INTF``.arid    = PORT``_arid;    \
    assign INTF``.araddr  = PORT``_araddr;  \
    assign INTF``.arburst = PORT``_arburst; \
    assign INTF``.arsize  = PORT``_arsize;  \
    assign INTF``.arlen   = PORT``_arlen;   \
    assign INTF``.arlock  = PORT``_arlock;  \
    assign INTF``.arcache = PORT``_arcache; \
    assign INTF``.arprot  = PORT``_arprot;  \
    assign INTF``.arvalid = PORT``_arvalid; \
    assign PORT``_arready = INTF``.arready; \
    assign PORT``_rid     = INTF``.rid;     \
    assign PORT``_rdata   = INTF``.rdata;   \
    assign PORT``_rresp   = INTF``.rresp;   \
    assign PORT``_rlast   = INTF``.rlast;   \
    assign PORT``_rvalid  = INTF``.rvalid;  \
    assign INTF``.rready  = PORT``_rready;


`define AXI_MST_INTF_TO_PORT(INTF, PORT)    \
    assign PORT``_awid    = INTF``.awid;    \
    assign PORT``_awaddr  = INTF``.awaddr;  \
    assign PORT``_awburst = INTF``.awburst; \
    assign PORT``_awsize  = INTF``.awsize;  \
    assign PORT``_awlen   = INTF``.awlen;   \
    assign PORT``_awlock  = INTF``.awlock;  \
    assign PORT``_awcache = INTF``.awcache; \
    assign PORT``_awprot  = INTF``.awprot;  \
    assign PORT``_awvalid = INTF``.awvalid; \
    assign INTF``.awready = PORT``_awready; \
    assign PORT``_wid     = INTF``.wid;     \
    assign PORT``_wstrb   = INTF``.wstrb;   \
    assign PORT``_wdata   = INTF``.wdata;   \
    assign PORT``_wlast   = INTF``.wlast;   \
    assign PORT``_wvalid  = INTF``.wvalid;  \
    assign INTF``.wready  = PORT``_wready;  \
    assign INTF``.bid     = PORT``_bid;     \
    assign INTF``.bresp   = PORT``_bresp;   \
    assign INTF``.bvalid  = PORT``_bvalid;  \
    assign PORT``_bready  = INTF``.bready;  \
    assign PORT``_arid    = INTF``.arid;    \
    assign PORT``_araddr  = INTF``.araddr;  \
    assign PORT``_arburst = INTF``.arburst; \
    assign PORT``_arsize  = INTF``.arsize;  \
    assign PORT``_arlen   = INTF``.arlen;   \
    assign PORT``_arlock  = INTF``.arlock;  \
    assign PORT``_arcache = INTF``.arcache; \
    assign PORT``_arprot  = INTF``.arprot;  \
    assign PORT``_arvalid = INTF``.arvalid; \
    assign INTF``.arready = PORT``_arready; \
    assign INTF``.rid     = PORT``_rid;     \
    assign INTF``.rdata   = PORT``_rdata;   \
    assign INTF``.rresp   = PORT``_rresp;   \
    assign INTF``.rlast   = PORT``_rlast;   \
    assign INTF``.rvalid  = PORT``_rvalid;  \
    assign PORT``_rready  = INTF``.rready;

`endif

module dbg_axi_arb_2to1 (
    input           clk,
    input           rstn,

    axi_intf.slave  s0_axi_intf,
    axi_intf.slave  s1_axi_intf,

    axi_intf.master m_axi_intf
);

`AXI_INTF_DEF(s0, 8)
`AXI_INTF_DEF(s1, 8)
`AXI_INTF_DEF( m, 9)

`AXI_MST_INTF_TO_PORT(s0_axi_intf, s0)
`AXI_MST_INTF_TO_PORT(s1_axi_intf, s1)
`AXI_MST_PORT_TO_INTF(m, m_axi_intf)

axi_2to1_mux_id8 u_axi_2to1_mux (
    .aclk       ( clk        ),
    .aresetn    ( rstn       ),

    `AXI_INTF_CONNECT(s0, s0),
    `AXI_INTF_CONNECT(s1, s1),
    `AXI_INTF_CONNECT( m,  m)
);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/peri_axi_arb_2to1.sv
/*--------------------------------------*/

`ifndef __INTF_DEFINE__
`define __INTF_DEFINE__

`define AXI_INTF_CONNECT(PORT, WIRE) \
    .``PORT``_awburst ( WIRE``_awburst ), \
    .``PORT``_awid    ( WIRE``_awid    ), \
    .``PORT``_awaddr  ( WIRE``_awaddr  ), \
    .``PORT``_awsize  ( WIRE``_awsize  ), \
    .``PORT``_awlen   ( WIRE``_awlen   ), \
    .``PORT``_awlock  ( WIRE``_awlock  ), \
    .``PORT``_awcache ( WIRE``_awcache ), \
    .``PORT``_awprot  ( WIRE``_awprot  ), \
    .``PORT``_awvalid ( WIRE``_awvalid ), \
    .``PORT``_awready ( WIRE``_awready ), \
    .``PORT``_wstrb   ( WIRE``_wstrb   ), \
    .``PORT``_wid     ( WIRE``_wid     ), \
    .``PORT``_wdata   ( WIRE``_wdata   ), \
    .``PORT``_wlast   ( WIRE``_wlast   ), \
    .``PORT``_wvalid  ( WIRE``_wvalid  ), \
    .``PORT``_wready  ( WIRE``_wready  ), \
    .``PORT``_bid     ( WIRE``_bid     ), \
    .``PORT``_bresp   ( WIRE``_bresp   ), \
    .``PORT``_bvalid  ( WIRE``_bvalid  ), \
    .``PORT``_bready  ( WIRE``_bready  ), \
    .``PORT``_araddr  ( WIRE``_araddr  ), \
    .``PORT``_arburst ( WIRE``_arburst ), \
    .``PORT``_arsize  ( WIRE``_arsize  ), \
    .``PORT``_arid    ( WIRE``_arid    ), \
    .``PORT``_arlen   ( WIRE``_arlen   ), \
    .``PORT``_arlock  ( WIRE``_arlock  ), \
    .``PORT``_arcache ( WIRE``_arcache ), \
    .``PORT``_arprot  ( WIRE``_arprot  ), \
    .``PORT``_arvalid ( WIRE``_arvalid ), \
    .``PORT``_arready ( WIRE``_arready ), \
    .``PORT``_rdata   ( WIRE``_rdata   ), \
    .``PORT``_rresp   ( WIRE``_rresp   ), \
    .``PORT``_rid     ( WIRE``_rid     ), \
    .``PORT``_rlast   ( WIRE``_rlast   ), \
    .``PORT``_rvalid  ( WIRE``_rvalid  ), \
    .``PORT``_rready  ( WIRE``_rready  )

`define AXI_INTF_SLV_DEF(NAME, ID) \
    input         [     1: 0] NAME``_awburst, \
    input         [ID - 1: 0] NAME``_awid,    \
    input         [    31: 0] NAME``_awaddr,  \
    input         [     2: 0] NAME``_awsize,  \
    input         [     7: 0] NAME``_awlen,   \
    input         [     1: 0] NAME``_awlock,  \
    input         [     3: 0] NAME``_awcache, \
    input         [     2: 0] NAME``_awprot,  \
    input                     NAME``_awvalid, \
    output logic              NAME``_awready, \
    input         [     3: 0] NAME``_wstrb,   \
    input         [ID - 1: 0] NAME``_wid,     \
    input         [    31: 0] NAME``_wdata,   \
    input                     NAME``_wlast,   \
    input                     NAME``_wvalid,  \
    output logic              NAME``_wready,  \
    output logic  [ID - 1: 0] NAME``_bid,     \
    output logic  [     1: 0] NAME``_bresp,   \
    output logic              NAME``_bvalid,  \
    input                     NAME``_bready,  \
    input         [    31: 0] NAME``_araddr,  \
    input         [     1: 0] NAME``_arburst, \
    input         [     2: 0] NAME``_arsize,  \
    input         [ID - 1: 0] NAME``_arid,    \
    input         [     7: 0] NAME``_arlen,   \
    input         [     1: 0] NAME``_arlock,  \
    input         [     3: 0] NAME``_arcache, \
    input         [     2: 0] NAME``_arprot,  \
    input                     NAME``_arvalid, \
    output logic              NAME``_arready, \
    output logic  [    31: 0] NAME``_rdata,   \
    output logic  [     1: 0] NAME``_rresp,   \
    output logic  [ID - 1: 0] NAME``_rid,     \
    output logic              NAME``_rlast,   \
    output logic              NAME``_rvalid,  \
    input                     NAME``_rready

`define AXI_INTF_MST_DEF(NAME, ID) \
    output logic  [     1: 0] NAME``_awburst, \
    output logic  [ID - 1: 0] NAME``_awid,    \
    output logic  [    31: 0] NAME``_awaddr,  \
    output logic  [     2: 0] NAME``_awsize,  \
    output logic  [     7: 0] NAME``_awlen,   \
    output logic  [     1: 0] NAME``_awlock,  \
    output logic  [     3: 0] NAME``_awcache, \
    output logic  [     2: 0] NAME``_awprot,  \
    output logic              NAME``_awvalid, \
    input                     NAME``_awready, \
    output logic  [     3: 0] NAME``_wstrb,   \
    output logic  [ID - 1: 0] NAME``_wid,     \
    output logic  [    31: 0] NAME``_wdata,   \
    output logic              NAME``_wlast,   \
    output logic              NAME``_wvalid,  \
    input                     NAME``_wready,  \
    input         [ID - 1: 0] NAME``_bid,     \
    input         [     1: 0] NAME``_bresp,   \
    input                     NAME``_bvalid,  \
    output logic              NAME``_bready,  \
    output logic  [    31: 0] NAME``_araddr,  \
    output logic  [     1: 0] NAME``_arburst, \
    output logic  [     2: 0] NAME``_arsize,  \
    output logic  [ID - 1: 0] NAME``_arid,    \
    output logic  [     7: 0] NAME``_arlen,   \
    output logic  [     1: 0] NAME``_arlock,  \
    output logic  [     3: 0] NAME``_arcache, \
    output logic  [     2: 0] NAME``_arprot,  \
    output logic              NAME``_arvalid, \
    input                     NAME``_arready, \
    input         [    31: 0] NAME``_rdata,   \
    input         [     1: 0] NAME``_rresp,   \
    input         [ID - 1: 0] NAME``_rid,     \
    input                     NAME``_rlast,   \
    input                     NAME``_rvalid,  \
    output logic              NAME``_rready

`define AXI_INTF_DEF(NAME, ID) \
    logic  [     1: 0] NAME``_awburst; \
    logic  [ID - 1: 0] NAME``_awid;    \
    logic  [    31: 0] NAME``_awaddr;  \
    logic  [     2: 0] NAME``_awsize;  \
    logic  [     7: 0] NAME``_awlen;   \
    logic  [     1: 0] NAME``_awlock;  \
    logic  [     3: 0] NAME``_awcache; \
    logic  [     2: 0] NAME``_awprot;  \
    logic              NAME``_awvalid; \
    logic              NAME``_awready; \
    logic  [     3: 0] NAME``_wstrb;   \
    logic  [ID - 1: 0] NAME``_wid;     \
    logic  [    31: 0] NAME``_wdata;   \
    logic              NAME``_wlast;   \
    logic              NAME``_wvalid;  \
    logic              NAME``_wready;  \
    logic  [ID - 1: 0] NAME``_bid;     \
    logic  [     1: 0] NAME``_bresp;   \
    logic              NAME``_bvalid;  \
    logic              NAME``_bready;  \
    logic  [    31: 0] NAME``_araddr;  \
    logic  [     1: 0] NAME``_arburst; \
    logic  [     2: 0] NAME``_arsize;  \
    logic  [ID - 1: 0] NAME``_arid;    \
    logic  [     7: 0] NAME``_arlen;   \
    logic  [     1: 0] NAME``_arlock;  \
    logic  [     3: 0] NAME``_arcache; \
    logic  [     2: 0] NAME``_arprot;  \
    logic              NAME``_arvalid; \
    logic              NAME``_arready; \
    logic  [    31: 0] NAME``_rdata;   \
    logic  [     1: 0] NAME``_rresp;   \
    logic  [ID - 1: 0] NAME``_rid;     \
    logic              NAME``_rlast;   \
    logic              NAME``_rvalid;  \
    logic              NAME``_rready;

`define APB_MST_PORT_TO_INTF(PORT, INTF)    \
    assign INTF``.psel    = PORT``_psel;    \
    assign INTF``.penable = PORT``_penable; \
    assign INTF``.paddr   = PORT``_paddr;   \
    assign INTF``.pwrite  = PORT``_pwrite;  \
    assign INTF``.pstrb   = PORT``_pstrb;   \
    assign INTF``.pprot   = PORT``_pprot;   \
    assign INTF``.pwdata  = PORT``_pwdata;  \
    assign PORT``_prdata  = INTF``.prdata;  \
    assign PORT``_pslverr = INTF``.pslverr; \
    assign PORT``_pready  = INTF``.pready;

`define APB_MST_INTF_TO_PORT(INTF, PORT)    \
    assign PORT``_psel    = INTF``.psel;    \
    assign PORT``_penable = INTF``.penable; \
    assign PORT``_paddr   = INTF``.paddr;   \
    assign PORT``_pwrite  = INTF``.pwrite;  \
    assign PORT``_pstrb   = INTF``.pstrb;   \
    assign PORT``_pprot   = INTF``.pprot;   \
    assign PORT``_pwdata  = INTF``.pwdata;  \
    assign INTF``.prdata  = PORT``_prdata;  \
    assign INTF``.pslverr = PORT``_pslverr; \
    assign INTF``.pready  = PORT``_pready;

`define AXI_MST_PORT_TO_INTF(PORT, INTF)    \
    assign INTF``.awid    = PORT``_awid;    \
    assign INTF``.awaddr  = PORT``_awaddr;  \
    assign INTF``.awburst = PORT``_awburst; \
    assign INTF``.awsize  = PORT``_awsize;  \
    assign INTF``.awlen   = PORT``_awlen;   \
    assign INTF``.awlock  = PORT``_awlock;  \
    assign INTF``.awcache = PORT``_awcache; \
    assign INTF``.awprot  = PORT``_awprot;  \
    assign INTF``.awvalid = PORT``_awvalid; \
    assign PORT``_awready = INTF``.awready; \
    assign INTF``.wid     = PORT``_wid;     \
    assign INTF``.wstrb   = PORT``_wstrb;   \
    assign INTF``.wdata   = PORT``_wdata;   \
    assign INTF``.wlast   = PORT``_wlast;   \
    assign INTF``.wvalid  = PORT``_wvalid;  \
    assign PORT``_wready  = INTF``.wready;  \
    assign PORT``_bid     = INTF``.bid;     \
    assign PORT``_bresp   = INTF``.bresp;   \
    assign PORT``_bvalid  = INTF``.bvalid;  \
    assign INTF``.bready  = PORT``_bready;  \
    assign INTF``.arid    = PORT``_arid;    \
    assign INTF``.araddr  = PORT``_araddr;  \
    assign INTF``.arburst = PORT``_arburst; \
    assign INTF``.arsize  = PORT``_arsize;  \
    assign INTF``.arlen   = PORT``_arlen;   \
    assign INTF``.arlock  = PORT``_arlock;  \
    assign INTF``.arcache = PORT``_arcache; \
    assign INTF``.arprot  = PORT``_arprot;  \
    assign INTF``.arvalid = PORT``_arvalid; \
    assign PORT``_arready = INTF``.arready; \
    assign PORT``_rid     = INTF``.rid;     \
    assign PORT``_rdata   = INTF``.rdata;   \
    assign PORT``_rresp   = INTF``.rresp;   \
    assign PORT``_rlast   = INTF``.rlast;   \
    assign PORT``_rvalid  = INTF``.rvalid;  \
    assign INTF``.rready  = PORT``_rready;


`define AXI_MST_INTF_TO_PORT(INTF, PORT)    \
    assign PORT``_awid    = INTF``.awid;    \
    assign PORT``_awaddr  = INTF``.awaddr;  \
    assign PORT``_awburst = INTF``.awburst; \
    assign PORT``_awsize  = INTF``.awsize;  \
    assign PORT``_awlen   = INTF``.awlen;   \
    assign PORT``_awlock  = INTF``.awlock;  \
    assign PORT``_awcache = INTF``.awcache; \
    assign PORT``_awprot  = INTF``.awprot;  \
    assign PORT``_awvalid = INTF``.awvalid; \
    assign INTF``.awready = PORT``_awready; \
    assign PORT``_wid     = INTF``.wid;     \
    assign PORT``_wstrb   = INTF``.wstrb;   \
    assign PORT``_wdata   = INTF``.wdata;   \
    assign PORT``_wlast   = INTF``.wlast;   \
    assign PORT``_wvalid  = INTF``.wvalid;  \
    assign INTF``.wready  = PORT``_wready;  \
    assign INTF``.bid     = PORT``_bid;     \
    assign INTF``.bresp   = PORT``_bresp;   \
    assign INTF``.bvalid  = PORT``_bvalid;  \
    assign PORT``_bready  = INTF``.bready;  \
    assign PORT``_arid    = INTF``.arid;    \
    assign PORT``_araddr  = INTF``.araddr;  \
    assign PORT``_arburst = INTF``.arburst; \
    assign PORT``_arsize  = INTF``.arsize;  \
    assign PORT``_arlen   = INTF``.arlen;   \
    assign PORT``_arlock  = INTF``.arlock;  \
    assign PORT``_arcache = INTF``.arcache; \
    assign PORT``_arprot  = INTF``.arprot;  \
    assign PORT``_arvalid = INTF``.arvalid; \
    assign INTF``.arready = PORT``_arready; \
    assign INTF``.rid     = PORT``_rid;     \
    assign INTF``.rdata   = PORT``_rdata;   \
    assign INTF``.rresp   = PORT``_rresp;   \
    assign INTF``.rlast   = PORT``_rlast;   \
    assign INTF``.rvalid  = PORT``_rvalid;  \
    assign PORT``_rready  = INTF``.rready;

`endif

module peri_axi_arb_2to1 (
    input           clk,
    input           rstn,

    axi_intf.slave  s0_axi_intf,
    axi_intf.slave  s1_axi_intf,

    axi_intf.master m_axi_intf
);

`AXI_INTF_DEF(s0,  9)
`AXI_INTF_DEF(s1,  9)
`AXI_INTF_DEF( m, 10)

`AXI_MST_INTF_TO_PORT(s0_axi_intf, s0)
`AXI_MST_INTF_TO_PORT(s1_axi_intf, s1)
`AXI_MST_PORT_TO_INTF(m, m_axi_intf)

axi_2to1_mux_id9 u_axi_2to1_mux (
    .aclk       ( clk        ),
    .aresetn    ( rstn       ),

    `AXI_INTF_CONNECT(s0, s0),
    `AXI_INTF_CONNECT(s1, s1),
    `AXI_INTF_CONNECT( m,  m)
);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/marb.sv
/*--------------------------------------*/

`ifndef __INTF_DEFINE__
`define __INTF_DEFINE__

`define AXI_INTF_CONNECT(PORT, WIRE) \
    .``PORT``_awburst ( WIRE``_awburst ), \
    .``PORT``_awid    ( WIRE``_awid    ), \
    .``PORT``_awaddr  ( WIRE``_awaddr  ), \
    .``PORT``_awsize  ( WIRE``_awsize  ), \
    .``PORT``_awlen   ( WIRE``_awlen   ), \
    .``PORT``_awlock  ( WIRE``_awlock  ), \
    .``PORT``_awcache ( WIRE``_awcache ), \
    .``PORT``_awprot  ( WIRE``_awprot  ), \
    .``PORT``_awvalid ( WIRE``_awvalid ), \
    .``PORT``_awready ( WIRE``_awready ), \
    .``PORT``_wstrb   ( WIRE``_wstrb   ), \
    .``PORT``_wid     ( WIRE``_wid     ), \
    .``PORT``_wdata   ( WIRE``_wdata   ), \
    .``PORT``_wlast   ( WIRE``_wlast   ), \
    .``PORT``_wvalid  ( WIRE``_wvalid  ), \
    .``PORT``_wready  ( WIRE``_wready  ), \
    .``PORT``_bid     ( WIRE``_bid     ), \
    .``PORT``_bresp   ( WIRE``_bresp   ), \
    .``PORT``_bvalid  ( WIRE``_bvalid  ), \
    .``PORT``_bready  ( WIRE``_bready  ), \
    .``PORT``_araddr  ( WIRE``_araddr  ), \
    .``PORT``_arburst ( WIRE``_arburst ), \
    .``PORT``_arsize  ( WIRE``_arsize  ), \
    .``PORT``_arid    ( WIRE``_arid    ), \
    .``PORT``_arlen   ( WIRE``_arlen   ), \
    .``PORT``_arlock  ( WIRE``_arlock  ), \
    .``PORT``_arcache ( WIRE``_arcache ), \
    .``PORT``_arprot  ( WIRE``_arprot  ), \
    .``PORT``_arvalid ( WIRE``_arvalid ), \
    .``PORT``_arready ( WIRE``_arready ), \
    .``PORT``_rdata   ( WIRE``_rdata   ), \
    .``PORT``_rresp   ( WIRE``_rresp   ), \
    .``PORT``_rid     ( WIRE``_rid     ), \
    .``PORT``_rlast   ( WIRE``_rlast   ), \
    .``PORT``_rvalid  ( WIRE``_rvalid  ), \
    .``PORT``_rready  ( WIRE``_rready  )

`define AXI_INTF_SLV_DEF(NAME, ID) \
    input         [     1: 0] NAME``_awburst, \
    input         [ID - 1: 0] NAME``_awid,    \
    input         [    31: 0] NAME``_awaddr,  \
    input         [     2: 0] NAME``_awsize,  \
    input         [     7: 0] NAME``_awlen,   \
    input         [     1: 0] NAME``_awlock,  \
    input         [     3: 0] NAME``_awcache, \
    input         [     2: 0] NAME``_awprot,  \
    input                     NAME``_awvalid, \
    output logic              NAME``_awready, \
    input         [     3: 0] NAME``_wstrb,   \
    input         [ID - 1: 0] NAME``_wid,     \
    input         [    31: 0] NAME``_wdata,   \
    input                     NAME``_wlast,   \
    input                     NAME``_wvalid,  \
    output logic              NAME``_wready,  \
    output logic  [ID - 1: 0] NAME``_bid,     \
    output logic  [     1: 0] NAME``_bresp,   \
    output logic              NAME``_bvalid,  \
    input                     NAME``_bready,  \
    input         [    31: 0] NAME``_araddr,  \
    input         [     1: 0] NAME``_arburst, \
    input         [     2: 0] NAME``_arsize,  \
    input         [ID - 1: 0] NAME``_arid,    \
    input         [     7: 0] NAME``_arlen,   \
    input         [     1: 0] NAME``_arlock,  \
    input         [     3: 0] NAME``_arcache, \
    input         [     2: 0] NAME``_arprot,  \
    input                     NAME``_arvalid, \
    output logic              NAME``_arready, \
    output logic  [    31: 0] NAME``_rdata,   \
    output logic  [     1: 0] NAME``_rresp,   \
    output logic  [ID - 1: 0] NAME``_rid,     \
    output logic              NAME``_rlast,   \
    output logic              NAME``_rvalid,  \
    input                     NAME``_rready

`define AXI_INTF_MST_DEF(NAME, ID) \
    output logic  [     1: 0] NAME``_awburst, \
    output logic  [ID - 1: 0] NAME``_awid,    \
    output logic  [    31: 0] NAME``_awaddr,  \
    output logic  [     2: 0] NAME``_awsize,  \
    output logic  [     7: 0] NAME``_awlen,   \
    output logic  [     1: 0] NAME``_awlock,  \
    output logic  [     3: 0] NAME``_awcache, \
    output logic  [     2: 0] NAME``_awprot,  \
    output logic              NAME``_awvalid, \
    input                     NAME``_awready, \
    output logic  [     3: 0] NAME``_wstrb,   \
    output logic  [ID - 1: 0] NAME``_wid,     \
    output logic  [    31: 0] NAME``_wdata,   \
    output logic              NAME``_wlast,   \
    output logic              NAME``_wvalid,  \
    input                     NAME``_wready,  \
    input         [ID - 1: 0] NAME``_bid,     \
    input         [     1: 0] NAME``_bresp,   \
    input                     NAME``_bvalid,  \
    output logic              NAME``_bready,  \
    output logic  [    31: 0] NAME``_araddr,  \
    output logic  [     1: 0] NAME``_arburst, \
    output logic  [     2: 0] NAME``_arsize,  \
    output logic  [ID - 1: 0] NAME``_arid,    \
    output logic  [     7: 0] NAME``_arlen,   \
    output logic  [     1: 0] NAME``_arlock,  \
    output logic  [     3: 0] NAME``_arcache, \
    output logic  [     2: 0] NAME``_arprot,  \
    output logic              NAME``_arvalid, \
    input                     NAME``_arready, \
    input         [    31: 0] NAME``_rdata,   \
    input         [     1: 0] NAME``_rresp,   \
    input         [ID - 1: 0] NAME``_rid,     \
    input                     NAME``_rlast,   \
    input                     NAME``_rvalid,  \
    output logic              NAME``_rready

`define AXI_INTF_DEF(NAME, ID) \
    logic  [     1: 0] NAME``_awburst; \
    logic  [ID - 1: 0] NAME``_awid;    \
    logic  [    31: 0] NAME``_awaddr;  \
    logic  [     2: 0] NAME``_awsize;  \
    logic  [     7: 0] NAME``_awlen;   \
    logic  [     1: 0] NAME``_awlock;  \
    logic  [     3: 0] NAME``_awcache; \
    logic  [     2: 0] NAME``_awprot;  \
    logic              NAME``_awvalid; \
    logic              NAME``_awready; \
    logic  [     3: 0] NAME``_wstrb;   \
    logic  [ID - 1: 0] NAME``_wid;     \
    logic  [    31: 0] NAME``_wdata;   \
    logic              NAME``_wlast;   \
    logic              NAME``_wvalid;  \
    logic              NAME``_wready;  \
    logic  [ID - 1: 0] NAME``_bid;     \
    logic  [     1: 0] NAME``_bresp;   \
    logic              NAME``_bvalid;  \
    logic              NAME``_bready;  \
    logic  [    31: 0] NAME``_araddr;  \
    logic  [     1: 0] NAME``_arburst; \
    logic  [     2: 0] NAME``_arsize;  \
    logic  [ID - 1: 0] NAME``_arid;    \
    logic  [     7: 0] NAME``_arlen;   \
    logic  [     1: 0] NAME``_arlock;  \
    logic  [     3: 0] NAME``_arcache; \
    logic  [     2: 0] NAME``_arprot;  \
    logic              NAME``_arvalid; \
    logic              NAME``_arready; \
    logic  [    31: 0] NAME``_rdata;   \
    logic  [     1: 0] NAME``_rresp;   \
    logic  [ID - 1: 0] NAME``_rid;     \
    logic              NAME``_rlast;   \
    logic              NAME``_rvalid;  \
    logic              NAME``_rready;

`define APB_MST_PORT_TO_INTF(PORT, INTF)    \
    assign INTF``.psel    = PORT``_psel;    \
    assign INTF``.penable = PORT``_penable; \
    assign INTF``.paddr   = PORT``_paddr;   \
    assign INTF``.pwrite  = PORT``_pwrite;  \
    assign INTF``.pstrb   = PORT``_pstrb;   \
    assign INTF``.pprot   = PORT``_pprot;   \
    assign INTF``.pwdata  = PORT``_pwdata;  \
    assign PORT``_prdata  = INTF``.prdata;  \
    assign PORT``_pslverr = INTF``.pslverr; \
    assign PORT``_pready  = INTF``.pready;

`define APB_MST_INTF_TO_PORT(INTF, PORT)    \
    assign PORT``_psel    = INTF``.psel;    \
    assign PORT``_penable = INTF``.penable; \
    assign PORT``_paddr   = INTF``.paddr;   \
    assign PORT``_pwrite  = INTF``.pwrite;  \
    assign PORT``_pstrb   = INTF``.pstrb;   \
    assign PORT``_pprot   = INTF``.pprot;   \
    assign PORT``_pwdata  = INTF``.pwdata;  \
    assign INTF``.prdata  = PORT``_prdata;  \
    assign INTF``.pslverr = PORT``_pslverr; \
    assign INTF``.pready  = PORT``_pready;

`define AXI_MST_PORT_TO_INTF(PORT, INTF)    \
    assign INTF``.awid    = PORT``_awid;    \
    assign INTF``.awaddr  = PORT``_awaddr;  \
    assign INTF``.awburst = PORT``_awburst; \
    assign INTF``.awsize  = PORT``_awsize;  \
    assign INTF``.awlen   = PORT``_awlen;   \
    assign INTF``.awlock  = PORT``_awlock;  \
    assign INTF``.awcache = PORT``_awcache; \
    assign INTF``.awprot  = PORT``_awprot;  \
    assign INTF``.awvalid = PORT``_awvalid; \
    assign PORT``_awready = INTF``.awready; \
    assign INTF``.wid     = PORT``_wid;     \
    assign INTF``.wstrb   = PORT``_wstrb;   \
    assign INTF``.wdata   = PORT``_wdata;   \
    assign INTF``.wlast   = PORT``_wlast;   \
    assign INTF``.wvalid  = PORT``_wvalid;  \
    assign PORT``_wready  = INTF``.wready;  \
    assign PORT``_bid     = INTF``.bid;     \
    assign PORT``_bresp   = INTF``.bresp;   \
    assign PORT``_bvalid  = INTF``.bvalid;  \
    assign INTF``.bready  = PORT``_bready;  \
    assign INTF``.arid    = PORT``_arid;    \
    assign INTF``.araddr  = PORT``_araddr;  \
    assign INTF``.arburst = PORT``_arburst; \
    assign INTF``.arsize  = PORT``_arsize;  \
    assign INTF``.arlen   = PORT``_arlen;   \
    assign INTF``.arlock  = PORT``_arlock;  \
    assign INTF``.arcache = PORT``_arcache; \
    assign INTF``.arprot  = PORT``_arprot;  \
    assign INTF``.arvalid = PORT``_arvalid; \
    assign PORT``_arready = INTF``.arready; \
    assign PORT``_rid     = INTF``.rid;     \
    assign PORT``_rdata   = INTF``.rdata;   \
    assign PORT``_rresp   = INTF``.rresp;   \
    assign PORT``_rlast   = INTF``.rlast;   \
    assign PORT``_rvalid  = INTF``.rvalid;  \
    assign INTF``.rready  = PORT``_rready;


`define AXI_MST_INTF_TO_PORT(INTF, PORT)    \
    assign PORT``_awid    = INTF``.awid;    \
    assign PORT``_awaddr  = INTF``.awaddr;  \
    assign PORT``_awburst = INTF``.awburst; \
    assign PORT``_awsize  = INTF``.awsize;  \
    assign PORT``_awlen   = INTF``.awlen;   \
    assign PORT``_awlock  = INTF``.awlock;  \
    assign PORT``_awcache = INTF``.awcache; \
    assign PORT``_awprot  = INTF``.awprot;  \
    assign PORT``_awvalid = INTF``.awvalid; \
    assign INTF``.awready = PORT``_awready; \
    assign PORT``_wid     = INTF``.wid;     \
    assign PORT``_wstrb   = INTF``.wstrb;   \
    assign PORT``_wdata   = INTF``.wdata;   \
    assign PORT``_wlast   = INTF``.wlast;   \
    assign PORT``_wvalid  = INTF``.wvalid;  \
    assign INTF``.wready  = PORT``_wready;  \
    assign INTF``.bid     = PORT``_bid;     \
    assign INTF``.bresp   = PORT``_bresp;   \
    assign INTF``.bvalid  = PORT``_bvalid;  \
    assign PORT``_bready  = INTF``.bready;  \
    assign PORT``_arid    = INTF``.arid;    \
    assign PORT``_araddr  = INTF``.araddr;  \
    assign PORT``_arburst = INTF``.arburst; \
    assign PORT``_arsize  = INTF``.arsize;  \
    assign PORT``_arlen   = INTF``.arlen;   \
    assign PORT``_arlock  = INTF``.arlock;  \
    assign PORT``_arcache = INTF``.arcache; \
    assign PORT``_arprot  = INTF``.arprot;  \
    assign PORT``_arvalid = INTF``.arvalid; \
    assign INTF``.arready = PORT``_arready; \
    assign INTF``.rid     = PORT``_rid;     \
    assign INTF``.rdata   = PORT``_rdata;   \
    assign INTF``.rresp   = PORT``_rresp;   \
    assign INTF``.rlast   = PORT``_rlast;   \
    assign INTF``.rvalid  = PORT``_rvalid;  \
    assign PORT``_rready  = INTF``.rready;

`endif

module marb (
    input                  clk,
    input                  rstn,

    axi_intf.slave         s0_axi_intf,
    axi_intf.slave         s1_axi_intf,
    axi_intf.slave         s2_axi_intf,
    axi_intf.slave         s3_axi_intf,
    axi_intf.slave         s4_axi_intf,

    output logic           m0_cs, 
    output logic           m0_we, 
    output logic  [ 31: 0] m0_addr,
    output logic  [  3: 0] m0_byte,
    output logic  [ 31: 0] m0_di,
    input         [ 31: 0] m0_do,
    input                  m0_busy,

    output logic           m1_cs, 
    output logic           m1_we, 
    output logic  [ 31: 0] m1_addr,
    output logic  [  3: 0] m1_byte,
    output logic  [ 31: 0] m1_di,
    input         [ 31: 0] m1_do,
    input                  m1_busy,

    apb_intf.master        m_core_apb,
    apb_intf.master        m_peri_apb,
    axi_intf.master        m_ddr_axi
);

`AXI_INTF_DEF(s0, 10)
`AXI_INTF_DEF(s1, 10)
`AXI_INTF_DEF(s2, 10)
`AXI_INTF_DEF(s3, 10)
`AXI_INTF_DEF(s4, 10)
`AXI_INTF_DEF(m0, 13)
`AXI_INTF_DEF(m1, 13)
`AXI_INTF_DEF(m2, 13)
`AXI_INTF_DEF(m3, 13)
`AXI_INTF_DEF(m4, 13)

`AXI_MST_INTF_TO_PORT(s0_axi_intf, s0)
`AXI_MST_INTF_TO_PORT(s1_axi_intf, s1)
`AXI_MST_INTF_TO_PORT(s2_axi_intf, s2)
`AXI_MST_INTF_TO_PORT(s3_axi_intf, s3)
`AXI_MST_INTF_TO_PORT(s4_axi_intf, s4)
`AXI_MST_PORT_TO_INTF(m0, m0_axi)
`AXI_MST_PORT_TO_INTF(m1, m1_axi)
`AXI_MST_PORT_TO_INTF(m2, m2_axi)
`AXI_MST_PORT_TO_INTF(m3, m3_axi)
`AXI_MST_PORT_TO_INTF(m4, m_ddr_axi)

axi_intf#(.ID_WIDTH(13)) m0_axi();
axi_intf#(.ID_WIDTH(13)) m1_axi();
axi_intf#(.ID_WIDTH(13)) m2_axi();
axi_intf#(.ID_WIDTH(13)) m3_axi();

axi_5to5_biu u_axi_5to5_biu (
    .aclk       ( clk        ),
    .aresetn    ( rstn       ),

    `AXI_INTF_CONNECT(s0, s0),
    `AXI_INTF_CONNECT(s1, s1),
    `AXI_INTF_CONNECT(s2, s2),
    `AXI_INTF_CONNECT(s3, s3),
    `AXI_INTF_CONNECT(s4, s4),
    `AXI_INTF_CONNECT(m0, m0),
    `AXI_INTF_CONNECT(m1, m1),
    `AXI_INTF_CONNECT(m2, m2),
    `AXI_INTF_CONNECT(m3, m3),
    `AXI_INTF_CONNECT(m4, m4)
);

axi2mem_bridge u_axi2mem0 (
    .aclk       ( clk           ),
    .aresetn    ( rstn          ),
    // AXI slave port
    .s_axi_intf ( m0_axi.slave  ),

    // Memory intface master port
    .m_cs       ( m0_cs         ),
    .m_we       ( m0_we         ),
    .m_addr     ( m0_addr       ),
    .m_byte     ( m0_byte       ),
    .m_di       ( m0_di         ),
    .m_do       ( m0_do         ),
    .m_busy     ( m0_busy       )
);

axi2mem_bridge u_axi2mem1 (
    .aclk       ( clk           ),
    .aresetn    ( rstn          ),
    // AXI slave port
    .s_axi_intf ( m1_axi.slave  ),

    // Memory intface master port
    .m_cs       ( m1_cs         ),
    .m_we       ( m1_we         ),
    .m_addr     ( m1_addr       ),
    .m_byte     ( m1_byte       ),
    .m_di       ( m1_di         ),
    .m_do       ( m1_do         ),
    .m_busy     ( m1_busy       )
);

axi2apb_bridge u_axi2apb_m2 (
    .aclk       ( clk             ),
    .aresetn    ( rstn            ),
    .s_axi_intf ( m2_axi.slave    ),

    // APB master port
    .m_apb_intf ( m_core_apb      )
);

axi2apb_bridge u_axi2apb_m3 (
    .aclk       ( clk             ),
    .aresetn    ( rstn            ),
    .s_axi_intf ( m3_axi.slave    ),

    // APB master port
    .m_apb_intf ( m_peri_apb      )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/cpu_top.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

//`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif

`define MDU_OP_LEN 4
`define ALU_OP_LEN 4
`define BPU_OP_LEN 2
`define CSR_OP_LEN 2
`define AMO_OP_LEN 4

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define GPR_ZERO_ADDR 5'b00000
`define GPR_RA_ADDR   5'b00001
`define GPR_SP_ADDR   5'b00010
`define GPR_GP_ADDR   5'b00011
`define GPR_TP_ADDR   5'b00100
`define GPR_T0_ADDR   5'b00101
`define GPR_T1_ADDR   5'b00110
`define GPR_T2_ADDR   5'b00111
`define GPR_S0_ADDR   5'b01000
`define GPR_FP_ADDR   5'b01000
`define GPR_S1_ADDR   5'b01001
`define GPR_A0_ADDR   5'b01010
`define GPR_A1_ADDR   5'b01011
`define GPR_A2_ADDR   5'b01100
`define GPR_A3_ADDR   5'b01101
`define GPR_A4_ADDR   5'b01110
`define GPR_A5_ADDR   5'b01111
`define GPR_A6_ADDR   5'b10000
`define GPR_A7_ADDR   5'b10001
`define GPR_S2_ADDR   5'b10010
`define GPR_S3_ADDR   5'b10011
`define GPR_S4_ADDR   5'b10100
`define GPR_S5_ADDR   5'b10101
`define GPR_S6_ADDR   5'b10110
`define GPR_S7_ADDR   5'b10111
`define GPR_S8_ADDR   5'b11000
`define GPR_S9_ADDR   5'b11001
`define GPR_S10_ADDR  5'b11010
`define GPR_S11_ADDR  5'b11011
`define GPR_T3_ADDR   5'b11100
`define GPR_T4_ADDR   5'b11101
`define GPR_T5_ADDR   5'b11110
`define GPR_T6_ADDR   5'b11111

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       'h0
`define CAUSE_INSTRUCTION_ACCESS     'h1
`define CAUSE_ILLEGAL_INSTRUCTION    'h2
`define CAUSE_BREAKPOINT             'h3
`define CAUSE_MISALIGNED_LOAD        'h4
`define CAUSE_LOAD_ACCESS            'h5
`define CAUSE_MISALIGNED_STORE       'h6
`define CAUSE_STORE_ACCESS           'h7
`define CAUSE_USER_ECALL             'h8
`define CAUSE_SUPERVISOR_ECALL       'h9
`define CAUSE_HYPERVISOR_ECALL       'ha
`define CAUSE_MACHINE_ECALL          'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT 'hc
`define CAUSE_LOAD_PAGE_FAULT        'hd
`define CAUSE_STORE_PAGE_FAULT       'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`define MCAUSE_CODE_WIDTH 6

`define MISA_MXL_XLEN_32  2'b01
`define MISA_MXL_XLEN_64  2'b10
`define MISA_MXL_XLEN_128 2'b11

`define SATP32_PPN_WIDTH  22
`define SATP32_ASID_WIDTH  9
`define SATP32_MODE_WIDTH  1

`define SATP64_PPN_WIDTH  44
`define SATP64_ASID_WIDTH 16
`define SATP64_MODE_WIDTH  4

`define SATP32_PPN_BIT     0+:`SATP32_PPN_WIDTH
`define SATP32_ASID_BIT   22+:`SATP32_ASID_WIDTH
`define SATP32_MODE_BIT   31+:`SATP32_MODE_WIDTH

`define SATP64_PPN_BIT     0+:`SATP64_PPN_WIDTH
`define SATP64_ASID_BIT   44+:`SATP64_ASID_WIDTH
`define SATP64_MODE_BIT   60+:`SATP64_MODE_WIDTH

`ifdef RV32
`define SATP_PPN_WIDTH  `SATP32_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP32_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP32_MODE_WIDTH
`define PADDR_LEN       (`SATP32_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`else
`define SATP_PPN_WIDTH  `SATP64_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP64_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP64_MODE_WIDTH
`define PADDR_LEN       (`SATP64_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`define SATP_MODE_SV39  `SATP_MODE_WIDTH'h8
`define SATP_MODE_SV48  `SATP_MODE_WIDTH'h9
`define SATP_MODE_SV57  `SATP_MODE_WIDTH'ha
`define SATP_MODE_SV64  `SATP_MODE_WIDTH'hb
`endif

`define PTE_V_BIT     0
`define PTE_R_BIT     1
`define PTE_W_BIT     2
`define PTE_X_BIT     3
`define PTE_U_BIT     4
`define PTE_G_BIT     5
`define PTE_A_BIT     6
`define PTE_D_BIT     7
`define PTE_RSW_BIT   8:9
`define PTE_PPN_SHIFT 10

`endif

module cpu_top (
    input                                    clk,
    input                                    srstn,
    input                                    xrstn,
    input        [              `XLEN - 1:0] cpu_id,
    output logic                             rv64_mode,
    input        [              `XLEN - 1:0] bootvec,
    output logic                             warm_rst_trigger,
    input        [                     63:0] systime,

    // mpu csr
    output logic [                  8 - 1:0] pmpcfg  [16],
    output logic [              `XLEN - 1:0] pmpaddr [16],
    output logic [                  8 - 1:0] pmacfg  [16],
    output logic [              `XLEN - 1:0] pmaaddr [16],

    // mmu csr
    output logic [    `SATP_PPN_WIDTH - 1:0] satp_ppn,
    output logic [   `SATP_ASID_WIDTH - 1:0] satp_asid,
    output logic [   `SATP_MODE_WIDTH - 1:0] satp_mode,
    output logic [                      1:0] prv,
    output logic                             sum,
    output logic                             mprv,
    output logic [                      1:0] mpp,

    // TLB control
    output logic                             tlb_flush_req,
    output logic                             tlb_flush_all_vaddr,
    output logic                             tlb_flush_all_asid,
    output logic [              `XLEN - 1:0] tlb_flush_vaddr,
    output logic [              `XLEN - 1:0] tlb_flush_asid,

    // interrupt interface
    input                                    msip,
    input                                    mtip,
    input                                    meip,
    input                                    seip,

    // insn interface
    output logic                             imem_en,
    output logic [       `IM_ADDR_LEN - 1:0] imem_addr,
    input        [              `XLEN - 1:0] imem_rdata,
    input        [                      1:0] imem_bad,
    input                                    imem_busy,
    output logic                             ic_flush,

    // data interface                             
    output logic                             dmem_en,
    output logic [       `IM_ADDR_LEN - 1:0] dmem_addr,
    output logic                             dmem_write,
    output logic                             dmem_ex,
    output logic [     `DM_DATA_LEN/8 - 1:0] dmem_strb,
    output logic [       `DM_DATA_LEN - 1:0] dmem_wdata,
    input        [       `DM_DATA_LEN - 1:0] dmem_rdata,
    input        [                      1:0] dmem_bad,
    input                                    dmem_xstate,
    input                                    dmem_busy,

    // debug intface
    output logic [              `XLEN - 1:0] dbg_gpr_all [32],
    input        [                     11:0] dbg_addr,
    input        [              `XLEN - 1:0] dbg_wdata,
    input                                    dbg_gpr_rd,
    input                                    dbg_gpr_wr,
    output logic [              `XLEN - 1:0] dbg_gpr_out,
    input                                    dbg_csr_rd,
    input                                    dbg_csr_wr,
    output logic [              `XLEN - 1:0] dbg_csr_out,
    output logic [       `IM_ADDR_LEN - 1:0] dbg_pc_out,
    input                                    dbg_exec,
    input        [       `IM_DATA_LEN - 1:0] dbg_insn,
    input                                    attach,
    output logic                             halted,

    // CPU tracer
    output logic                             trace_pkg_valid,
    output logic [                    255:0] trace_pkg
);

logic                             srstn_sync;
logic                             xrstn_sync;
logic                             wakeup_event;
logic                             sleep;
logic                             stall_wfi;
logic [                      5:0] insn_valid;
logic [       `IM_ADDR_LEN - 1:0] irq_vec;
logic [       `IM_ADDR_LEN - 1:0] ret_epc;

// Hazard Control Unit
logic                             if_stall;
logic                             id_stall;
logic                             exe_stall;
logic                             ma_stall;
logic                             mr_stall;
logic                             wb_stall;
logic                             if_flush;
logic                             id_flush;
logic                             exe_flush;
logic                             ma_flush;
logic                             mr_flush;
logic                             wb_flush;
logic                             if_flush_force;
logic                             id_flush_force;
logic                             exe_flush_force;
logic                             ma_flush_force;
logic                             mr_flush_force;
logic                             wb_flush_force;

// IF stage
logic                             if_pc_jump_en;
logic [       `IM_ADDR_LEN - 1:0] if_pc_jump;
logic                             if_jump_token;
logic [       `IM_ADDR_LEN - 1:0] if_pc;
logic [       `IM_DATA_LEN - 1:0] if_insn;
logic                             if_insn_valid;
logic [       `IM_ADDR_LEN - 1:0] if_insn_misaligned_epc;
logic                             if_insn_misaligned;
logic                             if_insn_page_fault;
logic                             if_insn_xes_fault;
logic [       `IM_ADDR_LEN - 1:0] if_insn_badaddr;

// IF/ID pipeline
logic [       `IM_ADDR_LEN - 1:0] if2id_pc;
logic [       `IM_DATA_LEN - 1:0] if2id_insn;
logic                             if2id_insn_valid;
logic [       `IM_ADDR_LEN - 1:0] if2id_insn_misaligned_epc;
logic                             if2id_insn_misaligned;
logic                             if2id_insn_page_fault;
logic                             if2id_insn_xes_fault;
logic [       `IM_ADDR_LEN - 1:0] if2id_insn_badaddr;
logic                             if2id_jump_token;
logic                             if2id_attach;
logic                             if2id_stall_flag;

// ID stage
logic [                      4:0] id_rd_addr;
logic [                      4:0] id_rs1_addr;
logic [                      4:0] id_rs2_addr;
logic [              `XLEN - 1:0] id_gpr_rs1_data;
logic [              `XLEN - 1:0] id_gpr_rs2_data;
logic [              `XLEN - 1:0] id_rs1_data;
logic [              `XLEN - 1:0] id_rs2_data;
logic [                     11:0] id_csr_addr;
logic                             id_amo_64;
logic                             id_len_64;
logic [              `XLEN - 1:0] id_imm;

logic [                      1:0] id_prv_req;
logic                             id_ill_insn;
logic                             id_fence;
logic                             id_fence_i;
logic                             id_ecall;
logic                             id_ebreak;
logic                             id_wfi;
logic                             id_sret;
logic                             id_mret;
logic                             id_jump;
logic                             id_jump_alu;
logic                             id_jump_fault;

logic                             id_rs1_rd;
logic                             id_rs2_rd;
logic                             id_mdu_sel;
logic [        `MDU_OP_LEN - 1:0] id_mdu_op;
logic [        `ALU_OP_LEN - 1:0] id_alu_op;
logic                             id_rs1_zero_sel;
logic                             id_rs2_imm_sel;
logic                             id_pc_imm_sel;
logic                             id_branch;
logic                             id_branch_zcmp;
logic [        `BPU_OP_LEN - 1:0] id_bpu_op;
logic [        `CSR_OP_LEN - 1:0] id_csr_op;
logic                             id_uimm_rs1_sel;
logic                             id_pc_alu_sel;
logic                             id_csr_alu_sel;
logic                             id_amo;
logic [        `AMO_OP_LEN - 1:0] id_amo_op;
logic                             id_mem_req;
logic                             id_mem_wr;
logic                             id_mem_ex;
logic [(`DM_DATA_LEN >> 3) - 1:0] id_mem_byte;
logic                             id_mem_sign_ext;
logic                             id_tlb_flush_req;
logic                             id_tlb_flush_all_vaddr;
logic                             id_tlb_flush_all_asid;

logic                             id_mem_cal_sel;
logic                             id_rd_wr;

logic                             id_hazard;
logic                             id_csr_rd;
logic                             id_csr_wr;
logic                             id_pmu_csr_wr;
logic                             id_fpu_csr_wr;
logic                             id_dbg_csr_wr;
logic                             id_mmu_csr_wr;
logic                             id_mpu_csr_wr;
logic                             id_sru_csr_wr;
logic [              `XLEN - 1:0] id_csr_rdata;
logic [              `XLEN - 1:0] id_pmu_csr_rdata;
logic [              `XLEN - 1:0] id_fpu_csr_rdata;
logic [              `XLEN - 1:0] id_dbg_csr_rdata;
logic [              `XLEN - 1:0] id_mmu_csr_rdata;
logic [              `XLEN - 1:0] id_mpu_csr_rdata;
logic [              `XLEN - 1:0] id_sru_csr_rdata;

// ID/EXE pipeline
logic [       `IM_ADDR_LEN - 1:0] id2exe_pc;
logic [       `IM_DATA_LEN - 1:0] id2exe_insn;
logic                             id2exe_insn_valid;
logic [                      4:0] id2exe_rd_addr;
logic [                      4:0] id2exe_rs1_addr;
logic [                      4:0] id2exe_rs2_addr;
logic [              `XLEN - 1:0] id2exe_rs1_data;
logic [              `XLEN - 1:0] id2exe_rs2_data;
logic [                     11:0] id2exe_csr_waddr;
logic [              `XLEN - 1:0] id2exe_csr_rdata;
logic                             id2exe_amo_64;
logic                             id2exe_len_64;
logic [              `XLEN - 1:0] id2exe_imm;

logic                             id2exe_rs1_rd;
logic                             id2exe_rs2_rd;
logic                             id2exe_mdu_sel;
logic [        `MDU_OP_LEN - 1:0] id2exe_mdu_op;
logic [        `ALU_OP_LEN - 1:0] id2exe_alu_op;
logic                             id2exe_rs1_zero_sel;
logic                             id2exe_rs2_imm_sel;
logic                             id2exe_pc_imm_sel;
logic                             id2exe_jump_alu;
logic                             id2exe_branch;
logic                             id2exe_branch_zcmp;
logic [        `BPU_OP_LEN - 1:0] id2exe_bpu_op;
logic [        `CSR_OP_LEN - 1:0] id2exe_csr_op;
logic                             id2exe_uimm_rs1_sel;
logic                             id2exe_csr_rd;
logic                             id2exe_pmu_csr_wr;
logic                             id2exe_fpu_csr_wr;
logic                             id2exe_dbg_csr_wr;
logic                             id2exe_mmu_csr_wr;
logic                             id2exe_mpu_csr_wr;
logic                             id2exe_sru_csr_wr;

logic                             id2exe_pc_alu_sel;
logic                             id2exe_csr_alu_sel;
logic                             id2exe_amo;
logic [        `AMO_OP_LEN - 1:0] id2exe_amo_op;
logic                             id2exe_mem_req;
logic                             id2exe_mem_wr;
logic                             id2exe_mem_ex;
logic [(`DM_DATA_LEN >> 3) - 1:0] id2exe_mem_byte;
logic                             id2exe_mem_sign_ext;

logic                             id2exe_mem_cal_sel;
logic                             id2exe_rd_wr;
logic                             id2exe_wfi;
logic                             id2exe_ecall;
logic                             id2exe_ebreak;
logic                             id2exe_sret;
logic                             id2exe_mret;
logic                             id2exe_ill_insn;
logic [                      1:0] id2exe_prv_req;
logic [       `IM_ADDR_LEN - 1:0] id2exe_insn_misaligned_epc;
logic                             id2exe_insn_misaligned;
logic                             id2exe_insn_page_fault;
logic                             id2exe_insn_xes_fault;
logic [       `IM_ADDR_LEN - 1:0] id2exe_insn_badaddr;
logic                             id2exe_tlb_flush_req;
logic                             id2exe_tlb_flush_all_vaddr;
logic                             id2exe_tlb_flush_all_asid;
logic                             id2exe_fence_i;
logic                             id2exe_attach;
logic                             id2exe_ext_csr_wr;
logic [              `XLEN - 1:0] id2exe_ext_csr_wdata;

// EXE stage
logic                             exe_insn_valid;
logic                             exe_alu_zero;
logic                             exe_jump_fault;
logic                             exe_branch;
logic                             exe_bpu_en;
logic [       `IM_ADDR_LEN - 1:0] exe_bpu_pc;
logic [              `XLEN - 1:0] exe_pc_imm;
logic [              `XLEN - 1:0] exe_pc_add_4;
logic [              `XLEN - 1:0] exe_rs1_data;
logic [              `XLEN - 1:0] exe_rs2_data;
logic [              `XLEN - 1:0] exe_alu_src1;
logic [              `XLEN - 1:0] exe_alu_src2;
logic [              `XLEN - 1:0] exe_alu_out;
logic [              `XLEN - 1:0] exe_mdu_out;
logic                             exe_mdu_sel;
logic                             exe_mdu_okay;
logic [              `XLEN - 1:0] exe_rd_data;
logic [              `XLEN - 1:0] exe_pc2rd;
logic                             exe_mem_hazard;
logic                             exe_gpr_hazard;
logic                             exe_csr_hazard;
logic                             exe_hazard;
logic                             exe_int_mask;
logic [              `XLEN - 1:0] exe_csr_src1;
logic [              `XLEN - 1:0] exe_csr_src2;
logic [              `XLEN - 1:0] exe_csr_alu_out;
logic [              `XLEN - 1:0] exe_csr_wdata_pre;
logic [              `XLEN - 1:0] exe_csr_wdata;
logic [              `XLEN - 1:0] exe_csr_sdata;
logic [              `XLEN - 1:0] exe_csr_cdata;
logic                             exe_pmu_csr_wr;
logic                             exe_fpu_csr_wr;
logic                             exe_dbg_csr_wr;
logic                             exe_mmu_csr_wr;
logic                             exe_mpu_csr_wr;
logic                             exe_sru_csr_wr;
logic                             exe_sret;
logic                             exe_mret;
logic                             exe_eret_en;
logic [                      1:0] exe_misa_mxl;
logic                             exe_misa_a_ext;
logic                             exe_misa_c_ext;
logic                             exe_misa_m_ext;
logic                             exe_touch_satp;
logic                             exe_satp_upd;
logic                             exe_misa_upd;
logic                             exe_insn_misaligned;
logic [              `XLEN - 1:0] exe_insn_misaligned_badaddr;
logic                             exe_mstatus_tsr;
logic                             exe_mstatus_tvm;
logic                             exe_pmu_csr_ill;
logic                             exe_irq_en;
logic [                      1:0] exe_prv;
logic                             exe_trap_en;
logic [       `IM_ADDR_LEN - 1:0] exe_trap_epc;
logic [              `XLEN - 1:0] exe_trap_cause;
logic [              `XLEN - 1:0] exe_trap_val;
logic [              `XLEN - 1:0] exe_cause;
logic [              `XLEN - 1:0] exe_tval;
logic [    `SATP_PPN_WIDTH - 1:0] exe_satp_ppn;
logic [   `SATP_ASID_WIDTH - 1:0] exe_satp_asid;
logic [   `SATP_MODE_WIDTH - 1:0] exe_satp_mode;
logic [                     31:0] exe_fwd_table;
logic [                     31:0] exe_hz_table;

// EXE/MEM pipeline
logic [       `IM_ADDR_LEN - 1:0] exe2ma_pc;
logic [       `IM_DATA_LEN - 1:0] exe2ma_insn;
logic                             exe2ma_insn_valid;
logic                             exe2ma_amo;
logic [        `AMO_OP_LEN - 1:0] exe2ma_amo_op;
logic                             exe2ma_mem_req;
logic                             exe2ma_mem_wr;
logic                             exe2ma_mem_ex;
logic [(`DM_DATA_LEN >> 3) - 1:0] exe2ma_mem_byte;
logic                             exe2ma_mem_sign_ext;
logic                             exe2ma_amo_64;
logic                             exe2ma_len_64;
logic [              `XLEN - 1:0] exe2ma_csr_rdata;
logic                             exe2ma_pc_alu_sel;
logic                             exe2ma_csr_alu_sel;
logic                             exe2ma_mem_cal_sel;
logic                             exe2ma_rd_wr;
logic [                      4:0] exe2ma_rd_addr;
logic [                      4:0] exe2ma_rs1_addr;
logic [                      4:0] exe2ma_rs2_addr;
logic [              `XLEN - 1:0] exe2ma_rd_data;
logic [              `XLEN - 1:0] exe2ma_pc2rd;
logic [              `XLEN - 1:0] exe2ma_rs1_data;
logic [              `XLEN - 1:0] exe2ma_rs2_data;
logic                             exe2ma_csr_wr;
logic [                     11:0] exe2ma_csr_waddr;
logic [              `XLEN - 1:0] exe2ma_csr_wdata;
logic                             exe2ma_wfi;
logic [                      1:0] exe2ma_prv;
logic                             exe2ma_trap_en;
logic [              `XLEN - 1:0] exe2ma_cause;
logic [              `XLEN - 1:0] exe2ma_tval;
logic [       `IM_ADDR_LEN - 1:0] exe2ma_epc;
logic                             exe2ma_tlb_flush_req;
logic                             exe2ma_tlb_flush_all_vaddr;
logic                             exe2ma_tlb_flush_all_asid;
logic                             exe2ma_fence_i;
logic                             exe2ma_attach;
logic                             exe2ma_pipe_restart;
logic [                     31:0] exe2ma_fwd_table;
logic [                     31:0] exe2ma_hz_table;

// MA stage
logic [              `XLEN - 1:0] ma_rd_data;

logic [              `XLEN - 1:0] ma_rs1_data;
logic                             ma_dpu_req;
logic                             ma_dpu_wr;
logic                             ma_dpu_ex;
logic [(`DM_DATA_LEN >> 3) - 1:0] ma_dpu_byte;
logic [       `DM_ADDR_LEN - 1:0] ma_dpu_addr;
logic [       `DM_DATA_LEN - 1:0] ma_dpu_wdata;

logic [       `DM_DATA_LEN - 1:0] ma_dpu_amo_wdata;

logic                             ma_pipe_restart;
logic [                     31:0] ma_fwd_table;
logic [                     31:0] ma_hz_table;

// MA/MR pipeline
logic [       `IM_ADDR_LEN - 1:0] ma2mr_pc;
logic [       `IM_DATA_LEN - 1:0] ma2mr_insn;
logic                             ma2mr_insn_valid;
logic [                      4:0] ma2mr_rd_addr;
logic                             ma2mr_rd_wr;
logic [(`DM_DATA_LEN >> 3) - 1:0] ma2mr_mem_byte;
logic                             ma2mr_mem_sign_ext;
logic                             ma2mr_mem_cal_sel;
logic                             ma2mr_len_64;
logic [              `XLEN - 1:0] ma2mr_rd_data;
logic [              `XLEN - 1:0] ma2mr_pc2rd;
logic [       `DM_ADDR_LEN - 1:0] ma2mr_mem_addr;
logic [       `DM_DATA_LEN - 1:0] ma2mr_mem_wdata;
logic                             ma2mr_mem_req_wo_flush;
logic                             ma2mr_mem_req;
logic                             ma2mr_mem_wr;
logic                             ma2mr_csr_wr;
logic [                     11:0] ma2mr_csr_waddr;
logic [              `XLEN - 1:0] ma2mr_csr_wdata;
logic                             ma2mr_wfi;
logic [                      1:0] ma2mr_prv;
logic                             ma2mr_trap_en;
logic [              `XLEN - 1:0] ma2mr_cause;
logic [              `XLEN - 1:0] ma2mr_tval;
logic [       `IM_ADDR_LEN - 1:0] ma2mr_epc;
logic                             ma2mr_attach;
logic                             ma2mr_tlb_flush_req;
logic                             ma2mr_tlb_flush_all_vaddr;
logic                             ma2mr_tlb_flush_all_asid;
logic [              `XLEN - 1:0] ma2mr_tlb_flush_vaddr;
logic [              `XLEN - 1:0] ma2mr_tlb_flush_asid;
logic                             ma2mr_fence_i;
logic                             ma2mr_pipe_restart;
logic [                     31:0] ma2mr_fwd_table;
logic [                     31:0] ma2mr_hz_table;

// MR stage
logic                             mr_amo_wr;
logic [       `DM_DATA_LEN - 1:0] mr_dpu_rdata;
logic                             mr_dpu_hazard;
logic                             mr_dpu_fault;
logic                             mr_load_misaligned;
logic                             mr_load_page_fault;
logic                             mr_load_xes_fault;
logic                             mr_store_misaligned;
logic                             mr_store_page_fault;
logic                             mr_store_xes_fault;

logic [              `XLEN - 1:0] mr_rd_data;
logic                             mr_pipe_restart;
logic [                     31:0] mr_fwd_table;
logic [                     31:0] all_fwd_table;

// MR/WB pipeline
logic [       `IM_ADDR_LEN - 1:0] mr2wb_pc;
logic [       `IM_DATA_LEN - 1:0] mr2wb_insn;
logic                             mr2wb_insn_valid;
logic [                      4:0] mr2wb_rd_addr;
logic                             mr2wb_rd_wr;
logic [(`DM_DATA_LEN >> 3) - 1:0] mr2wb_mem_byte;
logic                             mr2wb_mem_sign_ext;
logic                             mr2wb_len_64;
logic [              `XLEN - 1:0] mr2wb_rd_data;
logic [       `DM_ADDR_LEN - 1:0] mr2wb_mem_addr;
logic [       `DM_DATA_LEN - 1:0] mr2wb_mem_wdata;
logic                             mr2wb_mem_req;
logic                             mr2wb_mem_wr;
logic                             mr2wb_dpu_fault;
logic                             mr2wb_load_misaligned;
logic                             mr2wb_load_page_fault;
logic                             mr2wb_load_xes_fault;
logic                             mr2wb_store_misaligned;
logic                             mr2wb_store_page_fault;
logic                             mr2wb_store_xes_fault;
logic                             mr2wb_csr_wr;
logic [                     11:0] mr2wb_csr_waddr;
logic [              `XLEN - 1:0] mr2wb_csr_wdata;
logic                             mr2wb_wfi;
logic [                      1:0] mr2wb_prv;
logic                             mr2wb_trap_en;
logic [              `XLEN - 1:0] mr2wb_cause;
logic [              `XLEN - 1:0] mr2wb_tval;
logic [       `IM_ADDR_LEN - 1:0] mr2wb_epc;
logic [                     31:0] mr2wb_fwd_table;
logic                             mr2wb_attach;

// WB stage
logic [              `XLEN - 1:0] wb_rd_data;
logic                             wb_rd_wr;
logic                             wb_insn_valid;
logic [                     63:0] wb_mcycle;
logic                             wb_wfi;

// Forward
logic                             fwd_wb2id_rd_rs1;
logic                             fwd_wb2id_rd_rs2;

resetn_synchronizer u_sync_srstn (
    .clk        ( clk        ),
    .rstn_async ( srstn      ),
    .rstn_sync  ( srstn_sync )
);

resetn_synchronizer u_sync_xrstn (
    .clk        ( clk        ),
    .rstn_async ( xrstn      ),
    .rstn_sync  ( xrstn_sync )
);

assign stall_wfi  = (exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event;
// assign insn_valid = ~6'b0;
assign insn_valid = {1'b1, if2id_insn_valid, id2exe_insn_valid,
                     exe2ma_insn_valid | exe2ma_trap_en,
                     ma2mr_insn_valid  | ma2mr_trap_en,
                     mr2wb_insn_valid  | mr2wb_trap_en};

clkmnt u_clkmnt (
    .clk_free ( clk          ),
    .rstn     ( srstn_sync   ),
    .wfi      ( wb_wfi       ),
    .wakeup   ( wakeup_event ),
    .clk_ret  ( clk_wfi      ),
    .sleep    ( sleep        )
);

hzu u_hzu (
    .insn_valid      ( insn_valid      ),
    .pc_jump_en      ( if_pc_jump_en   ),
    .pc_alu_en       ( exe_bpu_en      ),
    .irq_en          ( exe_irq_en      ),
    .trap_en         ( exe_trap_en     ),
    .eret_en         ( exe_eret_en     ),
    .pipe_restart_en ( mr_pipe_restart ),
    .id_hazard       ( id_hazard       ),
    .exe_hazard      ( exe_hazard      ),
    .dpu_hazard      ( mr_dpu_hazard   ),
    .dpu_fault       ( mr2wb_dpu_fault ),
    .id_jump_fault   ( id_jump_fault   ),
    .exe_jump_fault  ( exe_jump_fault  ),
    .if_stall        ( if_stall        ),
    .id_stall        ( id_stall        ),
    .exe_stall       ( exe_stall       ),
    .ma_stall        ( ma_stall        ),
    .mr_stall        ( mr_stall        ),
    .wb_stall        ( wb_stall        ),
    .if_flush        ( if_flush        ),
    .id_flush        ( id_flush        ),
    .exe_flush       ( exe_flush       ),
    .ma_flush        ( ma_flush        ),
    .mr_flush        ( mr_flush        ),
    .wb_flush        ( wb_flush        ),
    .if_flush_force  ( if_flush_force  ),
    .id_flush_force  ( id_flush_force  ),
    .exe_flush_force ( exe_flush_force ),
    .ma_flush_force  ( ma_flush_force  ),
    .mr_flush_force  ( mr_flush_force  ),
    .wb_flush_force  ( wb_flush_force  )
);

// IF stage
ifu u_ifu (
    .clk             ( clk                          ),
    .rstn            ( srstn_sync                   ),
    .bootvec         ( bootvec                      ),
    .ic_flush        ( ic_flush                     ),
    .misa_c_ext      ( exe_misa_c_ext               ),
    .misa_mxl        ( exe_misa_mxl                 ),
    .irq_en          ( exe_irq_en | exe_trap_en     ),
    .irq_vec         ( irq_vec                      ),
    .eret_en         ( exe_eret_en                  ),
    .ret_epc         ( ret_epc                      ),
    .pc_jump_en      ( if_pc_jump_en                ),
    .pc_jump         ( if_pc_jump                   ),
    .pc_alu_en       ( exe_bpu_en                   ),
    .pc_alu          ( exe_bpu_pc                   ),
    .pipe_restart_en ( mr_pipe_restart              ),
    .pipe_restart    ( ma2mr_pc2rd                  ),
    .id_jump_fault   ( id_jump_fault                ),
    .exe_jump_fault  ( exe_jump_fault               ),
    .jump_token      ( if_jump_token                ),
    .imem_req        ( imem_en                      ),
    .imem_addr       ( imem_addr                    ),
    .imem_rdata      ( imem_rdata                   ),
    .imem_bad        ( imem_bad                     ),
    .imem_busy       ( imem_busy                    ),
    .id_pc           ( if2id_pc                     ),
    .exe_pc          ( id2exe_pc                    ),
    .pc              ( if_pc                        ),
    .insn            ( if_insn                      ),
    .insn_valid      ( if_insn_valid                ),
    .misaligned_epc  ( if_insn_misaligned_epc       ),
    .misaligned      ( if_insn_misaligned           ),
    .page_fault      ( if_insn_page_fault           ),
    .xes_fault       ( if_insn_xes_fault            ),
    .badaddr         ( if_insn_badaddr              ),
    .flush           ( if_flush                     ),
    .stall           ( if_stall | stall_wfi | sleep ),
    .attach          ( attach                       ),
    .dbg_exec        ( dbg_exec                     ),
    .dbg_insn        ( dbg_insn                     )
);

assign if_pc_jump_en = id_jump & ~if2id_stall_flag & ~if2id_jump_token & if2id_insn_valid;
assign if_pc_jump    = id_imm + if2id_pc;

// IF/ID pipeline
always_ff @(posedge clk_wfi or negedge srstn_sync) begin
    if (~srstn_sync) begin
        if2id_pc                  <= `IM_ADDR_LEN'b0;
        if2id_insn                <= `IM_DATA_LEN'b0;
        if2id_insn_valid          <= 1'b0;
        if2id_insn_misaligned_epc <= `IM_ADDR_LEN'b0;
        if2id_insn_misaligned     <= 1'b0;
        if2id_insn_page_fault     <= 1'b0;
        if2id_insn_xes_fault      <= 1'b0;
        if2id_insn_badaddr        <= `IM_ADDR_LEN'b0;
        if2id_jump_token          <= 1'b0;
        if2id_attach              <= 1'b0;
        if2id_stall_flag          <= 1'b0;
    end
    else begin
        if ((~id_stall & ~stall_wfi) | if_flush_force) begin
            if2id_pc                  <= if_pc;
            if2id_insn                <= {`IM_DATA_LEN{if_insn_valid}} & if_insn;
            if2id_insn_valid          <= ~if_flush & if_insn_valid;
            if2id_insn_misaligned_epc <= if_insn_misaligned_epc;
            if2id_insn_misaligned     <= if_insn_misaligned;
            if2id_insn_page_fault     <= if_insn_page_fault;
            if2id_insn_xes_fault      <= if_insn_xes_fault;
            if2id_insn_badaddr        <= if_insn_badaddr;
            if2id_jump_token          <= if_jump_token;
            if2id_attach              <= attach;
            if2id_stall_flag          <= 1'b0;
        end
        else begin
            if2id_insn_valid          <= ~id_jump_fault & if2id_insn_valid;
            if2id_stall_flag          <= 1'b1;
        end
    end
end

// ID stage
idu u_idu (
    .clk                 ( clk_wfi                ),
    .rstn                ( srstn_sync             ),
    .insn                ( if2id_insn             ),
    .insn_valid          ( if2id_insn_valid       ),
    .misa_mxl            ( exe_misa_mxl           ),
    .misa_a_ext          ( exe_misa_a_ext         ),
    .misa_c_ext          ( exe_misa_c_ext         ),
    .misa_m_ext          ( exe_misa_m_ext         ),
    .pc                  ( if2id_pc               ),
    .rd_wr_i             ( wb_rd_wr               ),
    .rd_addr_i           ( mr2wb_rd_addr          ),
    .rd_data             ( wb_rd_data             ),
    .rd_addr_o           ( id_rd_addr             ),
    .rs1_addr            ( id_rs1_addr            ),
    .rs2_addr            ( id_rs2_addr            ),
    .rs1_data            ( id_gpr_rs1_data        ),
    .rs2_data            ( id_gpr_rs2_data        ),
    .csr_addr            ( id_csr_addr            ),
    .amo_64_o            ( id_amo_64              ),
    .len_64_o            ( id_len_64              ),
    .imm                 ( id_imm                 ),

    // Control
    .prv_req             ( id_prv_req             ),
    .ill_insn            ( id_ill_insn            ),
    .fence               ( id_fence               ),
    .fence_i             ( id_fence_i             ),
    .ecall               ( id_ecall               ),
    .ebreak              ( id_ebreak              ),
    .wfi                 ( id_wfi                 ),
    .sret                ( id_sret                ),
    .mret                ( id_mret                ),
    .jump                ( id_jump                ),
    .jump_alu            ( id_jump_alu            ),

    // For EXE stage
    .rs1_rd              ( id_rs1_rd              ),
    .rs2_rd              ( id_rs2_rd              ),
    .mdu_sel             ( id_mdu_sel             ),
    .mdu_op              ( id_mdu_op              ),
    .alu_op              ( id_alu_op              ),
    .rs1_zero_sel        ( id_rs1_zero_sel        ),
    .rs2_imm_sel         ( id_rs2_imm_sel         ),
    .pc_imm_sel          ( id_pc_imm_sel          ),
    .branch              ( id_branch              ),
    .branch_zcmp         ( id_branch_zcmp         ),
    .bpu_op              ( id_bpu_op              ),
    .csr_op              ( id_csr_op              ),
    .uimm_rs1_sel        ( id_uimm_rs1_sel        ),
    .csr_rd              ( id_csr_rd              ),
    .csr_wr              ( id_csr_wr              ),

    // For MEM stage
    .pc_alu_sel          ( id_pc_alu_sel          ),
    .csr_alu_sel         ( id_csr_alu_sel         ),
    .amo                 ( id_amo                 ),
    .amo_op              ( id_amo_op              ),
    .mem_req             ( id_mem_req             ),
    .mem_wr              ( id_mem_wr              ),
    .mem_ex              ( id_mem_ex              ),
    .mem_byte            ( id_mem_byte            ),
    .mem_sign_ext        ( id_mem_sign_ext        ),
    .tlb_flush_req       ( id_tlb_flush_req       ),
    .tlb_flush_all_vaddr ( id_tlb_flush_all_vaddr ),
    .tlb_flush_all_asid  ( id_tlb_flush_all_asid  ),

    // For WB stage
    .mem_cal_sel         ( id_mem_cal_sel         ),
    .rd_wr_o             ( id_rd_wr               ),

    .halted              ( halted                 ),
    .dbg_gpr_all         ( dbg_gpr_all            ),
    .dbg_addr            ( dbg_addr               ),
    .dbg_wdata           ( dbg_wdata              ),
    .dbg_gpr_rd          ( dbg_gpr_rd             ),
    .dbg_gpr_wr          ( dbg_gpr_wr             ),
    .dbg_gpr_out         ( dbg_gpr_out            ),
    .dbg_csr_rd          ( dbg_csr_rd             ),
    .dbg_csr_wr          ( dbg_csr_wr             )
);

assign id_fpu_csr_rdata = `XLEN'b0;
assign id_dbg_csr_rdata = `XLEN'b0;

csr u_csr (
    .clk           ( clk_wfi          ),
    .rstn          ( srstn_sync       ),
    .misa_mxl      ( exe_misa_mxl     ),
    .rd            ( id_csr_rd        ),
    .wr            ( id_csr_wr        ),
    .raddr         ( id_csr_addr      ),
    .rdata         ( id_csr_rdata     ),
    .pmu_csr_wr    ( id_pmu_csr_wr    ),
    .fpu_csr_wr    ( id_fpu_csr_wr    ),
    .dbg_csr_wr    ( id_dbg_csr_wr    ),
    .mmu_csr_wr    ( id_mmu_csr_wr    ),
    .mpu_csr_wr    ( id_mpu_csr_wr    ),
    .sru_csr_wr    ( id_sru_csr_wr    ),
    .pmu_csr_rdata ( id_pmu_csr_rdata ),
    .fpu_csr_rdata ( id_fpu_csr_rdata ),
    .dbg_csr_rdata ( id_dbg_csr_rdata ),
    .mmu_csr_rdata ( id_mmu_csr_rdata ),
    .mpu_csr_rdata ( id_mpu_csr_rdata ),
    .sru_csr_rdata ( id_sru_csr_rdata )
);

assign dbg_csr_out = id_csr_rdata;

// ID forward
assign fwd_wb2id_rd_rs1 = mr2wb_rd_wr & (id_rs1_addr == mr2wb_rd_addr );
assign fwd_wb2id_rd_rs2 = mr2wb_rd_wr & (id_rs2_addr == mr2wb_rd_addr );

assign id_rs1_data = fwd_wb2id_rd_rs1 ? mr2wb_rd_data :
                                        id_gpr_rs1_data;
assign id_rs2_data = fwd_wb2id_rd_rs2 ? mr2wb_rd_data :
                                        id_gpr_rs2_data;

// ID Hazard
assign id_hazard = (id_csr_rd &&
                    (exe_pmu_csr_wr | exe_fpu_csr_wr | exe_dbg_csr_wr |
                     exe_mmu_csr_wr | exe_mpu_csr_wr | exe_sru_csr_wr) &&
                    (id_csr_addr == id2exe_csr_waddr));


// ID/EXE pipeline
always_ff @(posedge clk_wfi or negedge srstn_sync) begin
    if (~srstn_sync) begin
        id2exe_pc                  <= `IM_ADDR_LEN'b0;
        id2exe_insn                <= `IM_DATA_LEN'b0;
        id2exe_insn_valid          <= 1'b0;
        id2exe_rd_addr             <= 5'b0;
        id2exe_rs1_addr            <= 5'b0;
        id2exe_rs2_addr            <= 5'b0;
        id2exe_rs1_data            <= `XLEN'b0;
        id2exe_rs2_data            <= `XLEN'b0;
        id2exe_csr_waddr           <= 12'b0;
        id2exe_csr_rdata           <= `XLEN'b0;
        id2exe_amo_64              <= 1'b0;
        id2exe_len_64              <= 1'b0;
        id2exe_imm                 <= `XLEN'b0;
        id2exe_rs1_rd              <= 1'b0;
        id2exe_rs2_rd              <= 1'b0;
        id2exe_mdu_sel             <= 1'b0;
        id2exe_mdu_op              <= `MDU_OP_LEN'b0;
        id2exe_alu_op              <= `ALU_OP_LEN'b0;
        id2exe_rs1_zero_sel        <= 1'b0;
        id2exe_rs2_imm_sel         <= 1'b0;
        id2exe_pc_imm_sel          <= 1'b0;
        id2exe_jump_alu            <= 1'b0;
        id2exe_branch              <= 1'b0;
        id2exe_branch_zcmp         <= 1'b0;
        id2exe_bpu_op              <= `BPU_OP_LEN'b0;
        id2exe_csr_op              <= `CSR_OP_LEN'b0;
        id2exe_uimm_rs1_sel        <= 1'b0;
        id2exe_csr_rd              <= 1'b0;
        id2exe_pmu_csr_wr          <= 1'b0;
        id2exe_fpu_csr_wr          <= 1'b0;
        id2exe_dbg_csr_wr          <= 1'b0;
        id2exe_mmu_csr_wr          <= 1'b0;
        id2exe_mpu_csr_wr          <= 1'b0;
        id2exe_sru_csr_wr          <= 1'b0;
        id2exe_pc_alu_sel          <= 1'b0;
        id2exe_csr_alu_sel         <= 1'b0;
        id2exe_amo                 <= 1'b0;
        id2exe_amo_op              <= `AMO_OP_LEN'b0;
        id2exe_mem_req             <= 1'b0;
        id2exe_mem_wr              <= 1'b0;
        id2exe_mem_ex              <= 1'b0;
        id2exe_mem_byte            <= {(`DM_DATA_LEN >> 3){1'b0}};
        id2exe_mem_sign_ext        <= 1'b0;
        id2exe_mem_cal_sel         <= 1'b0;
        id2exe_rd_wr               <= 1'b0;
        id2exe_wfi                 <= 1'b0;
        id2exe_ecall               <= 1'b0;
        id2exe_ebreak              <= 1'b0;
        id2exe_sret                <= 1'b0;
        id2exe_mret                <= 1'b0;
        id2exe_ill_insn            <= 1'b0;
        id2exe_prv_req             <= 2'b0;
        id2exe_insn_misaligned_epc <= `IM_ADDR_LEN'b0;
        id2exe_insn_misaligned     <= 1'b0;
        id2exe_insn_page_fault     <= 1'b0;
        id2exe_insn_xes_fault      <= 1'b0;
        id2exe_insn_badaddr        <= `IM_ADDR_LEN'b0;
        id2exe_tlb_flush_req       <= 1'b0;
        id2exe_tlb_flush_all_vaddr <= 1'b0;
        id2exe_tlb_flush_all_asid  <= 1'b0;
        id2exe_fence_i             <= 1'b0;
        id2exe_attach              <= 1'b0;
        id2exe_ext_csr_wr          <= 1'b0;
        id2exe_ext_csr_wdata       <= 32'b0;
    end
    else begin
        if ((~exe_stall & ~stall_wfi) | id_flush_force) begin
            id2exe_pc                  <= if2id_pc;
            id2exe_insn                <= if2id_insn;
            id2exe_insn_valid          <= ~id_flush & ~id_jump_fault & if2id_insn_valid;
            id2exe_rd_addr             <= id_rd_addr;
            id2exe_rs1_addr            <= id_rs1_addr;
            id2exe_rs2_addr            <= id_rs2_addr;
            id2exe_rs1_data            <= id_rs1_data;
            id2exe_rs2_data            <= id_rs2_data;
            id2exe_csr_waddr           <= id_csr_addr;
            id2exe_csr_rdata           <= id_csr_rdata;
            id2exe_amo_64              <= id_amo_64;
            id2exe_len_64              <= id_len_64;
            id2exe_imm                 <= id_imm;
            id2exe_rs1_rd              <= id_rs1_rd;
            id2exe_rs2_rd              <= id_rs2_rd;
            id2exe_mdu_sel             <= ~id_flush & ~id_jump_fault & id_mdu_sel;
            id2exe_mdu_op              <= id_mdu_op;
            id2exe_alu_op              <= id_alu_op;
            id2exe_rs1_zero_sel        <= id_rs1_zero_sel;
            id2exe_rs2_imm_sel         <= id_rs2_imm_sel;
            id2exe_pc_imm_sel          <= id_pc_imm_sel;
            id2exe_jump_alu            <= ~id_flush & ~id_jump_fault & id_jump_alu;
            id2exe_branch              <= ~id_flush & ~id_jump_fault & id_branch;
            id2exe_branch_zcmp         <= id_branch_zcmp;
            id2exe_bpu_op              <= id_bpu_op;
            id2exe_csr_op              <= id_csr_op;
            id2exe_uimm_rs1_sel        <= id_uimm_rs1_sel;
            id2exe_csr_rd              <= ~id_flush & ~id_jump_fault & id_csr_rd;
            id2exe_pmu_csr_wr          <= ~id_flush & ~id_jump_fault & id_pmu_csr_wr;
            id2exe_fpu_csr_wr          <= ~id_flush & ~id_jump_fault & id_fpu_csr_wr;
            id2exe_dbg_csr_wr          <= ~id_flush & ~id_jump_fault & id_dbg_csr_wr;
            id2exe_mmu_csr_wr          <= ~id_flush & ~id_jump_fault & id_mmu_csr_wr;
            id2exe_mpu_csr_wr          <= ~id_flush & ~id_jump_fault & id_mpu_csr_wr;
            id2exe_sru_csr_wr          <= ~id_flush & ~id_jump_fault & id_sru_csr_wr;
            id2exe_pc_alu_sel          <= id_pc_alu_sel;
            id2exe_csr_alu_sel         <= id_csr_alu_sel;
            id2exe_amo                 <= id_amo;
            id2exe_amo_op              <= id_amo_op;
            id2exe_mem_req             <= ~id_flush & ~id_jump_fault & id_mem_req;
            id2exe_mem_wr              <= ~id_flush & ~id_jump_fault & id_mem_wr;
            id2exe_mem_ex              <= id_mem_ex;
            id2exe_mem_byte            <= id_mem_byte;
            id2exe_mem_sign_ext        <= id_mem_sign_ext;
            id2exe_mem_cal_sel         <= id_mem_cal_sel;
            id2exe_rd_wr               <= ~id_flush & ~id_jump_fault & id_rd_wr;
            id2exe_wfi                 <= ~id_flush & ~id_jump_fault & id_wfi;
            id2exe_ecall               <= ~id_flush & ~id_jump_fault & id_ecall;
            id2exe_ebreak              <= ~id_flush & ~id_jump_fault & id_ebreak;
            id2exe_sret                <= ~id_flush & ~id_jump_fault & id_sret;
            id2exe_mret                <= ~id_flush & ~id_jump_fault & id_mret;
            id2exe_ill_insn            <= ~id_flush & ~id_jump_fault & id_ill_insn;
            id2exe_prv_req             <= id_prv_req;
            id2exe_insn_misaligned_epc <= if2id_insn_misaligned_epc;
            id2exe_insn_misaligned     <= if2id_insn_misaligned;
            id2exe_insn_page_fault     <= if2id_insn_page_fault;
            id2exe_insn_xes_fault      <= if2id_insn_xes_fault;
            id2exe_insn_badaddr        <= if2id_insn_badaddr;
            id2exe_tlb_flush_req       <= ~id_flush & ~id_jump_fault & id_tlb_flush_req;
            id2exe_tlb_flush_all_vaddr <= id_tlb_flush_all_vaddr;
            id2exe_tlb_flush_all_asid  <= id_tlb_flush_all_asid;
            id2exe_fence_i             <= ~id_flush & ~id_jump_fault & id_fence_i;
            id2exe_attach              <= if2id_attach;
            id2exe_ext_csr_wr          <= dbg_csr_wr;
            id2exe_ext_csr_wdata       <= dbg_wdata;
        end
        else begin
            id2exe_insn_valid          <= ~exe_jump_fault & id2exe_insn_valid;
            id2exe_rs1_data            <= exe_rs1_data;
            id2exe_rs2_data            <= exe_rs2_data;
            id2exe_branch              <= exe_hazard & id2exe_branch;
            id2exe_jump_alu            <= id2exe_jump_alu & exe_gpr_hazard;
        end
    end
end

// EXE stage
assign exe_fwd_table = {31'b0, (id2exe_rd_wr & ~id2exe_mem_req)} << id2exe_rd_addr;
assign exe_hz_table  = {31'b0, (id2exe_rd_wr &  id2exe_mem_req)} << id2exe_rd_addr;
// RS1 Forward
assign exe_rs1_data  = ({`XLEN{ exe2ma_fwd_table   [id2exe_rs1_addr]}} & ma_rd_data     ) |
                       ({`XLEN{ ma2mr_fwd_table    [id2exe_rs1_addr]}} & ma2mr_rd_data  ) |
                       ({`XLEN{ mr2wb_fwd_table    [id2exe_rs1_addr]}} & wb_rd_data     ) |
                       ({`XLEN{~exe2ma_fwd_table   [id2exe_rs1_addr]&
                               ~ma2mr_fwd_table    [id2exe_rs1_addr]&
                               ~mr2wb_fwd_table    [id2exe_rs1_addr]}} & id2exe_rs1_data);

// RS2 Forward
assign exe_rs2_data  = ({`XLEN{ exe2ma_fwd_table   [id2exe_rs2_addr]}} & ma_rd_data     ) |
                       ({`XLEN{ ma2mr_fwd_table    [id2exe_rs2_addr]}} & ma2mr_rd_data  ) |
                       ({`XLEN{ mr2wb_fwd_table    [id2exe_rs2_addr]}} & wb_rd_data     ) |
                       ({`XLEN{~exe2ma_fwd_table   [id2exe_rs2_addr]&
                               ~ma2mr_fwd_table    [id2exe_rs2_addr]&
                               ~mr2wb_fwd_table    [id2exe_rs2_addr]}} & id2exe_rs2_data);

assign exe_mem_hazard = (id2exe_rs1_rd && (exe2ma_hz_table[id2exe_rs1_addr] || ma2mr_hz_table[id2exe_rs1_addr])) ||
                        (id2exe_rs2_rd && (exe2ma_hz_table[id2exe_rs2_addr] || ma2mr_hz_table[id2exe_rs2_addr])) ||
                        ma_pipe_restart || exe2ma_amo;
assign exe_gpr_hazard = exe_mem_hazard || (id2exe_mdu_sel && ~exe_mdu_okay);
assign exe_csr_hazard = (exe2ma_mem_req || ma2mr_mem_req_wo_flush) &&
                        (id2exe_pmu_csr_wr || id2exe_fpu_csr_wr || id2exe_dbg_csr_wr ||
                         id2exe_mmu_csr_wr || id2exe_mpu_csr_wr || id2exe_sru_csr_wr ||
                         id2exe_sret       || id2exe_mret       || id2exe_ill_insn);

assign exe_hazard = exe_gpr_hazard || exe_csr_hazard;


assign exe_pc_imm   = {{(`XLEN - `IM_ADDR_LEN){id2exe_pc[`IM_ADDR_LEN - 1]}}, id2exe_pc} + id2exe_imm;
assign exe_pc_add_4 = {{(`XLEN - `IM_ADDR_LEN){id2exe_pc[`IM_ADDR_LEN - 1]}}, id2exe_pc} + (id2exe_insn[1:0] == 2'b11 ? `XLEN'h4 : `XLEN'h2);
assign exe_pc2rd    = id2exe_pc_imm_sel   ? exe_pc_imm : exe_pc_add_4;

assign exe_alu_src1 = id2exe_rs1_zero_sel ? exe_rs1_data : `XLEN'b0;
assign exe_alu_src2 = id2exe_rs2_imm_sel  ? exe_rs2_data : id2exe_imm;

assign exe_mdu_sel  = id2exe_mdu_sel && ~exe_mem_hazard;

assign exe_branch   = id2exe_branch & ~exe_hazard;

bpu u_bpu(
    .bpu_op  ( id2exe_bpu_op      ),
    .jump    ( id2exe_jump_alu    ),
    .branch  ( exe_branch         ),
    .cmp_flag( id2exe_branch_zcmp ),
    .src1    ( exe_rs1_data       ),
    .src2    ( exe_rs2_data       ),
    .pc      ( id2exe_pc          ),
    .imm     ( id2exe_imm         ),
    .valid   ( exe_bpu_en         ),
    .out     ( exe_bpu_pc         )
);

alu u_alu (
   .alu_op    ( id2exe_alu_op ),
   .len_64    ( id2exe_len_64 ),
   .src1      ( exe_alu_src1  ),
   .src2      ( exe_alu_src2  ),
   .out       ( exe_alu_out   ),
   .zero_flag ( exe_alu_zero  )
);

mdu u_mdu(
    .clk    ( clk_wfi         ),
    .rstn   ( srstn_sync      ),
    .len_64 ( id2exe_len_64   ),
    .trig   ( exe_mdu_sel     ),
    .mdu_op ( id2exe_mdu_op   ),
    .flush  ( exe_flush_force ),
    .src1   ( exe_rs1_data    ),
    .src2   ( exe_rs2_data    ),
    .out    ( exe_mdu_out     ),
    .okay   ( exe_mdu_okay    )
);

assign exe_rd_data = ({`XLEN{ id2exe_mdu_sel}} & exe_mdu_out) |
                     ({`XLEN{~id2exe_mdu_sel}} & exe_alu_out);

assign exe_pmu_csr_wr = id2exe_pmu_csr_wr & ~exe_flush_force & ~exe_hazard & ~exe_irq_en & ~exe_trap_en & ~stall_wfi;
assign exe_fpu_csr_wr = id2exe_fpu_csr_wr & ~exe_flush_force & ~exe_hazard & ~exe_irq_en & ~exe_trap_en & ~stall_wfi;
assign exe_dbg_csr_wr = id2exe_dbg_csr_wr & ~exe_flush_force & ~exe_hazard & ~exe_irq_en & ~exe_trap_en & ~stall_wfi;
assign exe_mmu_csr_wr = id2exe_mmu_csr_wr & ~exe_flush_force & ~exe_hazard & ~exe_irq_en & ~exe_trap_en & ~stall_wfi;
assign exe_mpu_csr_wr = id2exe_mpu_csr_wr & ~exe_flush_force & ~exe_hazard & ~exe_irq_en & ~exe_trap_en & ~stall_wfi;
assign exe_sru_csr_wr = id2exe_sru_csr_wr & ~exe_flush_force & ~exe_hazard & ~exe_irq_en & ~exe_trap_en & ~stall_wfi;
assign exe_sret       = id2exe_sret       & ~exe_flush_force & ~exe_hazard & ~exe_irq_en & ~exe_trap_en & ~stall_wfi;
assign exe_mret       = id2exe_mret       & ~exe_flush_force & ~exe_hazard & ~exe_irq_en & ~exe_trap_en & ~stall_wfi;

assign exe_csr_src1 = id2exe_csr_rdata;
assign exe_csr_src2 = id2exe_uimm_rs1_sel ? {{(`XLEN-5){1'b0}}, id2exe_rs1_addr} : exe_rs1_data;

assign exe_int_mask   = exe_hazard || ~id2exe_insn_valid || ma_stall ||
                        ma_pipe_restart || mr_pipe_restart ||
                        exe2ma_mem_req || ma2mr_mem_req_wo_flush;

sru u_sru (
    .clk              ( clk_wfi           ),
    .clk_free         ( clk               ),
    .srstn            ( srstn_sync        ),
    .xrstn            ( xrstn_sync        ),
    .sleep            ( sleep             ),
    .misaligned       ( id2exe_pc[1]      ),
    .prv              ( exe_prv           ),
    .tvm              ( exe_mstatus_tvm   ),
    .tsr              ( exe_mstatus_tsr   ),
    .sum              ( sum               ),
    .mprv             ( mprv              ),
    .mpp              ( mpp               ),
    .warm_rst_trigger ( warm_rst_trigger  ),

    // IRQ signal
    .ext_msip         ( msip              ),
    .ext_mtip         ( mtip              ),
    .ext_meip         ( meip              ),
    .ext_seip         ( seip              ),
    .int_mask         ( exe_int_mask      ),
    .wakeup           ( wakeup_event      ),
    .irq_trigger      ( exe_irq_en        ),
    .cause            ( exe_cause         ),
    .tval             ( exe_tval          ),

    // PC control
    .trap_vec         ( irq_vec           ),
    .ret_epc          ( ret_epc           ),

    // Trap signal
    .trap_epc         ( exe_trap_epc      ),
    .trap_en          ( exe_trap_en       ),
    .trap_cause       ( exe_trap_cause    ),
    .trap_val         ( exe_trap_val      ),
    .sret             ( exe_sret          ),
    .mret             ( exe_mret          ),
    .eret_en          ( exe_eret_en       ),

    // Extension flag
    .misa_mxl         ( exe_misa_mxl      ),
    .misa_a_ext       ( exe_misa_a_ext    ),
    .misa_c_ext       ( exe_misa_c_ext    ),
    .misa_m_ext       ( exe_misa_m_ext    ),
    
    // CSR interface
    .csr_wr           ( exe_sru_csr_wr    ),
    .csr_waddr        ( id2exe_csr_waddr  ),
    .csr_raddr        ( id_csr_addr       ),
    .csr_sdata        ( exe_csr_sdata     ),
    .csr_cdata        ( exe_csr_cdata     ),
    .csr_rdata        ( id_sru_csr_rdata  )
);

mmu_csr u_mmu_csr (
    .clk       ( clk_wfi          ),
    .rstn      ( srstn_sync       ),

    .misa_mxl  ( exe_misa_mxl     ),

    .satp_ppn  ( exe_satp_ppn     ),
    .satp_asid ( exe_satp_asid    ),
    .satp_mode ( exe_satp_mode    ),

    // CSR interface
    .csr_wr    ( exe_mmu_csr_wr   ),
    .csr_waddr ( id2exe_csr_waddr ),
    .csr_raddr ( id_csr_addr      ),
    .csr_sdata ( exe_csr_sdata    ),
    .csr_cdata ( exe_csr_cdata    ),
    .csr_rdata ( id_mmu_csr_rdata )
);

mpu_csr u_mpu_csr (
    .clk       ( clk_wfi          ),
    .rstn      ( srstn_sync       ),
    .misa_mxl  ( exe_misa_mxl     ),
    .pmpcfg    ( pmpcfg           ),
    .pmpaddr   ( pmpaddr          ),
    .pmacfg    ( pmacfg           ),
    .pmaaddr   ( pmaaddr          ),

    // CSR interface
    .csr_wr    ( exe_mpu_csr_wr   ),
    .csr_waddr ( id2exe_csr_waddr ),
    .csr_raddr ( id_csr_addr      ),
    .csr_sdata ( exe_csr_sdata    ),
    .csr_cdata ( exe_csr_cdata    ),
    .csr_rdata ( id_mpu_csr_rdata )

);

assign exe_touch_satp = (id2exe_mmu_csr_wr | id2exe_csr_rd) & ~ma_pipe_restart &
                        ~exe_csr_hazard & ~stall_wfi && id2exe_csr_waddr == `CSR_SATP_ADDR;
assign exe_satp_upd =  id2exe_mmu_csr_wr & ~ma_pipe_restart &
                      ~exe_csr_hazard & ~stall_wfi && id2exe_csr_waddr == `CSR_SATP_ADDR;
assign exe_misa_upd =  id2exe_sru_csr_wr & ~ma_pipe_restart &
                      ~exe_csr_hazard & ~stall_wfi && id2exe_csr_waddr == `CSR_MISA_ADDR;

assign exe_insn_valid = id2exe_insn_valid &&
                        ~ma_pipe_restart && ~mr_pipe_restart &&
                        ~exe_hazard && ~stall_wfi;

tpu u_tpu (
    .insn_valid          ( exe_insn_valid              ),
    .insn                ( id2exe_insn                 ),
    .exe_pc              ( id2exe_pc                   ),
    .wb_pc               ( mr2wb_pc                    ),
    .ldst_badaddr        ( mr2wb_mem_addr              ),
    .insn_badaddr        ( id2exe_insn_badaddr         ),
    .prv_cur             ( exe_prv                     ),
    .prv_req             ( id2exe_prv_req              ),
    .touch_satp          ( exe_touch_satp              ),
    .tsr                 ( exe_mstatus_tsr             ),
    .tvm                 ( exe_mstatus_tvm             ),
    .sret                ( id2exe_sret                 ),
    .ecall               ( id2exe_ecall                ),
    .ebreak              ( id2exe_ebreak               ),
    .tlb_flush_req       ( id2exe_tlb_flush_req        ),
    .ill_insn            ( id2exe_ill_insn             ),
    .csr_ill             ( exe_pmu_csr_ill             ),
    .insn_misaligned_epc ( id2exe_insn_misaligned_epc  ),
    .insn_misaligned     ( id2exe_insn_misaligned      ),
    .insn_pg_fault       ( id2exe_insn_page_fault      ),
    .insn_xes_fault      ( id2exe_insn_xes_fault       ),
    .load_misaligned     ( mr2wb_load_misaligned       ),
    .load_pg_fault       ( mr2wb_load_page_fault       ),
    .load_xes_fault      ( mr2wb_load_xes_fault        ),
    .store_misaligned    ( mr2wb_store_misaligned      ),
    .store_pg_fault      ( mr2wb_store_page_fault      ),
    .store_xes_fault     ( mr2wb_store_xes_fault       ),
    .trap_en             ( exe_trap_en                 ),
    .trap_cause          ( exe_trap_cause              ),
    .trap_val            ( exe_trap_val                ),
    .trap_epc            ( exe_trap_epc                )
);

assign rv64_mode   = exe_misa_mxl == `MISA_MXL_XLEN_64;
assign satp_ppn    = exe_satp_ppn;
assign satp_asid   = exe_satp_asid;
assign satp_mode   = exe_satp_mode;
assign prv         = exe_prv;

csr_alu u_csr_alu(
    .csr_op ( id2exe_csr_op   ),
    .src1   ( exe_csr_src1    ),
    .src2   ( exe_csr_src2    ),
    .stb    ( exe_csr_sdata   ),
    .clr    ( exe_csr_cdata   ),
    .out    ( exe_csr_alu_out )
);

assign exe_csr_wdata_pre = id2exe_ext_csr_wr ? id2exe_ext_csr_wdata : exe_csr_alu_out;
assign exe_csr_wdata     = exe_misa_mxl == `MISA_MXL_XLEN_32 ? {32'b0, exe_csr_wdata_pre[31:0]}:
                                                               exe_csr_wdata_pre;

// EXE/MA pipeline
always_ff @(posedge clk_wfi or negedge srstn_sync) begin
    if (~srstn_sync) begin
        exe2ma_pc                  <= `IM_ADDR_LEN'b0;
        exe2ma_insn                <= `IM_DATA_LEN'b0;
        exe2ma_insn_valid          <= 1'b0;
        exe2ma_amo                 <= 1'b0;
        exe2ma_amo_op              <= `AMO_OP_LEN'b0;
        exe2ma_mem_req             <= 1'b0;
        exe2ma_mem_wr              <= 1'b0;
        exe2ma_mem_ex              <= 1'b0;
        exe2ma_mem_byte            <= {(`DM_DATA_LEN >> 3){1'b0}};
        exe2ma_mem_sign_ext        <= 1'b0;
        exe2ma_amo_64              <= 1'b0;
        exe2ma_len_64              <= 1'b0;
        exe2ma_pc_alu_sel          <= 1'b0;
        exe2ma_csr_rdata           <= `XLEN'b0;
        exe2ma_csr_alu_sel         <= 1'b0;
        exe2ma_mem_cal_sel         <= 1'b0;
        exe2ma_rd_wr               <= 1'b0;
        exe2ma_rd_addr             <= 5'b0;
        exe2ma_rs1_addr            <= 5'b0;
        exe2ma_rs2_addr            <= 5'b0;
        exe2ma_rd_data             <= `XLEN'b0;
        exe2ma_pc2rd               <= `XLEN'b0;
        exe2ma_rs1_data            <= `XLEN'b0;
        exe2ma_rs2_data            <= `XLEN'b0;
        exe2ma_csr_wr              <= 1'b0;
        exe2ma_csr_waddr           <= 12'b0;
        exe2ma_csr_wdata           <= `XLEN'b0;
        exe2ma_wfi                 <= 1'b0;
        exe2ma_prv                 <= 2'b0;
        exe2ma_trap_en             <= 1'b0;
        exe2ma_cause               <= `XLEN'b0;
        exe2ma_tval                <= `XLEN'b0;
        exe2ma_epc                 <= `IM_DATA_LEN'b0;
        exe2ma_tlb_flush_req       <= 1'b0;
        exe2ma_tlb_flush_all_vaddr <= 1'b0;
        exe2ma_tlb_flush_all_asid  <= 1'b0;
        exe2ma_fence_i             <= 1'b0;
        exe2ma_fwd_table           <= 32'b0;
        exe2ma_hz_table            <= 32'b0;
        exe2ma_attach              <= 1'b0;
        exe2ma_pipe_restart        <= 1'b0;
    end
    else begin
        if (~ma_stall | exe_flush_force) begin
            exe2ma_pc                  <= id2exe_pc;
            exe2ma_insn                <= id2exe_insn;
            exe2ma_insn_valid          <= ((~exe_flush & ~exe_jump_fault & ~exe_irq_en) | (id2exe_ecall & exe_trap_en)) & ~((exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event) & id2exe_insn_valid;
            exe2ma_amo                 <= ~exe_flush & ~exe_jump_fault & ~exe_irq_en & ~((exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event) & id2exe_amo;
            exe2ma_amo_op              <= id2exe_amo_op;
            exe2ma_mem_req             <= ~exe_flush & ~exe_jump_fault & ~exe_irq_en & ~((exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event) & id2exe_mem_req;
            exe2ma_mem_wr              <= ~exe_flush & ~exe_jump_fault & ~exe_irq_en & ~((exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event) & id2exe_mem_wr;
            exe2ma_mem_ex              <= id2exe_mem_ex;
            exe2ma_mem_byte            <= id2exe_mem_byte;
            exe2ma_mem_sign_ext        <= id2exe_mem_sign_ext;
            exe2ma_amo_64              <= id2exe_amo_64;
            exe2ma_len_64              <= id2exe_len_64;
            exe2ma_pc_alu_sel          <= id2exe_pc_alu_sel;
            exe2ma_csr_rdata           <= id2exe_csr_rdata;
            exe2ma_csr_alu_sel         <= id2exe_csr_alu_sel;
            exe2ma_mem_cal_sel         <= id2exe_mem_cal_sel;
            exe2ma_rd_wr               <= ~exe_flush & ~exe_jump_fault & ~exe_irq_en & ~((exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event) & id2exe_rd_wr;
            exe2ma_rd_addr             <= id2exe_rd_addr;
            exe2ma_rs1_addr            <= id2exe_rs1_addr;
            exe2ma_rs2_addr            <= id2exe_rs2_addr;
`ifdef RV32
            exe2ma_rd_data             <= exe_rd_data;
`else
            exe2ma_rd_data             <= id2exe_len_64 ? exe_rd_data : {{32{exe_rd_data[31]}}, exe_rd_data[31:0]};
`endif
            exe2ma_pc2rd               <= exe_pc2rd;
            exe2ma_rs1_data            <= exe_rs1_data;
            exe2ma_rs2_data            <= exe_rs2_data;
            exe2ma_csr_wr              <=  (exe_pmu_csr_wr|
                                            exe_fpu_csr_wr|
                                            exe_dbg_csr_wr|
                                            exe_mmu_csr_wr|
                                            exe_mpu_csr_wr|
                                            exe_sru_csr_wr);
            exe2ma_csr_waddr           <= id2exe_csr_waddr;
            exe2ma_csr_wdata           <= exe_csr_wdata;
            exe2ma_wfi                 <= ~exe_flush & ~exe_jump_fault & ~exe_irq_en & ~exe2ma_wfi & ~wakeup_event & id2exe_wfi;
            exe2ma_prv                 <= exe_prv;
            exe2ma_trap_en             <= ~(ma_pipe_restart | mr_pipe_restart) & (exe_irq_en | exe_trap_en);
            exe2ma_cause               <= exe_cause;
            exe2ma_tval                <= exe_tval;
            exe2ma_epc                 <= exe_trap_epc;
            exe2ma_tlb_flush_req       <= ~exe_flush & ~exe_jump_fault & ~exe_irq_en & ~((exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event) & id2exe_tlb_flush_req;
            exe2ma_tlb_flush_all_vaddr <= id2exe_tlb_flush_all_vaddr;
            exe2ma_tlb_flush_all_asid  <= id2exe_tlb_flush_all_asid;
            exe2ma_fence_i             <= ~exe_flush & ~exe_jump_fault & ~exe_irq_en & ~((exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event) & id2exe_fence_i;
            exe2ma_fwd_table           <= {32{~exe_flush & ~exe_jump_fault & ~exe_irq_en & ~((exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event)}} & exe_fwd_table;
            exe2ma_hz_table            <= {32{~exe_flush & ~exe_jump_fault & ~exe_irq_en & ~((exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event)}} & exe_hz_table;
            exe2ma_attach              <= id2exe_attach;
            exe2ma_pipe_restart        <= ~exe_flush & ~exe_jump_fault & ~exe_irq_en & ~((exe2ma_wfi | ma2mr_wfi | mr2wb_wfi) & ~wakeup_event) & ~exe_trap_en & (exe_misa_upd | exe_satp_upd);
        end
        else begin
            exe2ma_rs1_data            <= ma_rs1_data;
            exe2ma_rs2_data            <= ma_dpu_wdata;
        end
    end
end

// MEMORY ACCESS stage
// MEM_ADDR Forward
assign ma_fwd_table = exe2ma_fwd_table & ~exe_fwd_table & ~exe_hz_table;
assign ma_hz_table  = exe2ma_hz_table;

assign ma_dpu_req   = ~ma_flush_force & exe2ma_mem_req;
assign ma_dpu_wr    = exe2ma_mem_wr;
assign ma_dpu_ex    = exe2ma_mem_ex;
assign ma_dpu_byte  = exe2ma_mem_byte;
assign ma_dpu_addr  = exe2ma_rd_data;

assign ma_rs1_data  = ({`XLEN{ mr2wb_fwd_table [exe2ma_rs1_addr]}} & wb_rd_data     ) |
                      ({`XLEN{~mr2wb_fwd_table [exe2ma_rs1_addr]}} & exe2ma_rs1_data);
assign ma_dpu_wdata = ({`XLEN{ mr2wb_fwd_table [exe2ma_rs2_addr]}} & wb_rd_data     ) |
                      ({`XLEN{~mr2wb_fwd_table [exe2ma_rs2_addr]}} & exe2ma_rs2_data);

assign ma_pipe_restart = exe2ma_tlb_flush_req || exe2ma_fence_i || exe2ma_pipe_restart;

dpu u_dpu (
    .clk              ( clk_wfi              ),
    .rstn             ( srstn_sync           ),

    .len_64           ( exe2ma_len_64        ),
    .amo_64           ( exe2ma_amo_64        ),

    .amo_i            ( exe2ma_amo           ),
    .amo_op_i         ( exe2ma_amo_op        ),
    .pc_i             ( exe2ma_pc            ),
    .sign_ext_i       ( exe2ma_mem_sign_ext  ),
    .req_i            ( ma_dpu_req           ),
    .wr_i             ( ma_dpu_wr            ),
    .ex_i             ( ma_dpu_ex            ),
    .byte_i           ( ma_dpu_byte          ),
    .addr_i           ( ma_dpu_addr          ),
    .wdata_i          ( ma_dpu_wdata         ),

    .amo_wr_o         ( mr_amo_wr            ),
    .rdata_o          ( mr_dpu_rdata         ),
    .hazard_o         ( mr_dpu_hazard        ),

    .fault            ( mr_dpu_fault         ),
    .load_misaligned  ( mr_load_misaligned   ),
    .load_pg_fault    ( mr_load_page_fault   ),
    .load_xes_fault   ( mr_load_xes_fault    ),
    .store_misaligned ( mr_store_misaligned  ),
    .store_pg_fault   ( mr_store_page_fault  ),
    .store_xes_fault  ( mr_store_xes_fault   ),
                              
    .dmem_req         ( dmem_en              ),
    .dmem_addr        ( dmem_addr            ),
    .dmem_wr          ( dmem_write           ),
    .dmem_ex          ( dmem_ex              ),
    .dmem_byte        ( dmem_strb            ),
    .dmem_wdata       ( dmem_wdata           ),
    .dmem_rdata       ( dmem_rdata           ),
    .dmem_bad         ( dmem_bad             ),
    .dmem_xstate      ( dmem_xstate          ),
    .dmem_busy        ( dmem_busy            )
);

assign ma_rd_data = exe2ma_pc_alu_sel  ? exe2ma_pc2rd :
                    exe2ma_csr_alu_sel ? exe2ma_csr_rdata :
                                         exe2ma_rd_data;

// MA/WR pipeline
always_ff @(posedge clk_wfi or negedge srstn_sync) begin
    if (~srstn_sync) begin
        ma2mr_pc                  <= `IM_ADDR_LEN'b0;
        ma2mr_insn                <= `IM_DATA_LEN'b0;
        ma2mr_insn_valid          <= 1'b0;
        ma2mr_rd_wr               <= 1'b0;
        ma2mr_rd_addr             <= 5'b0;
        ma2mr_mem_byte            <= {(`DM_DATA_LEN >> 3){1'b0}};
        ma2mr_mem_sign_ext        <= 1'b0;
        ma2mr_mem_cal_sel         <= 1'b0;
        ma2mr_len_64              <= 1'b0;
        ma2mr_rd_data             <= `XLEN'b0;
        ma2mr_pc2rd               <= `XLEN'b0;
        ma2mr_mem_addr            <= `DM_ADDR_LEN'b0;
        ma2mr_mem_wdata           <= `DM_DATA_LEN'b0;
        ma2mr_mem_req_wo_flush    <= 1'b0;
        ma2mr_mem_req             <= 1'b0;
        ma2mr_mem_wr              <= 1'b0;
        ma2mr_csr_wr              <= 1'b0;
        ma2mr_csr_waddr           <= 12'b0;
        ma2mr_csr_wdata           <= `XLEN'b0;
        ma2mr_wfi                 <= 1'b0;
        ma2mr_prv                 <= 2'b0;
        ma2mr_trap_en             <= 1'b0;
        ma2mr_cause               <= `XLEN'b0;
        ma2mr_tval                <= `XLEN'b0;
        ma2mr_epc                 <= `IM_ADDR_LEN'b0;
        ma2mr_attach              <= 1'b0;
        ma2mr_tlb_flush_req       <= 1'b0;
        ma2mr_tlb_flush_all_vaddr <= 1'b0;
        ma2mr_tlb_flush_all_asid  <= 1'b0;
        ma2mr_tlb_flush_vaddr     <= `XLEN'b0;
        ma2mr_tlb_flush_asid      <= `XLEN'b0;
        ma2mr_fence_i             <= 1'b0;
        ma2mr_pipe_restart        <= 1'b0;
        ma2mr_fwd_table           <= 32'b0;
        ma2mr_hz_table            <= 32'b0;
    end
    else begin
        if ((~mr_stall & ~mr_amo_wr) | ma_flush_force) begin
            ma2mr_pc                  <= exe2ma_pc;
            ma2mr_insn                <= exe2ma_insn;
            ma2mr_insn_valid          <= ~ma_flush & exe2ma_insn_valid;
            ma2mr_rd_wr               <= ~ma_flush & exe2ma_rd_wr;
            ma2mr_rd_addr             <= exe2ma_rd_addr;
            ma2mr_pc2rd               <= exe2ma_pc2rd;
            ma2mr_mem_byte            <= dmem_strb;
            ma2mr_mem_sign_ext        <= exe2ma_mem_sign_ext;
            ma2mr_mem_cal_sel         <= exe2ma_mem_cal_sel;
            ma2mr_len_64              <= exe2ma_len_64;
`ifdef RV32
            ma2mr_rd_data             <= ma_rd_data;
`else
            ma2mr_rd_data             <= exe2ma_len_64 ? ma_rd_data : {{32{ma_rd_data[31]}}, ma_rd_data[31:0]};
`endif
            ma2mr_mem_addr            <= ma_dpu_addr;
            ma2mr_mem_wdata           <= dmem_wdata;
            ma2mr_mem_req_wo_flush    <= exe2ma_mem_req;
            ma2mr_mem_req             <= ~ma_flush & exe2ma_mem_req;
            ma2mr_mem_wr              <= ~ma_flush & exe2ma_mem_wr;
            ma2mr_csr_wr              <= exe2ma_csr_wr;
            ma2mr_csr_waddr           <= exe2ma_csr_waddr;
            ma2mr_csr_wdata           <= exe2ma_csr_wdata;
            ma2mr_wfi                 <= ~ma_flush & ~ma2mr_wfi & ~wakeup_event & exe2ma_wfi;
            ma2mr_prv                 <= exe2ma_prv;
            ma2mr_trap_en             <= exe2ma_trap_en;
            ma2mr_cause               <= exe2ma_cause;
            ma2mr_tval                <= exe2ma_tval;
            ma2mr_epc                 <= exe2ma_epc;
            ma2mr_attach              <= exe2ma_attach;
            ma2mr_tlb_flush_req       <= ~ma_flush & exe2ma_tlb_flush_req;
            ma2mr_tlb_flush_all_vaddr <= exe2ma_tlb_flush_all_vaddr;
            ma2mr_tlb_flush_all_asid  <= exe2ma_tlb_flush_all_asid;
            ma2mr_tlb_flush_vaddr     <= ma_rs1_data;
            ma2mr_tlb_flush_asid      <= ma_dpu_wdata;
            ma2mr_fence_i             <= ~ma_flush & exe2ma_fence_i;
            ma2mr_pipe_restart        <= ~ma_flush & ma_pipe_restart;
            ma2mr_fwd_table           <= {32{~ma_flush}} & ma_fwd_table;
            ma2mr_hz_table            <= {32{~ma_flush}} & ma_hz_table;
        end
    end
end

// MEMORY RECEIVE stage
assign mr_fwd_table  = (ma2mr_fwd_table | ma2mr_hz_table) & ~exe2ma_fwd_table & ~(exe_fwd_table & ~{32{exe_hazard}});
assign all_fwd_table = (mr_fwd_table & {32{~mr_stall}}) | (ma_fwd_table & {32{~ma_stall}}) | (exe_fwd_table & {32{~exe_stall}});
assign mr_rd_data    = ma2mr_mem_cal_sel ?  mr_dpu_rdata : ma2mr_rd_data;

assign tlb_flush_req       = ~mr_flush_force & (ma2mr_tlb_flush_req);
assign tlb_flush_all_vaddr = ma2mr_tlb_flush_all_vaddr;
assign tlb_flush_all_asid  = ma2mr_tlb_flush_all_asid;
assign tlb_flush_vaddr     = ma2mr_tlb_flush_vaddr;
assign tlb_flush_asid      = ma2mr_tlb_flush_asid;

assign ic_flush            = ~mr_flush_force & ma2mr_fence_i;
assign mr_pipe_restart     = ~mr_flush_force & ma2mr_pipe_restart;


// MR/WB pipeline
always_ff @(posedge clk_wfi or negedge srstn_sync) begin
    if (~srstn_sync) begin
        mr2wb_pc               <= `IM_ADDR_LEN'b0;
        mr2wb_insn             <= `IM_DATA_LEN'b0;
        mr2wb_insn_valid       <= 1'b0;
        mr2wb_rd_wr            <= 1'b0;
        mr2wb_rd_addr          <= 5'b0;
        mr2wb_mem_byte         <= {(`DM_DATA_LEN >> 3){1'b0}};
        mr2wb_mem_sign_ext     <= 1'b0;
        mr2wb_len_64           <= 1'b0;
        mr2wb_rd_data          <= `XLEN'b0;
        mr2wb_mem_addr         <= `DM_ADDR_LEN'b0;
        mr2wb_mem_wdata        <= `DM_DATA_LEN'b0;
        mr2wb_mem_req          <= 1'b0;
        mr2wb_mem_wr           <= 1'b0;
        mr2wb_dpu_fault        <= 1'b0;
        mr2wb_load_misaligned  <= 1'b0;
        mr2wb_load_page_fault  <= 1'b0;
        mr2wb_load_xes_fault   <= 1'b0;
        mr2wb_store_misaligned <= 1'b0;
        mr2wb_store_page_fault <= 1'b0;
        mr2wb_store_xes_fault  <= 1'b0;
        mr2wb_csr_wr           <= 1'b0;
        mr2wb_csr_waddr        <= 12'b0;
        mr2wb_csr_wdata        <= `XLEN'b0;
        mr2wb_wfi              <= 1'b0;
        mr2wb_prv              <= 2'b0;
        mr2wb_trap_en          <= 1'b0;
        mr2wb_cause            <= `XLEN'b0;
        mr2wb_tval             <= `XLEN'b0;
        mr2wb_epc              <= `IM_ADDR_LEN'b0;
        mr2wb_fwd_table        <= 32'b0;
        mr2wb_attach           <= 1'b0;
    end
    else begin
        if (~wb_stall | mr_flush_force) begin
            mr2wb_pc               <= ma2mr_pc;
            mr2wb_insn             <= ma2mr_insn;
            mr2wb_insn_valid       <= ~mr_flush & ~mr_amo_wr & ma2mr_insn_valid;
            mr2wb_rd_wr            <= ~mr_flush & ~mr_amo_wr & ma2mr_rd_wr;
            mr2wb_rd_addr          <= ma2mr_rd_addr;
            mr2wb_mem_byte         <= ma2mr_mem_byte;
            mr2wb_mem_sign_ext     <= ma2mr_mem_sign_ext;
            mr2wb_len_64           <= ma2mr_len_64;
`ifdef RV32
            mr2wb_rd_data          <= mr_rd_data;
`else
            mr2wb_rd_data          <= ma2mr_len_64 ? mr_rd_data : {{32{mr_rd_data[31]}}, mr_rd_data[31:0]};
`endif
            mr2wb_mem_addr         <= ma2mr_mem_addr;
            mr2wb_mem_wdata        <= ma2mr_mem_wdata;
            mr2wb_mem_req          <= ~mr_flush & ~mr_amo_wr & ma2mr_mem_req;
            mr2wb_mem_wr           <= ~mr_flush & ~mr_amo_wr & ma2mr_mem_wr;
            mr2wb_dpu_fault        <= ~mr_flush & ~mr_amo_wr & ma2mr_insn_valid & mr_dpu_fault;
            mr2wb_load_misaligned  <= ~mr_flush & ~mr_amo_wr & ma2mr_insn_valid & mr_load_misaligned;
            mr2wb_load_page_fault  <= ~mr_flush & ~mr_amo_wr & ma2mr_insn_valid & mr_load_page_fault;
            mr2wb_load_xes_fault   <= ~mr_flush & ~mr_amo_wr & ma2mr_insn_valid & mr_load_xes_fault;
            mr2wb_store_misaligned <= ~mr_flush & ~mr_amo_wr & ma2mr_insn_valid & mr_store_misaligned;
            mr2wb_store_page_fault <= ~mr_flush & ~mr_amo_wr & ma2mr_insn_valid & mr_store_page_fault;
            mr2wb_store_xes_fault  <= ~mr_flush & ~mr_amo_wr & ma2mr_insn_valid & mr_store_xes_fault;
            mr2wb_csr_wr           <= ma2mr_csr_wr;
            mr2wb_csr_waddr        <= ma2mr_csr_waddr;
            mr2wb_csr_wdata        <= ma2mr_csr_wdata;
            mr2wb_wfi              <= ~mr_flush & ~mr_amo_wr & ~mr2wb_wfi & ~wakeup_event & ma2mr_wfi;
            mr2wb_prv              <= ma2mr_prv;
            mr2wb_trap_en          <= ~mr_flush & ~mr_amo_wr & ma2mr_trap_en;
            mr2wb_cause            <= ma2mr_cause;
            mr2wb_tval             <= ma2mr_tval;
            mr2wb_epc              <= ma2mr_epc;
            mr2wb_fwd_table        <= {32{~mr_flush & ~mr_amo_wr}} & mr_fwd_table;
            mr2wb_attach           <= ma2mr_attach;
        end
    end
end

// WB stage
assign wb_rd_data    = mr2wb_rd_data;
assign wb_rd_wr      = ~wb_flush & mr2wb_rd_wr;
assign wb_insn_valid = ~wb_flush & mr2wb_insn_valid;
assign wb_wfi        = ~wb_flush & mr2wb_wfi;

assign dbg_pc_out    = mr2wb_pc;
assign halted        = mr2wb_attach;

// PMU
pmu u_pmu (
    .clk_free   ( clk               ),
    .rstn       ( srstn_sync        ),
    .cpu_id     ( cpu_id            ),
    .insn_valid ( wb_insn_valid     ),
    .misa_mxl   ( exe_misa_mxl      ),
    .prv        ( exe_prv           ),
    .mtime      ( systime           ),
    .mcycle     ( wb_mcycle         ),
    
    .csr_rd_chk ( id2exe_csr_rd     ),
    .csr_wr_chk ( id2exe_pmu_csr_wr ),
    .csr_wr     ( exe_pmu_csr_wr    ),
    .csr_raddr  ( id_csr_addr       ),
    .csr_waddr  ( id2exe_csr_waddr  ),
    .csr_sdata  ( exe_csr_sdata     ),
    .csr_cdata  ( exe_csr_cdata     ),
    .csr_rdata  ( id_pmu_csr_rdata  ),
    .csr_ill    ( exe_pmu_csr_ill   )
);

// Tracer
cpu_tracer u_cpu_tracer (
    .clk       ( clk_wfi         ),
    .srstn     ( srstn_sync      ),
    .xrstn     ( xrstn_sync      ),
    .valid     ( wb_insn_valid   ),
    .cycle     ( wb_mcycle       ),
    .misa_mxl  ( exe_misa_mxl    ),
    .len_64    ( mr2wb_len_64    ),
    .pc        ( mr2wb_pc        ),
    .epc       ( mr2wb_epc       ),
    .insn      ( mr2wb_insn      ),
    .prv       ( mr2wb_prv       ),
    .rd_wr     ( wb_rd_wr        ),
    .rd_addr   ( mr2wb_rd_addr   ),
    .rd_data   ( mr2wb_rd_data   ),
    .csr_wr    ( mr2wb_csr_wr    ),
    .csr_waddr ( mr2wb_csr_waddr ),
    .csr_wdata ( mr2wb_csr_wdata ),
    .mem_addr  ( mr2wb_mem_addr  ),
    .mem_req   ( mr2wb_mem_req   ),
    .mem_wr    ( mr2wb_mem_wr    ),
    .mem_byte  ( mr2wb_mem_byte  ),
    .mem_rdata ( mr2wb_rd_data   ),
    .mem_wdata ( mr2wb_mem_wdata ),
    .trap_en   ( mr2wb_trap_en   ),
    .mcause    ( mr2wb_cause     ),
    .mtval     ( mr2wb_tval      ),
    .halted    ( halted          ),
    .pkg_valid ( trace_pkg_valid ),
    .pkg       ( trace_pkg       )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/clkmnt.sv
/*--------------------------------------*/

module clkmnt (
    input        clk_free,
    input        rstn,
    input        wfi,
    input        wakeup,
    output logic clk_ret,
    output logic sleep
);

always_ff @(posedge clk_free or negedge rstn) begin
    if (~rstn)       sleep <= 1'b0;
    else if (wakeup) sleep <= 1'b0;
    else if (wfi)    sleep <= 1'b1;
end

CG u_cg(
    .CK   ( clk_free ),
    .EN   ( ~sleep   ),
    .CKEN ( clk_ret  )
);


endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/hzu.sv
/*--------------------------------------*/

module hzu (
    input  [5:0] insn_valid,
    input        pc_jump_en,
    input        pc_alu_en,
    input        irq_en,
    input        trap_en,
    input        eret_en,
    input        pipe_restart_en,
    input        id_hazard,
    input        exe_hazard,
    input        dpu_hazard,
    input        dpu_fault,
    input        id_jump_fault,
    input        exe_jump_fault,
    output       if_stall,
    output       id_stall,
    output       exe_stall,
    output       ma_stall,
    output       mr_stall,
    output       wb_stall,
    output       if_flush,
    output       id_flush,
    output       exe_flush,
    output       ma_flush,
    output       mr_flush,
    output       wb_flush,
    output       if_flush_force,
    output       id_flush_force,
    output       exe_flush_force,
    output       ma_flush_force,
    output       mr_flush_force,
    output       wb_flush_force
);

logic [5:0] stall_all;
logic [5:0] flush_all;
logic [5:0] flush_force_all;
logic [5:0] flush_jump_all;

assign {if_stall, id_stall, exe_stall, ma_stall, mr_stall, wb_stall} = stall_all;
assign {if_flush, id_flush, exe_flush, ma_flush, mr_flush, wb_flush} = flush_all | flush_jump_all | flush_force_all;
assign {if_flush_force, id_flush_force, exe_flush_force, ma_flush_force, mr_flush_force, wb_flush_force} = flush_force_all;

// assign {wb_stall, mr_stall, ma_stall, exe_stall, id_stall, if_stall} = stall_all;
// assign {wb_flush, mr_flush, ma_flush, exe_flush, id_flush, if_flush} = flush_all | flush_jump_all | flush_force_all;
// assign {wb_flush_force, mr_flush_force, ma_flush_force, exe_flush_force, id_flush_force, if_flush_force} = flush_force_all;

assign stall_all = (~({4'b0, dpu_hazard, 1'b0} + (insn_valid | 6'h2)) & (insn_valid | 6'h2))|
                   (~({2'b0, exe_hazard, 3'b0} + insn_valid) & insn_valid)|
                   (~({1'b0,  id_hazard, 4'b0} + insn_valid) & insn_valid);

// assign stall_all = dpu_hazard ? 6'b111110:
//                    exe_hazard ? 6'b111000:
//                    id_hazard  ? 6'b110000:
//                                 6'b000000;

assign flush_all = ({6{dpu_hazard}} & 6'b000010)|
                   ({6{exe_hazard}} & 6'b001000)|
                   ({6{pc_alu_en }} & 6'b110000)|
                   ({6{id_hazard }} & 6'b010000)|
                   ({6{pc_jump_en}} & 6'b100000);
// assign flush_all = dpu_hazard ? 6'b000010:
//                    exe_hazard ? 6'b001000:
//                    pc_alu_en  ? 6'b110000:
//                    id_hazard  ? 6'b010000:
//                    pc_jump_en ? 6'b100000:
//                                 6'b000000;

assign flush_jump_all = ({6{irq_en    }} & 6'b111000) |
                        ({6{trap_en   }} & 6'b111000) |
                        ({6{pc_alu_en }} & 6'b110000) |
                        ({6{pc_jump_en}} & 6'b100000);

assign flush_force_all = ({6{dpu_fault      }} & 6'b111111) |
                         ({6{pipe_restart_en}} & 6'b111100) |
                         ({6{eret_en        }} & 6'b110000) |
                         ({6{irq_en         }} & 6'b110000) |
                         ({6{trap_en        }} & 6'b110000) |
                         ({6{pc_alu_en      }} & 6'b100000);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/ifu.sv
/*--------------------------------------*/

module ifu (
    input                             clk,
    input                             rstn,
    input        [       `XLEN - 1:0] bootvec,

    input                             ic_flush,

    // Extension flag
    input                             misa_c_ext,
    input        [               1:0] misa_mxl,

    // Branch
    input                             irq_en,
    input        [`IM_ADDR_LEN - 1:0] irq_vec,
    input                             eret_en,
    input        [`IM_ADDR_LEN - 1:0] ret_epc,
    input                             pc_jump_en,
    input        [`IM_ADDR_LEN - 1:0] pc_jump,
    input                             pc_alu_en,
    input        [`IM_ADDR_LEN - 1:0] pc_alu,
    input                             pipe_restart_en,
    input        [`IM_ADDR_LEN - 1:0] pipe_restart,
    output logic                      id_jump_fault,
    output logic                      exe_jump_fault,
    output logic                      jump_token,

    // Insn Memory
    output logic                      imem_req,
    output logic [`IM_ADDR_LEN - 1:0] imem_addr,
    input        [       `XLEN - 1:0] imem_rdata,
    input        [               1:0] imem_bad,
    input                             imem_busy,

    input        [`IM_ADDR_LEN - 1:0] id_pc,
    input        [`IM_ADDR_LEN - 1:0] exe_pc,
    output logic [`IM_ADDR_LEN - 1:0] pc,
    output logic [`IM_DATA_LEN - 1:0] insn,
    output logic                      insn_valid,
    output logic [`IM_ADDR_LEN - 1:0] misaligned_epc,
    output logic                      misaligned,
    output logic                      page_fault,
    output logic                      xes_fault,
    output logic [`IM_ADDR_LEN - 1:0] badaddr,
    input                             flush,
    input                             stall,
    input                             attach,
    input                             dbg_exec,
    input        [`IM_DATA_LEN - 1:0] dbg_insn
);

logic                      jump_in_id;
logic                      jump_in_exe;
logic                      jump_in_mr;
logic                      jump;
logic [`IM_ADDR_LEN - 1:0] jump_addr;
logic [`IM_ADDR_LEN - 1:0] jump_addr_post;
logic [`IM_ADDR_LEN - 1:0] pc_nxt;
logic [`IM_ADDR_LEN - 1:0] insn_len;
logic                      insn_latch_valid;
logic [`IM_DATA_LEN - 1:0] insn_latch;
logic [               1:0] bad_latch;
logic                      imem_req_latch;
logic                      ifu_req_tmp;
logic                      misaligned_tmp;

logic                      pfu_pop;
logic [  `IM_ADDR_LEN-1:0] pfu_pc;
logic [  `IM_DATA_LEN-1:0] pfu_insn;
logic [               1:0] pfu_bad;
logic [  `IM_ADDR_LEN-1:0] pfu_badaddr;
logic                      pfu_empty;

assign jump_in_id  = pc_jump_en;
assign jump_in_exe = irq_en | pc_alu_en | eret_en;
assign jump_in_mr  = pipe_restart_en;
assign jump        = jump_in_id | jump_in_exe | jump_in_mr;
assign jump_addr   = pipe_restart_en ? pipe_restart:
                     eret_en         ? {ret_epc[`IM_ADDR_LEN-1:2], ret_epc[1] & misa_c_ext, 1'b0}:
                     irq_en          ? {irq_vec[`IM_ADDR_LEN-1:1], 1'b0}:
                     pc_alu_en       ? {pc_alu [`IM_ADDR_LEN-1:1], 1'b0}:
                                       {pc_jump[`IM_ADDR_LEN-1:1], 1'b0};

`ifdef RV32
assign jump_addr_post = jump_addr;
`else
assign jump_addr_post = {`IM_ADDR_LEN{misa_mxl == `MISA_MXL_XLEN_32}} & {{32{jump_addr[31]}}, jump_addr[0+:32]}|
                        {`IM_ADDR_LEN{misa_mxl == `MISA_MXL_XLEN_64}} & jump_addr;
`endif

// avoid for jar misaligned and write rd
assign id_jump_fault  = jump_in_id  & pc_jump[1] & ~misa_c_ext;
assign exe_jump_fault = pc_alu_en   & pc_alu[1]  & ~misa_c_ext;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        misaligned_epc <= {`IM_ADDR_LEN{1'b0}};
    end
    else begin
        if (jump_in_exe) begin
            misaligned_epc <= exe_pc;
        end
        else if (jump_in_id) begin
            misaligned_epc <= id_pc;
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        misaligned <= 1'b0;
    end
    else begin
        misaligned <= misaligned_tmp && jump;
    end
end

assign misaligned_tmp = jump_addr[1] && ~misa_c_ext;

assign pfu_pop        = ~stall & ~attach;

assign insn_valid     = attach ? dbg_exec :
                                 (pfu_pop && ~pfu_empty) || misaligned;

assign insn           = attach ? dbg_insn:
                                 pfu_insn;

assign pc             = pfu_pc;

assign {xes_fault, page_fault} = pfu_bad;
assign badaddr                 = misaligned ? pfu_pc : pfu_badaddr;

pfu u_pfu (
    .clk           ( clk                         ),
    .rstn          ( rstn                        ),
    .bootvec       ( bootvec                     ),
    .flush         ( ic_flush | eret_en | irq_en ),
    .jump          ( jump                        ),
    .jump_addr     ( jump_addr_post              ),
    .pop           ( pfu_pop                     ),
    .jump_token    ( jump_token                  ),
    .pc            ( pfu_pc                      ),
    .insn          ( pfu_insn                    ),
    .bad           ( pfu_bad                     ),
    .badaddr       ( pfu_badaddr                 ),
    .empty         ( pfu_empty                   ),

    // insn Memory
    .imem_req      ( imem_req                    ),
    .imem_addr     ( imem_addr                   ),
    .imem_rdata    ( imem_rdata                  ),
    .imem_bad      ( imem_bad                    ),
    .imem_busy     ( imem_busy                   ),
    
    // for btb
    .btb_wr        ( pc_jump_en                  ),
    .btb_addr_in   ( id_pc                       ),
    .btb_target_in ( pc_jump                     )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/pfu.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

//`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif

`define MDU_OP_LEN 4
`define ALU_OP_LEN 4
`define BPU_OP_LEN 2
`define CSR_OP_LEN 2
`define AMO_OP_LEN 4

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define GPR_ZERO_ADDR 5'b00000
`define GPR_RA_ADDR   5'b00001
`define GPR_SP_ADDR   5'b00010
`define GPR_GP_ADDR   5'b00011
`define GPR_TP_ADDR   5'b00100
`define GPR_T0_ADDR   5'b00101
`define GPR_T1_ADDR   5'b00110
`define GPR_T2_ADDR   5'b00111
`define GPR_S0_ADDR   5'b01000
`define GPR_FP_ADDR   5'b01000
`define GPR_S1_ADDR   5'b01001
`define GPR_A0_ADDR   5'b01010
`define GPR_A1_ADDR   5'b01011
`define GPR_A2_ADDR   5'b01100
`define GPR_A3_ADDR   5'b01101
`define GPR_A4_ADDR   5'b01110
`define GPR_A5_ADDR   5'b01111
`define GPR_A6_ADDR   5'b10000
`define GPR_A7_ADDR   5'b10001
`define GPR_S2_ADDR   5'b10010
`define GPR_S3_ADDR   5'b10011
`define GPR_S4_ADDR   5'b10100
`define GPR_S5_ADDR   5'b10101
`define GPR_S6_ADDR   5'b10110
`define GPR_S7_ADDR   5'b10111
`define GPR_S8_ADDR   5'b11000
`define GPR_S9_ADDR   5'b11001
`define GPR_S10_ADDR  5'b11010
`define GPR_S11_ADDR  5'b11011
`define GPR_T3_ADDR   5'b11100
`define GPR_T4_ADDR   5'b11101
`define GPR_T5_ADDR   5'b11110
`define GPR_T6_ADDR   5'b11111

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       'h0
`define CAUSE_INSTRUCTION_ACCESS     'h1
`define CAUSE_ILLEGAL_INSTRUCTION    'h2
`define CAUSE_BREAKPOINT             'h3
`define CAUSE_MISALIGNED_LOAD        'h4
`define CAUSE_LOAD_ACCESS            'h5
`define CAUSE_MISALIGNED_STORE       'h6
`define CAUSE_STORE_ACCESS           'h7
`define CAUSE_USER_ECALL             'h8
`define CAUSE_SUPERVISOR_ECALL       'h9
`define CAUSE_HYPERVISOR_ECALL       'ha
`define CAUSE_MACHINE_ECALL          'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT 'hc
`define CAUSE_LOAD_PAGE_FAULT        'hd
`define CAUSE_STORE_PAGE_FAULT       'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`define MCAUSE_CODE_WIDTH 6

`define MISA_MXL_XLEN_32  2'b01
`define MISA_MXL_XLEN_64  2'b10
`define MISA_MXL_XLEN_128 2'b11

`define SATP32_PPN_WIDTH  22
`define SATP32_ASID_WIDTH  9
`define SATP32_MODE_WIDTH  1

`define SATP64_PPN_WIDTH  44
`define SATP64_ASID_WIDTH 16
`define SATP64_MODE_WIDTH  4

`define SATP32_PPN_BIT     0+:`SATP32_PPN_WIDTH
`define SATP32_ASID_BIT   22+:`SATP32_ASID_WIDTH
`define SATP32_MODE_BIT   31+:`SATP32_MODE_WIDTH

`define SATP64_PPN_BIT     0+:`SATP64_PPN_WIDTH
`define SATP64_ASID_BIT   44+:`SATP64_ASID_WIDTH
`define SATP64_MODE_BIT   60+:`SATP64_MODE_WIDTH

`ifdef RV32
`define SATP_PPN_WIDTH  `SATP32_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP32_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP32_MODE_WIDTH
`define PADDR_LEN       (`SATP32_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`else
`define SATP_PPN_WIDTH  `SATP64_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP64_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP64_MODE_WIDTH
`define PADDR_LEN       (`SATP64_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`define SATP_MODE_SV39  `SATP_MODE_WIDTH'h8
`define SATP_MODE_SV48  `SATP_MODE_WIDTH'h9
`define SATP_MODE_SV57  `SATP_MODE_WIDTH'ha
`define SATP_MODE_SV64  `SATP_MODE_WIDTH'hb
`endif

`define PTE_V_BIT     0
`define PTE_R_BIT     1
`define PTE_W_BIT     2
`define PTE_X_BIT     3
`define PTE_U_BIT     4
`define PTE_G_BIT     5
`define PTE_A_BIT     6
`define PTE_D_BIT     7
`define PTE_RSW_BIT   8:9
`define PTE_PPN_SHIFT 10

`endif

module pfu (
    input                           clk,
    input                           rstn,
    input                           flush,
    input        [     `XLEN - 1:0] bootvec,
    input                           jump,
    input        [`IM_ADDR_LEN-1:0] jump_addr,
    input                           pop,
    output logic                    jump_token,
    output logic [`IM_ADDR_LEN-1:0] pc,
    output logic [`IM_ADDR_LEN-1:0] badaddr,
    output logic [`IM_DATA_LEN-1:0] insn,
    output logic [             1:0] bad,
    output logic                    empty,

    // Insn Memory
    output logic                    imem_req,
    output logic [`IM_ADDR_LEN-1:0] imem_addr,
    input        [       `XLEN-1:0] imem_rdata,
    input        [             1:0] imem_bad,
    input                           imem_busy,

    // for btb
    input                           btb_wr,
    input        [`IM_ADDR_LEN-1:0] btb_addr_in,
    input        [`IM_ADDR_LEN-1:0] btb_target_in
);

`define PFU_FIFO_DEPTH 8

`ifdef RV32
`define XLEN_DIV_16 2
`else
`define XLEN_DIV_16 4
`endif

logic [16*`PFU_FIFO_DEPTH-1:0] data_fifo;
logic [ 2*`PFU_FIFO_DEPTH-1:0] flag_fifo;
logic [                   2:0] wptr;
logic [                   2:0] rptr;
logic                          fifo_wr;
logic                          fifo_rd;
logic [                   3:0] _ndata;
logic [      `IM_ADDR_LEN-1:0] insn_len;
logic                          imem_req_latch;
logic [      `IM_ADDR_LEN-1:0] imem_addr_pre;
logic                          jump_latch;
logic [      `IM_ADDR_LEN-1:0] btb_pred;
logic                          btb_token;

assign insn    = ({`IM_DATA_LEN{_ndata == 4'd`PFU_FIFO_DEPTH + 4'd0}} & {imem_rdata[31:16] & {16{imem_rdata[1:0] == 2'b11}}, imem_rdata[15:0]}) |
                 ({`IM_DATA_LEN{_ndata == 4'd`PFU_FIFO_DEPTH + 4'd`XLEN_DIV_16 - 4'd1}} & {16'b0, imem_rdata[(`XLEN-16)+:16]}) |
`ifndef RV32
                 ({`IM_DATA_LEN{_ndata == 4'd`PFU_FIFO_DEPTH + 4'd`XLEN_DIV_16 - 4'd2}} & {imem_rdata[(`XLEN-16)+:16] & {16{imem_rdata[(`XLEN-32)+:2] == 2'b11}}, imem_rdata[(`XLEN-32)+:16]}) |
                 ({`IM_DATA_LEN{_ndata == 4'd`PFU_FIFO_DEPTH + 4'd`XLEN_DIV_16 - 4'd3}} & {imem_rdata[(`XLEN-32)+:16] & {16{imem_rdata[(`XLEN-48)+:2] == 2'b11}}, imem_rdata[(`XLEN-48)+:16]}) |
`endif
                 ({`IM_DATA_LEN{_ndata == 4'd`PFU_FIFO_DEPTH - 4'd1}} & {imem_rdata[15: 0] & {16{data_fifo[{rptr, 4'b0}+:2] == 2'b11}}, data_fifo[{rptr, 4'b0}+:16]}) |
                 ({`IM_DATA_LEN{_ndata <  4'd`PFU_FIFO_DEPTH - 4'd1}} & ({data_fifo[{(rptr + 3'b1), 4'b0}+:16] & {16{data_fifo[{rptr, 4'b0}+:2] == 2'b11}}, data_fifo[{rptr, 4'b0}+:16]}));

assign bad     = ({2{_ndata >= 4'd`PFU_FIFO_DEPTH}}        & imem_bad) |
                 ({2{_ndata == 4'd`PFU_FIFO_DEPTH - 4'd1}} & (|flag_fifo[{rptr, 1'b0}+:2] ? flag_fifo[{rptr, 1'b0}+:2] : imem_bad)) |
                 ({2{_ndata <  4'd`PFU_FIFO_DEPTH - 4'd1}} & (|flag_fifo[{rptr, 1'b0}+:2] ? flag_fifo[{rptr, 1'b0}+:2] : flag_fifo[{(rptr + 3'b1), 1'b0}+:2]));

assign badaddr = ({`IM_ADDR_LEN{_ndata >= 4'd`PFU_FIFO_DEPTH}} & pc) |
                 ({`IM_ADDR_LEN{_ndata <  4'd`PFU_FIFO_DEPTH}} & (|flag_fifo[{rptr, 1'b0}+:2] ? pc : pc + `IM_ADDR_LEN'h2));

assign insn_len = insn[1:0] == 2'b11 ? `IM_ADDR_LEN'h4 : `IM_ADDR_LEN'h2;

assign fifo_wr = imem_req_latch && ~imem_busy;
assign fifo_rd = pop && ~empty;
always_ff @(posedge clk) begin
`ifdef RV32
    if (~rstn) begin
        wptr   <= 3'b0;
        rptr   <= {2'b0, bootvec[1]};
        _ndata <= 4'd`PFU_FIFO_DEPTH + {3'b0, bootvec[1]};
    end
    else begin
        if (jump) begin
            wptr   <= 3'b0;
            rptr   <= {2'b0, jump_addr[1]};
            _ndata <= 4'd`PFU_FIFO_DEPTH + {3'b0, jump_addr[1]};
        end
        else if (btb_token & fifo_rd) begin
            wptr   <= 3'b0;
            rptr   <= {2'b0, btb_pred[1]};
            _ndata <= 4'd`PFU_FIFO_DEPTH + {3'b0, btb_pred[1]};
        end
`else
    if (~rstn) begin
        wptr   <= 3'b0;
        rptr   <= {1'b0, bootvec[2:1]};
        _ndata <= 4'd`PFU_FIFO_DEPTH + {2'b0, bootvec[2:1]};
    end
    else begin
        if (jump) begin
            wptr   <= 3'b0;
            rptr   <= {1'b0, jump_addr[2:1]};
            _ndata <= 4'd`PFU_FIFO_DEPTH + {2'b0, jump_addr[2:1]};
        end
        else if (btb_token & fifo_rd) begin
            wptr   <= 3'b0;
            rptr   <= {1'b0, btb_pred[2:1]};
            _ndata <= 4'd`PFU_FIFO_DEPTH + {2'b0, btb_pred[2:1]};
        end
`endif
        else begin
            wptr   <= wptr   + ({3{fifo_wr}} & 3'd`XLEN_DIV_16);
            rptr   <= rptr   + ({3{fifo_rd}} & insn_len[3:1]);
            _ndata <= _ndata + ({3{fifo_rd}} & insn_len[3:1]) - ({3{fifo_wr}} & 3'd`XLEN_DIV_16);
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        data_fifo <= {16*`PFU_FIFO_DEPTH{1'b0}};
        flag_fifo <= { 2*`PFU_FIFO_DEPTH{1'b0}};
    end
    else if (fifo_wr) begin
        data_fifo[{wptr, 4'b0}+:  `XLEN] <= imem_rdata;
        flag_fifo[{wptr, 1'b0}+:`XLEN/8] <= {`XLEN/16{imem_bad}};
    end
end

assign empty    = ~((_ndata <= (4'd`PFU_FIFO_DEPTH - 4'd2)) ||
                    (_ndata <= (4'd`PFU_FIFO_DEPTH - 4'd1) && insn[1:0] != 3'b11) ||
                    (_ndata <= (4'd`PFU_FIFO_DEPTH + 4'd`XLEN_DIV_16 - 4'd2) && fifo_wr) ||
                    (_ndata <= (4'd`PFU_FIFO_DEPTH + 4'd`XLEN_DIV_16 - 4'd1) && fifo_wr && imem_rdata[(`XLEN-16)+:2] != 3'b11));
assign imem_req =  ((_ndata >= (4'd`XLEN_DIV_16 * 2)) || (_ndata >= 4'd`XLEN_DIV_16 && ~imem_req_latch)) && ~imem_busy;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        imem_req_latch <= 1'b0;
    end
    else if (jump) begin
        imem_req_latch <= 1'b0;
    end
    else if (btb_token & fifo_rd & imem_busy)
        imem_req_latch <= 1'b0;
    else if (~imem_busy) begin
        imem_req_latch <= imem_req;
    end
end

`ifdef RV32
assign imem_addr = ~jump_latch & btb_token & ~empty ? {btb_pred[`IM_ADDR_LEN-1:2], 2'b0} : imem_addr_pre;
always_ff @(posedge clk) begin
    if (~rstn) begin
        imem_addr_pre <= {bootvec[`IM_ADDR_LEN-1:2], 2'b0};
    end
    else if (jump) begin
        imem_addr_pre <= {jump_addr[`IM_ADDR_LEN-1:2], 2'b0};
    end
    else if (btb_token & fifo_rd) begin
        imem_addr_pre <= imem_busy ? {btb_pred[`IM_ADDR_LEN-1:2], 2'b0} :
                                     {btb_pred[`IM_ADDR_LEN-1:2], 2'b0} + `IM_ADDR_LEN'h4;
    end
    else if (imem_req && ~imem_busy) begin
        imem_addr_pre <= imem_addr + `IM_ADDR_LEN'h4;
    end
end
`else
assign imem_addr = ~jump_latch & btb_token & ~empty ? {btb_pred[`IM_ADDR_LEN-1:3], 3'b0} : imem_addr_pre;
always_ff @(posedge clk) begin
    if (~rstn) begin
        imem_addr_pre <= {bootvec[`IM_ADDR_LEN-1:3], 3'b0};
    end
    else if (jump) begin
        imem_addr_pre <= {jump_addr[`IM_ADDR_LEN-1:3], 3'b0};
    end
    else if (btb_token & fifo_rd) begin
        imem_addr_pre <= imem_busy | ~imem_req ? {btb_pred[`IM_ADDR_LEN-1:3], 3'b0} :
                                                 {btb_pred[`IM_ADDR_LEN-1:3], 3'b0} + `IM_ADDR_LEN'h8;
    end
    else if (imem_req && ~imem_busy) begin
        imem_addr_pre <= imem_addr + `IM_ADDR_LEN'h8;
    end
end
`endif

always_ff @(posedge clk) begin
    if (~rstn) jump_latch <= 1'b0;
    else       jump_latch <= jump;
end

always_ff @(posedge clk) begin
    if (~rstn) begin
        pc <= bootvec;
    end
    else if (jump) begin
        pc <= jump_addr;
    end
    else if (fifo_rd) begin
        pc <= ~btb_token ? pc + insn_len:
                           btb_pred;
    end
end

assign jump_token = btb_token;

btb u_btb (
    .clk       ( clk           ),
    .rstn      ( rstn          ),
    .flush     ( flush         ),
    .pc_in     ( pc            ),
    .pc_out    ( btb_pred      ),
    .token     ( btb_token     ),
    .wr        ( btb_wr        ),
    .addr_in   ( btb_addr_in   ),
    .target_in ( btb_target_in )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/btb.sv
/*--------------------------------------*/

module btb (
    input                           clk,
    input                           rstn,
    input                           flush,
    input        [`IM_ADDR_LEN-1:0] pc_in,
    output logic [`IM_ADDR_LEN-1:0] pc_out,
    output logic                    token,
    input                           wr,
    input        [`IM_ADDR_LEN-1:0] addr_in,
    input        [`IM_ADDR_LEN-1:0] target_in
);

`define BTB_ENTRY 4

logic [        `BTB_ENTRY-1:0] valid;
logic [      `IM_ADDR_LEN-1:0] tag    [`BTB_ENTRY];
logic [      `IM_ADDR_LEN-1:0] target [`BTB_ENTRY];
logic [$clog2(`BTB_ENTRY)-1:0] wptr;

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 0; i < `BTB_ENTRY; i = i + 1) begin
            valid [i] <= 1'b0;
            tag   [i] <= `IM_ADDR_LEN'b0;
            target[i] <= `IM_ADDR_LEN'b0;
        end
        wptr <= {$clog2(`BTB_ENTRY){1'b0}};
    end
    else begin
        if (flush) begin
            for (i = 0; i < `BTB_ENTRY; i = i + 1) begin
                valid [i] <= 1'b0;
            end
        end
        else if (wr) begin
            valid [wptr] <= 1'b1;
            tag   [wptr] <= addr_in;
            target[wptr] <= target_in;
            wptr         <= wptr + {{$clog2(`BTB_ENTRY)-1{1'b0}}, 1'b1};
        end
    end
end

always_comb begin
    integer i;
    pc_out = `IM_ADDR_LEN'b0;
    token  = 1'b0;
    for (i = 0; i < `BTB_ENTRY; i = i + 1) begin
        pc_out = pc_out | ({`IM_ADDR_LEN{valid[i] && tag[i] == pc_in}} & target[i]);
        token  = token  | (valid[i] && tag[i] == pc_in);
    end
end


endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/idu.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

//`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif

`define MDU_OP_LEN 4
`define ALU_OP_LEN 4
`define BPU_OP_LEN 2
`define CSR_OP_LEN 2
`define AMO_OP_LEN 4

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define GPR_ZERO_ADDR 5'b00000
`define GPR_RA_ADDR   5'b00001
`define GPR_SP_ADDR   5'b00010
`define GPR_GP_ADDR   5'b00011
`define GPR_TP_ADDR   5'b00100
`define GPR_T0_ADDR   5'b00101
`define GPR_T1_ADDR   5'b00110
`define GPR_T2_ADDR   5'b00111
`define GPR_S0_ADDR   5'b01000
`define GPR_FP_ADDR   5'b01000
`define GPR_S1_ADDR   5'b01001
`define GPR_A0_ADDR   5'b01010
`define GPR_A1_ADDR   5'b01011
`define GPR_A2_ADDR   5'b01100
`define GPR_A3_ADDR   5'b01101
`define GPR_A4_ADDR   5'b01110
`define GPR_A5_ADDR   5'b01111
`define GPR_A6_ADDR   5'b10000
`define GPR_A7_ADDR   5'b10001
`define GPR_S2_ADDR   5'b10010
`define GPR_S3_ADDR   5'b10011
`define GPR_S4_ADDR   5'b10100
`define GPR_S5_ADDR   5'b10101
`define GPR_S6_ADDR   5'b10110
`define GPR_S7_ADDR   5'b10111
`define GPR_S8_ADDR   5'b11000
`define GPR_S9_ADDR   5'b11001
`define GPR_S10_ADDR  5'b11010
`define GPR_S11_ADDR  5'b11011
`define GPR_T3_ADDR   5'b11100
`define GPR_T4_ADDR   5'b11101
`define GPR_T5_ADDR   5'b11110
`define GPR_T6_ADDR   5'b11111

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       'h0
`define CAUSE_INSTRUCTION_ACCESS     'h1
`define CAUSE_ILLEGAL_INSTRUCTION    'h2
`define CAUSE_BREAKPOINT             'h3
`define CAUSE_MISALIGNED_LOAD        'h4
`define CAUSE_LOAD_ACCESS            'h5
`define CAUSE_MISALIGNED_STORE       'h6
`define CAUSE_STORE_ACCESS           'h7
`define CAUSE_USER_ECALL             'h8
`define CAUSE_SUPERVISOR_ECALL       'h9
`define CAUSE_HYPERVISOR_ECALL       'ha
`define CAUSE_MACHINE_ECALL          'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT 'hc
`define CAUSE_LOAD_PAGE_FAULT        'hd
`define CAUSE_STORE_PAGE_FAULT       'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`define MCAUSE_CODE_WIDTH 6

`define MISA_MXL_XLEN_32  2'b01
`define MISA_MXL_XLEN_64  2'b10
`define MISA_MXL_XLEN_128 2'b11

`define SATP32_PPN_WIDTH  22
`define SATP32_ASID_WIDTH  9
`define SATP32_MODE_WIDTH  1

`define SATP64_PPN_WIDTH  44
`define SATP64_ASID_WIDTH 16
`define SATP64_MODE_WIDTH  4

`define SATP32_PPN_BIT     0+:`SATP32_PPN_WIDTH
`define SATP32_ASID_BIT   22+:`SATP32_ASID_WIDTH
`define SATP32_MODE_BIT   31+:`SATP32_MODE_WIDTH

`define SATP64_PPN_BIT     0+:`SATP64_PPN_WIDTH
`define SATP64_ASID_BIT   44+:`SATP64_ASID_WIDTH
`define SATP64_MODE_BIT   60+:`SATP64_MODE_WIDTH

`ifdef RV32
`define SATP_PPN_WIDTH  `SATP32_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP32_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP32_MODE_WIDTH
`define PADDR_LEN       (`SATP32_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`else
`define SATP_PPN_WIDTH  `SATP64_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP64_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP64_MODE_WIDTH
`define PADDR_LEN       (`SATP64_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`define SATP_MODE_SV39  `SATP_MODE_WIDTH'h8
`define SATP_MODE_SV48  `SATP_MODE_WIDTH'h9
`define SATP_MODE_SV57  `SATP_MODE_WIDTH'ha
`define SATP_MODE_SV64  `SATP_MODE_WIDTH'hb
`endif

`define PTE_V_BIT     0
`define PTE_R_BIT     1
`define PTE_W_BIT     2
`define PTE_X_BIT     3
`define PTE_U_BIT     4
`define PTE_G_BIT     5
`define PTE_A_BIT     6
`define PTE_D_BIT     7
`define PTE_RSW_BIT   8:9
`define PTE_PPN_SHIFT 10

`endif

module idu (
    input                                    clk,
    input                                    rstn,
    input        [       `IM_DATA_LEN - 1:0] insn,
    input                                    insn_valid,
    input        [       `IM_ADDR_LEN - 1:0] pc,
    input                                    rd_wr_i,
    input        [                      4:0] rd_addr_i,
    input        [              `XLEN - 1:0] rd_data,
    output       [                      4:0] rd_addr_o,
    output logic [              `XLEN - 1:0] rs1_data,
    output logic [              `XLEN - 1:0] rs2_data,

    output logic [                      4:0] rs1_addr,
    output logic [                      4:0] rs2_addr,
    output logic [                     11:0] csr_addr,
    output logic                             amo_64_o,
    output logic                             len_64_o,
    output logic [              `XLEN - 1:0] imm,

    // Extension flag
    input        [                      1:0] misa_mxl,
    input                                    misa_a_ext,
    input                                    misa_c_ext,
    input                                    misa_m_ext,

    // Control
    output logic [                      1:0] prv_req,
    output logic                             ill_insn,
    output logic                             fence,
    output logic                             fence_i,
    output logic                             ecall,
    output logic                             ebreak,
    output logic                             wfi,
    output logic                             sret,
    output logic                             mret,
    output logic                             jump,
    output logic                             jump_alu,

    // EXE stage
    output logic                             rs1_rd,
    output logic                             rs2_rd,
    output logic                             mdu_sel,
    output logic [        `MDU_OP_LEN - 1:0] mdu_op,
    output logic [        `ALU_OP_LEN - 1:0] alu_op,
    output logic                             rs1_zero_sel,
    output logic                             rs2_imm_sel,
    output logic                             pc_imm_sel,
    output logic                             branch,
    output logic                             branch_zcmp,
    output logic [        `BPU_OP_LEN - 1:0] bpu_op,
    output logic [        `CSR_OP_LEN - 1:0] csr_op,
    output logic                             uimm_rs1_sel,
    output logic                             csr_rd,
    output logic                             csr_wr,

    // MEM stage
    output logic                             pc_alu_sel,
    output logic                             csr_alu_sel,
    output logic                             amo,
    output logic [        `AMO_OP_LEN - 1:0] amo_op,
    output logic                             mem_req,
    output logic                             mem_wr,
    output logic                             mem_ex,
    output logic [(`DM_DATA_LEN >> 3) - 1:0] mem_byte,
    output logic                             mem_sign_ext,
    output logic                             tlb_flush_req,
    output logic                             tlb_flush_all_vaddr,
    output logic                             tlb_flush_all_asid,

    // WB stage
    output logic                             mem_cal_sel,
    output logic                             rd_wr_o,

    input                                    halted,
    output logic [              `XLEN - 1:0] dbg_gpr_all [32],
    input        [                     11:0] dbg_addr,
    input        [              `XLEN - 1:0] dbg_wdata,
    input                                    dbg_gpr_rd,
    input                                    dbg_gpr_wr,
    output logic [              `XLEN - 1:0] dbg_gpr_out,
    input                                    dbg_csr_rd,
    input                                    dbg_csr_wr
);

logic             csr_rd_tmp;
logic             csr_wr_tmp;
/*
logic [`XLEN-1:0] rs1_data_pre;
logic [`XLEN-1:0] rs2_data_pre;
logic [`XLEN-1:0] rd_data_post;
*/

assign csr_addr  = (halted && (dbg_csr_rd || dbg_csr_wr)) ? dbg_addr : insn[31:20];

assign csr_rd    = csr_rd_tmp || (halted && dbg_csr_rd);
assign csr_wr    = csr_wr_tmp || (halted && dbg_csr_wr);

rfu u_rfu (
    .clk          ( clk           ),
    .rstn         ( rstn          ),
    .rs1_addr     ( rs1_addr      ),
    .rs2_addr     ( rs2_addr      ),
    .rs1_data     ( rs1_data      ),
    .rs2_data     ( rs2_data      ),
    .wen          ( rd_wr_i       ),
    .rd_addr      ( rd_addr_i     ),
    .rd_data      ( rd_data       ),
    .gpr          ( dbg_gpr_all   ),
    .halted       ( halted        ),
    .dbg_gpr_addr ( dbg_addr[4:0] ),
    .dbg_gpr_in   ( dbg_wdata     ),
    .dbg_gpr_rd   ( dbg_gpr_rd    ),
    .dbg_gpr_wr   ( dbg_gpr_wr    ),
    .dbg_gpr_out  ( dbg_gpr_out   )
);

dec u_dec (
    .insn                ( insn                ),
    .insn_valid          ( insn_valid          ),

    // Extension
    .misa_mxl            ( misa_mxl            ),
    .misa_a_ext          ( misa_a_ext          ),
    .misa_c_ext          ( misa_c_ext          ),
    .misa_m_ext          ( misa_m_ext          ),

    // Date
    .rs1_addr            ( rs1_addr            ),
    .rs2_addr            ( rs2_addr            ),
    .rd_addr             ( rd_addr_o           ),
    .amo_64              ( amo_64_o            ),
    .len_64              ( len_64_o            ),
    .imm                 ( imm                 ),

    // Control
    .prv_req             ( prv_req             ),
    .ill_insn            ( ill_insn            ),
    .fence               ( fence               ),
    .fence_i             ( fence_i             ),
    .ecall               ( ecall               ),
    .ebreak              ( ebreak              ),
    .wfi                 ( wfi                 ),
    .sret                ( sret                ),
    .mret                ( mret                ),
    .jump                ( jump                ),
    .jump_alu            ( jump_alu            ),

    // EXE stage
    .rs1_rd              ( rs1_rd              ),
    .rs2_rd              ( rs2_rd              ),
    .mdu_sel             ( mdu_sel             ),
    .mdu_op              ( mdu_op              ),
    .alu_op              ( alu_op              ),
    .rs1_zero_sel        ( rs1_zero_sel        ),
    .rs2_imm_sel         ( rs2_imm_sel         ),
    .pc_imm_sel          ( pc_imm_sel          ),
    .branch              ( branch              ),
    .branch_zcmp         ( branch_zcmp         ),
    .bpu_op              ( bpu_op              ),
    .csr_op              ( csr_op              ),
    .uimm_rs1_sel        ( uimm_rs1_sel        ),
    .csr_rd              ( csr_rd_tmp          ),
    .csr_wr              ( csr_wr_tmp          ),

    // MEM stage
    .pc_alu_sel          ( pc_alu_sel          ),
    .csr_alu_sel         ( csr_alu_sel         ),
    .amo                 ( amo                 ),
    .amo_op              ( amo_op              ),
    .mem_req             ( mem_req             ),
    .mem_wr              ( mem_wr              ),
    .mem_ex              ( mem_ex              ),
    .mem_byte            ( mem_byte            ),
    .mem_sign_ext        ( mem_sign_ext        ),
    .tlb_flush_req       ( tlb_flush_req       ),
    .tlb_flush_all_vaddr ( tlb_flush_all_vaddr ),
    .tlb_flush_all_asid  ( tlb_flush_all_asid  ),

    // WB stage
    .mem_cal_sel         ( mem_cal_sel         ),
    .reg_wr              ( rd_wr_o             )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/dec.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

//`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif

`define MDU_OP_LEN 4
`define ALU_OP_LEN 4
`define BPU_OP_LEN 2
`define CSR_OP_LEN 2
`define AMO_OP_LEN 4

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define GPR_ZERO_ADDR 5'b00000
`define GPR_RA_ADDR   5'b00001
`define GPR_SP_ADDR   5'b00010
`define GPR_GP_ADDR   5'b00011
`define GPR_TP_ADDR   5'b00100
`define GPR_T0_ADDR   5'b00101
`define GPR_T1_ADDR   5'b00110
`define GPR_T2_ADDR   5'b00111
`define GPR_S0_ADDR   5'b01000
`define GPR_FP_ADDR   5'b01000
`define GPR_S1_ADDR   5'b01001
`define GPR_A0_ADDR   5'b01010
`define GPR_A1_ADDR   5'b01011
`define GPR_A2_ADDR   5'b01100
`define GPR_A3_ADDR   5'b01101
`define GPR_A4_ADDR   5'b01110
`define GPR_A5_ADDR   5'b01111
`define GPR_A6_ADDR   5'b10000
`define GPR_A7_ADDR   5'b10001
`define GPR_S2_ADDR   5'b10010
`define GPR_S3_ADDR   5'b10011
`define GPR_S4_ADDR   5'b10100
`define GPR_S5_ADDR   5'b10101
`define GPR_S6_ADDR   5'b10110
`define GPR_S7_ADDR   5'b10111
`define GPR_S8_ADDR   5'b11000
`define GPR_S9_ADDR   5'b11001
`define GPR_S10_ADDR  5'b11010
`define GPR_S11_ADDR  5'b11011
`define GPR_T3_ADDR   5'b11100
`define GPR_T4_ADDR   5'b11101
`define GPR_T5_ADDR   5'b11110
`define GPR_T6_ADDR   5'b11111

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       'h0
`define CAUSE_INSTRUCTION_ACCESS     'h1
`define CAUSE_ILLEGAL_INSTRUCTION    'h2
`define CAUSE_BREAKPOINT             'h3
`define CAUSE_MISALIGNED_LOAD        'h4
`define CAUSE_LOAD_ACCESS            'h5
`define CAUSE_MISALIGNED_STORE       'h6
`define CAUSE_STORE_ACCESS           'h7
`define CAUSE_USER_ECALL             'h8
`define CAUSE_SUPERVISOR_ECALL       'h9
`define CAUSE_HYPERVISOR_ECALL       'ha
`define CAUSE_MACHINE_ECALL          'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT 'hc
`define CAUSE_LOAD_PAGE_FAULT        'hd
`define CAUSE_STORE_PAGE_FAULT       'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`define MCAUSE_CODE_WIDTH 6

`define MISA_MXL_XLEN_32  2'b01
`define MISA_MXL_XLEN_64  2'b10
`define MISA_MXL_XLEN_128 2'b11

`define SATP32_PPN_WIDTH  22
`define SATP32_ASID_WIDTH  9
`define SATP32_MODE_WIDTH  1

`define SATP64_PPN_WIDTH  44
`define SATP64_ASID_WIDTH 16
`define SATP64_MODE_WIDTH  4

`define SATP32_PPN_BIT     0+:`SATP32_PPN_WIDTH
`define SATP32_ASID_BIT   22+:`SATP32_ASID_WIDTH
`define SATP32_MODE_BIT   31+:`SATP32_MODE_WIDTH

`define SATP64_PPN_BIT     0+:`SATP64_PPN_WIDTH
`define SATP64_ASID_BIT   44+:`SATP64_ASID_WIDTH
`define SATP64_MODE_BIT   60+:`SATP64_MODE_WIDTH

`ifdef RV32
`define SATP_PPN_WIDTH  `SATP32_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP32_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP32_MODE_WIDTH
`define PADDR_LEN       (`SATP32_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`else
`define SATP_PPN_WIDTH  `SATP64_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP64_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP64_MODE_WIDTH
`define PADDR_LEN       (`SATP64_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`define SATP_MODE_SV39  `SATP_MODE_WIDTH'h8
`define SATP_MODE_SV48  `SATP_MODE_WIDTH'h9
`define SATP_MODE_SV57  `SATP_MODE_WIDTH'ha
`define SATP_MODE_SV64  `SATP_MODE_WIDTH'hb
`endif

`define PTE_V_BIT     0
`define PTE_R_BIT     1
`define PTE_W_BIT     2
`define PTE_X_BIT     3
`define PTE_U_BIT     4
`define PTE_G_BIT     5
`define PTE_A_BIT     6
`define PTE_D_BIT     7
`define PTE_RSW_BIT   8:9
`define PTE_PPN_SHIFT 10

`endif

module dec (
    input        [       `IM_DATA_LEN - 1:0] insn,
    input                                    insn_valid,

    // Extension flag
    input        [                      1:0] misa_mxl,
    input                                    misa_a_ext,
    input                                    misa_c_ext,
    input                                    misa_m_ext,

    // Data
    output logic [                      4:0] rs1_addr,
    output logic [                      4:0] rs2_addr,
    output logic [                      4:0] rd_addr,
    output logic                             amo_64,
    output logic                             len_64,

    output logic [              `XLEN - 1:0] imm,

    // Control
    output logic [                      1:0] prv_req,
    output logic                             ill_insn,
    output logic                             fence,
    output logic                             fence_i,
    output logic                             ecall,
    output logic                             ebreak,
    output logic                             wfi,
    output logic                             sret,
    output logic                             mret,
    output logic                             jump,
    output logic                             jump_alu,

    // EXE stage
    output logic                             rs1_rd,
    output logic                             rs2_rd,
    output logic                             mdu_sel,
    output logic [        `MDU_OP_LEN - 1:0] mdu_op,
    output logic [        `ALU_OP_LEN - 1:0] alu_op,
    output logic                             rs1_zero_sel,
    output logic                             rs2_imm_sel,
    output logic                             pc_imm_sel,
    output logic                             branch,
    output logic                             branch_zcmp,
    output logic [        `BPU_OP_LEN - 1:0] bpu_op,
    output logic [        `CSR_OP_LEN - 1:0] csr_op,
    output logic                             uimm_rs1_sel,
    output logic                             csr_rd,
    output logic                             csr_wr,

    // MEM stage
    output logic                             pc_alu_sel,
    output logic                             csr_alu_sel,
    output logic                             amo,
    output logic [        `AMO_OP_LEN - 1:0] amo_op,
    output logic                             mem_req,
    output logic                             mem_wr,
    output logic                             mem_ex,
    output logic [(`DM_DATA_LEN >> 3) - 1:0] mem_byte,
    output logic                             mem_sign_ext,
    output logic                             tlb_flush_req,
    output logic                             tlb_flush_all_vaddr,
    output logic                             tlb_flush_all_asid,

    // WB stage
    output logic                             mem_cal_sel,
    output logic                             reg_wr
);

parameter [`ALU_OP_LEN - 1:0] ALU_AND  = `ALU_OP_LEN'b0000,
                              ALU_OR   = `ALU_OP_LEN'b0001,
                              ALU_XOR  = `ALU_OP_LEN'b0010,
                              ALU_ADD  = `ALU_OP_LEN'b0011,
                              ALU_SUB  = `ALU_OP_LEN'b0100,
                              ALU_SLT  = `ALU_OP_LEN'b0101,
                              ALU_SLL  = `ALU_OP_LEN'b0110,
                              ALU_SRL  = `ALU_OP_LEN'b0111,
                              ALU_SLTU = `ALU_OP_LEN'b1000,
                              ALU_SRA  = `ALU_OP_LEN'b1001;
parameter [`BPU_OP_LEN - 1:0] BPU_EQ  = `BPU_OP_LEN'b00,
                              BPU_LT  = `BPU_OP_LEN'b01,
                              BPU_LTU = `BPU_OP_LEN'b10;
parameter [`MDU_OP_LEN - 1:0] MDU_MUL    = `MDU_OP_LEN'b0000,
                              MDU_MULHU  = `MDU_OP_LEN'b0001,
                              MDU_MULHSU = `MDU_OP_LEN'b0011,
                              MDU_MULH   = `MDU_OP_LEN'b0111,
                              MDU_DIVU   = `MDU_OP_LEN'b1000,
                              MDU_REMU   = `MDU_OP_LEN'b1001,
                              MDU_DIV    = `MDU_OP_LEN'b1110,
                              MDU_REM    = `MDU_OP_LEN'b1111;
parameter [`CSR_OP_LEN - 1:0] CSR_OP_NONE = `CSR_OP_LEN'b00,
                              CSR_OP_SET  = `CSR_OP_LEN'b01,
                              CSR_OP_CLR  = `CSR_OP_LEN'b10;
parameter [`AMO_OP_LEN - 1:0] AMO_SWAP = `AMO_OP_LEN'b0001,
                              AMO_ADD  = `AMO_OP_LEN'b0000,
                              AMO_XOR  = `AMO_OP_LEN'b0010,
                              AMO_AND  = `AMO_OP_LEN'b0110,
                              AMO_OR   = `AMO_OP_LEN'b0100,
                              AMO_MIN  = `AMO_OP_LEN'b1000,
                              AMO_MAX  = `AMO_OP_LEN'b1010,
                              AMO_MINU = `AMO_OP_LEN'b1100,
                              AMO_MAXU = `AMO_OP_LEN'b1110;
parameter [4:0] OP_LOAD      = 5'b00_000,
                OP_LOAD_FP   = 5'b00_001,
                OP_CUST_0    = 5'b00_010,
                OP_MISC_MEM  = 5'b00_011,
                OP_OP_IMM    = 5'b00_100,
                OP_AUIPC     = 5'b00_101,
                OP_OP_IMM_32 = 5'b00_110,
                OP_STORE     = 5'b01_000,
                OP_STORE_FP  = 5'b01_001,
                OP_CUST_1    = 5'b01_010,
                OP_AMO       = 5'b01_011,
                OP_OP        = 5'b01_100,
                OP_LUI       = 5'b01_101,
                OP_OP_32     = 5'b01_110,
                OP_MADD      = 5'b10_000,
                OP_MSUB      = 5'b10_001,
                OP_NMSUB     = 5'b10_010,
                OP_NMADD     = 5'b10_011,
                OP_OP_FP     = 5'b10_100,
                OP_RSV_0     = 5'b10_101,
                OP_CUST_2    = 5'b10_110,
                OP_BRANCH    = 5'b11_000,
                OP_JALR      = 5'b11_001,
                OP_RSV_1     = 5'b11_010,
                OP_JAL       = 5'b11_011,
                OP_SYSTEM    = 5'b11_100,
                OP_RSV_2     = 5'b11_101,
                OP_CUST_3    = 5'b11_110;

parameter [1:0] OP16_C0      = 2'b00,
                OP16_C1      = 2'b01,
                OP16_C2      = 2'b10;
parameter [2:0] FUNCT3_JALR    = 3'b000,
                FUNCT3_BEQ     = 3'b000,
                FUNCT3_BNE     = 3'b001,
                FUNCT3_BLT     = 3'b100,
                FUNCT3_BGE     = 3'b101,
                FUNCT3_BLTU    = 3'b110,
                FUNCT3_BGEU    = 3'b111,
                FUNCT3_LB      = 3'b000,
                FUNCT3_LH      = 3'b001,
                FUNCT3_LW      = 3'b010,
                FUNCT3_LD      = 3'b011,
                FUNCT3_LBU     = 3'b100,
                FUNCT3_LHU     = 3'b101,
                FUNCT3_LWU     = 3'b110,
                FUNCT3_SB      = 3'b000,
                FUNCT3_SH      = 3'b001,
                FUNCT3_SW      = 3'b010,
                FUNCT3_SD      = 3'b011,
                FUNCT3_ADDI    = 3'b000,
                FUNCT3_SLTI    = 3'b010,
                FUNCT3_SLTIU   = 3'b011,
                FUNCT3_XORI    = 3'b100,
                FUNCT3_ORI     = 3'b110,
                FUNCT3_ANDI    = 3'b111,
                FUNCT3_SLLI    = 3'b001,
                FUNCT3_SRLI    = 3'b101,
                FUNCT3_SRAI    = 3'b101,
                FUNCT3_ADD     = 3'b000,
                FUNCT3_SUB     = 3'b000,
                FUNCT3_SLL     = 3'b001,
                FUNCT3_SLT     = 3'b010,
                FUNCT3_SLTU    = 3'b011,
                FUNCT3_XOR     = 3'b100,
                FUNCT3_SRL     = 3'b101,
                FUNCT3_SRA     = 3'b101,
                FUNCT3_OR      = 3'b110,
                FUNCT3_AND     = 3'b111,
                FUNCT3_FENCE   = 3'b000,
                FUNCT3_FENCE_I = 3'b001,
                FUNCT3_PRIV    = 3'b000,
                FUNCT3_CSRRW   = 3'b001,
                FUNCT3_CSRRS   = 3'b010,
                FUNCT3_CSRRC   = 3'b011,
                FUNCT3_CSRRWI  = 3'b101,
                FUNCT3_CSRRSI  = 3'b110,
                FUNCT3_CSRRCI  = 3'b111,
                FUNCT3_MUL     = 3'b000,
                FUNCT3_MULH    = 3'b001,
                FUNCT3_MULHSU  = 3'b010,
                FUNCT3_MULHU   = 3'b011,
                FUNCT3_DIV     = 3'b100,
                FUNCT3_DIVU    = 3'b101,
                FUNCT3_REM     = 3'b110,
                FUNCT3_REMU    = 3'b111;

parameter [4:0] FUNCT5_LR      = 5'b00010,
                FUNCT5_SC      = 5'b00011,
                FUNCT5_AMOSWAP = 5'b00001,
                FUNCT5_AMOADD  = 5'b00000,
                FUNCT5_AMOXOR  = 5'b00100,
                FUNCT5_AMOAND  = 5'b01100,
                FUNCT5_AMOOR   = 5'b01000,
                FUNCT5_AMOMIN  = 5'b10000,
                FUNCT5_AMOMAX  = 5'b10100,
                FUNCT5_AMOMINU = 5'b11000,
                FUNCT5_AMOMAXU = 5'b11100;

parameter [6:0] FUNCT7_SLLI       = 7'b0000000,
                FUNCT7_SRLI       = 7'b0000000,
                FUNCT7_SRAI       = 7'b0100000,
                FUNCT7_OP0        = 7'b0000000,
                FUNCT7_OP1        = 7'b0100000,
                FUNCT7_SFENCE_VMA = 7'b0001001,
                FUNCT7_MULDIV     = 7'b0000001;

parameter [11:0] FUNCT12_ECALL  = 12'h000,
                 FUNCT12_EBREAK = 12'h001,
                 FUNCT12_WFI    = 12'h105,
                 FUNCT12_SRET   = 12'h102,
                 FUNCT12_MRET   = 12'h302;

// RVC
parameter [2:0] FUNCT3_C0_ADDI4SPN = 3'b000,
                FUNCT3_C0_FLD      = 3'b001,
                FUNCT3_C0_LW       = 3'b010,
                FUNCT3_C0_FLW      = 3'b011,
                FUNCT3_C0_FSD      = 3'b101,
                FUNCT3_C0_SW       = 3'b110,
                FUNCT3_C0_FSW      = 3'b111;

parameter [2:0] FUNCT3_C1_ADDI     = 3'b000,
                FUNCT3_C1_JAL      = 3'b001,
                FUNCT3_C1_LI       = 3'b010,
                FUNCT3_C1_LUI      = 3'b011,
                FUNCT3_C1_OP       = 3'b100,
                FUNCT3_C1_J        = 3'b101,
                FUNCT3_C1_BEQZ     = 3'b110,
                FUNCT3_C1_BNEZ     = 3'b111;

parameter [2:0] FUNCT3_C2_SLLI     = 3'b000,
                FUNCT3_C2_FLDSP    = 3'b001,
                FUNCT3_C2_LWSP     = 3'b010,
                FUNCT3_C2_FLWSP    = 3'b011,
                FUNCT3_C2_OP       = 3'b100,
                FUNCT3_C2_FSDSP    = 3'b101,
                FUNCT3_C2_SWSP     = 3'b110,
                FUNCT3_C2_FSWSP    = 3'b111;

parameter [2:0] FUNCT2_OP_IMM_C_SRLI = 2'b00,
                FUNCT2_OP_IMM_C_SRAI = 2'b01,
                FUNCT2_OP_IMM_C_ANDI = 2'b10,
                FUNCT2_OP_IMM_C_OP   = 2'b11;

parameter [2:0] FUNCT2_OP_C_SUB  = 2'b00,
                FUNCT2_OP_C_XOR  = 2'b01,
                FUNCT2_OP_C_OR   = 2'b10,
                FUNCT2_OP_C_AND  = 2'b11,
                FUNCT2_OP_C_SUBW = 2'b00,
                FUNCT2_OP_C_ADDW = 2'b01;

logic [`XLEN - 1:0] imm_i;
logic [`XLEN - 1:0] imm_s;
logic [`XLEN - 1:0] imm_b;
logic [`XLEN - 1:0] imm_u;
logic [`XLEN - 1:0] imm_j;

logic [`XLEN - 1:0] imm_ci_lwsp;
logic [`XLEN - 1:0] imm_ci_ldsp;
logic [`XLEN - 1:0] imm_ci_li;
logic [`XLEN - 1:0] imm_ci_lui;
logic [`XLEN - 1:0] imm_ci_addi16sp;
logic [`XLEN - 1:0] imm_css;
logic [`XLEN - 1:0] imm_css64;
logic [`XLEN - 1:0] imm_ciw;
logic [`XLEN - 1:0] imm_cl;
logic [`XLEN - 1:0] imm_cl64;
logic [`XLEN - 1:0] imm_cs;
logic [`XLEN - 1:0] imm_cb;
logic [`XLEN - 1:0] imm_cj;

assign imm_i     = {{(`XLEN-11){insn[31]}}, insn[30:25], insn[24:21], insn[20]};
assign imm_s     = {{(`XLEN-11){insn[31]}}, insn[30:25], insn[11:8],  insn[7]};
assign imm_b     = {{(`XLEN-12){insn[31]}}, insn[7],     insn[30:25], insn[11:8], 1'b0};
assign imm_u     = {{(`XLEN-31){insn[31]}}, insn[30:20], insn[19:12], 12'b0};
assign imm_j     = {{(`XLEN-20){insn[31]}}, insn[19:12], insn[20],    insn[30:25], insn[24:21], 1'b0};

assign imm_ci_lwsp     = {{(`XLEN-8){1'b0}},      insn[3:2], insn[12], insn[6:4], 2'b0};
assign imm_ci_ldsp     = {{(`XLEN-9){1'b0}},      insn[4:2], insn[12], insn[6:5], 3'b0};
assign imm_ci_li       = {{(`XLEN-5){insn[12]}},  insn[6:2]};
assign imm_ci_lui      = {{(`XLEN-17){insn[12]}}, insn[6:2], 12'b0};
assign imm_ci_addi16sp = {{(`XLEN-9){insn[12]}},  insn[4:3], insn[5], insn[2], insn[6], 4'b0};
assign imm_css         = {{(`XLEN-8){1'b0}},      insn[8:7], insn[12:9], 2'b0};
assign imm_css64       = {{(`XLEN-9){1'b0}},      insn[9:7], insn[12:10], 3'b0};
assign imm_ciw         = {{(`XLEN-10){1'b0}},     insn[10:7], insn[12:11], insn[5], insn[6], 2'b0};
assign imm_cl          = {{(`XLEN-7){1'b0}},      insn[5], insn[12:10], insn[6], 2'b0};
assign imm_cl64        = {{(`XLEN-8){1'b0}},      insn[6], insn[5], insn[12:10], 3'b0};
assign imm_cs          = {{(`XLEN-7){1'b0}},      insn[5], insn[12:10], insn[6], 2'b0};
assign imm_cb          = {{(`XLEN-8){insn[12]}},  insn[6:5], insn[2], insn[11:10], insn[4:3], 1'b0};
assign imm_cj          = {{(`XLEN-11){insn[12]}}, insn[8], insn[10:9], insn[6], insn[7], insn[2], insn[11], insn[5:3], 1'b0};

logic [        2: 0] funct3;
logic [        4: 0] funct5;
logic [        6: 0] funct7;

logic [       15:13] funct3_16;
logic [       15:13] funct2_16_op_imm;
logic [       15:13] funct2_16_op;

assign funct3           = insn[14:12];
assign funct5           = insn[31:27];
assign funct7           = insn[31:25];

assign funct3_16        = insn[15:13];
assign funct2_16_op_imm = insn[11:10];
assign funct2_16_op     = insn[ 6: 5];

logic [        6: 2] opcode_32;
logic [        1: 0] opcode_16;

assign opcode_16 = insn[1:0];
assign opcode_32 = insn[6:2];

always_comb begin
    amo_64              = 1'b0;
    len_64              = misa_mxl[1];
    rs1_rd              = 1'b0;
    rs2_rd              = 1'b0;
    rs1_addr            = insn[19:15];
    rs2_addr            = insn[24:20];
    rd_addr             = insn[11: 7];
    imm                 = `XLEN'b0;
    mdu_sel             = 1'b0;
    mdu_op              = `MDU_OP_LEN'b0;
    alu_op              = `ALU_OP_LEN'b0;
    rs1_zero_sel        = 1'b0;
    rs2_imm_sel         = 1'b0;
    pc_imm_sel          = 1'b0;
    branch              = 1'b0;
    branch_zcmp         = 1'b0;
    bpu_op              = `BPU_OP_LEN'b0;
    pc_alu_sel          = 1'b0;
    amo                 = 1'b0;
    amo_op              = `AMO_OP_LEN'b0;
    mem_req             = 1'b0;
    mem_wr              = 1'b0;
    mem_ex              = 1'b0;
    mem_byte            = {(`DM_DATA_LEN >> 3){1'b0}};
    mem_sign_ext        = 1'b0;
    mem_cal_sel         = 1'b0;
    reg_wr              = 1'b0;
    fence               = 1'b0;
    fence_i             = 1'b0;
    ecall               = 1'b0;
    ebreak              = 1'b0;
    wfi                 = 1'b0;
    sret                = 1'b0;
    mret                = 1'b0;
    jump                = 1'b0;
    jump_alu            = 1'b0;
    csr_op              = `CSR_OP_LEN'b0;
    uimm_rs1_sel        = 1'b0;
    csr_rd              = 1'b0;
    csr_wr              = 1'b0;
    csr_alu_sel         = 1'b0;
    ill_insn            = 1'b0;
    prv_req             = 2'b0;
    tlb_flush_req       = 1'b0;
    tlb_flush_all_vaddr = 1'b0;
    tlb_flush_all_asid  = 1'b0;
    if (insn_valid) begin
        case (opcode_16)
            OP16_C0: begin
                rs1_rd       = 1'b1;
                rs1_addr     = {2'b1, insn[ 9: 7]};
                rs2_addr     = {2'b1, insn[ 4: 2]};
                rd_addr      = {2'b1, insn[ 4: 2]};
                ill_insn     = ~misa_c_ext;
                case (funct3_16)
                    FUNCT3_C0_ADDI4SPN: begin
                        rs1_addr     = `GPR_SP_ADDR;
                        imm          = imm_ciw;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b0;
                        pc_alu_sel   = 1'b0;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        mem_cal_sel  = 1'b0;
                        reg_wr       = |rd_addr;
                        alu_op       = ALU_ADD;
                        ill_insn     = ill_insn | ~|imm;
                    end
                    FUNCT3_C0_FLD     : begin
                        ill_insn     = 1'b1;
                    end
                    FUNCT3_C0_LW      : begin
                        imm          = imm_cl;
                        alu_op       = ALU_ADD;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b0;
                        mem_req      = 1'b1;
                        mem_wr       = 1'b0;
                        reg_wr       = |rd_addr;
                        mem_cal_sel  = 1'b1;
                        mem_byte     = {{((`DM_DATA_LEN >> 3) - 4){1'b0}}, 4'b1111};
                        mem_sign_ext = 1'b1;
                    end
                    FUNCT3_C0_FLW     : begin // RV32: FLW     RV64: LD
`ifndef RV32
                        case (misa_mxl)
                            `MISA_MXL_XLEN_32: begin
`endif
                                ill_insn     = 1'b1;
`ifndef RV32
                            end
                            `MISA_MXL_XLEN_64: begin
                                imm          = imm_cl64;
                                alu_op       = ALU_ADD;
                                rs1_zero_sel = 1'b1;
                                rs2_imm_sel  = 1'b0;
                                mem_req      = 1'b1;
                                mem_wr       = 1'b0;
                                reg_wr       = |rd_addr;
                                mem_cal_sel  = 1'b1;
                                mem_byte     = 8'hff;
                                mem_sign_ext = 1'b1;
                            end
                            default          : ill_insn     = 1'b1;
                        endcase
`endif
                    end
                    FUNCT3_C0_FSD     : begin
                        ill_insn     = 1'b1;
                    end
                    FUNCT3_C0_SW      : begin
                        rs2_rd       = 1'b1;
                        imm          = imm_cs;
                        alu_op       = ALU_ADD;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b0;
                        mem_req      = 1'b1;
                        mem_wr       = 1'b1;
                        reg_wr       = 1'b0;
                        mem_byte     = {{((`DM_DATA_LEN >> 3) - 4){1'b0}}, 4'b1111};
                    end
                    FUNCT3_C0_FSW     : begin // RV32: FSW     RV64: SD
`ifndef RV32
                        case (misa_mxl)
                            `MISA_MXL_XLEN_32: begin
`endif
                                ill_insn     = 1'b1;
`ifndef RV32
                            end
                            `MISA_MXL_XLEN_64: begin
                                rs2_rd       = 1'b1;
                                imm          = imm_cl64;
                                alu_op       = ALU_ADD;
                                rs1_zero_sel = 1'b1;
                                rs2_imm_sel  = 1'b0;
                                mem_req      = 1'b1;
                                mem_wr       = 1'b1;
                                reg_wr       = 1'b0;
                                mem_byte     = 8'hff;
                            end
                            default          : ill_insn     = 1'b1;
                        endcase
`endif
                    end
                    default           : begin
                        ill_insn     = 1'b1;
                    end
                endcase
            end
            OP16_C1: begin
                rs1_rd       = 1'b1;
                rs1_addr     = {2'b1, insn[ 9: 7]};
                rs2_addr     = {2'b1, insn[ 4: 2]};
                rd_addr      = {2'b1, insn[ 9: 7]};
                case (funct3_16)
                    FUNCT3_C1_ADDI: begin
                        rs1_addr     = insn[ 11: 7];
                        rd_addr      = insn[ 11: 7];
                        imm          = imm_ci_li;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b0;
                        pc_alu_sel   = 1'b0;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        mem_cal_sel  = 1'b0;
                        reg_wr       = |rd_addr;
                        alu_op       = ALU_ADD;
                    end
                    FUNCT3_C1_JAL : begin // RV32: JAL     RV64: ADDIW
`ifndef RV32
                        case (misa_mxl)
                            `MISA_MXL_XLEN_32: begin
`endif
                                rs1_rd       = 1'b0;
                                rs2_rd       = 1'b0;
                                rd_addr      = `GPR_RA_ADDR;
                                imm          = imm_cj;
                                rs1_zero_sel = 1'b1;
                                rs2_imm_sel  = 1'b1;
                                pc_imm_sel   = 1'b0;
                                pc_alu_sel   = 1'b1;
                                mem_req      = 1'b0;
                                mem_wr       = 1'b0;
                                mem_cal_sel  = 1'b0;
                                reg_wr       = 1'b1;
                                jump         = 1'b1;
`ifndef RV32
                            end
                            `MISA_MXL_XLEN_64: begin
                                rs1_addr     = insn[ 11: 7];
                                rd_addr      = insn[ 11: 7];
                                len_64       = 1'b0;
                                rs1_rd       = 1'b1;
                                imm          = imm_ci_li;
                                rs1_zero_sel = 1'b1;
                                rs2_imm_sel  = 1'b0;
                                pc_alu_sel   = 1'b0;
                                mem_req      = 1'b0;
                                mem_wr       = 1'b0;
                                mem_cal_sel  = 1'b0;
                                reg_wr       = |rd_addr;
                                alu_op       = ALU_ADD;
                            end
                            default          : ill_insn     = 1'b1;
                        endcase
`endif
                    end
                    FUNCT3_C1_LI  : begin
                        rs1_addr     = `GPR_ZERO_ADDR;
                        rd_addr      = insn[ 11: 7];
                        imm          = imm_ci_li;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b0;
                        pc_alu_sel   = 1'b0;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        mem_cal_sel  = 1'b0;
                        reg_wr       = |rd_addr;
                        alu_op       = ALU_ADD;
                    end
                    FUNCT3_C1_LUI : begin
                        rs1_addr     = insn[ 11: 7];
                        rd_addr      = insn[ 11: 7];
                        alu_op       = ALU_ADD;
                        rs2_imm_sel  = 1'b0;
                        pc_alu_sel   = 1'b0;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        mem_cal_sel  = 1'b0;
                        reg_wr       = |rd_addr;
                        if (rd_addr == `GPR_SP_ADDR) begin
                            imm          = imm_ci_addi16sp;
                            rs1_zero_sel = 1'b1;
                        end
                        else begin
                            rs1_rd       = 1'b0;
                            rs2_rd       = 1'b0;
                            imm          = imm_ci_lui;
                            rs1_zero_sel = 1'b0;
                        end
                    end
                    FUNCT3_C1_OP  : begin
                        imm          = imm_ci_li;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b0;
                        pc_alu_sel   = 1'b0;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        mem_cal_sel  = 1'b0;
                        reg_wr       = 1'b1;
                        case (funct2_16_op_imm)
                            FUNCT2_OP_IMM_C_SRLI: begin
                                alu_op       = ALU_SRL;
                                ill_insn     = ill_insn | (insn[12] & ~misa_mxl[1]);
                            end
                            FUNCT2_OP_IMM_C_SRAI: begin
                                alu_op       = ALU_SRA;
                                ill_insn     = ill_insn | (insn[12] & ~misa_mxl[1]);
                            end
                            FUNCT2_OP_IMM_C_ANDI: begin
                                alu_op       = ALU_AND;
                            end
                            FUNCT2_OP_IMM_C_OP  : begin
                                rs2_rd       = 1'b1;
                                rs2_imm_sel  = 1'b1;
                                if (insn[12] == 1'b0) begin
                                    case (funct2_16_op)
                                        FUNCT2_OP_C_SUB: begin
                                            alu_op       = ALU_SUB;
                                        end
                                        FUNCT2_OP_C_XOR: begin
                                            alu_op       = ALU_XOR;
                                        end
                                        FUNCT2_OP_C_OR : begin
                                            alu_op       = ALU_OR;
                                        end
                                        FUNCT2_OP_C_AND: begin
                                            alu_op       = ALU_AND;
                                        end
                                        default        : begin
                                            ill_insn     = 1'b1;
                                        end
                                    endcase
                                end
                                else begin
`ifndef RV32
                                    len_64       = 1'b0;
                                    case (funct2_16_op)
                                        FUNCT2_OP_C_SUBW: begin
                                            alu_op       = ALU_SUB;
                                        end
                                        FUNCT2_OP_C_ADDW: begin
                                            alu_op       = ALU_ADD;
                                        end
                                        default        : begin
`endif
                                            ill_insn     = 1'b1;
`ifndef RV32
                                        end
                                    endcase
`endif
                                end
                            end
                            default             : begin
                                ill_insn     = 1'b1;
                            end
                        endcase
                    end
                    FUNCT3_C1_J   : begin
                        rs1_rd       = 1'b0;
                        rs2_rd       = 1'b0;
                        rd_addr      = `GPR_ZERO_ADDR;
                        imm          = imm_cj;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b1;
                        pc_imm_sel   = 1'b0;
                        pc_alu_sel   = 1'b1;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        mem_cal_sel  = 1'b0;
                        reg_wr       = 1'b0;
                        jump         = 1'b1;
                    end
                    FUNCT3_C1_BEQZ: begin
                        rs2_rd       = 1'b1;
                        rs2_addr     = `GPR_ZERO_ADDR;
                        imm          = imm_cb;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b1;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        reg_wr       = 1'b0;
                        branch       = 1'b1;
                        alu_op       = ALU_SUB;
                        branch_zcmp  = 1'b1;
                    end
                    FUNCT3_C1_BNEZ: begin
                        rs2_rd       = 1'b1;
                        rs2_addr     = `GPR_ZERO_ADDR;
                        imm          = imm_cb;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b1;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        reg_wr       = 1'b0;
                        branch       = 1'b1;
                        alu_op       = ALU_SUB;
                        branch_zcmp  = 1'b0;
                    end
                    default       : begin
                        ill_insn     = 1'b1;
                    end
                endcase
            end
            OP16_C2: begin
                rs1_rd       = 1'b1;
                rs1_addr     = insn[11: 7];
                rs2_addr     = insn[ 6: 2];
                rd_addr      = insn[11: 7];
                case (funct3_16)
                    FUNCT3_C2_SLLI : begin
                        imm          = imm_ci_li;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b0;
                        pc_alu_sel   = 1'b0;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        mem_cal_sel  = 1'b0;
                        reg_wr       = |rd_addr;
                        alu_op       = ALU_SLL;
                        ill_insn     = ill_insn | (insn[12] & ~misa_mxl[1]);
                    end
                    FUNCT3_C2_FLDSP: begin
                        ill_insn     = 1'b1;
                    end
                    FUNCT3_C2_LWSP : begin
                        rs1_addr     = `GPR_SP_ADDR;
                        imm          = imm_ci_lwsp;
                        alu_op       = ALU_ADD;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b0;
                        mem_req      = 1'b1;
                        mem_wr       = 1'b0;
                        reg_wr       = |rd_addr;
                        mem_cal_sel  = 1'b1;
                        mem_byte     = {{((`DM_DATA_LEN >> 3) - 4){1'b0}}, 4'b1111};
                        mem_sign_ext = 1'b1;
                        ill_insn     = ill_insn | ~|rd_addr;
                    end
                    FUNCT3_C2_FLWSP: begin // RV32: FLWSP     RV64: LDSP
`ifndef RV32
                        case (misa_mxl)
                            `MISA_MXL_XLEN_32: begin
`endif
                                ill_insn     = 1'b1;
`ifndef RV32
                            end
                            `MISA_MXL_XLEN_64: begin
                                rs1_addr     = `GPR_SP_ADDR;
                                imm          = imm_ci_ldsp;
                                alu_op       = ALU_ADD;
                                rs1_zero_sel = 1'b1;
                                rs2_imm_sel  = 1'b0;
                                mem_req      = 1'b1;
                                mem_wr       = 1'b0;
                                reg_wr       = |rd_addr;
                                mem_cal_sel  = 1'b1;
                                mem_byte     = 8'hff;
                                mem_sign_ext = 1'b1;
                                ill_insn     = ill_insn | ~|rd_addr;
                            end
                            default          : ill_insn     = 1'b1;
                        endcase
`endif
                    end
                    FUNCT3_C2_OP   : begin
                        if (~insn[12]) begin
                            if (rs2_addr == `GPR_ZERO_ADDR) begin
                                rd_addr      = `GPR_ZERO_ADDR;
                                imm          = `XLEN'b0;
                                alu_op       = ALU_ADD;
                                rs1_zero_sel = 1'b1;
                                rs2_imm_sel  = 1'b0;
                                pc_imm_sel   = 1'b0;
                                pc_alu_sel   = 1'b1;
                                mem_req      = 1'b0;
                                mem_wr       = 1'b0;
                                mem_cal_sel  = 1'b0;
                                reg_wr       = |rd_addr;
                                jump_alu     = 1'b1;
                                ill_insn     = ill_insn | ~|rs1_addr;
                            end
                            else begin
                                rs2_rd       = 1'b1;
                                rs1_addr     = `GPR_ZERO_ADDR;
                                rs1_zero_sel = 1'b1;
                                rs2_imm_sel  = 1'b1;
                                pc_alu_sel   = 1'b0;
                                mem_req      = 1'b0;
                                mem_wr       = 1'b0;
                                mem_cal_sel  = 1'b0;
                                reg_wr       = |rd_addr;
                                alu_op       = ALU_ADD;
                            end
                        end
                        else begin
                            if (rs2_addr == `GPR_ZERO_ADDR) begin
                                if (rs1_addr == `GPR_ZERO_ADDR) begin
                                    rs1_rd       = 1'b0;
                                    mem_req      = 1'b0;
                                    mem_wr       = 1'b0;
                                    reg_wr       = 1'b0;
                                    ebreak       = 1'b1;
                                end
                                else begin
                                    rd_addr      = `GPR_RA_ADDR;
                                    imm          = `XLEN'b0;
                                    alu_op       = ALU_ADD;
                                    rs1_zero_sel = 1'b1;
                                    rs2_imm_sel  = 1'b0;
                                    pc_imm_sel   = 1'b0;
                                    pc_alu_sel   = 1'b1;
                                    mem_req      = 1'b0;
                                    mem_wr       = 1'b0;
                                    mem_cal_sel  = 1'b0;
                                    reg_wr       = 1'b1;
                                    jump_alu     = 1'b1;
                                end
                            end
                            else begin
                                rs2_rd       = 1'b1;
                                rs1_zero_sel = 1'b1;
                                rs2_imm_sel  = 1'b1;
                                pc_alu_sel   = 1'b0;
                                mem_req      = 1'b0;
                                mem_wr       = 1'b0;
                                mem_cal_sel  = 1'b0;
                                reg_wr       = |rd_addr;
                                alu_op       = ALU_ADD;
                            end
                        end
                    end
                    FUNCT3_C2_FSDSP: begin
                        ill_insn     = 1'b1;
                    end
                    FUNCT3_C2_SWSP : begin
                        rs2_rd       = 1'b1;
                        rs1_addr     = `GPR_SP_ADDR;
                        imm          = imm_css;
                        alu_op       = ALU_ADD;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b0;
                        mem_req      = 1'b1;
                        mem_wr       = 1'b1;
                        reg_wr       = 1'b0;
                        mem_byte     = {{((`DM_DATA_LEN >> 3) - 4){1'b0}}, 4'b1111};
                    end
                    FUNCT3_C2_FSWSP: begin // RV32: FLWSP     RV64: LDSP
`ifndef RV32
                        case (misa_mxl)
                            `MISA_MXL_XLEN_32: begin
`endif
                                ill_insn     = 1'b1;
`ifndef RV32
                            end
                            `MISA_MXL_XLEN_64: begin
                                rs2_rd       = 1'b1;
                                rs1_addr     = `GPR_SP_ADDR;
                                imm          = imm_css64;
                                alu_op       = ALU_ADD;
                                rs1_zero_sel = 1'b1;
                                rs2_imm_sel  = 1'b0;
                                mem_req      = 1'b1;
                                mem_wr       = 1'b1;
                                reg_wr       = 1'b0;
                                mem_byte     = 8'hff;
                            end
                            default          : ill_insn     = 1'b1;
                        endcase
`endif
                    end
                    default        : begin
                        ill_insn     = 1'b1;
                    end
                endcase
            end
            default: begin
                rs1_addr            = insn[19:15];
                rs2_addr            = insn[24:20];
                rd_addr             = insn[11: 7];
                case (opcode_32)
                    OP_LOAD     : begin
                        rs1_rd       = 1'b1;
                        imm          = imm_i;
                        alu_op       = ALU_ADD;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b0;
                        mem_req      = 1'b1;
                        mem_wr       = 1'b0;
                        reg_wr       = |rd_addr;
                        mem_cal_sel  = 1'b1;
                        case (funct3)
                            FUNCT3_LB : begin
                                mem_byte     = {{((`DM_DATA_LEN/8) - 1){1'b0}}, 1'b1   };
                                mem_sign_ext = 1'b1;
                            end
                            FUNCT3_LH : begin
                                mem_byte     = {{((`DM_DATA_LEN/8) - 2){1'b0}}, 2'b11  };
                                mem_sign_ext = 1'b1;
                            end
                            FUNCT3_LW : begin
                                mem_byte     = {{((`DM_DATA_LEN/8) - 4){1'b0}}, 4'b1111};
                                mem_sign_ext = 1'b1;
                            end
                            FUNCT3_LBU: begin
                                mem_byte     = {{((`DM_DATA_LEN/8) - 1){1'b0}}, 1'b1   };
                                mem_sign_ext = 1'b0;
                            end
                            FUNCT3_LHU: begin
                                mem_byte     = {{((`DM_DATA_LEN/8) - 2){1'b0}}, 2'b11  };
                                mem_sign_ext = 1'b0;
                            end
`ifndef RV32
                            FUNCT3_LWU: begin
                                mem_byte     = {{((`DM_DATA_LEN/8) - 4){1'b0}}, 4'b1111};
                                mem_sign_ext = 1'b0;
                                ill_insn     = ill_insn | ~misa_mxl[1];
                            end
                            FUNCT3_LD : begin
                                mem_byte     = 8'hff;
                                mem_sign_ext = 1'b1;
                                ill_insn     = ill_insn | ~misa_mxl[1];
                            end
`endif
                            default   : begin
                                ill_insn     = 1'b1;
                            end
                        endcase
                    end
                    OP_LOAD_FP  : ill_insn     = 1'b1;
                    OP_CUST_0   : ill_insn     = 1'b1;
                    OP_MISC_MEM : begin
                        case ({funct3, insn[11:7], insn[19:15], insn[31:28]})
                            {FUNCT3_FENCE  , 5'b0, 5'b0, 4'b0}: begin
                                mem_req      = 1'b0;
                                mem_wr       = 1'b0;
                                reg_wr       = 1'b0;
                                fence        = 1'b1;
                            end
                            {FUNCT3_FENCE_I, 5'b0, 5'b0, 4'b0}: begin
                                if (insn[27:20] == 8'b0) begin
                                    mem_req      = 1'b0;
                                    mem_wr       = 1'b0;
                                    reg_wr       = 1'b0;
                                    fence_i      = 1'b1;
                                    pc_imm_sel   = 1'b0;
                                end
                                else ill_insn     = 1'b1;
                            end
                            default       : begin
                                ill_insn     = 1'b1;
                            end
                        endcase
                    end
                    OP_OP_IMM   : begin
                        rs1_rd       = 1'b1;
                        imm          = imm_i;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b0;
                        pc_alu_sel   = 1'b0;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        mem_cal_sel  = 1'b0;
                        reg_wr       = |rd_addr;
                        case (funct3)
                            FUNCT3_ADDI : alu_op       = ALU_ADD;
                            FUNCT3_SLTI : alu_op       = ALU_SLT;
                            FUNCT3_SLTIU: alu_op       = ALU_SLTU;
                            FUNCT3_XORI : alu_op       = ALU_XOR;
                            FUNCT3_ORI  : alu_op       = ALU_OR;
                            FUNCT3_ANDI : alu_op       = ALU_AND;
                            FUNCT3_SLLI : begin
                                ill_insn     = ill_insn | (insn[25] & ~misa_mxl[1]);
                                case (funct7[6:1])
                                    FUNCT7_SLLI[6:1]: alu_op       = ALU_SLL;
                                    default         : ill_insn     = 1'b1;
                                endcase
                            end
                            FUNCT3_SRLI : begin
                                ill_insn     = ill_insn | (insn[25] & ~misa_mxl[1]);
                                case (funct7[6:1])
                                    FUNCT7_SRLI[6:1]: alu_op       = ALU_SRL;
                                    FUNCT7_SRAI[6:1]: alu_op       = ALU_SRA;
                                    default         : ill_insn     = 1'b1;
                                endcase
                            end
                            default     : ill_insn     = 1'b1;
                        endcase
                    end
                    OP_AUIPC    : begin
                        imm          = imm_u;
                        alu_op       = ALU_ADD;
                        rs1_zero_sel = 1'b1;
                        pc_imm_sel   = 1'b1;
                        pc_alu_sel   = 1'b1;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        mem_cal_sel  = 1'b0;
                        reg_wr       = |rd_addr;
                    end
                    OP_OP_IMM_32: begin
`ifdef RV32
                        ill_insn     = 1'b1;
`else
                        len_64       = 1'b0;
                        rs1_rd       = 1'b1;
                        imm          = imm_i;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b0;
                        pc_alu_sel   = 1'b0;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        mem_cal_sel  = 1'b0;
                        reg_wr       = |rd_addr;
                        ill_insn     = ill_insn | ~misa_mxl[1];
                        case (funct3)
                            FUNCT3_ADDI : alu_op       = ALU_ADD;
                            FUNCT3_SLLI : begin
                                ill_insn     = ill_insn | insn[25];
                                case (funct7[6:1])
                                    FUNCT7_SLLI[6:1]: alu_op       = ALU_SLL;
                                    default         : ill_insn     = 1'b1;
                                endcase
                            end
                            FUNCT3_SRLI : begin
                                ill_insn     = ill_insn | insn[25];
                                case (funct7[6:1])
                                    FUNCT7_SRLI[6:1]: alu_op       = ALU_SRL;
                                    FUNCT7_SRAI[6:1]: alu_op       = ALU_SRA;
                                    default         : ill_insn     = 1'b1;
                                endcase
                            end
                            default     : ill_insn     = 1'b1;
                        endcase
`endif
                    end
                    OP_STORE    : begin
                        rs1_rd       = 1'b1;
                        rs2_rd       = 1'b1;
                        imm          = imm_s;
                        alu_op       = ALU_ADD;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b0;
                        mem_req      = 1'b1;
                        mem_wr       = 1'b1;
                        reg_wr       = 1'b0;
                        case (funct3)
                            FUNCT3_SB: begin
                                mem_byte     = {{((`DM_DATA_LEN >> 3) - 1){1'b0}}, 1'b1   };
                            end
                            FUNCT3_SH: begin
                                mem_byte     = {{((`DM_DATA_LEN >> 3) - 2){1'b0}}, 2'b11  };
                            end
                            FUNCT3_SW: begin
                                mem_byte     = {{((`DM_DATA_LEN >> 3) - 4){1'b0}}, 4'b1111};
                            end
`ifndef RV32
                            FUNCT3_SD: begin
                                mem_byte     = 8'hff;
                                ill_insn     = ill_insn | ~misa_mxl[1];
                            end
`endif
                            default  : begin
                                ill_insn     = 1'b1;
                            end
                        endcase
                    end
                    OP_STORE_FP : ill_insn     = 1'b1;
                    OP_CUST_1   : ill_insn     = 1'b1;
                    OP_AMO      : begin
                        amo_64       = funct3 == 3'b011;
                        amo          = 1'b1;
                        rs1_rd       = 1'b1;
                        rs2_rd       = 1'b1;
                        imm          = `XLEN'b0;
                        alu_op       = ALU_ADD;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b0;
                        mem_req      = 1'b1;
                        mem_wr       = 1'b0;
                        mem_ex       = 1'b1;
                        reg_wr       = |rd_addr;
                        mem_cal_sel  = 1'b1;
                        mem_sign_ext = 1'b1;
`ifdef RV32
                        mem_byte     = {{((`DM_DATA_LEN >> 3) - 4){1'b0}}, 4'b1111};
                        ill_insn     = ill_insn | ~misa_a_ext | (funct3 != 3'b010);
`else
                        mem_byte     = ({8{funct3 == 3'b010}} & 8'h0f)|
                                       ({8{funct3 == 3'b011}} & 8'hff);
                        ill_insn     = ill_insn | ~misa_a_ext | (funct3 != 3'b010 && funct3 != 3'b011) |
                                                                (funct3 == 3'b011 && ~misa_mxl[1]);
`endif
                        case (funct5)
                            FUNCT5_LR     : begin 
                                amo          = 1'b0;
                                rs2_rd       = 1'b0;
                                ill_insn     = ill_insn || rs2_addr != `GPR_ZERO_ADDR;
                            end
                            FUNCT5_SC     : begin
                                amo          = 1'b0;
                                mem_wr       = 1'b1;
                            end
                            FUNCT5_AMOSWAP: amo_op       = AMO_SWAP;
                            FUNCT5_AMOADD : amo_op       = AMO_ADD;
                            FUNCT5_AMOXOR : amo_op       = AMO_XOR;
                            FUNCT5_AMOAND : amo_op       = AMO_AND;
                            FUNCT5_AMOOR  : amo_op       = AMO_OR;
                            FUNCT5_AMOMIN : amo_op       = AMO_MIN;
                            FUNCT5_AMOMAX : amo_op       = AMO_MAX;
                            FUNCT5_AMOMINU: amo_op       = AMO_MINU;
                            FUNCT5_AMOMAXU: amo_op       = AMO_MAXU;
                            default       : ill_insn     = 1'b1;
                        endcase
                    end
                    OP_OP       : begin
                        rs1_rd       = 1'b1;
                        rs2_rd       = 1'b1;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b1;
                        pc_alu_sel   = 1'b0;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        mem_cal_sel  = 1'b0;
                        reg_wr       = |rd_addr;
                        case (funct7)
                            FUNCT7_OP0   : begin
                                case (funct3)
                                    FUNCT3_ADD : alu_op       = ALU_ADD;
                                    FUNCT3_SLL : alu_op       = ALU_SLL;
                                    FUNCT3_SLT : alu_op       = ALU_SLT;
                                    FUNCT3_SLTU: alu_op       = ALU_SLTU;
                                    FUNCT3_XOR : alu_op       = ALU_XOR;
                                    FUNCT3_SRL : alu_op       = ALU_SRL;
                                    FUNCT3_OR  : alu_op       = ALU_OR;
                                    FUNCT3_AND : alu_op       = ALU_AND;
                                    default    : ill_insn     = 1'b1;
                                endcase
                            end
                            FUNCT7_OP1   : begin
                                case (funct3)
                                    FUNCT3_ADD : alu_op       = ALU_SUB;
                                    FUNCT3_SRL : alu_op       = ALU_SRA;
                                    default    : ill_insn     = 1'b1;
                                endcase
                            end
                            FUNCT7_MULDIV: begin
                                mdu_sel             = 1'b1;
                                ill_insn            = ill_insn | ~misa_m_ext;
                                case (funct3)
                                    FUNCT3_MUL   : mdu_op   = MDU_MUL;
                                    FUNCT3_MULH  : mdu_op   = MDU_MULH;
                                    FUNCT3_MULHSU: mdu_op   = MDU_MULHSU;
                                    FUNCT3_MULHU : mdu_op   = MDU_MULHU;
                                    FUNCT3_DIV   : mdu_op   = MDU_DIV;
                                    FUNCT3_DIVU  : mdu_op   = MDU_DIVU;
                                    FUNCT3_REM   : mdu_op   = MDU_REM;
                                    FUNCT3_REMU  : mdu_op   = MDU_REMU;
                                    default      : ill_insn = 1'b1;
                                endcase
                            end
                            default      : ill_insn     = 1'b1;
                        endcase
                    end
                    OP_LUI      : begin
                        imm          = imm_u;
                        alu_op       = ALU_OR;
                        rs1_zero_sel = 1'b0;
                        rs2_imm_sel  = 1'b0;
                        pc_alu_sel   = 1'b0;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        mem_cal_sel  = 1'b0;
                        reg_wr       = |rd_addr;
                    end
                    OP_OP_32    : begin
`ifdef RV32
                        ill_insn     = 1'b1;
`else
                        len_64       = 1'b0;
                        rs1_rd       = 1'b1;
                        rs2_rd       = 1'b1;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b1;
                        pc_alu_sel   = 1'b0;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        mem_cal_sel  = 1'b0;
                        reg_wr       = |rd_addr;
                        ill_insn     = ill_insn | ~misa_mxl[1];
                        case (funct7)
                            FUNCT7_OP0   : begin
                                case (funct3)
                                    FUNCT3_ADD : alu_op       = ALU_ADD;
                                    FUNCT3_SLL : alu_op       = ALU_SLL;
                                    FUNCT3_SRL : alu_op       = ALU_SRL;
                                    default    : ill_insn     = 1'b1;
                                endcase
                            end
                            FUNCT7_OP1   : begin
                                case (funct3)
                                    FUNCT3_ADD : alu_op       = ALU_SUB;
                                    FUNCT3_SRL : alu_op       = ALU_SRA;
                                    default    : ill_insn     = 1'b1;
                                endcase
                            end
                            FUNCT7_MULDIV: begin
                                mdu_sel             = 1'b1;
                                ill_insn            = ill_insn | ~misa_m_ext;
                                case (funct3)
                                    FUNCT3_MUL : mdu_op   = MDU_MUL;
                                    FUNCT3_DIV : mdu_op   = MDU_DIV;
                                    FUNCT3_DIVU: mdu_op   = MDU_DIVU;
                                    FUNCT3_REM : mdu_op   = MDU_REM;
                                    FUNCT3_REMU: mdu_op   = MDU_REMU;
                                    default    : ill_insn = 1'b1;
                                endcase
                            end
                            default      : ill_insn     = 1'b1;
                        endcase
`endif
                    end
                    OP_MADD     : ill_insn     = 1'b1;
                    OP_MSUB     : ill_insn     = 1'b1;
                    OP_NMSUB    : ill_insn     = 1'b1;
                    OP_NMADD    : ill_insn     = 1'b1;
                    OP_OP_FP    : ill_insn     = 1'b1;
                    OP_CUST_2   : ill_insn     = 1'b1;
                    OP_BRANCH   : begin
                        rs1_rd       = 1'b1;
                        rs2_rd       = 1'b1;
                        imm          = imm_b;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b1;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        reg_wr       = 1'b0;
                        branch       = 1'b1;
                        case (funct3)
                            FUNCT3_BEQ : begin
                                alu_op       = ALU_SUB;
                                bpu_op       = BPU_EQ;
                                branch_zcmp  = 1'b1;
                            end
                            FUNCT3_BNE : begin
                                alu_op       = ALU_SUB;
                                bpu_op       = BPU_EQ;
                                branch_zcmp  = 1'b0;
                            end
                            FUNCT3_BLT : begin
                                alu_op       = ALU_SLT;
                                bpu_op       = BPU_LT;
                                branch_zcmp  = 1'b1;
                            end
                            FUNCT3_BGE : begin
                                alu_op       = ALU_SLT;
                                bpu_op       = BPU_LT;
                                branch_zcmp  = 1'b0;
                            end
                            FUNCT3_BLTU: begin
                                alu_op       = ALU_SLTU;
                                bpu_op       = BPU_LTU;
                                branch_zcmp  = 1'b1;
                            end
                            FUNCT3_BGEU: begin
                                alu_op       = ALU_SLTU;
                                bpu_op       = BPU_LTU;
                                branch_zcmp  = 1'b0;
                            end
                            default    : begin
                                ill_insn     = 1'b1;
                            end
                        endcase
                    end
                    OP_JALR     : begin
                        rs1_rd       = 1'b1;
                        imm          = imm_i;
                        alu_op       = ALU_ADD;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b0;
                        pc_imm_sel   = 1'b0;
                        pc_alu_sel   = 1'b1;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        mem_cal_sel  = 1'b0;
                        reg_wr       = |rd_addr;
                        jump_alu     = 1'b1;
                    end
                    OP_JAL      : begin
                        imm          = imm_j;
                        rs1_zero_sel = 1'b1;
                        rs2_imm_sel  = 1'b1;
                        pc_imm_sel   = 1'b0;
                        pc_alu_sel   = 1'b1;
                        mem_req      = 1'b0;
                        mem_wr       = 1'b0;
                        mem_cal_sel  = 1'b0;
                        reg_wr       = |rd_addr;
                        jump         = 1'b1;
                    end
                    OP_SYSTEM   : begin
                        case (funct3)
                            FUNCT3_PRIV  : begin
                                if (funct7 == FUNCT7_SFENCE_VMA) begin
                                    rs1_rd       = 1'b1;
                                    rs2_rd       = 1'b1;
                                    tlb_flush_req       = 1'b1;
                                    tlb_flush_all_vaddr = ~|insn[19:15];
                                    tlb_flush_all_asid  = ~|insn[24:20];
                                    pc_imm_sel   = 1'b0;
                                end
                                else if ({insn[11:7], insn[19:15]} == {5'b0, 5'b0}) begin
                                    case (insn[31:20])
                                        FUNCT12_ECALL: begin
                                            mem_req      = 1'b0;
                                            mem_wr       = 1'b0;
                                            reg_wr       = 1'b0;
                                            ecall        = 1'b1;
                                        end
                                        FUNCT12_EBREAK: begin
                                            mem_req      = 1'b0;
                                            mem_wr       = 1'b0;
                                            reg_wr       = 1'b0;
                                            ebreak       = 1'b1;
                                        end
                                        FUNCT12_WFI   : begin
                                            wfi          = 1'b1;
                                        end
                                        FUNCT12_SRET  : begin
                                            sret         = 1'b1;
                                            prv_req      = insn[29:28];
                                        end
                                        FUNCT12_MRET  : begin
                                            mret         = 1'b1;
                                            prv_req      = insn[29:28];
                                        end
                                        default       : begin
                                            ill_insn     = 1'b1;
                                        end
                                    endcase
                                end
                                else begin
                                    ill_insn     = 1'b1;
                                end
                            end
                            FUNCT3_CSRRW : begin
                                rs1_rd       = 1'b1;
                                imm          = imm_i;
                                csr_op       = CSR_OP_NONE;
                                rs1_zero_sel = 1'b0;
                                rs2_imm_sel  = 1'b0;
                                pc_alu_sel   = 1'b0;
                                reg_wr       = |rd_addr;
                                uimm_rs1_sel = 1'b0;
                                csr_rd       = |rd_addr;
                                csr_wr       = 1'b1;
                                csr_alu_sel  = 1'b1;
                                prv_req      = insn[29:28];
                                ill_insn     = ill_insn | (csr_wr && insn[31:28] == 4'hc);
                            end
                            FUNCT3_CSRRS : begin
                                rs1_rd       = 1'b1;
                                imm          = imm_i;
                                csr_op       = CSR_OP_SET;
                                rs1_zero_sel = 1'b0;
                                rs2_imm_sel  = 1'b0;
                                pc_alu_sel   = 1'b0;
                                reg_wr       = |rd_addr;
                                uimm_rs1_sel = 1'b0;
                                csr_rd       = |rd_addr;
                                csr_wr       = |rs1_addr;
                                csr_alu_sel  = 1'b1;
                                prv_req      = insn[29:28];
                                ill_insn     = ill_insn | (csr_wr && insn[31:28] == 4'hc);
                            end
                            FUNCT3_CSRRC : begin
                                rs1_rd       = 1'b1;
                                imm          = imm_i;
                                csr_op       = CSR_OP_CLR;
                                rs1_zero_sel = 1'b0;
                                rs2_imm_sel  = 1'b0;
                                pc_alu_sel   = 1'b0;
                                reg_wr       = |rd_addr;
                                uimm_rs1_sel = 1'b0;
                                csr_rd       = |rd_addr;
                                csr_wr       = |rs1_addr;
                                csr_alu_sel  = 1'b1;
                                prv_req      = insn[29:28];
                                ill_insn     = ill_insn | (csr_wr && insn[31:28] == 4'hc);
                            end
                            FUNCT3_CSRRWI: begin
                                imm          = imm_i;
                                csr_op       = CSR_OP_NONE;
                                rs1_zero_sel = 1'b0;
                                rs2_imm_sel  = 1'b0;
                                pc_alu_sel   = 1'b0;
                                reg_wr       = |rd_addr;
                                uimm_rs1_sel = 1'b1;
                                csr_rd       = |rd_addr;
                                csr_wr       = 1'b1;
                                csr_alu_sel  = 1'b1;
                                prv_req      = insn[29:28];
                                ill_insn     = ill_insn | (csr_wr && insn[31:28] == 4'hc);
                            end
                            FUNCT3_CSRRSI: begin
                                imm          = imm_i;
                                csr_op       = CSR_OP_SET;
                                rs1_zero_sel = 1'b0;
                                rs2_imm_sel  = 1'b0;
                                pc_alu_sel   = 1'b0;
                                reg_wr       = |rd_addr;
                                uimm_rs1_sel = 1'b1;
                                csr_rd       = |rd_addr;
                                csr_wr       = |rs1_addr;
                                csr_alu_sel  = 1'b1;
                                prv_req      = insn[29:28];
                                ill_insn     = ill_insn | (csr_wr && insn[31:28] == 4'hc);
                            end
                            FUNCT3_CSRRCI: begin
                                imm          = imm_i;
                                csr_op       = CSR_OP_CLR;
                                rs1_zero_sel = 1'b0;
                                rs2_imm_sel  = 1'b0;
                                pc_alu_sel   = 1'b0;
                                reg_wr       = |rd_addr;
                                uimm_rs1_sel = 1'b1;
                                csr_rd       = |rd_addr;
                                csr_wr       = |rs1_addr;
                                csr_alu_sel  = 1'b1;
                                prv_req      = insn[29:28];
                                ill_insn     = ill_insn | (csr_wr && insn[31:28] == 4'hc);
                            end
                            default       : begin
                                ill_insn     = 1'b1;
                            end
                        endcase
                    end
                    OP_CUST_3   : ill_insn = 1'b1;
                    default     : ill_insn = 1'b1;
                endcase
            end
        endcase
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/agu.sv
/*--------------------------------------*/

module agu (
    input        [`XLEN-1:0] base,
    input        [`XLEN-1:0] offset,
    output logic [`XLEN-1:0] out
);

assign out = base + offset;

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/rfu.sv
/*--------------------------------------*/

module rfu (
    input                      clk,
    input                      rstn,
    input        [        4:0] rs1_addr,
    input        [        4:0] rs2_addr,
    output logic [`XLEN - 1:0] rs1_data,
    output logic [`XLEN - 1:0] rs2_data,
    input                      wen,
    input        [        4:0] rd_addr,
    input        [`XLEN - 1:0] rd_data,

    output logic [`XLEN - 1:0] gpr [32],
    input                      halted,
    input        [        4:0] dbg_gpr_addr,
    input        [`XLEN - 1:0] dbg_gpr_in,
    input                      dbg_gpr_rd,
    input                      dbg_gpr_wr,
    output logic [`XLEN - 1:0] dbg_gpr_out
);

logic               rstn_sync;
integer             i;

logic [        4:0] rd_addr_dbg;
logic               wen_dbg;
logic [`XLEN - 1:0] rd_data_dbg;

assign rd_addr_dbg = (halted && dbg_gpr_wr) ? dbg_gpr_addr : rd_addr;
assign wen_dbg     = wen || (halted && dbg_gpr_wr);
assign rd_data_dbg = (halted && dbg_gpr_wr) ? dbg_gpr_in : rd_data;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        for (i = 0; i < 32; i = i + 1) begin
            gpr[i] <= {`XLEN{1'b0}};
        end
    end
    else begin
        if (wen_dbg & |rd_addr_dbg) begin
            gpr[rd_addr_dbg] <= rd_data_dbg;
        end
    end
end

assign rs1_data = gpr[rs1_addr];
assign rs2_data = gpr[rs2_addr];

assign dbg_gpr_out = gpr[dbg_gpr_addr];

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/csr.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

//`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif

`define MDU_OP_LEN 4
`define ALU_OP_LEN 4
`define BPU_OP_LEN 2
`define CSR_OP_LEN 2
`define AMO_OP_LEN 4

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define GPR_ZERO_ADDR 5'b00000
`define GPR_RA_ADDR   5'b00001
`define GPR_SP_ADDR   5'b00010
`define GPR_GP_ADDR   5'b00011
`define GPR_TP_ADDR   5'b00100
`define GPR_T0_ADDR   5'b00101
`define GPR_T1_ADDR   5'b00110
`define GPR_T2_ADDR   5'b00111
`define GPR_S0_ADDR   5'b01000
`define GPR_FP_ADDR   5'b01000
`define GPR_S1_ADDR   5'b01001
`define GPR_A0_ADDR   5'b01010
`define GPR_A1_ADDR   5'b01011
`define GPR_A2_ADDR   5'b01100
`define GPR_A3_ADDR   5'b01101
`define GPR_A4_ADDR   5'b01110
`define GPR_A5_ADDR   5'b01111
`define GPR_A6_ADDR   5'b10000
`define GPR_A7_ADDR   5'b10001
`define GPR_S2_ADDR   5'b10010
`define GPR_S3_ADDR   5'b10011
`define GPR_S4_ADDR   5'b10100
`define GPR_S5_ADDR   5'b10101
`define GPR_S6_ADDR   5'b10110
`define GPR_S7_ADDR   5'b10111
`define GPR_S8_ADDR   5'b11000
`define GPR_S9_ADDR   5'b11001
`define GPR_S10_ADDR  5'b11010
`define GPR_S11_ADDR  5'b11011
`define GPR_T3_ADDR   5'b11100
`define GPR_T4_ADDR   5'b11101
`define GPR_T5_ADDR   5'b11110
`define GPR_T6_ADDR   5'b11111

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       'h0
`define CAUSE_INSTRUCTION_ACCESS     'h1
`define CAUSE_ILLEGAL_INSTRUCTION    'h2
`define CAUSE_BREAKPOINT             'h3
`define CAUSE_MISALIGNED_LOAD        'h4
`define CAUSE_LOAD_ACCESS            'h5
`define CAUSE_MISALIGNED_STORE       'h6
`define CAUSE_STORE_ACCESS           'h7
`define CAUSE_USER_ECALL             'h8
`define CAUSE_SUPERVISOR_ECALL       'h9
`define CAUSE_HYPERVISOR_ECALL       'ha
`define CAUSE_MACHINE_ECALL          'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT 'hc
`define CAUSE_LOAD_PAGE_FAULT        'hd
`define CAUSE_STORE_PAGE_FAULT       'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`define MCAUSE_CODE_WIDTH 6

`define MISA_MXL_XLEN_32  2'b01
`define MISA_MXL_XLEN_64  2'b10
`define MISA_MXL_XLEN_128 2'b11

`define SATP32_PPN_WIDTH  22
`define SATP32_ASID_WIDTH  9
`define SATP32_MODE_WIDTH  1

`define SATP64_PPN_WIDTH  44
`define SATP64_ASID_WIDTH 16
`define SATP64_MODE_WIDTH  4

`define SATP32_PPN_BIT     0+:`SATP32_PPN_WIDTH
`define SATP32_ASID_BIT   22+:`SATP32_ASID_WIDTH
`define SATP32_MODE_BIT   31+:`SATP32_MODE_WIDTH

`define SATP64_PPN_BIT     0+:`SATP64_PPN_WIDTH
`define SATP64_ASID_BIT   44+:`SATP64_ASID_WIDTH
`define SATP64_MODE_BIT   60+:`SATP64_MODE_WIDTH

`ifdef RV32
`define SATP_PPN_WIDTH  `SATP32_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP32_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP32_MODE_WIDTH
`define PADDR_LEN       (`SATP32_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`else
`define SATP_PPN_WIDTH  `SATP64_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP64_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP64_MODE_WIDTH
`define PADDR_LEN       (`SATP64_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`define SATP_MODE_SV39  `SATP_MODE_WIDTH'h8
`define SATP_MODE_SV48  `SATP_MODE_WIDTH'h9
`define SATP_MODE_SV57  `SATP_MODE_WIDTH'ha
`define SATP_MODE_SV64  `SATP_MODE_WIDTH'hb
`endif

`define PTE_V_BIT     0
`define PTE_R_BIT     1
`define PTE_W_BIT     2
`define PTE_X_BIT     3
`define PTE_U_BIT     4
`define PTE_G_BIT     5
`define PTE_A_BIT     6
`define PTE_D_BIT     7
`define PTE_RSW_BIT   8:9
`define PTE_PPN_SHIFT 10

`endif

module csr (
    input                       clk,
    input                       rstn,
    input        [        1: 0] misa_mxl,
    input                       rd,
    input                       wr,
    input        [       11: 0] raddr,
    output logic [`XLEN - 1: 0] rdata,
    output logic                pmu_csr_wr,
    output logic                fpu_csr_wr,
    output logic                dbg_csr_wr,
    output logic                mmu_csr_wr,
    output logic                mpu_csr_wr,
    output logic                sru_csr_wr,
    input        [`XLEN - 1: 0] pmu_csr_rdata,
    input        [`XLEN - 1: 0] fpu_csr_rdata,
    input        [`XLEN - 1: 0] dbg_csr_rdata,
    input        [`XLEN - 1: 0] mmu_csr_rdata,
    input        [`XLEN - 1: 0] mpu_csr_rdata,
    input        [`XLEN - 1: 0] sru_csr_rdata

);

logic [`XLEN - 1: 0] rdata_pre;

logic                pmu_csr_sel;
logic                dbg_csr_sel;
logic                mmu_csr_sel;
logic                mpu_csr_sel;
logic                sru_csr_sel;
logic                fpu_csr_sel;

assign pmu_csr_sel = raddr[11] || {raddr[11:10], raddr[7:5]} == 5'b00_001 || raddr == 12'h106 || raddr == 12'h306;
assign dbg_csr_sel = raddr[11:10] == 2'b01;
assign mmu_csr_sel = raddr == 12'h180;
assign mpu_csr_sel = {raddr[11:10], raddr[7]} == 3'b00_1 && ~mmu_csr_sel;
assign sru_csr_sel = (({raddr[11:10], raddr[7:6]} == 4'b00_00 && ~fpu_csr_sel) ||
                       {raddr[11:10], raddr[7:6]} == 4'b00_01) && (raddr != 12'h106 || raddr != 12'h306);
assign fpu_csr_sel = raddr[11:2] == 10'b0000_0000_00 && raddr[1:0] != 2'b00;

assign pmu_csr_wr = pmu_csr_sel & wr;
assign fpu_csr_wr = fpu_csr_sel & wr;
assign dbg_csr_wr = dbg_csr_sel & wr;
assign mmu_csr_wr = mmu_csr_sel & wr;
assign mpu_csr_wr = mpu_csr_sel & wr;
assign sru_csr_wr = sru_csr_sel & wr;

assign rdata_pre = ({`XLEN{pmu_csr_sel}} & pmu_csr_rdata) |
                   ({`XLEN{dbg_csr_sel}} & dbg_csr_rdata) |
                   ({`XLEN{mmu_csr_sel}} & mmu_csr_rdata) |
                   ({`XLEN{mpu_csr_sel}} & mpu_csr_rdata) |
                   ({`XLEN{sru_csr_sel}} & sru_csr_rdata) |
                   ({`XLEN{fpu_csr_sel}} & fpu_csr_rdata);

`ifdef RV32
assign rdata = rdata_pre;
`else
assign rdata = misa_mxl == 2'h1 ? {{32{rdata_pre[31]}}, rdata_pre[31:0]}:
                                  rdata_pre;
`endif

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/csr_alu.sv
/*--------------------------------------*/

module csr_alu (
    input        [`CSR_OP_LEN-1:0] csr_op,
    input        [      `XLEN-1:0] src1,
    input        [      `XLEN-1:0] src2,
    output logic [      `XLEN-1:0] stb,
    output logic [      `XLEN-1:0] clr,
    output logic [      `XLEN-1:0] out
);

parameter [`CSR_OP_LEN - 1:0] CSR_OP_NONE = `CSR_OP_LEN'b00,
                              CSR_OP_SET  = `CSR_OP_LEN'b01,
                              CSR_OP_CLR  = `CSR_OP_LEN'b10;

always_comb begin
    out = `XLEN'b0;
    case (csr_op)
        CSR_OP_NONE: out = src2;
        CSR_OP_SET : out = src1 |  src2;
        CSR_OP_CLR : out = src1 & ~src2;
    endcase
end

always_comb begin
    stb = `XLEN'b0;
    case (csr_op)
        CSR_OP_NONE: stb = src2;
        CSR_OP_SET : stb = src2;
    endcase
end

always_comb begin
    clr = `XLEN'b0;
    case (csr_op)
        CSR_OP_NONE: clr = ~src2;
        CSR_OP_CLR : clr =  src2;
    endcase
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/sru.sv
/*--------------------------------------*/

/* CSR information */
// User Trap Setup
// 0x000 URW ustatus User status register.
// 0x004 URW uie User interrupt-enable register.
// 0x005 URW utvec User trap handler base address.
// User Trap Handling
// 0x040 URW uscratch Scratch register for user trap handlers.
// 0x041 URW uepc User exception program counter.
// 0x042 URW ucause User trap cause.
// 0x043 URW utval User bad address or instruction.
// 0x044 URW uip User interrupt pending.
// Supervisor Trap Setup
// 0x100 SRW sstatus Supervisor status register.
// 0x102 SRW sedeleg Supervisor exception delegation register.
// 0x103 SRW sideleg Supervisor interrupt delegation register.
// 0x104 SRW sie Supervisor interrupt-enable register.
// 0x105 SRW stvec Supervisor trap handler base address.
// Supervisor Trap Handling
// 0x140 SRW sscratch Scratch register for supervisor trap handlers.
// 0x141 SRW sepc Supervisor exception program counter.
// 0x142 SRW scause Supervisor trap cause.
// 0x143 SRW stval Supervisor bad address or instruction.
// 0x144 SRW sip Supervisor interrupt pending
// Machine Trap Setup
// 0x300 MRW mstatus Machine status register.
// 0x301 MRW misa ISA and extensions
// 0x302 MRW medeleg Machine exception delegation register.
// 0x303 MRW mideleg Machine interrupt delegation register.
// 0x304 MRW mie Machine interrupt-enable register.
// 0x305 MRW mtvec Machine trap-handler base address.
// Machine Trap Handling
// 0x340 MRW mscratch Scratch register for machine trap handlers.
// 0x341 MRW mepc Machine exception program counter.
// 0x342 MRW mcause Machine trap cause.
// 0x343 MRW mtval Machine bad address or instruction.
// 0x344 MRW mip Machine interrupt pending.

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

//`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif

`define MDU_OP_LEN 4
`define ALU_OP_LEN 4
`define BPU_OP_LEN 2
`define CSR_OP_LEN 2
`define AMO_OP_LEN 4

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define GPR_ZERO_ADDR 5'b00000
`define GPR_RA_ADDR   5'b00001
`define GPR_SP_ADDR   5'b00010
`define GPR_GP_ADDR   5'b00011
`define GPR_TP_ADDR   5'b00100
`define GPR_T0_ADDR   5'b00101
`define GPR_T1_ADDR   5'b00110
`define GPR_T2_ADDR   5'b00111
`define GPR_S0_ADDR   5'b01000
`define GPR_FP_ADDR   5'b01000
`define GPR_S1_ADDR   5'b01001
`define GPR_A0_ADDR   5'b01010
`define GPR_A1_ADDR   5'b01011
`define GPR_A2_ADDR   5'b01100
`define GPR_A3_ADDR   5'b01101
`define GPR_A4_ADDR   5'b01110
`define GPR_A5_ADDR   5'b01111
`define GPR_A6_ADDR   5'b10000
`define GPR_A7_ADDR   5'b10001
`define GPR_S2_ADDR   5'b10010
`define GPR_S3_ADDR   5'b10011
`define GPR_S4_ADDR   5'b10100
`define GPR_S5_ADDR   5'b10101
`define GPR_S6_ADDR   5'b10110
`define GPR_S7_ADDR   5'b10111
`define GPR_S8_ADDR   5'b11000
`define GPR_S9_ADDR   5'b11001
`define GPR_S10_ADDR  5'b11010
`define GPR_S11_ADDR  5'b11011
`define GPR_T3_ADDR   5'b11100
`define GPR_T4_ADDR   5'b11101
`define GPR_T5_ADDR   5'b11110
`define GPR_T6_ADDR   5'b11111

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       'h0
`define CAUSE_INSTRUCTION_ACCESS     'h1
`define CAUSE_ILLEGAL_INSTRUCTION    'h2
`define CAUSE_BREAKPOINT             'h3
`define CAUSE_MISALIGNED_LOAD        'h4
`define CAUSE_LOAD_ACCESS            'h5
`define CAUSE_MISALIGNED_STORE       'h6
`define CAUSE_STORE_ACCESS           'h7
`define CAUSE_USER_ECALL             'h8
`define CAUSE_SUPERVISOR_ECALL       'h9
`define CAUSE_HYPERVISOR_ECALL       'ha
`define CAUSE_MACHINE_ECALL          'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT 'hc
`define CAUSE_LOAD_PAGE_FAULT        'hd
`define CAUSE_STORE_PAGE_FAULT       'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`define MCAUSE_CODE_WIDTH 6

`define MISA_MXL_XLEN_32  2'b01
`define MISA_MXL_XLEN_64  2'b10
`define MISA_MXL_XLEN_128 2'b11

`define SATP32_PPN_WIDTH  22
`define SATP32_ASID_WIDTH  9
`define SATP32_MODE_WIDTH  1

`define SATP64_PPN_WIDTH  44
`define SATP64_ASID_WIDTH 16
`define SATP64_MODE_WIDTH  4

`define SATP32_PPN_BIT     0+:`SATP32_PPN_WIDTH
`define SATP32_ASID_BIT   22+:`SATP32_ASID_WIDTH
`define SATP32_MODE_BIT   31+:`SATP32_MODE_WIDTH

`define SATP64_PPN_BIT     0+:`SATP64_PPN_WIDTH
`define SATP64_ASID_BIT   44+:`SATP64_ASID_WIDTH
`define SATP64_MODE_BIT   60+:`SATP64_MODE_WIDTH

`ifdef RV32
`define SATP_PPN_WIDTH  `SATP32_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP32_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP32_MODE_WIDTH
`define PADDR_LEN       (`SATP32_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`else
`define SATP_PPN_WIDTH  `SATP64_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP64_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP64_MODE_WIDTH
`define PADDR_LEN       (`SATP64_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`define SATP_MODE_SV39  `SATP_MODE_WIDTH'h8
`define SATP_MODE_SV48  `SATP_MODE_WIDTH'h9
`define SATP_MODE_SV57  `SATP_MODE_WIDTH'ha
`define SATP_MODE_SV64  `SATP_MODE_WIDTH'hb
`endif

`define PTE_V_BIT     0
`define PTE_R_BIT     1
`define PTE_W_BIT     2
`define PTE_X_BIT     3
`define PTE_U_BIT     4
`define PTE_G_BIT     5
`define PTE_A_BIT     6
`define PTE_D_BIT     7
`define PTE_RSW_BIT   8:9
`define PTE_PPN_SHIFT 10

`endif
`ifndef __CSR_DEFINE__
`define __CSR_DEFINE__

`define CSR_WDATA(DEST, RANGE) \
        ((``DEST`` | csr_sdata[RANGE]) & ~csr_cdata[RANGE])

`endif

module sru (
    input                           clk,
    input                           clk_free,
    input                           srstn,
    input                           xrstn,
    input                           sleep,
    input                           misaligned,
    output logic [             1:0] prv,
    output logic                    tsr,
    output logic                    tvm,
    output logic                    sum,
    output logic                    mprv,
    output logic [             1:0] mpp,
    output logic                    warm_rst_trigger,

    // IRQ signal
    input                           ext_msip,
    input                           ext_mtip,
    input                           ext_meip,
    input                           ext_seip,
    input                           int_mask,
    output logic                    wakeup,
    output logic                    irq_trigger,
    output logic [       `XLEN-1:0] cause,
    output logic [       `XLEN-1:0] tval,

    // PC control
    output logic [`IM_ADDR_LEN-1:0] trap_vec,
    output logic [`IM_ADDR_LEN-1:0] ret_epc,

    // Trap signal
    input        [`IM_ADDR_LEN-1:0] trap_epc,
    input                           trap_en,
    input        [       `XLEN-1:0] trap_cause,
    input        [       `XLEN-1:0] trap_val,
    input                           sret,
    input                           mret,
    output logic                    eret_en,

    // Extension flag
    output logic [             1:0] misa_mxl,
    output logic                    misa_a_ext,
    output logic                    misa_c_ext,
    output logic                    misa_m_ext,
    
    // CSR interface
    input                           csr_wr,
    input        [            11:0] csr_waddr,
    input        [            11:0] csr_raddr,
    // input        [       `XLEN-1:0] csr_wdata,
    input        [       `XLEN-1:0] csr_sdata,
    input        [       `XLEN-1:0] csr_cdata,
    output logic [       `XLEN-1:0] csr_rdata
);

logic                          trap_m_mode;
logic                          trap_s_mode;
logic                          ints_m_mode_pre;
logic                          ints_s_mode_pre;
logic                          ints_m_mode;
logic                          ints_s_mode;
logic [      `IM_ADDR_LEN-1:0] vec_offset;
logic                          msip_d1;
logic                          mtip_d1;
logic                          meip_d1;
logic                          seip_d1;
logic                          seip_d2;

logic [             `XLEN-1:0] sstatus;
logic [                  30:0] sstatus_low;
// logic [       `XLEN-1:0] sedeleg;
// logic [       `XLEN-1:0] sideleg;
logic [             `XLEN-1:0] sie;
logic [             `XLEN-1:0] sip;
logic [             `XLEN-1:0] stvec;
logic [             `XLEN-1:0] sscratch;
logic [             `XLEN-1:0] sepc;
logic [             `XLEN-1:0] scause;
logic [             `XLEN-1:0] stval;
logic [             `XLEN-1:0] mstatus;
logic [                  30:0] mstatus_low;
logic [             `XLEN-1:0] misa;
logic [             `XLEN-1:0] medeleg;
logic [             `XLEN-1:0] mideleg;
logic [             `XLEN-1:0] mie;
logic [             `XLEN-1:0] mtvec;
logic [             `XLEN-1:0] mscratch;
logic [             `XLEN-1:0] mepc;
logic [             `XLEN-1:0] mcause;
logic [             `XLEN-1:0] mtval;
logic [             `XLEN-1:0] mip;

logic                          mstatus_sie;
logic                          mstatus_mie;
logic                          mstatus_spie;
logic                          mstatus_mpie;
logic                          mstatus_spp;
logic [                   1:0] mstatus_mpp;
logic [                   1:0] mstatus_fs;
logic [                   1:0] mstatus_xs;
logic                          mstatus_mprv;
logic                          mstatus_sum;
logic                          mstatus_mxr;
logic                          mstatus_tvm;
logic                          mstatus_tw;
logic                          mstatus_tsr;
logic [                   1:0] mstatus_uxl;
logic [                   1:0] mstatus_sxl;
logic                          mstatus_sd;

logic                          medeleg_imisalign;
logic                          medeleg_bp;
logic                          medeleg_uecall;
logic                          medeleg_instpgfault;
logic                          medeleg_ldpgfault;
logic                          medeleg_stpgfault;

logic                          mideleg_ssip;
logic                          mideleg_stip;
logic                          mideleg_seip;

logic                          mie_ssie;
logic                          mie_msie;
logic                          mie_stie;
logic                          mie_mtie;
logic                          mie_seie;
logic                          mie_meie;

logic                          mip_ssip;
logic                          mip_msip;
logic                          mip_stip;
logic                          mip_mtip;
logic                          mip_seip;
logic                          mip_seip_sw;
logic                          mip_meip;

logic [                  25:0] misa_ext;
logic [                   1:0] nxt_misa_mxl;


logic [`MCAUSE_CODE_WIDTH-1:0] mcause_code;
logic                          mcause_int;

logic [`MCAUSE_CODE_WIDTH-1:0] scause_code;
logic                          scause_int;

logic [             `XLEN-1:0] ints_en;
logic [             `XLEN-1:0] ints_m_en;
logic [             `XLEN-1:0] ints_s_en;

assign ints_en     = mie & mip;
assign ints_m_en   = ints_en & ~mideleg;
assign ints_s_en   = ints_en &  mideleg;

assign wakeup      = |ints_en;
assign irq_trigger = ~trap_en && (ints_m_mode || ints_s_mode);
assign ret_epc     = sret ? sepc : mepc;
assign eret_en     = ~trap_en && (sret || mret);

assign trap_m_mode     = ~trap_s_mode;
assign trap_s_mode     = prv <= `PRV_S && |(medeleg & (`XLEN'b1 << trap_cause[`XLEN-2:0]));
assign ints_m_mode_pre = ((prv == `PRV_M && mstatus_mie) || prv < `PRV_M) && |ints_m_en;
assign ints_s_mode_pre = ((prv == `PRV_S && mstatus_sie) || prv < `PRV_S) && |ints_s_en && !ints_m_mode_pre;
assign ints_m_mode     = ints_m_mode_pre && ~int_mask;
assign ints_s_mode     = ints_s_mode_pre && ~int_mask;

assign trap_vec    = ((trap_en ?  (trap_m_mode     ? mtvec : stvec):
                                 ((ints_m_mode_pre ? mtvec : stvec) + vec_offset)) &
                     ~`IM_ADDR_LEN'h3);

assign vec_offset  = /*trap_en     ? `IM_ADDR_LEN'd0:*/
                     ints_s_mode_pre ?     ints_s_en[`MIP_MEIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_MEIP_BIT << 2) & {`IM_ADDR_LEN{stvec[0]}}:
                                           ints_s_en[`MIP_MSIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_MSIP_BIT << 2) & {`IM_ADDR_LEN{stvec[0]}}:
                                           ints_s_en[`MIP_MTIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_MTIP_BIT << 2) & {`IM_ADDR_LEN{stvec[0]}}:
                                           ints_s_en[`MIP_SEIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_SEIP_BIT << 2) & {`IM_ADDR_LEN{stvec[0]}}:
                                           ints_s_en[`MIP_SSIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_SSIP_BIT << 2) & {`IM_ADDR_LEN{stvec[0]}}:
                                           /*ints_s_en[`MIP_STIP_BIT] ? */ (`IM_ADDR_LEN'd`MIP_STIP_BIT << 2) & {`IM_ADDR_LEN{stvec[0]}}:
                     /*ints_m_mode_pre ?*/ ints_m_en[`MIP_MEIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_MEIP_BIT << 2) & {`IM_ADDR_LEN{mtvec[0]}}:
                                           ints_m_en[`MIP_MSIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_MSIP_BIT << 2) & {`IM_ADDR_LEN{mtvec[0]}}:
                                           ints_m_en[`MIP_MTIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_MTIP_BIT << 2) & {`IM_ADDR_LEN{mtvec[0]}}:
                                           ints_m_en[`MIP_SEIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_SEIP_BIT << 2) & {`IM_ADDR_LEN{mtvec[0]}}:
                                           ints_m_en[`MIP_SSIP_BIT]      ? (`IM_ADDR_LEN'd`MIP_SSIP_BIT << 2) & {`IM_ADDR_LEN{mtvec[0]}}:
                                           /*ints_m_en[`MIP_STIP_BIT] ? */ (`IM_ADDR_LEN'd`MIP_STIP_BIT << 2) & {`IM_ADDR_LEN{mtvec[0]}};
                                           /*`IM_ADDR_LEN'd0;*/


assign cause       = trap_en     ? trap_cause : 
                     ints_s_mode ? ints_s_en[`MIP_MEIP_BIT]      ? (`XLEN'd`MIP_MEIP_BIT | (`XLEN'd1 << 31)):
                                   ints_s_en[`MIP_MSIP_BIT]      ? (`XLEN'd`MIP_MSIP_BIT | (`XLEN'd1 << 31)):
                                   ints_s_en[`MIP_MTIP_BIT]      ? (`XLEN'd`MIP_MTIP_BIT | (`XLEN'd1 << 31)):
                                   ints_s_en[`MIP_SEIP_BIT]      ? (`XLEN'd`MIP_SEIP_BIT | (`XLEN'd1 << 31)):
                                   ints_s_en[`MIP_SSIP_BIT]      ? (`XLEN'd`MIP_SSIP_BIT | (`XLEN'd1 << 31)):
                                   /*ints_s_en[`MIP_STIP_BIT] ? */ (`XLEN'd`MIP_STIP_BIT | (`XLEN'd1 << 31)):
                     ints_m_mode ? ints_m_en[`MIP_MEIP_BIT]      ? (`XLEN'd`MIP_MEIP_BIT | (`XLEN'd1 << 31)):
                                   ints_m_en[`MIP_MSIP_BIT]      ? (`XLEN'd`MIP_MSIP_BIT | (`XLEN'd1 << 31)):
                                   ints_m_en[`MIP_MTIP_BIT]      ? (`XLEN'd`MIP_MTIP_BIT | (`XLEN'd1 << 31)):
                                   ints_m_en[`MIP_SEIP_BIT]      ? (`XLEN'd`MIP_SEIP_BIT | (`XLEN'd1 << 31)):
                                   ints_m_en[`MIP_SSIP_BIT]      ? (`XLEN'd`MIP_SSIP_BIT | (`XLEN'd1 << 31)):
                                   /*ints_m_en[`MIP_STIP_BIT] ? */ (`XLEN'd`MIP_STIP_BIT | (`XLEN'd1 << 31)):
                                   `XLEN'd0;

assign tval         = trap_en ? trap_val : `XLEN'd0;

always_ff @(posedge clk or negedge srstn) begin
    if (~srstn) prv <= `PRV_M;
    else if (trap_en) begin
        if (trap_s_mode) begin
            prv <= `PRV_S;
        end
        else begin
            prv <= `PRV_M;
        end
    end
    else if (ints_m_mode) begin
        prv <= `PRV_M;
    end
    else if (ints_s_mode) begin
        prv <= `PRV_S;
    end
    else if (sret) begin
        prv <= {1'b0, mstatus_spp};
    end
    else if (mret) begin
        prv <= mstatus_mpp;
    end
end

always_ff @(posedge clk or negedge srstn) begin
    if (~srstn) 
        stvec <= `XLEN'b0;
    else if (csr_wr && csr_waddr == `CSR_STVEC_ADDR)
        stvec <= `CSR_WDATA(stvec, `XLEN-1:0) & ~`XLEN'h2;
end

always_ff @(posedge clk or negedge srstn) begin
    if (~srstn)
        sscratch <= `XLEN'b0;
    else if (csr_wr && csr_waddr == `CSR_SSCRATCH_ADDR)
        sscratch <= `CSR_WDATA(sscratch, `XLEN-1:0);
end

always_ff @(posedge clk or negedge srstn) begin
    if (~srstn) begin
        sepc <= `XLEN'b0;
    end
    else if (trap_en && trap_s_mode) begin
        sepc <= trap_epc;
    end
    else if (ints_s_mode) begin
        sepc <= trap_epc;
    end
    else if (csr_wr && csr_waddr == `CSR_SEPC_ADDR) begin
        sepc <= `CSR_WDATA(sepc, `XLEN-1:0) & ~`XLEN'h1;
    end
end

`ifdef RV32
assign scause = {scause_int, {`XLEN-`MCAUSE_CODE_WIDTH-1{1'b0}}, scause_code};
`else
assign scause = misa_mxl == 2'h1 ? {32'b0, scause_int, {   32-`MCAUSE_CODE_WIDTH-1{1'b0}}, scause_code}:
                misa_mxl == 2'h2 ? {       scause_int, {`XLEN-`MCAUSE_CODE_WIDTH-1{1'b0}}, scause_code}:
                                   `XLEN'b0;
`endif

always_ff @(posedge clk or negedge srstn) begin
    if (~srstn) begin
        scause_int  <= 1'b0;
        scause_code <= `MCAUSE_CODE_WIDTH'b0;
    end
    else if (trap_en && trap_s_mode) begin
        scause_int  <= trap_cause[`XLEN-1];
        scause_code <= trap_cause[0+:`MCAUSE_CODE_WIDTH];
    end
    else if (ints_s_mode) begin
        scause_int  <= 1'b1;
        scause_code <= ints_s_en[`MIP_MEIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_MEIP_BIT:
                       ints_s_en[`MIP_MSIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_MSIP_BIT:
                       ints_s_en[`MIP_MTIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_MTIP_BIT:
                       ints_s_en[`MIP_SEIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_SEIP_BIT:
                       ints_s_en[`MIP_SSIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_SSIP_BIT:
                       ints_s_en[`MIP_STIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_STIP_BIT:
                                                  `MCAUSE_CODE_WIDTH'b1;
    end
    else if (csr_wr && csr_waddr == `CSR_SCAUSE_ADDR) begin
        scause_int  <= misa_mxl == 2'h1 ? `CSR_WDATA(scause_int, 31):
                                          `CSR_WDATA(scause_int, `XLEN-1);
        scause_code <= `CSR_WDATA(scause_code, 0+:`MCAUSE_CODE_WIDTH);
    end
end

always_ff @(posedge clk or negedge srstn) begin
    if (~srstn) begin
        stval <= `XLEN'b0;
    end
    else if (trap_en && trap_s_mode) begin
        stval <= trap_val;
    end
    else if (ints_s_mode) begin
        stval <= `XLEN'b0;
    end
    else if (csr_wr && csr_waddr == `CSR_STVAL_ADDR)begin
        stval <= `CSR_WDATA(stval, `XLEN-1: 0);
    end
end

assign mstatus_low = {mstatus_sd, 8'b0, mstatus_tsr, /*mstatus_tw*/1'b0, mstatus_tvm,
                      mstatus_mxr, mstatus_sum, mstatus_mprv, mstatus_xs,
                      mstatus_fs, mstatus_mpp, 2'b0, mstatus_spp,
                      mstatus_mpie, 1'b0, mstatus_spie, 1'b0,
                      mstatus_mie, 1'b0, mstatus_sie, 1'b0};

assign sstatus_low = {1'b0, 8'b0, 1'b0, 1'b0, 1'b0,
                      mstatus_mxr, mstatus_sum, 1'b0, mstatus_xs,
                      mstatus_fs, 2'b0, 2'b0, mstatus_spp,
                      1'b0, 1'b0, mstatus_spie, 1'b0,
                      1'b0, 1'b0, mstatus_sie, 1'b0};

`ifdef RV32
assign mstatus     = {mstatus_sd, mstatus_low};
assign sstatus     = {mstatus_sd, sstatus_low};
`else
assign mstatus     = misa_mxl == 2'h1 ? {{`XLEN-32{1'b0}}, mstatus_sd, mstatus_low}:
                     misa_mxl == 2'h2 ? {mstatus_sd, {`XLEN-37{1'b0}}, mstatus_sxl, mstatus_uxl, 1'b0, mstatus_low}:
                                        `XLEN'b0;
assign sstatus     = misa_mxl == 2'h1 ? {{`XLEN-32{1'b0}}, mstatus_sd, sstatus_low}:
                     misa_mxl == 2'h2 ? {mstatus_sd, {`XLEN-37{1'b0}},        2'b0, mstatus_uxl, 1'b0, sstatus_low}:
                                        `XLEN'b0;
`endif

assign tvm     = mstatus_tvm;
assign tsr     = mstatus_tsr;
assign sum     = mstatus_sum;
assign mprv    = mstatus_mprv;
assign mpp     = mstatus_mpp;
assign mstatus_sd   = (|mstatus_fs) | (|mstatus_xs);

always_ff @(posedge clk or negedge srstn) begin
    if (~srstn) begin
        mstatus_sie  <= 1'b0;
        mstatus_mie  <= 1'b0;
        mstatus_spie <= 1'b0;
        mstatus_mpie <= 1'b0;
        mstatus_spp  <= 1'b0;
        mstatus_mpp  <= 2'b0;
        mstatus_fs   <= 2'b0;
        mstatus_xs   <= 2'b0;
        mstatus_mprv <= 1'b0;
        mstatus_sum  <= 1'b0;
        mstatus_mxr  <= 1'b0;
        mstatus_tvm  <= 1'b0;
        mstatus_tw   <= 1'b0;
        mstatus_tsr  <= 1'b0;
        mstatus_uxl  <= 2'h2;
        mstatus_sxl  <= 2'h2;
    end
    else if (trap_en) begin
        if (trap_s_mode) begin
            mstatus_spp  <= prv[0];
            mstatus_spie <= mstatus_sie;
            mstatus_sie  <= 1'b0;
        end
        else begin
            mstatus_mpp  <= prv;
            mstatus_mpie <= mstatus_mie;
            mstatus_mie  <= 1'b0;
        end
    end
    else if (ints_m_mode) begin
        mstatus_mpp  <= prv;
        mstatus_mpie <= mstatus_mie;
        mstatus_mie  <= 1'b0;
    end
    else if (ints_s_mode) begin
        mstatus_spp  <= prv[0];
        mstatus_spie <= mstatus_sie;
        mstatus_sie  <= 1'b0;
    end
    else if (sret) begin
        mstatus_spp  <= 1'b0;
        mstatus_sie  <= mstatus_spie;
        mstatus_spie <= 1'b1;
    end
    else if (mret) begin
        mstatus_mpp  <= `PRV_U;
        mstatus_mie  <= mstatus_mpie;
        mstatus_mpie <= 1'b1;
    end
    else if (csr_wr && csr_waddr == `CSR_SSTATUS_ADDR) begin
        mstatus_sie  <= `CSR_WDATA(mstatus_sie , `MSTATUS_SIE_BIT );
        mstatus_spie <= `CSR_WDATA(mstatus_spie, `MSTATUS_SPIE_BIT);
        mstatus_spp  <= `CSR_WDATA(mstatus_spp , `MSTATUS_SPP_BIT );
        mstatus_fs   <= `CSR_WDATA(mstatus_fs  , `MSTATUS_FS_BIT  );
        // mstatus_xs   <= `CSR_WDATA(mstatus_xs  , `MSTATUS_XS_BIT );
        mstatus_sum  <= `CSR_WDATA(mstatus_sum , `MSTATUS_SUM_BIT );
        mstatus_mxr  <= `CSR_WDATA(mstatus_mxr , `MSTATUS_MXR_BIT );
    end
    else if (csr_wr && csr_waddr == `CSR_MSTATUS_ADDR) begin
        mstatus_sie  <= `CSR_WDATA(mstatus_sie , `MSTATUS_SIE_BIT );
        mstatus_mie  <= `CSR_WDATA(mstatus_mie , `MSTATUS_MIE_BIT );
        mstatus_spie <= `CSR_WDATA(mstatus_spie, `MSTATUS_SPIE_BIT);
        mstatus_mpie <= `CSR_WDATA(mstatus_mpie, `MSTATUS_MPIE_BIT);
        mstatus_spp  <= `CSR_WDATA(mstatus_spp , `MSTATUS_SPP_BIT );
        mstatus_mpp  <= `CSR_WDATA(mstatus_mpp , `MSTATUS_MPP_BIT );
        mstatus_fs   <= `CSR_WDATA(mstatus_fs  , `MSTATUS_FS_BIT  );
        mstatus_xs   <= `CSR_WDATA(mstatus_xs  , `MSTATUS_XS_BIT  );
        mstatus_mprv <= `CSR_WDATA(mstatus_mprv, `MSTATUS_MPRV_BIT);
        mstatus_sum  <= `CSR_WDATA(mstatus_sum , `MSTATUS_SUM_BIT );
        mstatus_mxr  <= `CSR_WDATA(mstatus_mxr , `MSTATUS_MXR_BIT );
        mstatus_tvm  <= `CSR_WDATA(mstatus_tvm , `MSTATUS_TVM_BIT );
        mstatus_tw   <= `CSR_WDATA(mstatus_tw  , `MSTATUS_TW_BIT  );
        mstatus_tsr  <= `CSR_WDATA(mstatus_tsr , `MSTATUS_TSR_BIT );
    end
end

assign misa = misa_mxl == 2'h1 ? {{`XLEN-32{1'b0}}, misa_mxl, 4'b0, misa_ext}:
              misa_mxl == 2'h2 ? {misa_mxl, {`XLEN-28{1'b0}}, misa_ext}:
                                 `XLEN'b0;
assign misa_ext = ({25'b0,       1'b1} << ("i" - "a"))|
                  ({25'b0,       1'b1} << ("e" - "a"))|
                  ({25'b0,       1'b1} << ("s" - "a"))|
                  ({25'b0,       1'b1} << ("u" - "a"))|
                  ({25'b0, misa_a_ext} << ("a" - "a"))|
                  ({25'b0, misa_c_ext} << ("c" - "a"))|
                  ({25'b0, misa_m_ext} << ("m" - "a"));

assign warm_rst_trigger = 
`ifdef RV32
                          1'b0;
`else
                          csr_wr && csr_waddr == `CSR_MISA_ADDR && 
                          ((misa_mxl == 2'h1 && `CSR_WDATA(misa_mxl, 31:30) != 2'h1)||
                           (misa_mxl == 2'h2 && `CSR_WDATA(misa_mxl, 63:62) != 2'h2));
`endif

assign nxt_misa_mxl = ({2{misa_mxl == 2'h1}} & `CSR_WDATA(misa_mxl, 31:30))|
                      ({2{misa_mxl == 2'h2}} & `CSR_WDATA(misa_mxl, 63:62));

always_ff @(posedge clk or negedge xrstn) begin
    if (~xrstn) begin
`ifdef RV32
        misa_mxl   <= 2'h1;
`else
        misa_mxl   <= 2'h2;
`endif
        misa_a_ext <= 1'b1;
        misa_c_ext <= 1'b1;
        misa_m_ext <= 1'b1;
    end
    else if (csr_wr && csr_waddr == `CSR_MISA_ADDR) begin
`ifndef RV32
        misa_mxl   <= nxt_misa_mxl == 2'h1 ? 2'h1:
                      nxt_misa_mxl == 2'h2 ? 2'h2:
                                             misa_mxl;
`endif
        misa_c_ext <= misaligned ? misa_c_ext : `CSR_WDATA(misa_c_ext, "c" - "a");
        misa_m_ext <= `CSR_WDATA(misa_m_ext, "m" - "a");
    end
end

assign medeleg = {{(`XLEN-16){1'b0}}, medeleg_stpgfault, 1'b0, medeleg_ldpgfault,
                  medeleg_instpgfault, 1'b0, 1'b0, 1'b0, medeleg_uecall, 1'b0, 1'b0,
                  1'b0, 1'b0, medeleg_bp, 1'b0, 1'b0, medeleg_imisalign};

always_ff @(posedge clk or negedge srstn) begin
    if (~srstn) begin
        medeleg_imisalign   <= 1'b0;
        medeleg_bp          <= 1'b0;
        medeleg_uecall      <= 1'b0;
        medeleg_instpgfault <= 1'b0;
        medeleg_ldpgfault   <= 1'b0;
        medeleg_stpgfault   <= 1'b0;
    end
    else if (csr_wr && csr_waddr == `CSR_MEDELEG_ADDR) begin
        medeleg_imisalign   <= `CSR_WDATA(medeleg_imisalign  , `CAUSE_MISALIGNED_FETCH      );
        medeleg_bp          <= `CSR_WDATA(medeleg_bp         , `CAUSE_BREAKPOINT            );
        medeleg_uecall      <= `CSR_WDATA(medeleg_uecall     , `CAUSE_USER_ECALL            );
        medeleg_instpgfault <= `CSR_WDATA(medeleg_instpgfault, `CAUSE_INSTRUCTION_PAGE_FAULT);
        medeleg_ldpgfault   <= `CSR_WDATA(medeleg_ldpgfault  , `CAUSE_LOAD_PAGE_FAULT       );
        medeleg_stpgfault   <= `CSR_WDATA(medeleg_stpgfault  , `CAUSE_STORE_PAGE_FAULT      );
    end
end

assign mideleg = {{(`XLEN-10){1'b0}}, mideleg_seip, 3'b0, mideleg_stip, 3'b0, mideleg_ssip, 1'b0};

always_ff @(posedge clk or negedge srstn) begin
    if (~srstn) begin
        mideleg_ssip <= 1'b0;
        mideleg_stip <= 1'b0;
        mideleg_seip <= 1'b0;
    end
    else if (csr_wr && csr_waddr == `CSR_MIDELEG_ADDR) begin
        mideleg_ssip <= `CSR_WDATA(mideleg_ssip, 1);
        mideleg_stip <= `CSR_WDATA(mideleg_stip, 5);
        mideleg_seip <= `CSR_WDATA(mideleg_seip, 9);
    end
end

assign mie = {{(`XLEN-12){1'b0}}, mie_meie, 1'b0, mie_seie, 1'b0, mie_mtie, 1'b0,
              mie_stie, 1'b0, mie_msie, 1'b0, mie_ssie, 1'b0};

assign sie = {{(`XLEN-10){1'b0}}, mie_seie, 3'b0, mie_stie, 3'b0, mie_ssie, 1'b0};

always_ff @(posedge clk or negedge srstn) begin
    if (~srstn) begin
        mie_ssie <= 1'b0;
        mie_msie <= 1'b0;
        mie_stie <= 1'b0;
        mie_mtie <= 1'b0;
        mie_seie <= 1'b0;
        mie_meie <= 1'b0;
    end
    else if (csr_wr && csr_waddr == `CSR_SIE_ADDR) begin
        mie_ssie <= `CSR_WDATA(mie_ssie, 1);
        mie_stie <= `CSR_WDATA(mie_stie, 5);
        mie_seie <= `CSR_WDATA(mie_seie, 9);
    end
    else if (csr_wr && csr_waddr == `CSR_MIE_ADDR) begin
        mie_ssie <= `CSR_WDATA(mie_ssie,  1);
        mie_msie <= `CSR_WDATA(mie_msie,  3);
        mie_stie <= `CSR_WDATA(mie_stie,  5);
        mie_mtie <= `CSR_WDATA(mie_mtie,  7);
        mie_seie <= `CSR_WDATA(mie_seie,  9);
        mie_meie <= `CSR_WDATA(mie_meie, 11);
    end
end

always_ff @(posedge clk or negedge srstn) begin
    if (~srstn)
        mtvec <= `XLEN'b0;
    else if (csr_wr && csr_waddr == `CSR_MTVEC_ADDR)
        mtvec <= `CSR_WDATA(mtvec, `XLEN-1:0) & ~`XLEN'h2;
end

always_ff @(posedge clk or negedge srstn) begin
    if (~srstn)
        mscratch <= `XLEN'b0;
    else if (csr_wr && csr_waddr == `CSR_MSCRATCH_ADDR)
        mscratch <= `CSR_WDATA(mscratch, `XLEN-1:0);
end

always_ff @(posedge clk or negedge srstn) begin
    if (~srstn) begin
        mepc <= `XLEN'b0;
    end
    else if (trap_en && ~trap_s_mode) begin
        mepc <= trap_epc;
    end
    else if (ints_m_mode) begin
        mepc <= trap_epc;
    end
    else if (csr_wr && csr_waddr == `CSR_MEPC_ADDR) begin
        mepc <= `CSR_WDATA(mepc, `XLEN-1:0) & ~`XLEN'h1;
    end
end

`ifdef RV32
assign mcause = {mcause_int, {`XLEN-`MCAUSE_CODE_WIDTH-1{1'b0}}, mcause_code};
`else
assign mcause = misa_mxl == 2'h1 ? {32'b0, mcause_int, {   32-`MCAUSE_CODE_WIDTH-1{1'b0}}, mcause_code}:
                misa_mxl == 2'h2 ? {       mcause_int, {`XLEN-`MCAUSE_CODE_WIDTH-1{1'b0}}, mcause_code}:
                                   `XLEN'b0;
`endif

always_ff @(posedge clk or negedge srstn) begin
    if (~srstn) begin
        mcause_int  <= 1'b0;
        mcause_code <= `MCAUSE_CODE_WIDTH'b0;
    end
    else if (trap_en && ~trap_s_mode) begin
        mcause_int  <= trap_cause[`XLEN-1];
        mcause_code <= trap_cause[0+:`MCAUSE_CODE_WIDTH];
    end
    else if (ints_m_mode) begin
        mcause_int  <= 1'b1;
        mcause_code <= ints_m_en[`MIP_MEIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_MEIP_BIT:
                       ints_m_en[`MIP_MSIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_MSIP_BIT:
                       ints_m_en[`MIP_MTIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_MTIP_BIT:
                       ints_m_en[`MIP_SEIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_SEIP_BIT:
                       ints_m_en[`MIP_SSIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_SSIP_BIT:
                       ints_m_en[`MIP_STIP_BIT] ? `MCAUSE_CODE_WIDTH'd`MIP_STIP_BIT:
                                                  `MCAUSE_CODE_WIDTH'd1;
    end
    else if (csr_wr && csr_waddr == `CSR_MCAUSE_ADDR) begin
        mcause_int  <= misa_mxl == 2'h1 ? `CSR_WDATA(mcause_int, 31):
                                          `CSR_WDATA(mcause_int, `XLEN-1);
        mcause_code <= `CSR_WDATA(mcause_code, 0+:`MCAUSE_CODE_WIDTH);
    end
end

always_ff @(posedge clk or negedge srstn) begin
    if (~srstn) begin
        mtval <= `XLEN'b0;
    end
    else if (trap_en && ~trap_s_mode) begin
        mtval <= trap_val;
    end
    else if (ints_m_mode) begin
        mtval <= `XLEN'b0;
    end
    else if (csr_wr && csr_waddr == `CSR_MTVAL_ADDR) begin
        mtval <= `CSR_WDATA(mtval, `XLEN-1:0);
    end
end

assign mip = {{(`XLEN-12){1'b0}}, mip_meip, 1'b0, mip_seip, 1'b0, mip_mtip, 1'b0,
              mip_stip, 1'b0, mip_msip, 1'b0, mip_ssip, 1'b0};

assign sip = {{(`XLEN-10){1'b0}}, mip_seip, 3'b0, mip_stip, 3'b0, mip_ssip, 1'b0};

assign mip_seip = seip_d1 | mip_seip_sw;

always_ff @(posedge clk_free or negedge srstn) begin
    if (~srstn) begin
        msip_d1  <= 1'b0;
        mtip_d1  <= 1'b0;
        meip_d1  <= 1'b0;
        seip_d1  <= 1'b0;
        seip_d2  <= 1'b0;
        mip_msip <= 1'b0;
        mip_mtip <= 1'b0;
        mip_meip <= 1'b0;
    end
    else begin
        msip_d1  <= ext_msip;
        mtip_d1  <= ext_mtip;
        meip_d1  <= ext_meip;
        seip_d1  <= ext_seip;
        seip_d2  <= seip_d1;
        mip_msip <= msip_d1;
        mip_mtip <= mtip_d1;
        mip_meip <= meip_d1;
    end
end

always_ff @(posedge clk or negedge srstn) begin
    if (~srstn) begin
        mip_ssip    <= 1'b0;
        mip_stip    <= 1'b0;
        mip_seip_sw <= 1'b0;
    end
    else if (~sleep) begin
        if (csr_wr && csr_waddr == `CSR_SIP_ADDR)  begin
            mip_ssip    <= (mip_ssip    | csr_sdata[1]) & ~csr_cdata[1];
            mip_seip_sw <= (mip_seip_sw | csr_sdata[9]) & ~csr_cdata[9];
        end
        else if (csr_wr && csr_waddr == `CSR_MIP_ADDR) begin
            mip_ssip    <= (mip_ssip    | csr_sdata[1]) & ~csr_cdata[1];
            mip_stip    <= (mip_stip    | csr_sdata[5]) & ~csr_cdata[5];
            mip_seip_sw <= (mip_seip_sw | csr_sdata[9]) & ~csr_cdata[9];
        end
    end
end

always_comb begin
    csr_rdata = `XLEN'b0;
    case (csr_raddr) 
        `CSR_SSTATUS_ADDR   : csr_rdata = sstatus;
        `CSR_SEDELEG_ADDR   : csr_rdata = `XLEN'b0;
        `CSR_SIDELEG_ADDR   : csr_rdata = `XLEN'b0;
        `CSR_SIE_ADDR       : csr_rdata = sie & mideleg;
        `CSR_STVEC_ADDR     : csr_rdata = stvec;
        `CSR_SSCRATCH_ADDR  : csr_rdata = sscratch;
        `CSR_SEPC_ADDR      : csr_rdata = sepc;
        `CSR_SCAUSE_ADDR    : csr_rdata = scause;
        `CSR_STVAL_ADDR     : csr_rdata = stval;
        `CSR_SIP_ADDR       : csr_rdata = sip & mideleg;
        `CSR_MSTATUS_ADDR   : csr_rdata = mstatus;
        `CSR_MISA_ADDR      : csr_rdata = misa;
        `CSR_MEDELEG_ADDR   : csr_rdata = medeleg;
        `CSR_MIDELEG_ADDR   : csr_rdata = mideleg;
        `CSR_MIE_ADDR       : csr_rdata = mie;
        `CSR_MTVEC_ADDR     : csr_rdata = mtvec;
        `CSR_MSCRATCH_ADDR  : csr_rdata = mscratch;
        `CSR_MEPC_ADDR      : csr_rdata = mepc;
        `CSR_MCAUSE_ADDR    : csr_rdata = mcause;
        `CSR_MTVAL_ADDR     : csr_rdata = mtval;
        `CSR_MIP_ADDR       : csr_rdata = mip;
    endcase
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/bpu.sv
/*--------------------------------------*/

module bpu (
    input        [`BPU_OP_LEN - 1:0] bpu_op,
    input                            jump,
    input                            branch,
    input                            cmp_flag,
    input        [      `XLEN - 1:0] src1,
    input        [      `XLEN - 1:0] src2,
    input        [      `XLEN - 1:0] pc,
    input        [      `XLEN - 1:0] imm,
    output logic                     valid,
    output logic [      `XLEN - 1:0] out
);

parameter [`BPU_OP_LEN - 1:0] BPU_EQ  = `BPU_OP_LEN'b00,
                              BPU_LT  = `BPU_OP_LEN'b01,
                              BPU_LTU = `BPU_OP_LEN'b10;

logic                      flag;
logic        [`XLEN - 1:0] pc_imm;
logic        [`XLEN - 1:0] src1_imm;
logic signed [`XLEN - 1:0] signed_src1;
logic signed [`XLEN - 1:0] signed_src2;
logic                      jump_en;
logic                      branch_en;


assign signed_src1 = src1;
assign signed_src2 = src2;
assign pc_imm      = pc + imm;
assign src1_imm    = src1 + imm;

assign jump_en   = jump;
assign branch_en = branch && (~cmp_flag ^ flag);

assign valid = jump_en || branch_en;
assign out   = ({`XLEN{jump_en  }} & src1_imm)|
               ({`XLEN{branch_en}} & pc_imm  );

always_comb begin
    flag = 1'b0;
    case (bpu_op)
        BPU_EQ : flag = src1 == src2;
        BPU_LT : flag = signed_src1 < signed_src2;
        BPU_LTU: flag = src1        < src2       ;
    endcase
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/alu.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

//`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif

`define MDU_OP_LEN 4
`define ALU_OP_LEN 4
`define BPU_OP_LEN 2
`define CSR_OP_LEN 2
`define AMO_OP_LEN 4

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define GPR_ZERO_ADDR 5'b00000
`define GPR_RA_ADDR   5'b00001
`define GPR_SP_ADDR   5'b00010
`define GPR_GP_ADDR   5'b00011
`define GPR_TP_ADDR   5'b00100
`define GPR_T0_ADDR   5'b00101
`define GPR_T1_ADDR   5'b00110
`define GPR_T2_ADDR   5'b00111
`define GPR_S0_ADDR   5'b01000
`define GPR_FP_ADDR   5'b01000
`define GPR_S1_ADDR   5'b01001
`define GPR_A0_ADDR   5'b01010
`define GPR_A1_ADDR   5'b01011
`define GPR_A2_ADDR   5'b01100
`define GPR_A3_ADDR   5'b01101
`define GPR_A4_ADDR   5'b01110
`define GPR_A5_ADDR   5'b01111
`define GPR_A6_ADDR   5'b10000
`define GPR_A7_ADDR   5'b10001
`define GPR_S2_ADDR   5'b10010
`define GPR_S3_ADDR   5'b10011
`define GPR_S4_ADDR   5'b10100
`define GPR_S5_ADDR   5'b10101
`define GPR_S6_ADDR   5'b10110
`define GPR_S7_ADDR   5'b10111
`define GPR_S8_ADDR   5'b11000
`define GPR_S9_ADDR   5'b11001
`define GPR_S10_ADDR  5'b11010
`define GPR_S11_ADDR  5'b11011
`define GPR_T3_ADDR   5'b11100
`define GPR_T4_ADDR   5'b11101
`define GPR_T5_ADDR   5'b11110
`define GPR_T6_ADDR   5'b11111

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       'h0
`define CAUSE_INSTRUCTION_ACCESS     'h1
`define CAUSE_ILLEGAL_INSTRUCTION    'h2
`define CAUSE_BREAKPOINT             'h3
`define CAUSE_MISALIGNED_LOAD        'h4
`define CAUSE_LOAD_ACCESS            'h5
`define CAUSE_MISALIGNED_STORE       'h6
`define CAUSE_STORE_ACCESS           'h7
`define CAUSE_USER_ECALL             'h8
`define CAUSE_SUPERVISOR_ECALL       'h9
`define CAUSE_HYPERVISOR_ECALL       'ha
`define CAUSE_MACHINE_ECALL          'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT 'hc
`define CAUSE_LOAD_PAGE_FAULT        'hd
`define CAUSE_STORE_PAGE_FAULT       'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`define MCAUSE_CODE_WIDTH 6

`define MISA_MXL_XLEN_32  2'b01
`define MISA_MXL_XLEN_64  2'b10
`define MISA_MXL_XLEN_128 2'b11

`define SATP32_PPN_WIDTH  22
`define SATP32_ASID_WIDTH  9
`define SATP32_MODE_WIDTH  1

`define SATP64_PPN_WIDTH  44
`define SATP64_ASID_WIDTH 16
`define SATP64_MODE_WIDTH  4

`define SATP32_PPN_BIT     0+:`SATP32_PPN_WIDTH
`define SATP32_ASID_BIT   22+:`SATP32_ASID_WIDTH
`define SATP32_MODE_BIT   31+:`SATP32_MODE_WIDTH

`define SATP64_PPN_BIT     0+:`SATP64_PPN_WIDTH
`define SATP64_ASID_BIT   44+:`SATP64_ASID_WIDTH
`define SATP64_MODE_BIT   60+:`SATP64_MODE_WIDTH

`ifdef RV32
`define SATP_PPN_WIDTH  `SATP32_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP32_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP32_MODE_WIDTH
`define PADDR_LEN       (`SATP32_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`else
`define SATP_PPN_WIDTH  `SATP64_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP64_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP64_MODE_WIDTH
`define PADDR_LEN       (`SATP64_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`define SATP_MODE_SV39  `SATP_MODE_WIDTH'h8
`define SATP_MODE_SV48  `SATP_MODE_WIDTH'h9
`define SATP_MODE_SV57  `SATP_MODE_WIDTH'ha
`define SATP_MODE_SV64  `SATP_MODE_WIDTH'hb
`endif

`define PTE_V_BIT     0
`define PTE_R_BIT     1
`define PTE_W_BIT     2
`define PTE_X_BIT     3
`define PTE_U_BIT     4
`define PTE_G_BIT     5
`define PTE_A_BIT     6
`define PTE_D_BIT     7
`define PTE_RSW_BIT   8:9
`define PTE_PPN_SHIFT 10

`endif

module alu (
    input        [`ALU_OP_LEN - 1:0] alu_op,
    input                            len_64,
    input        [      `XLEN - 1:0] src1,
    input        [      `XLEN - 1:0] src2,
    output logic [      `XLEN - 1:0] out,
    output logic                     zero_flag
);

parameter [`ALU_OP_LEN - 1:0] ALU_AND  = `ALU_OP_LEN'b0000,
                              ALU_OR   = `ALU_OP_LEN'b0001,
                              ALU_XOR  = `ALU_OP_LEN'b0010,
                              ALU_ADD  = `ALU_OP_LEN'b0011,
                              ALU_SUB  = `ALU_OP_LEN'b0100,
                              ALU_SLT  = `ALU_OP_LEN'b0101,
                              ALU_SLL  = `ALU_OP_LEN'b0110,
                              ALU_SRL  = `ALU_OP_LEN'b0111,
                              ALU_SLTU = `ALU_OP_LEN'b1000,
                              ALU_SRA  = `ALU_OP_LEN'b1001;

logic        [`XLEN - 1:0] out_pre;
logic        [`XLEN - 1:0] src1_zext;
logic        [`XLEN - 1:0] src1_post;
logic        [`XLEN - 1:0] src2_post;
logic signed [`XLEN - 1:0] signed_src1;
logic signed [`XLEN - 1:0] signed_src2;
logic        [        5:0] shamt;


assign signed_src1 = src1_post;
assign signed_src2 = src2_post;
assign zero_flag   = ~|out;

`ifdef RV32
assign out       = out_pre;
assign src1_zext = src1;
assign src1_post = src1;
assign src2_post = src2;
assign shamt     = {1'b0, src2[4:0]};
`else
assign out       = len_64 ? out_pre : {{32{out_pre[31]}}, out_pre[31:0]};
assign src1_zext = {{32{len_64}} & src1[`XLEN-1:32], src1[31:0]};
assign src1_post = len_64 ? src1    : {{32{src1   [31]}}, src1   [31:0]};
assign src2_post = len_64 ? src2    : {{32{src2   [31]}}, src2   [31:0]};
assign shamt     = {src2[5] & len_64, src2[4:0]};
`endif

always_comb begin
    out_pre = `XLEN'b0;
    case (alu_op)
        ALU_AND : out_pre = src1 & src2;
        ALU_OR  : out_pre = src1 | src2;
        ALU_XOR : out_pre = src1 ^ src2;
        ALU_ADD : out_pre = src1 + src2;
        ALU_SUB : out_pre = src1 - src2;
        ALU_SLT : out_pre = (signed_src1 < signed_src2) ? `XLEN'b1 : `XLEN'b0;
        ALU_SLTU: out_pre = (src1_post   < src2_post  ) ? `XLEN'b1 : `XLEN'b0;
        ALU_SLL : out_pre = src1        <<  shamt;
        ALU_SRL : out_pre = src1_zext   >>  shamt;
        ALU_SRA : out_pre = signed_src1 >>> shamt;
    endcase
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/mdu.sv
/*--------------------------------------*/

module mdu (
    input                          clk,
    input                          rstn,
    input                          trig,
    input                          len_64,
    input        [`MDU_OP_LEN-1:0] mdu_op,
    input                          flush,
    input        [      `XLEN-1:0] src1,
    input        [      `XLEN-1:0] src2,
    output logic [      `XLEN-1:0] out,
    output logic                   okay
);

parameter [`MDU_OP_LEN - 1:0] MDU_MUL    = `MDU_OP_LEN'b0000,
                              MDU_MULHU  = `MDU_OP_LEN'b0001,
                              MDU_MULHSU = `MDU_OP_LEN'b0011,
                              MDU_MULH   = `MDU_OP_LEN'b0111,
                              MDU_DIVU   = `MDU_OP_LEN'b1000,
                              MDU_REMU   = `MDU_OP_LEN'b1001,
                              MDU_DIV    = `MDU_OP_LEN'b1110,
                              MDU_REM    = `MDU_OP_LEN'b1111;

logic               sel;
logic               rdh;
logic               signed1;
logic               signed2;
logic               mul_trig;
logic               div_trig;
logic [2*`XLEN-1:0] mul_out;
logic [2*`XLEN-1:0] div_out;
logic               mul_okay;
logic               div_okay;
logic [  `XLEN-1:0] src1_post;
logic [  `XLEN-1:0] src2_post;

assign {sel, signed2, signed1, rdh} = mdu_op;

assign mul_trig = ~sel & trig;
assign div_trig =  sel & trig;
assign out      = ({`XLEN{~sel & ~rdh}} & mul_out[    0+:`XLEN]) |
`ifdef RV32
                  ({`XLEN{~sel &  rdh}} & mul_out[`XLEN+:`XLEN]) |
`else
                  ({`XLEN{~sel &  rdh & ~len_64}} & mul_out[   32+:`XLEN]) |
                  ({`XLEN{~sel &  rdh &  len_64}} & mul_out[`XLEN+:`XLEN]) |
`endif
                  ({`XLEN{ sel & ~rdh}} & div_out[    0+:`XLEN]) |
                  ({`XLEN{ sel &  rdh}} & div_out[`XLEN+:`XLEN]);
assign okay     = (~sel & mul_okay) | (sel & div_okay);

assign src1_post = len_64 ? src1 : {{32{src1[31] & signed1}}, src1[31:0]};
assign src2_post = len_64 ? src2 : {{32{src2[31] & signed2}}, src2[31:0]};

mul u_mul (
    .clk     ( clk       ),
    .rstn    ( rstn      ),
    .trig    ( mul_trig  ),
    .flush   ( flush     ),
    .signed1 ( signed1   ),
    .src1    ( src1_post ),
    .signed2 ( signed2   ),
    .src2    ( src2_post ),
    .out     ( mul_out   ),
    .okay    ( mul_okay  )
);

div u_div (
    .clk     ( clk       ),
    .rstn    ( rstn      ),
    .trig    ( div_trig  ),
    .flush   ( flush     ),
    .signed1 ( signed1   ),
    .src1    ( src1_post ),
    .signed2 ( signed2   ),
    .src2    ( src2_post ),
    .out     ( div_out   ),
    .okay    ( div_okay  )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/mul.sv
/*--------------------------------------*/

module mul (
    input                      clk,
    input                      rstn,
    input                      trig,
    input                      flush,
    input                      signed1,
    input        [  `XLEN-1:0] src1,
    input                      signed2,
    input        [  `XLEN-1:0] src2,
    output logic [2*`XLEN-1:0] out,
    output logic               okay
);

logic [2*`XLEN-1:0] src1_ext;
logic [2*`XLEN-1:0] src2_ext;

logic [        1:0] cur_state;
logic [        1:0] nxt_state;

parameter[1:0] STATE_IDLE = 2'h0,
               STATE_EXEC = 2'h1,
               STATE_DONE = 2'h2;

always_ff @(posedge clk or negedge rstn) begin: reg_src
    if (~rstn) begin
        src1_ext <= {2*`XLEN{1'b0}};
        src2_ext <= {2*`XLEN{1'b0}};
    end
    else if (trig) begin
        src1_ext <= {{`XLEN{signed1 & src1[`XLEN-1]}}, src1};
        src2_ext <= {{`XLEN{signed2 & src2[`XLEN-1]}}, src2};
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_out
    if (~rstn) begin
        out <= {2*`XLEN{1'b0}};
    end
    else begin
        out <= src1_ext * src2_ext;;
    end
end

// assign src1_ext = {{`XLEN{signed1 & src1[`XLEN-1]}}, src1};
// assign src2_ext = {{`XLEN{signed2 & src2[`XLEN-1]}}, src2};

// assign out  = src1_ext * src2_ext;

always_ff @(posedge clk or negedge rstn) begin: fsm
    if (~rstn) cur_state <= STATE_IDLE;
    else       cur_state <= nxt_state;
end

always_comb begin: next_state
    nxt_state = cur_state;
    case (cur_state)
        STATE_IDLE: nxt_state = trig ? STATE_EXEC : STATE_IDLE;
        STATE_EXEC: nxt_state = STATE_DONE;
        STATE_DONE: nxt_state = STATE_IDLE;
    endcase
end

assign okay = cur_state == STATE_DONE;

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/div.sv
/*--------------------------------------*/

module div (
    input                      clk,
    input                      rstn,
    input                      trig,
    input                      flush,
    input                      signed1,
    input        [  `XLEN-1:0] src1,
    input                      signed2,
    input        [  `XLEN-1:0] src2,
    output logic [2*`XLEN-1:0] out,
    output logic               okay
);

localparam STATE_IDLE = 2'b00;
localparam STATE_EXEC = 2'b01;
localparam STATE_OKAY = 2'b10;

logic [        1:0] cur_state;
logic [        1:0] nxt_state;

logic [  `XLEN-1:0] src1_pos;
logic [  `XLEN-1:0] src2_pos;
logic [  `XLEN-1:0] src2_pos_latch;

logic               neg1;
logic               neg2;

logic               neg1_latch;
logic               neg2_latch;

logic [        6:0] src1_clz;
logic [        6:0] src2_clz;

logic [        6:0] sft_bit;
logic [        5:0] sft_bit_div2;
logic [        5:0] cnt;
logic [        5:0] nxt_cnt;
logic               skip;

`define NBIT_DIV 2
logic [    `XLEN-1:0] dividend     [`NBIT_DIV];
logic [    `XLEN-1:0] nxt_dividend [`NBIT_DIV];
logic [`NBIT_DIV-1:0] res;
logic [    `XLEN-1:0] rem;
logic [    `XLEN-1:0] tmp;


assign neg1     = signed1 & src1[`XLEN-1];
assign neg2     = signed2 & src2[`XLEN-1];

assign src1_pos = neg1 ? -src1 : src1;
assign src2_pos = neg2 ? -src2 : src2;

`ifdef RV32
assign src1_clz[6] = 1'b0;
clz_32 u_src1_clz (
    .in  ( src1_pos      ),
    .out ( src1_clz[5:0] )
);

assign src2_clz[6] = 1'b0;
clz_32 u_src2_clz (
    .in  ( src2_pos      ),
    .out ( src2_clz[5:0] )
);
`else
clz_64 u_src1_clz (
    .in  ( src1_pos ),
    .out ( src1_clz )
);

clz_64 u_src2_clz (
    .in  ( src2_pos ),
    .out ( src2_clz )
);
`endif

assign sft_bit      = 7'd`XLEN - 7'b1 - src2_clz + src1_clz;
`ifdef RV32
assign sft_bit_div2 = {1'b0, sft_bit[5:1]};
assign nxt_cnt      = 6'd15 - sft_bit_div2;
`else
assign sft_bit_div2 = sft_bit[6:1];
assign nxt_cnt      = 6'd31 - sft_bit_div2;
`endif


always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) cur_state <= STATE_IDLE;
    else       cur_state <= nxt_state;
end

always_comb begin
    nxt_state = cur_state;
    case (cur_state)
        STATE_IDLE: nxt_state = flush ? STATE_IDLE :
                                trig  ? skip ? STATE_OKAY:
                                               STATE_EXEC:
                                        STATE_IDLE;
        STATE_EXEC: nxt_state = flush | ~|cnt ? STATE_OKAY : STATE_EXEC;
        STATE_OKAY: nxt_state = STATE_IDLE;
    endcase
end

always_comb begin
    okay = 1'b0;
    case (cur_state)
        STATE_IDLE: begin
            okay = 1'b0;
        end
        STATE_EXEC: begin
            okay = 1'b0;
        end
        STATE_OKAY: begin
            okay = 1'b1;
        end
    endcase
end

assign skip = (src2 == `XLEN'b1) || (src2 == -`XLEN'b1 && signed2) || (src2 == `XLEN'b0) || (src1_pos < src2_pos);

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        out            <= {2*`XLEN{1'b0}};
        src2_pos_latch <= `XLEN'b0;
        neg1_latch     <= 1'b0;
        neg2_latch     <= 1'b0;
    end
    else begin
        if (skip) begin
            out[    0+:`XLEN] <= ({`XLEN{src2 ==  `XLEN'b1           }} &  src1) |
                                 ({`XLEN{src2 == -`XLEN'b1 && signed2}} & -src1) |
                                 ({`XLEN{src2 ==  `XLEN'b0           }} & -`XLEN'b1) |
                                 ({`XLEN{src1_pos < src2_pos         }} &  `XLEN'b0);
            out[`XLEN+:`XLEN] <= ({`XLEN{src2 ==  `XLEN'b1           }} &  `XLEN'b0) |
                                 ({`XLEN{src2 == -`XLEN'b1 && signed2}} & -`XLEN'b0) |
                                 ({`XLEN{src2 ==  `XLEN'b0           }} &  src1) |
                                 ({`XLEN{src1_pos < src2_pos         }} &  src1);
        end
        else if (cur_state == STATE_IDLE) begin
            out            <= src1_pos << {sft_bit_div2, 1'b0};
            src2_pos_latch <= src2_pos;
            neg1_latch     <= neg1;
            neg2_latch     <= neg2;
        end
        else begin
            if (~|cnt) begin
                out[    0+:`XLEN] <= neg1_latch ^ neg2_latch ? -{out[`XLEN-1-`NBIT_DIV:0],  res} : {out[`XLEN-1-`NBIT_DIV:0], res};
                out[`XLEN+:`XLEN] <= neg1_latch              ? -rem : rem;
            end
            else out <= {rem, out[`XLEN-1-`NBIT_DIV:0], res};
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        cnt <= 6'b0;
    end
    else begin
        if (cur_state == STATE_IDLE) begin
            cnt <= nxt_cnt;
        end
        else begin
            cnt <= |cnt ? cnt - 6'b1 : cnt;
        end
    end
end

assign tmp = out[`XLEN-`NBIT_DIV+:`XLEN];

genvar g;
generate
    for (g = `NBIT_DIV-1; g >= 0; g = g - 1) begin: g_div_unit
        if (g == `NBIT_DIV-1) begin: g_div_unit_1st
            assign dividend[g] = {{`NBIT_DIV-1{1'b0}}, tmp[`XLEN-1:`NBIT_DIV-1]};
        end
        else begin: g_div_unit_nth
            assign dividend[g] = {nxt_dividend[g+1][`XLEN-2:0], tmp[g]};
        end
        assign res[g]          = src2_pos_latch <= dividend[g];
        assign nxt_dividend[g] = res[g] ? dividend[g] - src2_pos_latch : dividend[g];
    end
endgenerate
assign rem = nxt_dividend[0];

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/tpu.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

//`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif

`define MDU_OP_LEN 4
`define ALU_OP_LEN 4
`define BPU_OP_LEN 2
`define CSR_OP_LEN 2
`define AMO_OP_LEN 4

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define GPR_ZERO_ADDR 5'b00000
`define GPR_RA_ADDR   5'b00001
`define GPR_SP_ADDR   5'b00010
`define GPR_GP_ADDR   5'b00011
`define GPR_TP_ADDR   5'b00100
`define GPR_T0_ADDR   5'b00101
`define GPR_T1_ADDR   5'b00110
`define GPR_T2_ADDR   5'b00111
`define GPR_S0_ADDR   5'b01000
`define GPR_FP_ADDR   5'b01000
`define GPR_S1_ADDR   5'b01001
`define GPR_A0_ADDR   5'b01010
`define GPR_A1_ADDR   5'b01011
`define GPR_A2_ADDR   5'b01100
`define GPR_A3_ADDR   5'b01101
`define GPR_A4_ADDR   5'b01110
`define GPR_A5_ADDR   5'b01111
`define GPR_A6_ADDR   5'b10000
`define GPR_A7_ADDR   5'b10001
`define GPR_S2_ADDR   5'b10010
`define GPR_S3_ADDR   5'b10011
`define GPR_S4_ADDR   5'b10100
`define GPR_S5_ADDR   5'b10101
`define GPR_S6_ADDR   5'b10110
`define GPR_S7_ADDR   5'b10111
`define GPR_S8_ADDR   5'b11000
`define GPR_S9_ADDR   5'b11001
`define GPR_S10_ADDR  5'b11010
`define GPR_S11_ADDR  5'b11011
`define GPR_T3_ADDR   5'b11100
`define GPR_T4_ADDR   5'b11101
`define GPR_T5_ADDR   5'b11110
`define GPR_T6_ADDR   5'b11111

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       'h0
`define CAUSE_INSTRUCTION_ACCESS     'h1
`define CAUSE_ILLEGAL_INSTRUCTION    'h2
`define CAUSE_BREAKPOINT             'h3
`define CAUSE_MISALIGNED_LOAD        'h4
`define CAUSE_LOAD_ACCESS            'h5
`define CAUSE_MISALIGNED_STORE       'h6
`define CAUSE_STORE_ACCESS           'h7
`define CAUSE_USER_ECALL             'h8
`define CAUSE_SUPERVISOR_ECALL       'h9
`define CAUSE_HYPERVISOR_ECALL       'ha
`define CAUSE_MACHINE_ECALL          'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT 'hc
`define CAUSE_LOAD_PAGE_FAULT        'hd
`define CAUSE_STORE_PAGE_FAULT       'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`define MCAUSE_CODE_WIDTH 6

`define MISA_MXL_XLEN_32  2'b01
`define MISA_MXL_XLEN_64  2'b10
`define MISA_MXL_XLEN_128 2'b11

`define SATP32_PPN_WIDTH  22
`define SATP32_ASID_WIDTH  9
`define SATP32_MODE_WIDTH  1

`define SATP64_PPN_WIDTH  44
`define SATP64_ASID_WIDTH 16
`define SATP64_MODE_WIDTH  4

`define SATP32_PPN_BIT     0+:`SATP32_PPN_WIDTH
`define SATP32_ASID_BIT   22+:`SATP32_ASID_WIDTH
`define SATP32_MODE_BIT   31+:`SATP32_MODE_WIDTH

`define SATP64_PPN_BIT     0+:`SATP64_PPN_WIDTH
`define SATP64_ASID_BIT   44+:`SATP64_ASID_WIDTH
`define SATP64_MODE_BIT   60+:`SATP64_MODE_WIDTH

`ifdef RV32
`define SATP_PPN_WIDTH  `SATP32_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP32_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP32_MODE_WIDTH
`define PADDR_LEN       (`SATP32_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`else
`define SATP_PPN_WIDTH  `SATP64_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP64_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP64_MODE_WIDTH
`define PADDR_LEN       (`SATP64_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`define SATP_MODE_SV39  `SATP_MODE_WIDTH'h8
`define SATP_MODE_SV48  `SATP_MODE_WIDTH'h9
`define SATP_MODE_SV57  `SATP_MODE_WIDTH'ha
`define SATP_MODE_SV64  `SATP_MODE_WIDTH'hb
`endif

`define PTE_V_BIT     0
`define PTE_R_BIT     1
`define PTE_W_BIT     2
`define PTE_X_BIT     3
`define PTE_U_BIT     4
`define PTE_G_BIT     5
`define PTE_A_BIT     6
`define PTE_D_BIT     7
`define PTE_RSW_BIT   8:9
`define PTE_PPN_SHIFT 10

`endif

module tpu (
    input                           insn_valid,
    input        [`IM_DATA_LEN-1:0] insn,
    input        [`IM_ADDR_LEN-1:0] exe_pc,
    input        [`IM_ADDR_LEN-1:0] wb_pc,
    input        [`DM_ADDR_LEN-1:0] ldst_badaddr,
    input        [`IM_ADDR_LEN-1:0] insn_badaddr,
    input        [             1:0] prv_cur,
    input        [             1:0] prv_req,
    input                           touch_satp,
    input                           tvm,
    input                           tsr,
    input                           sret,
    input                           ecall,
    input                           ebreak,
    input                           tlb_flush_req,
    input                           ill_insn,
    input                           csr_ill,
    input        [`IM_ADDR_LEN-1:0] insn_misaligned_epc,
    input                           insn_misaligned,
    input                           insn_pg_fault,
    input                           insn_xes_fault,
    input                           load_misaligned,
    input                           load_pg_fault,
    input                           load_xes_fault,
    input                           store_misaligned,
    input                           store_pg_fault,
    input                           store_xes_fault,
    output logic                    trap_en,
    output logic [       `XLEN-1:0] trap_cause,
    output logic [`IM_ADDR_LEN-1:0] trap_epc,
    output logic [       `XLEN-1:0] trap_val
);

logic trap_insn_misaligned;
logic trap_insn_access_fault;
logic trap_ill_insn;
logic trap_insn_addr_break_point;
logic trap_ldst_addr_break_point;
logic trap_env_break_point;
logic trap_load_misaligned;
logic trap_load_access_fault;
logic trap_store_misaligned;
logic trap_store_access_fault;
logic trap_u_ecall;
logic trap_s_ecall;
logic trap_h_ecall;
logic trap_m_ecall;
logic trap_insn_pg_fault;
logic trap_load_pg_fault;
logic trap_store_pg_fault;

logic if_trap_en;
logic exe_trap_en;
logic wb_trap_en;

assign trap_insn_misaligned       = insn_misaligned;
assign trap_insn_access_fault     = insn_xes_fault;
assign trap_ill_insn              = ill_insn || csr_ill || prv_cur < prv_req ||
                                    ((touch_satp || tlb_flush_req) && tvm && prv_cur < `PRV_M) ||
                                    (sret && tsr && prv_cur < `PRV_M);
assign trap_insn_addr_break_point = 1'b0;
assign trap_ldst_addr_break_point = 1'b0;
assign trap_env_break_point       = ebreak;
assign trap_load_misaligned       = load_misaligned;
assign trap_load_access_fault     = load_xes_fault;
assign trap_store_misaligned      = store_misaligned;
assign trap_store_access_fault    = store_xes_fault;
assign trap_u_ecall               = ecall && prv_cur == `PRV_U;
assign trap_s_ecall               = ecall && prv_cur == `PRV_S;
assign trap_h_ecall               = ecall && prv_cur == `PRV_H;
assign trap_m_ecall               = ecall && prv_cur == `PRV_M;
assign trap_insn_pg_fault         = insn_pg_fault;
assign trap_load_pg_fault         = load_pg_fault;
assign trap_store_pg_fault        = store_pg_fault;

assign trap_en = (insn_valid && (if_trap_en | exe_trap_en)) || wb_trap_en;

assign if_trap_en  = trap_insn_misaligned | trap_insn_access_fault |
                     trap_insn_pg_fault | trap_insn_addr_break_point;

assign exe_trap_en = trap_ill_insn |
                     trap_env_break_point |
                     trap_u_ecall | trap_s_ecall |
                     trap_h_ecall | trap_m_ecall;

assign wb_trap_en = trap_load_misaligned   | trap_store_misaligned |
                    trap_load_access_fault | trap_store_access_fault |
                    trap_load_pg_fault     | trap_store_pg_fault |
                    trap_ldst_addr_break_point;

assign trap_cause = wb_trap_en ?
                    (({`XLEN{trap_store_misaligned      }} & `XLEN'd6) |
                     ({`XLEN{trap_load_misaligned       }} & `XLEN'd4) |
                     ({`XLEN{trap_store_pg_fault        }} & `XLEN'd15) |
                     ({`XLEN{trap_load_pg_fault         }} & `XLEN'd13) |
                     ({`XLEN{trap_store_access_fault    }} & `XLEN'd7) |
                     ({`XLEN{trap_load_access_fault     }} & `XLEN'd5) |
                     ({`XLEN{trap_ldst_addr_break_point }} & `XLEN'd3)):
                    if_trap_en ?
                    (({`XLEN{trap_insn_addr_break_point }} & `XLEN'd3) |
                     ({`XLEN{trap_insn_pg_fault         }} & `XLEN'd12) |
                     ({`XLEN{trap_insn_access_fault     }} & `XLEN'd1) |
                     ({`XLEN{trap_insn_misaligned       }} & `XLEN'd0)):
                    exe_trap_en ?
                    (({`XLEN{trap_ill_insn              }} & `XLEN'd2) |
                     ({`XLEN{trap_u_ecall               }} & `XLEN'd8) |
                     ({`XLEN{trap_s_ecall               }} & `XLEN'd9) |
                     ({`XLEN{trap_m_ecall               }} & `XLEN'd11) |
                     ({`XLEN{trap_env_break_point       }} & `XLEN'd3)):
                                                             `XLEN'd0;

assign trap_val   = wb_trap_en           ? ldst_badaddr:
                    trap_insn_misaligned ? exe_pc:
                    if_trap_en           ? insn_badaddr:
                    trap_ill_insn        ? insn:
                                           `XLEN'd0;

assign trap_epc   = wb_trap_en           ? wb_pc :
                    trap_insn_misaligned ? insn_misaligned_epc:
                                           exe_pc;

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/dpu.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

//`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif

`define MDU_OP_LEN 4
`define ALU_OP_LEN 4
`define BPU_OP_LEN 2
`define CSR_OP_LEN 2
`define AMO_OP_LEN 4

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define GPR_ZERO_ADDR 5'b00000
`define GPR_RA_ADDR   5'b00001
`define GPR_SP_ADDR   5'b00010
`define GPR_GP_ADDR   5'b00011
`define GPR_TP_ADDR   5'b00100
`define GPR_T0_ADDR   5'b00101
`define GPR_T1_ADDR   5'b00110
`define GPR_T2_ADDR   5'b00111
`define GPR_S0_ADDR   5'b01000
`define GPR_FP_ADDR   5'b01000
`define GPR_S1_ADDR   5'b01001
`define GPR_A0_ADDR   5'b01010
`define GPR_A1_ADDR   5'b01011
`define GPR_A2_ADDR   5'b01100
`define GPR_A3_ADDR   5'b01101
`define GPR_A4_ADDR   5'b01110
`define GPR_A5_ADDR   5'b01111
`define GPR_A6_ADDR   5'b10000
`define GPR_A7_ADDR   5'b10001
`define GPR_S2_ADDR   5'b10010
`define GPR_S3_ADDR   5'b10011
`define GPR_S4_ADDR   5'b10100
`define GPR_S5_ADDR   5'b10101
`define GPR_S6_ADDR   5'b10110
`define GPR_S7_ADDR   5'b10111
`define GPR_S8_ADDR   5'b11000
`define GPR_S9_ADDR   5'b11001
`define GPR_S10_ADDR  5'b11010
`define GPR_S11_ADDR  5'b11011
`define GPR_T3_ADDR   5'b11100
`define GPR_T4_ADDR   5'b11101
`define GPR_T5_ADDR   5'b11110
`define GPR_T6_ADDR   5'b11111

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       'h0
`define CAUSE_INSTRUCTION_ACCESS     'h1
`define CAUSE_ILLEGAL_INSTRUCTION    'h2
`define CAUSE_BREAKPOINT             'h3
`define CAUSE_MISALIGNED_LOAD        'h4
`define CAUSE_LOAD_ACCESS            'h5
`define CAUSE_MISALIGNED_STORE       'h6
`define CAUSE_STORE_ACCESS           'h7
`define CAUSE_USER_ECALL             'h8
`define CAUSE_SUPERVISOR_ECALL       'h9
`define CAUSE_HYPERVISOR_ECALL       'ha
`define CAUSE_MACHINE_ECALL          'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT 'hc
`define CAUSE_LOAD_PAGE_FAULT        'hd
`define CAUSE_STORE_PAGE_FAULT       'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`define MCAUSE_CODE_WIDTH 6

`define MISA_MXL_XLEN_32  2'b01
`define MISA_MXL_XLEN_64  2'b10
`define MISA_MXL_XLEN_128 2'b11

`define SATP32_PPN_WIDTH  22
`define SATP32_ASID_WIDTH  9
`define SATP32_MODE_WIDTH  1

`define SATP64_PPN_WIDTH  44
`define SATP64_ASID_WIDTH 16
`define SATP64_MODE_WIDTH  4

`define SATP32_PPN_BIT     0+:`SATP32_PPN_WIDTH
`define SATP32_ASID_BIT   22+:`SATP32_ASID_WIDTH
`define SATP32_MODE_BIT   31+:`SATP32_MODE_WIDTH

`define SATP64_PPN_BIT     0+:`SATP64_PPN_WIDTH
`define SATP64_ASID_BIT   44+:`SATP64_ASID_WIDTH
`define SATP64_MODE_BIT   60+:`SATP64_MODE_WIDTH

`ifdef RV32
`define SATP_PPN_WIDTH  `SATP32_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP32_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP32_MODE_WIDTH
`define PADDR_LEN       (`SATP32_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`else
`define SATP_PPN_WIDTH  `SATP64_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP64_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP64_MODE_WIDTH
`define PADDR_LEN       (`SATP64_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`define SATP_MODE_SV39  `SATP_MODE_WIDTH'h8
`define SATP_MODE_SV48  `SATP_MODE_WIDTH'h9
`define SATP_MODE_SV57  `SATP_MODE_WIDTH'ha
`define SATP_MODE_SV64  `SATP_MODE_WIDTH'hb
`endif

`define PTE_V_BIT     0
`define PTE_R_BIT     1
`define PTE_W_BIT     2
`define PTE_X_BIT     3
`define PTE_U_BIT     4
`define PTE_G_BIT     5
`define PTE_A_BIT     6
`define PTE_D_BIT     7
`define PTE_RSW_BIT   8:9
`define PTE_PPN_SHIFT 10

`endif

module dpu (
    input                                    clk,
    input                                    rstn,

    input                                    len_64,
    input                                    amo_64,
    
    input                                    amo_i,
    input        [        `AMO_OP_LEN - 1:0] amo_op_i,
    input        [       `IM_ADDR_LEN - 1:0] pc_i,
    input                                    sign_ext_i,
    input                                    req_i,
    input                                    wr_i,
    input                                    ex_i,
    input        [     `DM_DATA_LEN/8 - 1:0] byte_i,
    input        [       `DM_ADDR_LEN - 1:0] addr_i,
    input        [       `DM_DATA_LEN - 1:0] wdata_i,

    output logic                             amo_wr_o,
    output logic [       `DM_DATA_LEN - 1:0] rdata_o,
    output logic                             hazard_o,

    output logic                             fault,
    output logic                             load_misaligned,
    output logic                             store_misaligned,
    output logic                             load_pg_fault,
    output logic                             store_pg_fault,
    output logic                             load_xes_fault,
    output logic                             store_xes_fault,

    output logic                             dmem_req,
    output logic [       `DM_ADDR_LEN - 1:0] dmem_addr,
    output logic                             dmem_wr,
    output logic                             dmem_ex,
    output logic [     `DM_DATA_LEN/8 - 1:0] dmem_byte,
    output logic [       `DM_DATA_LEN - 1:0] dmem_wdata,
    input        [       `DM_DATA_LEN - 1:0] dmem_rdata,
    input        [                      1:0] dmem_bad,
    input                                    dmem_xstate,
    input                                    dmem_busy
);

logic                              misaligned;
logic                              dmem_req_done;
logic                              dmem_req_latch;
logic                              data_latch_valid;
logic  [       `DM_DATA_LEN - 1:0] data_latch;
logic  [       `DM_DATA_LEN - 1:0] dmem_rdata_shft;
logic  [       `DM_DATA_LEN - 1:0] dmem_rdata_ext;
logic  [       `DM_ADDR_LEN - 1:0] addr_latch;
logic                              sign_ext_latch;
logic  [     `DM_DATA_LEN/8 - 1:0] byte_latch;
logic                              load_latch;
logic                              store_latch;
logic                              amo_64_latch;
logic                              sc_latch;


logic                              amo_wr;
logic  [          `AMO_OP_LEN-1:0] amo_op;
logic  [                `XLEN-1:0] amo_src;
                                  
logic  [                `XLEN-1:0] amo_mem_rdata;
logic  [                `XLEN-1:0] amo_mem_wdata;


assign dmem_req_done = dmem_req_latch & ~amo_wr & ~dmem_busy;

assign dmem_req      = (req_i & ~misaligned & ~(dmem_req_latch & |dmem_bad) & ~dmem_busy) |
                       (amo_wr & ~dmem_busy & ~|dmem_bad);
assign dmem_addr     = amo_wr ? addr_latch : addr_i;
assign dmem_wr       = wr_i | amo_wr;
assign dmem_ex       = ex_i | amo_wr;

assign amo_wr_o      = amo_wr;
assign rdata_o       = sc_latch & store_latch ? {{`XLEN-1{1'b0}}, ~dmem_xstate}:
                       data_latch_valid       ? data_latch : dmem_rdata_ext;
assign hazard_o      = (dmem_req_latch & ~dmem_req_done) |
                       (req_i & ~misaligned & dmem_busy);

assign misaligned      = (addr_i[0] && byte_i[1]) ||
                         (addr_i[1] && byte_i[3])
`ifndef RV32
                         || (addr_i[2] && byte_i[7])
`endif
                         ;
assign load_pg_fault   = ~dmem_busy & dmem_bad[0] & load_latch;
assign store_pg_fault  = ~dmem_busy & dmem_bad[0] & store_latch;
assign load_xes_fault  = ~dmem_busy & dmem_bad[1] & load_latch;
assign store_xes_fault = ~dmem_busy & dmem_bad[1] & store_latch;
assign fault           = (~dmem_busy & |dmem_bad) || load_misaligned || store_misaligned;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        load_misaligned  <= 1'b0;
        store_misaligned <= 1'b0;
    end
    else begin
        load_misaligned  <= req_i & misaligned & ~wr_i;
        store_misaligned <= req_i & misaligned &  wr_i;
    end
end

`ifdef RV32
assign dmem_byte  = amo_wr ? byte_latch    : (byte_i  <<  addr_i[0+:$clog2(`XLEN/8)]);
assign dmem_wdata = amo_wr ? amo_mem_wdata : (wdata_i << {addr_i[0+:$clog2(`XLEN/8)], 3'b0});
`else
assign dmem_byte  = amo_wr ? (( byte_latch             & {`DM_DATA_LEN/8{~addr_latch[2]}})|
                              ({byte_latch[3:0], 4'b0} & {`DM_DATA_LEN/8{ addr_latch[2]}})):
                             (byte_i  <<  addr_i[0+:$clog2(`XLEN/8)]);
assign dmem_wdata = amo_wr ? (( amo_mem_wdata               & {`DM_DATA_LEN{~addr_latch[2]}})|
                              ({amo_mem_wdata[31:0], 32'b0} & {`DM_DATA_LEN{ addr_latch[2]}})):
                             (wdata_i << {addr_i[0+:$clog2(`XLEN/8)], 3'b0});
`endif

assign dmem_rdata_shft = dmem_rdata >> {addr_latch[0+:$clog2(`XLEN/8)], 3'b0};

always_comb begin
`ifdef RV32
    if (byte_latch[3])      dmem_rdata_ext = {{`XLEN-32{sign_ext_latch & dmem_rdata_shft[31]}}, dmem_rdata_shft[31:0]};
`else
    if (byte_latch[7])      dmem_rdata_ext = dmem_rdata_shft[63:0];
    else if (byte_latch[3]) dmem_rdata_ext = {{`XLEN-32{sign_ext_latch & dmem_rdata_shft[31]}}, dmem_rdata_shft[31:0]};
`endif
    else if (byte_latch[1]) dmem_rdata_ext = {{`XLEN-16{sign_ext_latch & dmem_rdata_shft[15]}}, dmem_rdata_shft[15:0]};
    else if (byte_latch[0]) dmem_rdata_ext = {{`XLEN- 8{sign_ext_latch & dmem_rdata_shft[ 7]}}, dmem_rdata_shft[ 7:0]};
    else                    dmem_rdata_ext = `XLEN'b0;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        data_latch_valid <= 1'b0;
    end
    else if (dmem_req_done & ~amo_wr) begin
        data_latch_valid <= 1'b0;
    end
    else if (~dmem_busy & dmem_req_latch) begin
        data_latch_valid <= 1'b1;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        data_latch <= `DM_DATA_LEN'b0;
    end
    else if (~dmem_busy & dmem_req_latch & load_latch) begin
        data_latch <= dmem_rdata_ext;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        sc_latch    <= 1'b0;
        load_latch  <= 1'b0;
        store_latch <= 1'b0;
    end
    else if (dmem_req & ~dmem_busy) begin
        sc_latch    <=  ex_i & ~amo_i;
        load_latch  <= ~dmem_wr;
        store_latch <=  dmem_wr;
    end
    else if (~dmem_busy) begin
        sc_latch    <= 1'b0;
        load_latch  <= 1'b0;
        store_latch <= 1'b0;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        dmem_req_latch <= 1'b0;
    end
    else if (dmem_req & ~dmem_busy) begin
        dmem_req_latch <= 1'b1;
    end
    else if (dmem_req_done) begin
        dmem_req_latch <= 1'b0;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        addr_latch     <= `DM_ADDR_LEN'b0;
        sign_ext_latch <= 1'b0;
        byte_latch     <= 4'b0;
        amo_64_latch   <= 1'b0;
    end
    else if (dmem_req & ~dmem_busy) begin
        addr_latch     <= addr_i;
        sign_ext_latch <= sign_ext_i;
        byte_latch     <= byte_i;
        amo_64_latch   <= amo_64;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        amo_wr  <= 1'b0;
        amo_op  <= `AMO_OP_LEN'b0;
        amo_src <= `XLEN'b0;
    end
    else if (dmem_req & ~dmem_busy) begin
        amo_wr  <= ~amo_wr & amo_i;
        amo_op  <= amo_op_i;
`ifdef RV32
        amo_src <= wdata_i;
`else
        amo_src <= amo_64 ? wdata_i : {{32{wdata_i[31]}}, wdata_i[31:0]};
`endif
    end
end

`ifdef RV32
assign amo_mem_rdata  = dmem_rdata;
`else
assign amo_mem_rdata  = amo_64_latch ? dmem_rdata :
                                      (({`XLEN{~addr_latch[2]}} & {{32{dmem_rdata[31]}}, dmem_rdata[31: 0]})|
                                       ({`XLEN{ addr_latch[2]}} & {{32{dmem_rdata[63]}}, dmem_rdata[63:32]}));
`endif

amo u_amo (
    .clk            ( clk            ),
    .rstn           ( rstn           ),
    .amo_op         ( amo_op         ),
    .amo_src        ( amo_src        ),
    
    // memory intf
    .amo_mem_rdata  ( amo_mem_rdata  ),
    .amo_mem_wdata  ( amo_mem_wdata  )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/amo.sv
/*--------------------------------------*/

module amo (
    input                          clk,
    input                          rstn,
    input        [`AMO_OP_LEN-1:0] amo_op,
    input        [      `XLEN-1:0] amo_src,
    
    // memory intf
    input        [      `XLEN-1:0] amo_mem_rdata,
    output logic [      `XLEN-1:0] amo_mem_wdata
);

parameter [`AMO_OP_LEN - 1:0] AMO_SWAP = `AMO_OP_LEN'b0001,
                              AMO_ADD  = `AMO_OP_LEN'b0000,
                              AMO_XOR  = `AMO_OP_LEN'b0010,
                              AMO_AND  = `AMO_OP_LEN'b0110,
                              AMO_OR   = `AMO_OP_LEN'b0100,
                              AMO_MIN  = `AMO_OP_LEN'b1000,
                              AMO_MAX  = `AMO_OP_LEN'b1010,
                              AMO_MINU = `AMO_OP_LEN'b1100,
                              AMO_MAXU = `AMO_OP_LEN'b1110;

always_comb begin
    amo_mem_wdata = `XLEN'b0;
    case (amo_op)
        AMO_SWAP: amo_mem_wdata = amo_src;
        AMO_ADD : amo_mem_wdata = amo_mem_rdata + amo_src;
        AMO_XOR : amo_mem_wdata = amo_mem_rdata ^ amo_src;
        AMO_AND : amo_mem_wdata = amo_mem_rdata & amo_src;
        AMO_OR  : amo_mem_wdata = amo_mem_rdata | amo_src;
        AMO_MIN : amo_mem_wdata = $signed(amo_mem_rdata) < $signed(amo_src) ? amo_mem_rdata : amo_src;
        AMO_MAX : amo_mem_wdata = $signed(amo_mem_rdata) > $signed(amo_src) ? amo_mem_rdata : amo_src;
        AMO_MINU: amo_mem_wdata = amo_mem_rdata < amo_src ? amo_mem_rdata : amo_src;
        AMO_MAXU: amo_mem_wdata = amo_mem_rdata > amo_src ? amo_mem_rdata : amo_src;
    endcase
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/pmu.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

//`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif

`define MDU_OP_LEN 4
`define ALU_OP_LEN 4
`define BPU_OP_LEN 2
`define CSR_OP_LEN 2
`define AMO_OP_LEN 4

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define GPR_ZERO_ADDR 5'b00000
`define GPR_RA_ADDR   5'b00001
`define GPR_SP_ADDR   5'b00010
`define GPR_GP_ADDR   5'b00011
`define GPR_TP_ADDR   5'b00100
`define GPR_T0_ADDR   5'b00101
`define GPR_T1_ADDR   5'b00110
`define GPR_T2_ADDR   5'b00111
`define GPR_S0_ADDR   5'b01000
`define GPR_FP_ADDR   5'b01000
`define GPR_S1_ADDR   5'b01001
`define GPR_A0_ADDR   5'b01010
`define GPR_A1_ADDR   5'b01011
`define GPR_A2_ADDR   5'b01100
`define GPR_A3_ADDR   5'b01101
`define GPR_A4_ADDR   5'b01110
`define GPR_A5_ADDR   5'b01111
`define GPR_A6_ADDR   5'b10000
`define GPR_A7_ADDR   5'b10001
`define GPR_S2_ADDR   5'b10010
`define GPR_S3_ADDR   5'b10011
`define GPR_S4_ADDR   5'b10100
`define GPR_S5_ADDR   5'b10101
`define GPR_S6_ADDR   5'b10110
`define GPR_S7_ADDR   5'b10111
`define GPR_S8_ADDR   5'b11000
`define GPR_S9_ADDR   5'b11001
`define GPR_S10_ADDR  5'b11010
`define GPR_S11_ADDR  5'b11011
`define GPR_T3_ADDR   5'b11100
`define GPR_T4_ADDR   5'b11101
`define GPR_T5_ADDR   5'b11110
`define GPR_T6_ADDR   5'b11111

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       'h0
`define CAUSE_INSTRUCTION_ACCESS     'h1
`define CAUSE_ILLEGAL_INSTRUCTION    'h2
`define CAUSE_BREAKPOINT             'h3
`define CAUSE_MISALIGNED_LOAD        'h4
`define CAUSE_LOAD_ACCESS            'h5
`define CAUSE_MISALIGNED_STORE       'h6
`define CAUSE_STORE_ACCESS           'h7
`define CAUSE_USER_ECALL             'h8
`define CAUSE_SUPERVISOR_ECALL       'h9
`define CAUSE_HYPERVISOR_ECALL       'ha
`define CAUSE_MACHINE_ECALL          'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT 'hc
`define CAUSE_LOAD_PAGE_FAULT        'hd
`define CAUSE_STORE_PAGE_FAULT       'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`define MCAUSE_CODE_WIDTH 6

`define MISA_MXL_XLEN_32  2'b01
`define MISA_MXL_XLEN_64  2'b10
`define MISA_MXL_XLEN_128 2'b11

`define SATP32_PPN_WIDTH  22
`define SATP32_ASID_WIDTH  9
`define SATP32_MODE_WIDTH  1

`define SATP64_PPN_WIDTH  44
`define SATP64_ASID_WIDTH 16
`define SATP64_MODE_WIDTH  4

`define SATP32_PPN_BIT     0+:`SATP32_PPN_WIDTH
`define SATP32_ASID_BIT   22+:`SATP32_ASID_WIDTH
`define SATP32_MODE_BIT   31+:`SATP32_MODE_WIDTH

`define SATP64_PPN_BIT     0+:`SATP64_PPN_WIDTH
`define SATP64_ASID_BIT   44+:`SATP64_ASID_WIDTH
`define SATP64_MODE_BIT   60+:`SATP64_MODE_WIDTH

`ifdef RV32
`define SATP_PPN_WIDTH  `SATP32_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP32_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP32_MODE_WIDTH
`define PADDR_LEN       (`SATP32_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`else
`define SATP_PPN_WIDTH  `SATP64_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP64_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP64_MODE_WIDTH
`define PADDR_LEN       (`SATP64_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`define SATP_MODE_SV39  `SATP_MODE_WIDTH'h8
`define SATP_MODE_SV48  `SATP_MODE_WIDTH'h9
`define SATP_MODE_SV57  `SATP_MODE_WIDTH'ha
`define SATP_MODE_SV64  `SATP_MODE_WIDTH'hb
`endif

`define PTE_V_BIT     0
`define PTE_R_BIT     1
`define PTE_W_BIT     2
`define PTE_X_BIT     3
`define PTE_U_BIT     4
`define PTE_G_BIT     5
`define PTE_A_BIT     6
`define PTE_D_BIT     7
`define PTE_RSW_BIT   8:9
`define PTE_PPN_SHIFT 10

`endif
`ifndef __CSR_DEFINE__
`define __CSR_DEFINE__

`define CSR_WDATA(DEST, RANGE) \
        ((``DEST`` | csr_sdata[RANGE]) & ~csr_cdata[RANGE])

`endif

// 0x106 SRW scounteren Supervisor counter enable.
// 0x306 MRW mcounteren Machine counter enable.

module pmu (
    input                    clk_free,
    input                    rstn,
    input        [`XLEN-1:0] cpu_id,
    input                    insn_valid,
    input        [      1:0] misa_mxl,
    input        [      1:0] prv,
    input        [     63:0] mtime,
    output logic [     63:0] mcycle,
    
    // CSR interface
    input                    csr_rd_chk, // EXE-stage
    input                    csr_wr_chk, // EXE-stage
    input                    csr_wr,
    input        [     11:0] csr_waddr,
    input        [     11:0] csr_raddr,
    // input        [`XLEN-1:0] csr_wdata,
    input        [`XLEN-1:0] csr_sdata,
    input        [`XLEN-1:0] csr_cdata,
    output logic [`XLEN-1:0] csr_rdata,
    output logic             csr_ill
);


logic [`XLEN-1:0] scounteren;
logic [`XLEN-1:0] mcounteren;
logic [`XLEN-1:0] mhartid;
// logic [     63:0] mcycle;
logic [     63:0] minstret;

assign csr_ill = (misa_mxl == `MISA_MXL_XLEN_64 && (csr_rd_chk || csr_wr_chk) &&
                 (csr_waddr == `CSR_MCYCLEH_ADDR || csr_waddr == `CSR_MINSTRETH_ADDR)) ||
                 (prv < `PRV_M && (csr_rd_chk || csr_wr_chk) && csr_waddr[11:5] == 7'b1100_000 &&
                 ~mcounteren[csr_waddr[4:0]]) ||
                 (prv < `PRV_S && (csr_rd_chk || csr_wr_chk) && csr_waddr[11:5] == 7'b1100_000 &&
                 ~scounteren[csr_waddr[4:0]]);

always_ff @(posedge clk_free or negedge rstn) begin
    if (~rstn)
        scounteren <= `XLEN'b0;
    else if (csr_wr && csr_waddr == `CSR_SCOUNTEREN_ADDR)
        scounteren[0+:32] <= `CSR_WDATA(scounteren[0+:32], 0+:32);
end

always_ff @(posedge clk_free or negedge rstn) begin
    if (~rstn)
        mcounteren <= `XLEN'b0;
    else if (csr_wr && csr_waddr == `CSR_MCOUNTEREN_ADDR)
        mcounteren[0+:32] <= `CSR_WDATA(mcounteren[0+:32], 0+:32);
end

always_ff @(posedge clk_free or negedge rstn) begin
    if (~rstn)
        mcycle            <= 64'b0;
    else if (csr_wr && csr_waddr == `CSR_MCYCLE_ADDR)
        mcycle[ 0+:`XLEN] <= `CSR_WDATA(mcycle[0+:`XLEN], 0+:`XLEN);
    else if (csr_wr && csr_waddr == `CSR_MCYCLEH_ADDR)
        mcycle[32+:   32] <= `CSR_WDATA(mcycle[32+:32], 0+:32);
    else
        mcycle            <= mcycle + 64'b1;
end

always_ff @(posedge clk_free or negedge rstn) begin
    if (~rstn)
        minstret            <= 64'b0;
    else if (csr_wr && csr_waddr == `CSR_MINSTRET_ADDR)
        minstret[ 0+:`XLEN] <= `CSR_WDATA(minstret[ 0+:`XLEN], 0+:`XLEN);
    else if (csr_wr && csr_waddr == `CSR_MINSTRETH_ADDR)
        minstret[32+:   32] <= `CSR_WDATA(minstret[32+:   32], 32+:32);
    else
        minstret            <= minstret + {63'b0, insn_valid};
end

always_ff @(posedge clk_free or negedge rstn) begin
    if (~rstn) mhartid <= `XLEN'b0;
    else       mhartid <= cpu_id;
end

always_comb begin
    csr_rdata = `XLEN'b0;
    case (csr_raddr) 
        `CSR_CYCLE_ADDR:      csr_rdata = mcycle    [ 0+:`XLEN];
        `CSR_CYCLEH_ADDR:     csr_rdata = mcycle    [32+:   32];
        `CSR_TIME_ADDR:       csr_rdata = mtime     [ 0+:`XLEN];
        `CSR_TIMEH_ADDR:      csr_rdata = mtime     [32+:   32];
        `CSR_INSTRET_ADDR:    csr_rdata = minstret  [ 0+:`XLEN];
        `CSR_INSTRETH_ADDR:   csr_rdata = minstret  [32+:   32];
        `CSR_SCOUNTEREN_ADDR: csr_rdata = scounteren;
        `CSR_MCOUNTEREN_ADDR: csr_rdata = mcounteren;
        `CSR_MCYCLE_ADDR:     csr_rdata = mcycle    [ 0+:`XLEN];
        `CSR_MCYCLEH_ADDR:    csr_rdata = mcycle    [32+:   32];
        `CSR_MINSTRET_ADDR:   csr_rdata = minstret  [ 0+:`XLEN];
        `CSR_MINSTRETH_ADDR:  csr_rdata = minstret  [32+:   32];
        `CSR_MHARTID_ADDR:    csr_rdata = mhartid;
    endcase
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/mpu_csr.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

//`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif

`define MDU_OP_LEN 4
`define ALU_OP_LEN 4
`define BPU_OP_LEN 2
`define CSR_OP_LEN 2
`define AMO_OP_LEN 4

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define GPR_ZERO_ADDR 5'b00000
`define GPR_RA_ADDR   5'b00001
`define GPR_SP_ADDR   5'b00010
`define GPR_GP_ADDR   5'b00011
`define GPR_TP_ADDR   5'b00100
`define GPR_T0_ADDR   5'b00101
`define GPR_T1_ADDR   5'b00110
`define GPR_T2_ADDR   5'b00111
`define GPR_S0_ADDR   5'b01000
`define GPR_FP_ADDR   5'b01000
`define GPR_S1_ADDR   5'b01001
`define GPR_A0_ADDR   5'b01010
`define GPR_A1_ADDR   5'b01011
`define GPR_A2_ADDR   5'b01100
`define GPR_A3_ADDR   5'b01101
`define GPR_A4_ADDR   5'b01110
`define GPR_A5_ADDR   5'b01111
`define GPR_A6_ADDR   5'b10000
`define GPR_A7_ADDR   5'b10001
`define GPR_S2_ADDR   5'b10010
`define GPR_S3_ADDR   5'b10011
`define GPR_S4_ADDR   5'b10100
`define GPR_S5_ADDR   5'b10101
`define GPR_S6_ADDR   5'b10110
`define GPR_S7_ADDR   5'b10111
`define GPR_S8_ADDR   5'b11000
`define GPR_S9_ADDR   5'b11001
`define GPR_S10_ADDR  5'b11010
`define GPR_S11_ADDR  5'b11011
`define GPR_T3_ADDR   5'b11100
`define GPR_T4_ADDR   5'b11101
`define GPR_T5_ADDR   5'b11110
`define GPR_T6_ADDR   5'b11111

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       'h0
`define CAUSE_INSTRUCTION_ACCESS     'h1
`define CAUSE_ILLEGAL_INSTRUCTION    'h2
`define CAUSE_BREAKPOINT             'h3
`define CAUSE_MISALIGNED_LOAD        'h4
`define CAUSE_LOAD_ACCESS            'h5
`define CAUSE_MISALIGNED_STORE       'h6
`define CAUSE_STORE_ACCESS           'h7
`define CAUSE_USER_ECALL             'h8
`define CAUSE_SUPERVISOR_ECALL       'h9
`define CAUSE_HYPERVISOR_ECALL       'ha
`define CAUSE_MACHINE_ECALL          'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT 'hc
`define CAUSE_LOAD_PAGE_FAULT        'hd
`define CAUSE_STORE_PAGE_FAULT       'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`define MCAUSE_CODE_WIDTH 6

`define MISA_MXL_XLEN_32  2'b01
`define MISA_MXL_XLEN_64  2'b10
`define MISA_MXL_XLEN_128 2'b11

`define SATP32_PPN_WIDTH  22
`define SATP32_ASID_WIDTH  9
`define SATP32_MODE_WIDTH  1

`define SATP64_PPN_WIDTH  44
`define SATP64_ASID_WIDTH 16
`define SATP64_MODE_WIDTH  4

`define SATP32_PPN_BIT     0+:`SATP32_PPN_WIDTH
`define SATP32_ASID_BIT   22+:`SATP32_ASID_WIDTH
`define SATP32_MODE_BIT   31+:`SATP32_MODE_WIDTH

`define SATP64_PPN_BIT     0+:`SATP64_PPN_WIDTH
`define SATP64_ASID_BIT   44+:`SATP64_ASID_WIDTH
`define SATP64_MODE_BIT   60+:`SATP64_MODE_WIDTH

`ifdef RV32
`define SATP_PPN_WIDTH  `SATP32_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP32_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP32_MODE_WIDTH
`define PADDR_LEN       (`SATP32_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`else
`define SATP_PPN_WIDTH  `SATP64_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP64_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP64_MODE_WIDTH
`define PADDR_LEN       (`SATP64_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`define SATP_MODE_SV39  `SATP_MODE_WIDTH'h8
`define SATP_MODE_SV48  `SATP_MODE_WIDTH'h9
`define SATP_MODE_SV57  `SATP_MODE_WIDTH'ha
`define SATP_MODE_SV64  `SATP_MODE_WIDTH'hb
`endif

`define PTE_V_BIT     0
`define PTE_R_BIT     1
`define PTE_W_BIT     2
`define PTE_X_BIT     3
`define PTE_U_BIT     4
`define PTE_G_BIT     5
`define PTE_A_BIT     6
`define PTE_D_BIT     7
`define PTE_RSW_BIT   8:9
`define PTE_PPN_SHIFT 10

`endif

// Machine Memory Protection
// 0x3A0 MRW pmpcfg0 Physical memory protection configuration.
// 0x3A1 MRW pmpcfg1 Physical memory protection configuration, RV32 only.
// 0x3A2 MRW pmpcfg2 Physical memory protection configuration.
// 0x3A3 MRW pmpcfg3 Physical memory protection configuration, RV32 only.
// 0x3B0 MRW pmpaddr0 Physical memory protection address register.
// 0x3B1 MRW pmpaddr1 Physical memory protection address register.
// .
// .
// .
// 0x3BF MRW pmpaddr15 Physical memory protection address register.
// 0x3C0 MRW pmacfg0 Physical memory protection configuration.
// 0x3C1 MRW pmacfg1 Physical memory protection configuration, RV32 only.
// 0x3C2 MRW pmacfg2 Physical memory protection configuration.
// 0x3C3 MRW pmacfg3 Physical memory protection configuration, RV32 only.
// 0x3D0 MRW pmaaddr0 Physical memory protection address register.
// 0x3D1 MRW pmaaddr1 Physical memory protection address register.
// .
// .
// .
// 0x3DF MRW pmaaddr15 Physical memory protection address register.

module mpu_csr (
    input                    clk,
    input                    rstn,
    input        [      1:0] misa_mxl,
    output logic [    8-1:0] pmpcfg  [16],
    output logic [`XLEN-1:0] pmpaddr [16],
    output logic [    8-1:0] pmacfg  [16],
    output logic [`XLEN-1:0] pmaaddr [16],

    // CSR interface
    input                    csr_wr,
    input        [     11:0] csr_waddr,
    input        [     11:0] csr_raddr,
    // input        [`XLEN-1:0] csr_wdata,
    input        [`XLEN-1:0] csr_sdata,
    input        [`XLEN-1:0] csr_cdata,
    output logic [`XLEN-1:0] csr_rdata

);

parameter [11:0] CSR_PMPADDR_ADDR [0:15] = {
    `CSR_PMPADDR0_ADDR ,
    `CSR_PMPADDR1_ADDR ,
    `CSR_PMPADDR2_ADDR ,
    `CSR_PMPADDR3_ADDR ,
    `CSR_PMPADDR4_ADDR ,
    `CSR_PMPADDR5_ADDR ,
    `CSR_PMPADDR6_ADDR ,
    `CSR_PMPADDR7_ADDR ,
    `CSR_PMPADDR8_ADDR ,
    `CSR_PMPADDR9_ADDR ,
    `CSR_PMPADDR10_ADDR,
    `CSR_PMPADDR11_ADDR,
    `CSR_PMPADDR12_ADDR,
    `CSR_PMPADDR13_ADDR,
    `CSR_PMPADDR14_ADDR,
    `CSR_PMPADDR15_ADDR
};

logic [     63:0] pmpcfg0;
logic [     63:0] pmpcfg2;

logic [     15:0] pmpcfg_l;
logic [      1:0] pmpcfg_a [16];
logic [     15:0] pmpcfg_x;
logic [     15:0] pmpcfg_w;
logic [     15:0] pmpcfg_r;

always_comb begin
    integer i;
    for (i = 0; i < 16; i = i + 1) begin
        pmpcfg[i] = {pmpcfg_l[i], 2'b0, pmpcfg_a[i], pmpcfg_x[i], pmpcfg_w[i], pmpcfg_r[i]};
    end

    for (i = 0; i < 8; i = i + 1) begin
        pmpcfg0[i*8+:8] = pmpcfg[i  ];
        pmpcfg2[i*8+:8] = pmpcfg[i+8];
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 0; i < 16; i = i + 1) begin
            pmpcfg_l[i] <= 1'b0;
            pmpcfg_a[i] <= 2'b0;
            pmpcfg_x[i] <= 1'b0;
            pmpcfg_w[i] <= 1'b0;
            pmpcfg_r[i] <= 1'b0;
        end
    end
    else if (csr_wr && csr_waddr == `CSR_PMPCFG0_ADDR) begin
        for (i = 0; i < 4; i = i + 1) begin
            if (~pmpcfg_l[i]) begin
                pmpcfg_l[i] <= `CSR_WDATA(pmpcfg_l[i], (i*8)+`PMPCFG_L_BIT);
                pmpcfg_a[i] <= `CSR_WDATA(pmpcfg_a[i], (i*8)+`PMPCFG_A_BIT);
                pmpcfg_x[i] <= `CSR_WDATA(pmpcfg_x[i], (i*8)+`PMPCFG_X_BIT);
                pmpcfg_w[i] <= `CSR_WDATA(pmpcfg_w[i], (i*8)+`PMPCFG_W_BIT)&
                               `CSR_WDATA(pmpcfg_r[i], (i*8)+`PMPCFG_R_BIT); // if R=0 => W=0
                pmpcfg_r[i] <= `CSR_WDATA(pmpcfg_r[i], (i*8)+`PMPCFG_R_BIT);
            end
        end
`ifndef RV32
        for (i = 4; i < 8; i = i + 1) begin
            if (~pmpcfg_l[i] && misa_mxl == `MISA_MXL_XLEN_64) begin
                pmpcfg_l[i] <= `CSR_WDATA(pmpcfg_l[i], (i*8)+`PMPCFG_L_BIT);
                pmpcfg_a[i] <= `CSR_WDATA(pmpcfg_a[i], (i*8)+`PMPCFG_A_BIT);
                pmpcfg_x[i] <= `CSR_WDATA(pmpcfg_x[i], (i*8)+`PMPCFG_X_BIT);
                pmpcfg_w[i] <= `CSR_WDATA(pmpcfg_w[i], (i*8)+`PMPCFG_W_BIT)&
                               `CSR_WDATA(pmpcfg_r[i], (i*8)+`PMPCFG_R_BIT); // if R=0 => W=0
                pmpcfg_r[i] <= `CSR_WDATA(pmpcfg_r[i], (i*8)+`PMPCFG_R_BIT);
            end
        end
`endif
    end
    else if (csr_wr && csr_waddr == `CSR_PMPCFG1_ADDR && misa_mxl == `MISA_MXL_XLEN_32) begin
        for (i = 0; i < 4; i = i + 1) begin
            if (~pmpcfg_l[i+4]) begin
                pmpcfg_l[i+4] <= `CSR_WDATA(pmpcfg_l[i+4], (i*8)+`PMPCFG_L_BIT);
                pmpcfg_a[i+4] <= `CSR_WDATA(pmpcfg_a[i+4], (i*8)+`PMPCFG_A_BIT);
                pmpcfg_x[i+4] <= `CSR_WDATA(pmpcfg_x[i+4], (i*8)+`PMPCFG_X_BIT);
                pmpcfg_w[i+4] <= `CSR_WDATA(pmpcfg_w[i+4], (i*8)+`PMPCFG_W_BIT)&
                                 `CSR_WDATA(pmpcfg_r[i+4], (i*8)+`PMPCFG_R_BIT); // if R=0 => W=0
                pmpcfg_r[i+4] <= `CSR_WDATA(pmpcfg_r[i+4], (i*8)+`PMPCFG_R_BIT);
            end
        end
    end
    else if (csr_wr && csr_waddr == `CSR_PMPCFG2_ADDR) begin
        for (i = 0; i < 4; i = i + 1) begin
            if (~pmpcfg_l[i+8]) begin
                pmpcfg_l[i+8] <= `CSR_WDATA(pmpcfg_l[i+8], (i*8)+`PMPCFG_L_BIT);
                pmpcfg_a[i+8] <= `CSR_WDATA(pmpcfg_a[i+8], (i*8)+`PMPCFG_A_BIT);
                pmpcfg_x[i+8] <= `CSR_WDATA(pmpcfg_x[i+8], (i*8)+`PMPCFG_X_BIT);
                pmpcfg_w[i+8] <= `CSR_WDATA(pmpcfg_w[i+8], (i*8)+`PMPCFG_W_BIT)&
                                 `CSR_WDATA(pmpcfg_r[i+8], (i*8)+`PMPCFG_R_BIT); // if R=0 => W=0
                pmpcfg_r[i+8] <= `CSR_WDATA(pmpcfg_r[i+8], (i*8)+`PMPCFG_R_BIT);
            end
        end
`ifndef RV32
        for (i = 4; i < 8; i = i + 1) begin
            if (~pmpcfg_l[i+8] && misa_mxl == `MISA_MXL_XLEN_64) begin
                pmpcfg_l[i+8] <= `CSR_WDATA(pmpcfg_l[i+8], (i*8)+`PMPCFG_L_BIT);
                pmpcfg_a[i+8] <= `CSR_WDATA(pmpcfg_a[i+8], (i*8)+`PMPCFG_A_BIT);
                pmpcfg_x[i+8] <= `CSR_WDATA(pmpcfg_x[i+8], (i*8)+`PMPCFG_X_BIT);
                pmpcfg_w[i+8] <= `CSR_WDATA(pmpcfg_w[i+8], (i*8)+`PMPCFG_W_BIT)&
                                 `CSR_WDATA(pmpcfg_r[i+8], (i*8)+`PMPCFG_R_BIT); // if R=0 => W=0
                pmpcfg_r[i+8] <= `CSR_WDATA(pmpcfg_r[i+8], (i*8)+`PMPCFG_R_BIT);
            end
        end
`endif
    end
    else if (csr_wr && csr_waddr == `CSR_PMPCFG3_ADDR && misa_mxl == `MISA_MXL_XLEN_32) begin
        for (i = 0; i < 4; i = i + 1) begin
            if (~pmpcfg_l[i+12]) begin
                pmpcfg_l[i+12] <= `CSR_WDATA(pmpcfg_l[i+12], (i*8)+`PMPCFG_L_BIT);
                pmpcfg_a[i+12] <= `CSR_WDATA(pmpcfg_a[i+12], (i*8)+`PMPCFG_A_BIT);
                pmpcfg_x[i+12] <= `CSR_WDATA(pmpcfg_x[i+12], (i*8)+`PMPCFG_X_BIT);
                pmpcfg_w[i+12] <= `CSR_WDATA(pmpcfg_w[i+12], (i*8)+`PMPCFG_W_BIT)&
                                  `CSR_WDATA(pmpcfg_r[i+12], (i*8)+`PMPCFG_R_BIT); // if R=0 => W=0
                pmpcfg_r[i+12] <= `CSR_WDATA(pmpcfg_r[i+12], (i*8)+`PMPCFG_R_BIT);
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 0; i < 16; i = i + 1) begin
            pmpaddr[i] <= `XLEN'b0;
        end
    end
    else begin
        for (i = 0; i < 15; i = i + 1) begin
            if (csr_wr && csr_waddr == CSR_PMPADDR_ADDR[i] &&
                !pmpcfg_l[i] && !(pmpcfg_l[i+1] && pmpcfg_a[i+1] == `PMPCFG_A_TOR)) begin
                pmpaddr[i] <= `CSR_WDATA(pmpaddr[i], `XLEN-1:0) &
                              ((`XLEN'b1 << (`PADDR_LEN-2)) - `XLEN'b1);
            end
        end
        if (csr_wr && csr_waddr == CSR_PMPADDR_ADDR[15] && !pmpcfg_l[15]) begin
            pmpaddr[15] <= `CSR_WDATA(pmpaddr[15], `XLEN-1:0) &
                           ((`XLEN'b1 << (`PADDR_LEN-2)) - `XLEN'b1);
        end
    end
end

parameter [11:0] CSR_PMAADDR_ADDR [0:15] = {
    `CSR_PMAADDR0_ADDR ,
    `CSR_PMAADDR1_ADDR ,
    `CSR_PMAADDR2_ADDR ,
    `CSR_PMAADDR3_ADDR ,
    `CSR_PMAADDR4_ADDR ,
    `CSR_PMAADDR5_ADDR ,
    `CSR_PMAADDR6_ADDR ,
    `CSR_PMAADDR7_ADDR ,
    `CSR_PMAADDR8_ADDR ,
    `CSR_PMAADDR9_ADDR ,
    `CSR_PMAADDR10_ADDR,
    `CSR_PMAADDR11_ADDR,
    `CSR_PMAADDR12_ADDR,
    `CSR_PMAADDR13_ADDR,
    `CSR_PMAADDR14_ADDR,
    `CSR_PMAADDR15_ADDR
};

logic [     63:0] pmacfg0;
logic [     63:0] pmacfg2;

logic [     15:0] pmacfg_l;
logic [      1:0] pmacfg_a [16];
logic [     15:0] pmacfg_c;
logic [     15:0] pmacfg_e;

always_comb begin
    integer i;
    for (i = 0; i < 16; i = i + 1) begin
        pmacfg[i] = {pmacfg_l[i], 2'b0, pmacfg_a[i], 1'b0, pmacfg_c[i], pmacfg_e[i]};
    end

    for (i = 0; i < 8; i = i + 1) begin
        pmacfg0[i*8+:8] = pmacfg[i  ];
        pmacfg2[i*8+:8] = pmacfg[i+8];
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 2; i < 16; i = i + 1) begin
            pmacfg_l[i] <= 1'b0;
            pmacfg_a[i] <= 2'b0;
            pmacfg_c[i] <= 1'b0;
            pmacfg_e[i] <= 1'b0;
        end
        pmacfg_l[0] <= 1'b1;
        pmacfg_a[0] <= `PMACFG_A_TOR;
        pmacfg_c[0] <= 1'b1;
        pmacfg_e[0] <= 1'b0;
        pmacfg_l[1] <= 1'b1;
        pmacfg_a[1] <= `PMACFG_A_TOR;
        pmacfg_c[1] <= 1'b0;
        pmacfg_e[1] <= 1'b0;
    end
    else if (csr_wr && csr_waddr == `CSR_PMACFG0_ADDR) begin
        for (i = 0; i < 4; i = i + 1) begin
            if (~pmacfg_l[i]) begin
                pmacfg_l[i] <= `CSR_WDATA(pmacfg_l[i], (i*8)+`PMACFG_L_BIT);
                pmacfg_a[i] <= `CSR_WDATA(pmacfg_a[i], (i*8)+`PMACFG_A_BIT);
                pmacfg_c[i] <= `CSR_WDATA(pmacfg_c[i], (i*8)+`PMACFG_C_BIT);
                pmacfg_e[i] <= `CSR_WDATA(pmacfg_e[i], (i*8)+`PMACFG_E_BIT);
            end
        end
`ifndef RV32
        for (i = 4; i < 8; i = i + 1) begin
            if (~pmacfg_l[i] && misa_mxl == `MISA_MXL_XLEN_64) begin
                pmacfg_l[i] <= `CSR_WDATA(pmacfg_l[i], (i*8)+`PMACFG_L_BIT);
                pmacfg_a[i] <= `CSR_WDATA(pmacfg_a[i], (i*8)+`PMACFG_A_BIT);
                pmacfg_c[i] <= `CSR_WDATA(pmacfg_c[i], (i*8)+`PMACFG_C_BIT);
                pmacfg_e[i] <= `CSR_WDATA(pmacfg_e[i], (i*8)+`PMACFG_E_BIT);
            end
        end
`endif
    end
    else if (csr_wr && csr_waddr == `CSR_PMACFG1_ADDR && misa_mxl == `MISA_MXL_XLEN_32) begin
        for (i = 0; i < 4; i = i + 1) begin
            if (~pmacfg_l[i+4]) begin
                pmacfg_l[i+4] <= `CSR_WDATA(pmacfg_l[i+4], (i*8)+`PMACFG_L_BIT);
                pmacfg_a[i+4] <= `CSR_WDATA(pmacfg_a[i+4], (i*8)+`PMACFG_A_BIT);
                pmacfg_c[i+4] <= `CSR_WDATA(pmacfg_c[i+4], (i*8)+`PMACFG_C_BIT);
                pmacfg_e[i+4] <= `CSR_WDATA(pmacfg_e[i+4], (i*8)+`PMACFG_E_BIT);
            end
        end
    end
    else if (csr_wr && csr_waddr == `CSR_PMACFG2_ADDR) begin
        for (i = 0; i < 4; i = i + 1) begin
            if (~pmacfg_l[i+8]) begin
                pmacfg_l[i+8] <= `CSR_WDATA(pmacfg_l[i+8], (i*8)+`PMACFG_L_BIT);
                pmacfg_a[i+8] <= `CSR_WDATA(pmacfg_a[i+8], (i*8)+`PMACFG_A_BIT);
                pmacfg_c[i+8] <= `CSR_WDATA(pmacfg_c[i+8], (i*8)+`PMACFG_C_BIT);
                pmacfg_e[i+8] <= `CSR_WDATA(pmacfg_e[i+8], (i*8)+`PMACFG_E_BIT);
            end
        end
`ifndef RV32
        for (i = 4; i < 8; i = i + 1) begin
            if (~pmacfg_l[i+8] && misa_mxl == `MISA_MXL_XLEN_64) begin
                pmacfg_l[i+8] <= `CSR_WDATA(pmacfg_l[i+8], (i*8)+`PMACFG_L_BIT);
                pmacfg_a[i+8] <= `CSR_WDATA(pmacfg_a[i+8], (i*8)+`PMACFG_A_BIT);
                pmacfg_c[i+8] <= `CSR_WDATA(pmacfg_c[i+8], (i*8)+`PMACFG_C_BIT);
                pmacfg_e[i+8] <= `CSR_WDATA(pmacfg_e[i+8], (i*8)+`PMACFG_E_BIT);
            end
        end
`endif
    end
    else if (csr_wr && csr_waddr == `CSR_PMACFG3_ADDR && misa_mxl == `MISA_MXL_XLEN_32) begin
        for (i = 0; i < 4; i = i + 1) begin
            if (~pmacfg_l[i+12]) begin
                pmacfg_l[i+12] <= `CSR_WDATA(pmacfg_l[i+12], (i*8)+`PMACFG_L_BIT);
                pmacfg_a[i+12] <= `CSR_WDATA(pmacfg_a[i+12], (i*8)+`PMACFG_A_BIT);
                pmacfg_c[i+12] <= `CSR_WDATA(pmacfg_c[i+12], (i*8)+`PMACFG_C_BIT);
                pmacfg_e[i+12] <= `CSR_WDATA(pmacfg_e[i+12], (i*8)+`PMACFG_E_BIT);
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 2; i < 16; i = i + 1) begin
            pmaaddr[i] <= `XLEN'b0;
        end
        pmaaddr[0] <= `XLEN'h0100_0000;
        pmaaddr[1] <= `XLEN'h1000_0000;
    end
    else begin
        for (i = 0; i < 15; i = i + 1) begin
            if (csr_wr && csr_waddr == CSR_PMAADDR_ADDR[i] &&
                !pmacfg_l[i] && !(pmacfg_l[i+1] && pmacfg_a[i+1] == `PMACFG_A_TOR)) begin
                pmaaddr[i] <= `CSR_WDATA(pmaaddr[i], `XLEN-1:0) &
                              ((`XLEN'b1 << (`PADDR_LEN-2)) - `XLEN'b1);
            end
        end
        if (csr_wr && csr_waddr == CSR_PMAADDR_ADDR[15] && !pmacfg_l[15]) begin
            pmaaddr[15] <= `CSR_WDATA(pmaaddr[15], `XLEN-1:0) &
                           ((`XLEN'b1 << (`PADDR_LEN-2)) - `XLEN'b1);
        end
    end
end

always_comb begin
    csr_rdata = `XLEN'b0;
    case (csr_raddr) 
        `CSR_PMPCFG0_ADDR  : csr_rdata = pmpcfg0[0+:`XLEN];
        `CSR_PMPCFG1_ADDR  : csr_rdata = pmpcfg0[63:32];
        `CSR_PMPCFG2_ADDR  : csr_rdata = pmpcfg2[0+:`XLEN];
        `CSR_PMPCFG3_ADDR  : csr_rdata = pmpcfg2[63:32];
        `CSR_PMPADDR0_ADDR : csr_rdata = pmpaddr[0 ] & ({`XLEN{pmpcfg_a[0 ][1]}} | ~(pmpaddr[0 ] & ~(pmpaddr[0 ] + `XLEN'b1)));
        `CSR_PMPADDR1_ADDR : csr_rdata = pmpaddr[1 ] & ({`XLEN{pmpcfg_a[1 ][1]}} | ~(pmpaddr[1 ] & ~(pmpaddr[1 ] + `XLEN'b1)));
        `CSR_PMPADDR2_ADDR : csr_rdata = pmpaddr[2 ] & ({`XLEN{pmpcfg_a[2 ][1]}} | ~(pmpaddr[2 ] & ~(pmpaddr[2 ] + `XLEN'b1)));
        `CSR_PMPADDR3_ADDR : csr_rdata = pmpaddr[3 ] & ({`XLEN{pmpcfg_a[3 ][1]}} | ~(pmpaddr[3 ] & ~(pmpaddr[3 ] + `XLEN'b1)));
        `CSR_PMPADDR4_ADDR : csr_rdata = pmpaddr[4 ] & ({`XLEN{pmpcfg_a[4 ][1]}} | ~(pmpaddr[4 ] & ~(pmpaddr[4 ] + `XLEN'b1)));
        `CSR_PMPADDR5_ADDR : csr_rdata = pmpaddr[5 ] & ({`XLEN{pmpcfg_a[5 ][1]}} | ~(pmpaddr[5 ] & ~(pmpaddr[5 ] + `XLEN'b1)));
        `CSR_PMPADDR6_ADDR : csr_rdata = pmpaddr[6 ] & ({`XLEN{pmpcfg_a[6 ][1]}} | ~(pmpaddr[6 ] & ~(pmpaddr[6 ] + `XLEN'b1)));
        `CSR_PMPADDR7_ADDR : csr_rdata = pmpaddr[7 ] & ({`XLEN{pmpcfg_a[7 ][1]}} | ~(pmpaddr[7 ] & ~(pmpaddr[7 ] + `XLEN'b1)));
        `CSR_PMPADDR8_ADDR : csr_rdata = pmpaddr[8 ] & ({`XLEN{pmpcfg_a[8 ][1]}} | ~(pmpaddr[8 ] & ~(pmpaddr[8 ] + `XLEN'b1)));
        `CSR_PMPADDR9_ADDR : csr_rdata = pmpaddr[9 ] & ({`XLEN{pmpcfg_a[9 ][1]}} | ~(pmpaddr[9 ] & ~(pmpaddr[9 ] + `XLEN'b1)));
        `CSR_PMPADDR10_ADDR: csr_rdata = pmpaddr[10] & ({`XLEN{pmpcfg_a[10][1]}} | ~(pmpaddr[10] & ~(pmpaddr[10] + `XLEN'b1)));
        `CSR_PMPADDR11_ADDR: csr_rdata = pmpaddr[11] & ({`XLEN{pmpcfg_a[11][1]}} | ~(pmpaddr[11] & ~(pmpaddr[11] + `XLEN'b1)));
        `CSR_PMPADDR12_ADDR: csr_rdata = pmpaddr[12] & ({`XLEN{pmpcfg_a[12][1]}} | ~(pmpaddr[12] & ~(pmpaddr[12] + `XLEN'b1)));
        `CSR_PMPADDR13_ADDR: csr_rdata = pmpaddr[13] & ({`XLEN{pmpcfg_a[13][1]}} | ~(pmpaddr[13] & ~(pmpaddr[13] + `XLEN'b1)));
        `CSR_PMPADDR14_ADDR: csr_rdata = pmpaddr[14] & ({`XLEN{pmpcfg_a[14][1]}} | ~(pmpaddr[14] & ~(pmpaddr[14] + `XLEN'b1)));
        `CSR_PMPADDR15_ADDR: csr_rdata = pmpaddr[15] & ({`XLEN{pmpcfg_a[15][1]}} | ~(pmpaddr[15] & ~(pmpaddr[15] + `XLEN'b1)));
        `CSR_PMACFG0_ADDR  : csr_rdata = pmacfg0[0+:`XLEN];
        `CSR_PMACFG1_ADDR  : csr_rdata = pmacfg0[63:32];
        `CSR_PMACFG2_ADDR  : csr_rdata = pmacfg2[0+:`XLEN];
        `CSR_PMACFG3_ADDR  : csr_rdata = pmacfg2[63:32];
        `CSR_PMAADDR0_ADDR : csr_rdata = pmaaddr[0 ] & ({`XLEN{pmacfg_a[0 ][1]}} | ~(pmaaddr[0 ] & ~(pmaaddr[0 ] + `XLEN'b1)));
        `CSR_PMAADDR1_ADDR : csr_rdata = pmaaddr[1 ] & ({`XLEN{pmacfg_a[1 ][1]}} | ~(pmaaddr[1 ] & ~(pmaaddr[1 ] + `XLEN'b1)));
        `CSR_PMAADDR2_ADDR : csr_rdata = pmaaddr[2 ] & ({`XLEN{pmacfg_a[2 ][1]}} | ~(pmaaddr[2 ] & ~(pmaaddr[2 ] + `XLEN'b1)));
        `CSR_PMAADDR3_ADDR : csr_rdata = pmaaddr[3 ] & ({`XLEN{pmacfg_a[3 ][1]}} | ~(pmaaddr[3 ] & ~(pmaaddr[3 ] + `XLEN'b1)));
        `CSR_PMAADDR4_ADDR : csr_rdata = pmaaddr[4 ] & ({`XLEN{pmacfg_a[4 ][1]}} | ~(pmaaddr[4 ] & ~(pmaaddr[4 ] + `XLEN'b1)));
        `CSR_PMAADDR5_ADDR : csr_rdata = pmaaddr[5 ] & ({`XLEN{pmacfg_a[5 ][1]}} | ~(pmaaddr[5 ] & ~(pmaaddr[5 ] + `XLEN'b1)));
        `CSR_PMAADDR6_ADDR : csr_rdata = pmaaddr[6 ] & ({`XLEN{pmacfg_a[6 ][1]}} | ~(pmaaddr[6 ] & ~(pmaaddr[6 ] + `XLEN'b1)));
        `CSR_PMAADDR7_ADDR : csr_rdata = pmaaddr[7 ] & ({`XLEN{pmacfg_a[7 ][1]}} | ~(pmaaddr[7 ] & ~(pmaaddr[7 ] + `XLEN'b1)));
        `CSR_PMAADDR8_ADDR : csr_rdata = pmaaddr[8 ] & ({`XLEN{pmacfg_a[8 ][1]}} | ~(pmaaddr[8 ] & ~(pmaaddr[8 ] + `XLEN'b1)));
        `CSR_PMAADDR9_ADDR : csr_rdata = pmaaddr[9 ] & ({`XLEN{pmacfg_a[9 ][1]}} | ~(pmaaddr[9 ] & ~(pmaaddr[9 ] + `XLEN'b1)));
        `CSR_PMAADDR10_ADDR: csr_rdata = pmaaddr[10] & ({`XLEN{pmacfg_a[10][1]}} | ~(pmaaddr[10] & ~(pmaaddr[10] + `XLEN'b1)));
        `CSR_PMAADDR11_ADDR: csr_rdata = pmaaddr[11] & ({`XLEN{pmacfg_a[11][1]}} | ~(pmaaddr[11] & ~(pmaaddr[11] + `XLEN'b1)));
        `CSR_PMAADDR12_ADDR: csr_rdata = pmaaddr[12] & ({`XLEN{pmacfg_a[12][1]}} | ~(pmaaddr[12] & ~(pmaaddr[12] + `XLEN'b1)));
        `CSR_PMAADDR13_ADDR: csr_rdata = pmaaddr[13] & ({`XLEN{pmacfg_a[13][1]}} | ~(pmaaddr[13] & ~(pmaaddr[13] + `XLEN'b1)));
        `CSR_PMAADDR14_ADDR: csr_rdata = pmaaddr[14] & ({`XLEN{pmacfg_a[14][1]}} | ~(pmaaddr[14] & ~(pmaaddr[14] + `XLEN'b1)));
        `CSR_PMAADDR15_ADDR: csr_rdata = pmaaddr[15] & ({`XLEN{pmacfg_a[15][1]}} | ~(pmaaddr[15] & ~(pmaaddr[15] + `XLEN'b1)));
    endcase
end


endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/mpu.sv
/*--------------------------------------*/

`ifndef __CPU_DEFINE__
`define __CPU_DEFINE__

//`define RV32

`ifdef RV32
  `define XLEN 32
  
  `define IM_ADDR_LEN 32
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 32
  `define DM_DATA_LEN 32
`else
  `define XLEN 64
  
  `define IM_ADDR_LEN 64
  `define IM_DATA_LEN 32
  
  `define DM_ADDR_LEN 64
  `define DM_DATA_LEN 64

`endif

`define MDU_OP_LEN 4
`define ALU_OP_LEN 4
`define BPU_OP_LEN 2
`define CSR_OP_LEN 2
`define AMO_OP_LEN 4

`define PRV_U 2'h0
`define PRV_S 2'h1
`define PRV_H 2'h2
`define PRV_M 2'h3

`define GPR_ZERO_ADDR 5'b00000
`define GPR_RA_ADDR   5'b00001
`define GPR_SP_ADDR   5'b00010
`define GPR_GP_ADDR   5'b00011
`define GPR_TP_ADDR   5'b00100
`define GPR_T0_ADDR   5'b00101
`define GPR_T1_ADDR   5'b00110
`define GPR_T2_ADDR   5'b00111
`define GPR_S0_ADDR   5'b01000
`define GPR_FP_ADDR   5'b01000
`define GPR_S1_ADDR   5'b01001
`define GPR_A0_ADDR   5'b01010
`define GPR_A1_ADDR   5'b01011
`define GPR_A2_ADDR   5'b01100
`define GPR_A3_ADDR   5'b01101
`define GPR_A4_ADDR   5'b01110
`define GPR_A5_ADDR   5'b01111
`define GPR_A6_ADDR   5'b10000
`define GPR_A7_ADDR   5'b10001
`define GPR_S2_ADDR   5'b10010
`define GPR_S3_ADDR   5'b10011
`define GPR_S4_ADDR   5'b10100
`define GPR_S5_ADDR   5'b10101
`define GPR_S6_ADDR   5'b10110
`define GPR_S7_ADDR   5'b10111
`define GPR_S8_ADDR   5'b11000
`define GPR_S9_ADDR   5'b11001
`define GPR_S10_ADDR  5'b11010
`define GPR_S11_ADDR  5'b11011
`define GPR_T3_ADDR   5'b11100
`define GPR_T4_ADDR   5'b11101
`define GPR_T5_ADDR   5'b11110
`define GPR_T6_ADDR   5'b11111

`define CSR_USTATUS_ADDR        12'h000
`define CSR_UIE_ADDR            12'h004
`define CSR_UTVEC_ADDR          12'h005
`define CSR_USCRATCH_ADDR       12'h040
`define CSR_UEPC_ADDR           12'h041
`define CSR_UCAUSE_ADDR         12'h042
`define CSR_UTVAL_ADDR          12'h043
`define CSR_UIP_ADDR            12'h044
`define CSR_FFLAGS_ADDR         12'h001
`define CSR_FRM_ADDR            12'h002
`define CSR_FCSR_ADDR           12'h003
`define CSR_CYCLE_ADDR          12'hc00
`define CSR_TIME_ADDR           12'hc01
`define CSR_INSTRET_ADDR        12'hc02
`define CSR_HPMCOUNTER3_ADDR    12'hc03
`define CSR_HPMCOUNTER4_ADDR    12'hc04
`define CSR_HPMCOUNTER5_ADDR    12'hc05
`define CSR_HPMCOUNTER6_ADDR    12'hc06
`define CSR_HPMCOUNTER7_ADDR    12'hc07
`define CSR_HPMCOUNTER8_ADDR    12'hc08
`define CSR_HPMCOUNTER9_ADDR    12'hc09
`define CSR_HPMCOUNTER10_ADDR   12'hc0a
`define CSR_HPMCOUNTER11_ADDR   12'hc0b
`define CSR_HPMCOUNTER12_ADDR   12'hc0c
`define CSR_HPMCOUNTER13_ADDR   12'hc0d
`define CSR_HPMCOUNTER14_ADDR   12'hc0e
`define CSR_HPMCOUNTER15_ADDR   12'hc0f
`define CSR_HPMCOUNTER16_ADDR   12'hc10
`define CSR_HPMCOUNTER17_ADDR   12'hc11
`define CSR_HPMCOUNTER18_ADDR   12'hc12
`define CSR_HPMCOUNTER19_ADDR   12'hc13
`define CSR_HPMCOUNTER20_ADDR   12'hc14
`define CSR_HPMCOUNTER21_ADDR   12'hc15
`define CSR_HPMCOUNTER22_ADDR   12'hc16
`define CSR_HPMCOUNTER23_ADDR   12'hc17
`define CSR_HPMCOUNTER24_ADDR   12'hc18
`define CSR_HPMCOUNTER25_ADDR   12'hc19
`define CSR_HPMCOUNTER26_ADDR   12'hc1a
`define CSR_HPMCOUNTER27_ADDR   12'hc1b
`define CSR_HPMCOUNTER28_ADDR   12'hc1c
`define CSR_HPMCOUNTER29_ADDR   12'hc1d
`define CSR_HPMCOUNTER30_ADDR   12'hc1e
`define CSR_HPMCOUNTER31_ADDR   12'hc1f
`define CSR_CYCLEH_ADDR         12'hc80
`define CSR_TIMEH_ADDR          12'hc81
`define CSR_INSTRETH_ADDR       12'hc82
`define CSR_HPMCOUNTER3H_ADDR   12'hc83
`define CSR_HPMCOUNTER4H_ADDR   12'hc84
`define CSR_HPMCOUNTER5H_ADDR   12'hc85
`define CSR_HPMCOUNTER6H_ADDR   12'hc86
`define CSR_HPMCOUNTER7H_ADDR   12'hc87
`define CSR_HPMCOUNTER8H_ADDR   12'hc88
`define CSR_HPMCOUNTER9H_ADDR   12'hc89
`define CSR_HPMCOUNTER10H_ADDR  12'hc8a
`define CSR_HPMCOUNTER11H_ADDR  12'hc8b
`define CSR_HPMCOUNTER12H_ADDR  12'hc8c
`define CSR_HPMCOUNTER13H_ADDR  12'hc8d
`define CSR_HPMCOUNTER14H_ADDR  12'hc8e
`define CSR_HPMCOUNTER15H_ADDR  12'hc8f
`define CSR_HPMCOUNTER16H_ADDR  12'hc90
`define CSR_HPMCOUNTER17H_ADDR  12'hc91
`define CSR_HPMCOUNTER18H_ADDR  12'hc92
`define CSR_HPMCOUNTER19H_ADDR  12'hc93
`define CSR_HPMCOUNTER20H_ADDR  12'hc94
`define CSR_HPMCOUNTER21H_ADDR  12'hc95
`define CSR_HPMCOUNTER22H_ADDR  12'hc96
`define CSR_HPMCOUNTER23H_ADDR  12'hc97
`define CSR_HPMCOUNTER24H_ADDR  12'hc98
`define CSR_HPMCOUNTER25H_ADDR  12'hc99
`define CSR_HPMCOUNTER26H_ADDR  12'hc9a
`define CSR_HPMCOUNTER27H_ADDR  12'hc9b
`define CSR_HPMCOUNTER28H_ADDR  12'hc9c
`define CSR_HPMCOUNTER29H_ADDR  12'hc9d
`define CSR_HPMCOUNTER30H_ADDR  12'hc9e
`define CSR_HPMCOUNTER31H_ADDR  12'hc9f

`define CSR_SSTATUS_ADDR        12'h100
`define CSR_SEDELEG_ADDR        12'h102
`define CSR_SIDELEG_ADDR        12'h103
`define CSR_SIE_ADDR            12'h104
`define CSR_STVEC_ADDR          12'h105
`define CSR_SCOUNTEREN_ADDR     12'h106
`define CSR_SSCRATCH_ADDR       12'h140
`define CSR_SEPC_ADDR           12'h141
`define CSR_SCAUSE_ADDR         12'h142
`define CSR_STVAL_ADDR          12'h143
`define CSR_SIP_ADDR            12'h144
`define CSR_SATP_ADDR           12'h180

`define CSR_MVENDORID_ADDR      12'hf11
`define CSR_MARCHID_ADDR        12'hf12
`define CSR_MIMPID_ADDR         12'hf13
`define CSR_MHARTID_ADDR        12'hf14
`define CSR_MSTATUS_ADDR        12'h300
`define CSR_MISA_ADDR           12'h301
`define CSR_MEDELEG_ADDR        12'h302
`define CSR_MIDELEG_ADDR        12'h303
`define CSR_MIE_ADDR            12'h304
`define CSR_MTVEC_ADDR          12'h305
`define CSR_MCOUNTEREN_ADDR     12'h306
`define CSR_MSCRATCH_ADDR       12'h340
`define CSR_MEPC_ADDR           12'h341
`define CSR_MCAUSE_ADDR         12'h342
`define CSR_MTVAL_ADDR          12'h343
`define CSR_MIP_ADDR            12'h344
`define CSR_PMPCFG0_ADDR        12'h3a0
`define CSR_PMPCFG1_ADDR        12'h3a1
`define CSR_PMPCFG2_ADDR        12'h3a2
`define CSR_PMPCFG3_ADDR        12'h3a3
`define CSR_PMPADDR0_ADDR       12'h3b0
`define CSR_PMPADDR1_ADDR       12'h3b1
`define CSR_PMPADDR2_ADDR       12'h3b2
`define CSR_PMPADDR3_ADDR       12'h3b3
`define CSR_PMPADDR4_ADDR       12'h3b4
`define CSR_PMPADDR5_ADDR       12'h3b5
`define CSR_PMPADDR6_ADDR       12'h3b6
`define CSR_PMPADDR7_ADDR       12'h3b7
`define CSR_PMPADDR8_ADDR       12'h3b8
`define CSR_PMPADDR9_ADDR       12'h3b9
`define CSR_PMPADDR10_ADDR      12'h3ba
`define CSR_PMPADDR11_ADDR      12'h3bb
`define CSR_PMPADDR12_ADDR      12'h3bc
`define CSR_PMPADDR13_ADDR      12'h3bd
`define CSR_PMPADDR14_ADDR      12'h3be
`define CSR_PMPADDR15_ADDR      12'h3bf
`define CSR_PMACFG0_ADDR        12'h3c0
`define CSR_PMACFG1_ADDR        12'h3c1
`define CSR_PMACFG2_ADDR        12'h3c2
`define CSR_PMACFG3_ADDR        12'h3c3
`define CSR_PMAADDR0_ADDR       12'h3d0
`define CSR_PMAADDR1_ADDR       12'h3d1
`define CSR_PMAADDR2_ADDR       12'h3d2
`define CSR_PMAADDR3_ADDR       12'h3d3
`define CSR_PMAADDR4_ADDR       12'h3d4
`define CSR_PMAADDR5_ADDR       12'h3d5
`define CSR_PMAADDR6_ADDR       12'h3d6
`define CSR_PMAADDR7_ADDR       12'h3d7
`define CSR_PMAADDR8_ADDR       12'h3d8
`define CSR_PMAADDR9_ADDR       12'h3d9
`define CSR_PMAADDR10_ADDR      12'h3da
`define CSR_PMAADDR11_ADDR      12'h3db
`define CSR_PMAADDR12_ADDR      12'h3dc
`define CSR_PMAADDR13_ADDR      12'h3dd
`define CSR_PMAADDR14_ADDR      12'h3de
`define CSR_PMAADDR15_ADDR      12'h3df
`define CSR_MCYCLE_ADDR         12'hb00
`define CSR_MINSTRET_ADDR       12'hb02
`define CSR_MHPMCOUNTER3_ADDR   12'hb03
`define CSR_MHPMCOUNTER4_ADDR   12'hb04
`define CSR_MHPMCOUNTER5_ADDR   12'hb05
`define CSR_MHPMCOUNTER6_ADDR   12'hb06
`define CSR_MHPMCOUNTER7_ADDR   12'hb07
`define CSR_MHPMCOUNTER8_ADDR   12'hb08
`define CSR_MHPMCOUNTER9_ADDR   12'hb09
`define CSR_MHPMCOUNTER10_ADDR  12'hb0a
`define CSR_MHPMCOUNTER11_ADDR  12'hb0b
`define CSR_MHPMCOUNTER12_ADDR  12'hb0c
`define CSR_MHPMCOUNTER13_ADDR  12'hb0d
`define CSR_MHPMCOUNTER14_ADDR  12'hb0e
`define CSR_MHPMCOUNTER15_ADDR  12'hb0f
`define CSR_MHPMCOUNTER16_ADDR  12'hb10
`define CSR_MHPMCOUNTER17_ADDR  12'hb11
`define CSR_MHPMCOUNTER18_ADDR  12'hb12
`define CSR_MHPMCOUNTER19_ADDR  12'hb13
`define CSR_MHPMCOUNTER20_ADDR  12'hb14
`define CSR_MHPMCOUNTER21_ADDR  12'hb15
`define CSR_MHPMCOUNTER22_ADDR  12'hb16
`define CSR_MHPMCOUNTER23_ADDR  12'hb17
`define CSR_MHPMCOUNTER24_ADDR  12'hb18
`define CSR_MHPMCOUNTER25_ADDR  12'hb19
`define CSR_MHPMCOUNTER26_ADDR  12'hb1a
`define CSR_MHPMCOUNTER27_ADDR  12'hb1b
`define CSR_MHPMCOUNTER28_ADDR  12'hb1c
`define CSR_MHPMCOUNTER29_ADDR  12'hb1d
`define CSR_MHPMCOUNTER30_ADDR  12'hb1e
`define CSR_MHPMCOUNTER31_ADDR  12'hb1f
`define CSR_MCYCLEH_ADDR        12'hb80
`define CSR_MINSTRETH_ADDR      12'hb82
`define CSR_MHPMCOUNTER3H_ADDR  12'hb83
`define CSR_MHPMCOUNTER4H_ADDR  12'hb84
`define CSR_MHPMCOUNTER5H_ADDR  12'hb85
`define CSR_MHPMCOUNTER6H_ADDR  12'hb86
`define CSR_MHPMCOUNTER7H_ADDR  12'hb87
`define CSR_MHPMCOUNTER8H_ADDR  12'hb88
`define CSR_MHPMCOUNTER9H_ADDR  12'hb89
`define CSR_MHPMCOUNTER10H_ADDR 12'hb8a
`define CSR_MHPMCOUNTER11H_ADDR 12'hb8b
`define CSR_MHPMCOUNTER12H_ADDR 12'hb8c
`define CSR_MHPMCOUNTER13H_ADDR 12'hb8d
`define CSR_MHPMCOUNTER14H_ADDR 12'hb8e
`define CSR_MHPMCOUNTER15H_ADDR 12'hb8f
`define CSR_MHPMCOUNTER16H_ADDR 12'hb90
`define CSR_MHPMCOUNTER17H_ADDR 12'hb91
`define CSR_MHPMCOUNTER18H_ADDR 12'hb92
`define CSR_MHPMCOUNTER19H_ADDR 12'hb93
`define CSR_MHPMCOUNTER20H_ADDR 12'hb94
`define CSR_MHPMCOUNTER21H_ADDR 12'hb95
`define CSR_MHPMCOUNTER22H_ADDR 12'hb96
`define CSR_MHPMCOUNTER23H_ADDR 12'hb97
`define CSR_MHPMCOUNTER24H_ADDR 12'hb98
`define CSR_MHPMCOUNTER25H_ADDR 12'hb99
`define CSR_MHPMCOUNTER26H_ADDR 12'hb9a
`define CSR_MHPMCOUNTER27H_ADDR 12'hb9b
`define CSR_MHPMCOUNTER28H_ADDR 12'hb9c
`define CSR_MHPMCOUNTER29H_ADDR 12'hb9d
`define CSR_MHPMCOUNTER30H_ADDR 12'hb9e
`define CSR_MHPMCOUNTER31H_ADDR 12'hb9f
`define CSR_MHPMEVENT3_ADDR     12'h323
`define CSR_MHPMEVENT4_ADDR     12'h324
`define CSR_MHPMEVENT5_ADDR     12'h325
`define CSR_MHPMEVENT6_ADDR     12'h326
`define CSR_MHPMEVENT7_ADDR     12'h327
`define CSR_MHPMEVENT8_ADDR     12'h328
`define CSR_MHPMEVENT9_ADDR     12'h329
`define CSR_MHPMEVENT10_ADDR    12'h32a
`define CSR_MHPMEVENT11_ADDR    12'h32b
`define CSR_MHPMEVENT12_ADDR    12'h32c
`define CSR_MHPMEVENT13_ADDR    12'h32d
`define CSR_MHPMEVENT14_ADDR    12'h32e
`define CSR_MHPMEVENT15_ADDR    12'h32f
`define CSR_MHPMEVENT16_ADDR    12'h330
`define CSR_MHPMEVENT17_ADDR    12'h331
`define CSR_MHPMEVENT18_ADDR    12'h332
`define CSR_MHPMEVENT19_ADDR    12'h333
`define CSR_MHPMEVENT20_ADDR    12'h334
`define CSR_MHPMEVENT21_ADDR    12'h335
`define CSR_MHPMEVENT22_ADDR    12'h336
`define CSR_MHPMEVENT23_ADDR    12'h337
`define CSR_MHPMEVENT24_ADDR    12'h338
`define CSR_MHPMEVENT25_ADDR    12'h339
`define CSR_MHPMEVENT26_ADDR    12'h33a
`define CSR_MHPMEVENT27_ADDR    12'h33b
`define CSR_MHPMEVENT28_ADDR    12'h33c
`define CSR_MHPMEVENT29_ADDR    12'h33d
`define CSR_MHPMEVENT30_ADDR    12'h33e
`define CSR_MHPMEVENT31_ADDR    12'h33f

`define CSR_TSELECT_ADDR        12'h7a0
`define CSR_TDATA1_ADDR         12'h7a1
`define CSR_TDATA2_ADDR         12'h7a2
`define CSR_TDATA3_ADDR         12'h7a3
`define CSR_DCSR_ADDR           12'h7b0
`define CSR_DPC_ADDR            12'h7b1
`define CSR_DSCRATCH_ADDR       12'h7b2

`define MSTATUS_SIE   (`XLEN'd1 <<  1)
`define MSTATUS_MIE   (`XLEN'd1 <<  3)
`define MSTATUS_SPIE  (`XLEN'd1 <<  5)
`define MSTATUS_MPIE  (`XLEN'd1 <<  7)
`define MSTATUS_SPP   (`XLEN'd1 <<  8)
`define MSTATUS_MPP   (`XLEN'd3 << 11)
`define MSTATUS_FS    (`XLEN'd3 << 13)
`define MSTATUS_XS    (`XLEN'd3 << 15)
`define MSTATUS_MPRV  (`XLEN'd1 << 17)
`define MSTATUS_SUM   (`XLEN'd1 << 18)
`define MSTATUS_MXR   (`XLEN'd1 << 19)
`define MSTATUS_TW    (`XLEN'd1 << 21)
`define MSTATUS_TVM   (`XLEN'd1 << 20)
`define MSTATUS_TSR   (`XLEN'd1 << 22)
`define MSTATUS_UXL   (`XLEN'd3 << 32)
`define MSTATUS_SXL   (`XLEN'd3 << 34)
`define MSTATUS_64_SD (`XLEN'd1 << 63)
`define MSTATUS_32_SD (`XLEN'd1 << 31)

`define MSTATUS_SIE_BIT    1+:1
`define MSTATUS_MIE_BIT    3+:1
`define MSTATUS_SPIE_BIT   5+:1
`define MSTATUS_MPIE_BIT   7+:1
`define MSTATUS_SPP_BIT    8+:1
`define MSTATUS_MPP_BIT   11+:2
`define MSTATUS_FS_BIT    13+:2
`define MSTATUS_XS_BIT    15+:2
`define MSTATUS_MPRV_BIT  17+:1
`define MSTATUS_SUM_BIT   18+:1
`define MSTATUS_MXR_BIT   19+:1
`define MSTATUS_TVM_BIT   20+:1
`define MSTATUS_TW_BIT    21+:1
`define MSTATUS_TSR_BIT   22+:1
`define MSTATUS_UXL_BIT   32+:2
`define MSTATUS_SXL_BIT   34+:2
`define MSTATUS_64_SD_BIT 63+:1
`define MSTATUS_32_SD_BIT 31+:1

`define CAUSE_MISALIGNED_FETCH       'h0
`define CAUSE_INSTRUCTION_ACCESS     'h1
`define CAUSE_ILLEGAL_INSTRUCTION    'h2
`define CAUSE_BREAKPOINT             'h3
`define CAUSE_MISALIGNED_LOAD        'h4
`define CAUSE_LOAD_ACCESS            'h5
`define CAUSE_MISALIGNED_STORE       'h6
`define CAUSE_STORE_ACCESS           'h7
`define CAUSE_USER_ECALL             'h8
`define CAUSE_SUPERVISOR_ECALL       'h9
`define CAUSE_HYPERVISOR_ECALL       'ha
`define CAUSE_MACHINE_ECALL          'hb
`define CAUSE_INSTRUCTION_PAGE_FAULT 'hc
`define CAUSE_LOAD_PAGE_FAULT        'hd
`define CAUSE_STORE_PAGE_FAULT       'hf

`define MIP_SSIP_BIT  1
`define MIP_MSIP_BIT  3
`define MIP_STIP_BIT  5
`define MIP_MTIP_BIT  7
`define MIP_SEIP_BIT  9
`define MIP_MEIP_BIT 11

`define MIP_SSIP (`XLEN'b1 <<  1)
`define MIP_MSIP (`XLEN'b1 <<  3)
`define MIP_STIP (`XLEN'b1 <<  5)
`define MIP_MTIP (`XLEN'b1 <<  7)
`define MIP_SEIP (`XLEN'b1 <<  9)
`define MIP_MEIP (`XLEN'b1 << 11)

`define PMPCFG_L_BIT 7
`define PMPCFG_A_BIT 3+:2
`define PMPCFG_X_BIT 2
`define PMPCFG_W_BIT 1
`define PMPCFG_R_BIT 0

`define PMPCFG_A_OFF   2'h0
`define PMPCFG_A_TOR   2'h1
`define PMPCFG_A_NA4   2'h2
`define PMPCFG_A_NAPOT 2'h3

`define PMACFG_L_BIT 7
`define PMACFG_A_BIT 3+:2
`define PMACFG_C_BIT 1
`define PMACFG_E_BIT 0

`define PMACFG_A_OFF   2'h0
`define PMACFG_A_TOR   2'h1
`define PMACFG_A_NA4   2'h2
`define PMACFG_A_NAPOT 2'h3

`define MCAUSE_CODE_WIDTH 6

`define MISA_MXL_XLEN_32  2'b01
`define MISA_MXL_XLEN_64  2'b10
`define MISA_MXL_XLEN_128 2'b11

`define SATP32_PPN_WIDTH  22
`define SATP32_ASID_WIDTH  9
`define SATP32_MODE_WIDTH  1

`define SATP64_PPN_WIDTH  44
`define SATP64_ASID_WIDTH 16
`define SATP64_MODE_WIDTH  4

`define SATP32_PPN_BIT     0+:`SATP32_PPN_WIDTH
`define SATP32_ASID_BIT   22+:`SATP32_ASID_WIDTH
`define SATP32_MODE_BIT   31+:`SATP32_MODE_WIDTH

`define SATP64_PPN_BIT     0+:`SATP64_PPN_WIDTH
`define SATP64_ASID_BIT   44+:`SATP64_ASID_WIDTH
`define SATP64_MODE_BIT   60+:`SATP64_MODE_WIDTH

`ifdef RV32
`define SATP_PPN_WIDTH  `SATP32_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP32_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP32_MODE_WIDTH
`define PADDR_LEN       (`SATP32_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`else
`define SATP_PPN_WIDTH  `SATP64_PPN_WIDTH 
`define SATP_ASID_WIDTH `SATP64_ASID_WIDTH
`define SATP_MODE_WIDTH `SATP64_MODE_WIDTH
`define PADDR_LEN       (`SATP64_PPN_WIDTH + 12)
`define SATP_MODE_NONE  `SATP_MODE_WIDTH'h0
`define SATP_MODE_SV32  `SATP_MODE_WIDTH'h1
`define SATP_MODE_SV39  `SATP_MODE_WIDTH'h8
`define SATP_MODE_SV48  `SATP_MODE_WIDTH'h9
`define SATP_MODE_SV57  `SATP_MODE_WIDTH'ha
`define SATP_MODE_SV64  `SATP_MODE_WIDTH'hb
`endif

`define PTE_V_BIT     0
`define PTE_R_BIT     1
`define PTE_W_BIT     2
`define PTE_X_BIT     3
`define PTE_U_BIT     4
`define PTE_G_BIT     5
`define PTE_A_BIT     6
`define PTE_D_BIT     7
`define PTE_RSW_BIT   8:9
`define PTE_PPN_SHIFT 10

`endif

module mpu (
    input                         clk,
    input                         rstn,
    input        [           7:0] pmpcfg  [16],
    input        [     `XLEN-1:0] pmpaddr [16],
    input        [           7:0] pmacfg  [16],
    input        [     `XLEN-1:0] pmaaddr [16],
    input        [`PADDR_LEN-1:0] paddr,

    output logic                  pmp_v,
    output logic                  pmp_l,
    output logic                  pmp_x,
    output logic                  pmp_w,
    output logic                  pmp_r,

    output logic                  pma_v,
    output logic                  pma_l,
    output logic                  pma_c,
    output logic                  pma_e
        
);

logic [     15:0] pmp_match;
logic             pmp_v_tmp;
logic             pmp_l_tmp;
logic             pmp_x_tmp;
logic             pmp_w_tmp;
logic             pmp_r_tmp;

genvar g;
generate
    for (g = 0; g < 16; g = g + 1) begin: g_pmp
        logic [  `XLEN:0] mask_tmp;
        logic [`XLEN+2:0] mask;
        logic             napot_match;
        logic             tor_match;

        assign mask_tmp = {pmpaddr[g], pmpcfg[g][`PMPCFG_A_BIT] != `PMPCFG_A_NA4};
        assign mask     = {~(mask_tmp & ~(mask_tmp + {`XLEN'b0, 1'b1})), 2'b0};

        assign napot_match = ~|(({pmpaddr[g][0+:`PADDR_LEN-2], 2'b0} ^ paddr) & mask[0+:`PADDR_LEN]);
        if (g == 0) begin: g_first
            assign tor_match = {`PADDR_LEN{1'b0}} <= paddr && paddr < {pmpaddr[g][0+:`PADDR_LEN-2], 2'b0};
        end
        else begin: g_non_first
            assign tor_match = {pmpaddr[g-1][0+:`PADDR_LEN-2], 2'b0} <= paddr &&
                               paddr < {pmpaddr[g][0+:`PADDR_LEN-2], 2'b0};
        end
        
        assign pmp_match[g] = (pmpcfg[g][`PMPCFG_A_BIT] == `PMPCFG_A_TOR   && tor_match) |
                              (pmpcfg[g][`PMPCFG_A_BIT] == `PMPCFG_A_NA4   && napot_match) |
                              (pmpcfg[g][`PMPCFG_A_BIT] == `PMPCFG_A_NAPOT && napot_match);
    end
endgenerate

assign pmp_v_tmp = |pmp_match;

always_comb begin
    integer i;
    pmp_l_tmp = 1'b0;
    pmp_x_tmp = 1'b0;
    pmp_w_tmp = 1'b0;
    pmp_r_tmp = 1'b0;
    for (i = 0; i < 16; i = i + 1) begin
        pmp_l_tmp = pmp_l_tmp | (pmp_match[i] & pmpcfg[i][`PMPCFG_L_BIT]);
        pmp_x_tmp = pmp_x_tmp | (pmp_match[i] & pmpcfg[i][`PMPCFG_X_BIT]);
        pmp_w_tmp = pmp_w_tmp | (pmp_match[i] & pmpcfg[i][`PMPCFG_W_BIT]);
        pmp_r_tmp = pmp_r_tmp | (pmp_match[i] & pmpcfg[i][`PMPCFG_R_BIT]);
    end
end

// assign pmp_v = pmp_v_tmp;
// assign pmp_l = pmp_l_tmp;
// assign pmp_x = pmp_x_tmp;
// assign pmp_w = pmp_w_tmp;
// assign pmp_r = pmp_r_tmp;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        pmp_v <= 1'b0;
        pmp_l <= 1'b0;
        pmp_x <= 1'b0;
        pmp_w <= 1'b0;
        pmp_r <= 1'b0;
    end
    else begin
        pmp_v <= pmp_v_tmp;
        pmp_l <= pmp_l_tmp;
        pmp_x <= pmp_x_tmp;
        pmp_w <= pmp_w_tmp;
        pmp_r <= pmp_r_tmp;
    end
end

logic [     15:0] pma_match;
logic             pma_v_tmp;
logic             pma_l_tmp;
logic             pma_c_tmp;
logic             pma_e_tmp;

generate
    for (g = 0; g < 16; g = g + 1) begin: g_pma
        logic [  `XLEN:0] mask_tmp;
        logic [`XLEN+2:0] mask;
        logic             napot_match;
        logic             tor_match;

        assign mask_tmp = {pmaaddr[g], pmacfg[g][`PMACFG_A_BIT] != `PMACFG_A_NA4};
        assign mask     = {~(mask_tmp & ~(mask_tmp + {`XLEN'b0, 1'b1})), 2'b0};

        assign napot_match = ~|(({pmaaddr[g][0+:`PADDR_LEN-2], 2'b0} ^ paddr) & mask[0+:`PADDR_LEN]);
        if (g == 0) begin: g_first
            assign tor_match = {`PADDR_LEN{1'b0}} <= paddr && paddr < {pmaaddr[g][0+:`PADDR_LEN-2], 2'b0};
        end
        else begin: g_non_first
            assign tor_match = {pmaaddr[g-1][0+:`PADDR_LEN-2], 2'b0} <= paddr &&
                               paddr < {pmaaddr[g][0+:`PADDR_LEN-2], 2'b0};
        end
        
        assign pma_match[g] = (pmacfg[g][`PMACFG_A_BIT] == `PMACFG_A_TOR   && tor_match) |
                              (pmacfg[g][`PMACFG_A_BIT] == `PMACFG_A_NA4   && napot_match) |
                              (pmacfg[g][`PMACFG_A_BIT] == `PMACFG_A_NAPOT && napot_match);
    end
endgenerate

assign pma_v_tmp = |pma_match;

always_comb begin
    integer i;
    pma_l_tmp = 1'b0;
    pma_c_tmp = 1'b0;
    pma_e_tmp = 1'b0;
    for (i = 0; i < 16; i = i + 1) begin
        pma_l_tmp = pma_l_tmp | (pma_match[i] & pmacfg[i][`PMACFG_L_BIT]);
        pma_c_tmp = pma_c_tmp | (pma_match[i] & pmacfg[i][`PMACFG_C_BIT]);
        pma_e_tmp = pma_e_tmp | (pma_match[i] & pmacfg[i][`PMACFG_E_BIT]);
    end
    for (i = 0; i < 16; i = i + 1) begin
        pma_c_tmp = pma_c_tmp & ~(pma_match[i] & ~pmacfg[i][`PMACFG_C_BIT]);
        pma_e_tmp = pma_e_tmp & ~(pma_match[i] & ~pmacfg[i][`PMACFG_E_BIT]);
    end
end

// assign pma_v = pma_v_tmp;
// assign pma_l = pma_l_tmp;
// assign pma_c = pma_c_tmp;
// assign pma_e = pma_e_tmp;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        pma_v <= 1'b0;
        pma_l <= 1'b0;
        pma_c <= 1'b0;
        pma_e <= 1'b0;
    end
    else begin
        pma_v <= pma_v_tmp;
        pma_l <= pma_l_tmp;
        pma_c <= pma_c_tmp;
        pma_e <= pma_e_tmp;
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/mmu_csr.sv
/*--------------------------------------*/

`ifndef __CSR_DEFINE__
`define __CSR_DEFINE__

`define CSR_WDATA(DEST, RANGE) \
        ((``DEST`` | csr_sdata[RANGE]) & ~csr_cdata[RANGE])

`endif

module mmu_csr (
    input                               clk,
    input                               rstn,

    input        [                 1:0] misa_mxl,

    output logic [ `SATP_PPN_WIDTH-1:0] satp_ppn,
    output logic [`SATP_ASID_WIDTH-1:0] satp_asid,
    output logic [`SATP_MODE_WIDTH-1:0] satp_mode,
    // CSR interface
    input                               csr_wr,
    input        [                11:0] csr_waddr,
    input        [                11:0] csr_raddr,
    // input        [           `XLEN-1:0] csr_wdata,
    input        [           `XLEN-1:0] csr_sdata,
    input        [           `XLEN-1:0] csr_cdata,
    output logic [           `XLEN-1:0] csr_rdata
);

logic [           `XLEN-1:0] satp;

`ifdef RV32
assign satp = {satp_mode, satp_asid, satp_ppn};
`else
assign satp = misa_mxl == 2'h1 ? {32'b0, satp_mode[0+:`SATP32_MODE_WIDTH],
                                         satp_asid[0+:`SATP32_ASID_WIDTH],
                                         satp_ppn [0+:`SATP32_PPN_WIDTH]}:
                                 {satp_mode, satp_asid, satp_ppn};
`endif

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        satp_ppn  <= `SATP_PPN_WIDTH'b0;
        satp_asid <= `SATP_ASID_WIDTH'b0;
        satp_mode <= `SATP_MODE_WIDTH'b0;
    end
    else if (csr_wr && csr_waddr == `CSR_SATP_ADDR) begin
`ifdef RV32
        satp_ppn  <= `CSR_WDATA(satp_ppn ,  `SATP32_PPN_BIT);
        satp_asid <= `CSR_WDATA(satp_asid, `SATP32_ASID_BIT);
        satp_mode <= `CSR_WDATA(satp_mode, `SATP32_MODE_BIT);
`else
        satp_ppn  <= misa_mxl == 2'h1 ? `CSR_WDATA(satp_ppn , `SATP32_PPN_BIT):
                                        `CSR_WDATA(satp_ppn , `SATP64_PPN_BIT);
        satp_asid <= misa_mxl == 2'h1 ? `CSR_WDATA(satp_asid, `SATP32_ASID_BIT):
                                        `CSR_WDATA(satp_asid, `SATP64_ASID_BIT);
        satp_mode <= misa_mxl == 2'h1 ? `CSR_WDATA(satp_mode, `SATP32_MODE_BIT):
                                        `CSR_WDATA(satp_mode, `SATP64_MODE_BIT);
`endif
    end
end

always_comb begin
    csr_rdata = `XLEN'b0;
    case (csr_raddr) 
        `CSR_SATP_ADDR   : csr_rdata = satp;
    endcase
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/mmu.sv
/*--------------------------------------*/

`ifndef __INTF_DEFINE__
`define __INTF_DEFINE__

`define AXI_INTF_CONNECT(PORT, WIRE) \
    .``PORT``_awburst ( WIRE``_awburst ), \
    .``PORT``_awid    ( WIRE``_awid    ), \
    .``PORT``_awaddr  ( WIRE``_awaddr  ), \
    .``PORT``_awsize  ( WIRE``_awsize  ), \
    .``PORT``_awlen   ( WIRE``_awlen   ), \
    .``PORT``_awlock  ( WIRE``_awlock  ), \
    .``PORT``_awcache ( WIRE``_awcache ), \
    .``PORT``_awprot  ( WIRE``_awprot  ), \
    .``PORT``_awvalid ( WIRE``_awvalid ), \
    .``PORT``_awready ( WIRE``_awready ), \
    .``PORT``_wstrb   ( WIRE``_wstrb   ), \
    .``PORT``_wid     ( WIRE``_wid     ), \
    .``PORT``_wdata   ( WIRE``_wdata   ), \
    .``PORT``_wlast   ( WIRE``_wlast   ), \
    .``PORT``_wvalid  ( WIRE``_wvalid  ), \
    .``PORT``_wready  ( WIRE``_wready  ), \
    .``PORT``_bid     ( WIRE``_bid     ), \
    .``PORT``_bresp   ( WIRE``_bresp   ), \
    .``PORT``_bvalid  ( WIRE``_bvalid  ), \
    .``PORT``_bready  ( WIRE``_bready  ), \
    .``PORT``_araddr  ( WIRE``_araddr  ), \
    .``PORT``_arburst ( WIRE``_arburst ), \
    .``PORT``_arsize  ( WIRE``_arsize  ), \
    .``PORT``_arid    ( WIRE``_arid    ), \
    .``PORT``_arlen   ( WIRE``_arlen   ), \
    .``PORT``_arlock  ( WIRE``_arlock  ), \
    .``PORT``_arcache ( WIRE``_arcache ), \
    .``PORT``_arprot  ( WIRE``_arprot  ), \
    .``PORT``_arvalid ( WIRE``_arvalid ), \
    .``PORT``_arready ( WIRE``_arready ), \
    .``PORT``_rdata   ( WIRE``_rdata   ), \
    .``PORT``_rresp   ( WIRE``_rresp   ), \
    .``PORT``_rid     ( WIRE``_rid     ), \
    .``PORT``_rlast   ( WIRE``_rlast   ), \
    .``PORT``_rvalid  ( WIRE``_rvalid  ), \
    .``PORT``_rready  ( WIRE``_rready  )

`define AXI_INTF_SLV_DEF(NAME, ID) \
    input         [     1: 0] NAME``_awburst, \
    input         [ID - 1: 0] NAME``_awid,    \
    input         [    31: 0] NAME``_awaddr,  \
    input         [     2: 0] NAME``_awsize,  \
    input         [     7: 0] NAME``_awlen,   \
    input         [     1: 0] NAME``_awlock,  \
    input         [     3: 0] NAME``_awcache, \
    input         [     2: 0] NAME``_awprot,  \
    input                     NAME``_awvalid, \
    output logic              NAME``_awready, \
    input         [     3: 0] NAME``_wstrb,   \
    input         [ID - 1: 0] NAME``_wid,     \
    input         [    31: 0] NAME``_wdata,   \
    input                     NAME``_wlast,   \
    input                     NAME``_wvalid,  \
    output logic              NAME``_wready,  \
    output logic  [ID - 1: 0] NAME``_bid,     \
    output logic  [     1: 0] NAME``_bresp,   \
    output logic              NAME``_bvalid,  \
    input                     NAME``_bready,  \
    input         [    31: 0] NAME``_araddr,  \
    input         [     1: 0] NAME``_arburst, \
    input         [     2: 0] NAME``_arsize,  \
    input         [ID - 1: 0] NAME``_arid,    \
    input         [     7: 0] NAME``_arlen,   \
    input         [     1: 0] NAME``_arlock,  \
    input         [     3: 0] NAME``_arcache, \
    input         [     2: 0] NAME``_arprot,  \
    input                     NAME``_arvalid, \
    output logic              NAME``_arready, \
    output logic  [    31: 0] NAME``_rdata,   \
    output logic  [     1: 0] NAME``_rresp,   \
    output logic  [ID - 1: 0] NAME``_rid,     \
    output logic              NAME``_rlast,   \
    output logic              NAME``_rvalid,  \
    input                     NAME``_rready

`define AXI_INTF_MST_DEF(NAME, ID) \
    output logic  [     1: 0] NAME``_awburst, \
    output logic  [ID - 1: 0] NAME``_awid,    \
    output logic  [    31: 0] NAME``_awaddr,  \
    output logic  [     2: 0] NAME``_awsize,  \
    output logic  [     7: 0] NAME``_awlen,   \
    output logic  [     1: 0] NAME``_awlock,  \
    output logic  [     3: 0] NAME``_awcache, \
    output logic  [     2: 0] NAME``_awprot,  \
    output logic              NAME``_awvalid, \
    input                     NAME``_awready, \
    output logic  [     3: 0] NAME``_wstrb,   \
    output logic  [ID - 1: 0] NAME``_wid,     \
    output logic  [    31: 0] NAME``_wdata,   \
    output logic              NAME``_wlast,   \
    output logic              NAME``_wvalid,  \
    input                     NAME``_wready,  \
    input         [ID - 1: 0] NAME``_bid,     \
    input         [     1: 0] NAME``_bresp,   \
    input                     NAME``_bvalid,  \
    output logic              NAME``_bready,  \
    output logic  [    31: 0] NAME``_araddr,  \
    output logic  [     1: 0] NAME``_arburst, \
    output logic  [     2: 0] NAME``_arsize,  \
    output logic  [ID - 1: 0] NAME``_arid,    \
    output logic  [     7: 0] NAME``_arlen,   \
    output logic  [     1: 0] NAME``_arlock,  \
    output logic  [     3: 0] NAME``_arcache, \
    output logic  [     2: 0] NAME``_arprot,  \
    output logic              NAME``_arvalid, \
    input                     NAME``_arready, \
    input         [    31: 0] NAME``_rdata,   \
    input         [     1: 0] NAME``_rresp,   \
    input         [ID - 1: 0] NAME``_rid,     \
    input                     NAME``_rlast,   \
    input                     NAME``_rvalid,  \
    output logic              NAME``_rready

`define AXI_INTF_DEF(NAME, ID) \
    logic  [     1: 0] NAME``_awburst; \
    logic  [ID - 1: 0] NAME``_awid;    \
    logic  [    31: 0] NAME``_awaddr;  \
    logic  [     2: 0] NAME``_awsize;  \
    logic  [     7: 0] NAME``_awlen;   \
    logic  [     1: 0] NAME``_awlock;  \
    logic  [     3: 0] NAME``_awcache; \
    logic  [     2: 0] NAME``_awprot;  \
    logic              NAME``_awvalid; \
    logic              NAME``_awready; \
    logic  [     3: 0] NAME``_wstrb;   \
    logic  [ID - 1: 0] NAME``_wid;     \
    logic  [    31: 0] NAME``_wdata;   \
    logic              NAME``_wlast;   \
    logic              NAME``_wvalid;  \
    logic              NAME``_wready;  \
    logic  [ID - 1: 0] NAME``_bid;     \
    logic  [     1: 0] NAME``_bresp;   \
    logic              NAME``_bvalid;  \
    logic              NAME``_bready;  \
    logic  [    31: 0] NAME``_araddr;  \
    logic  [     1: 0] NAME``_arburst; \
    logic  [     2: 0] NAME``_arsize;  \
    logic  [ID - 1: 0] NAME``_arid;    \
    logic  [     7: 0] NAME``_arlen;   \
    logic  [     1: 0] NAME``_arlock;  \
    logic  [     3: 0] NAME``_arcache; \
    logic  [     2: 0] NAME``_arprot;  \
    logic              NAME``_arvalid; \
    logic              NAME``_arready; \
    logic  [    31: 0] NAME``_rdata;   \
    logic  [     1: 0] NAME``_rresp;   \
    logic  [ID - 1: 0] NAME``_rid;     \
    logic              NAME``_rlast;   \
    logic              NAME``_rvalid;  \
    logic              NAME``_rready;

`define APB_MST_PORT_TO_INTF(PORT, INTF)    \
    assign INTF``.psel    = PORT``_psel;    \
    assign INTF``.penable = PORT``_penable; \
    assign INTF``.paddr   = PORT``_paddr;   \
    assign INTF``.pwrite  = PORT``_pwrite;  \
    assign INTF``.pstrb   = PORT``_pstrb;   \
    assign INTF``.pprot   = PORT``_pprot;   \
    assign INTF``.pwdata  = PORT``_pwdata;  \
    assign PORT``_prdata  = INTF``.prdata;  \
    assign PORT``_pslverr = INTF``.pslverr; \
    assign PORT``_pready  = INTF``.pready;

`define APB_MST_INTF_TO_PORT(INTF, PORT)    \
    assign PORT``_psel    = INTF``.psel;    \
    assign PORT``_penable = INTF``.penable; \
    assign PORT``_paddr   = INTF``.paddr;   \
    assign PORT``_pwrite  = INTF``.pwrite;  \
    assign PORT``_pstrb   = INTF``.pstrb;   \
    assign PORT``_pprot   = INTF``.pprot;   \
    assign PORT``_pwdata  = INTF``.pwdata;  \
    assign INTF``.prdata  = PORT``_prdata;  \
    assign INTF``.pslverr = PORT``_pslverr; \
    assign INTF``.pready  = PORT``_pready;

`define AXI_MST_PORT_TO_INTF(PORT, INTF)    \
    assign INTF``.awid    = PORT``_awid;    \
    assign INTF``.awaddr  = PORT``_awaddr;  \
    assign INTF``.awburst = PORT``_awburst; \
    assign INTF``.awsize  = PORT``_awsize;  \
    assign INTF``.awlen   = PORT``_awlen;   \
    assign INTF``.awlock  = PORT``_awlock;  \
    assign INTF``.awcache = PORT``_awcache; \
    assign INTF``.awprot  = PORT``_awprot;  \
    assign INTF``.awvalid = PORT``_awvalid; \
    assign PORT``_awready = INTF``.awready; \
    assign INTF``.wid     = PORT``_wid;     \
    assign INTF``.wstrb   = PORT``_wstrb;   \
    assign INTF``.wdata   = PORT``_wdata;   \
    assign INTF``.wlast   = PORT``_wlast;   \
    assign INTF``.wvalid  = PORT``_wvalid;  \
    assign PORT``_wready  = INTF``.wready;  \
    assign PORT``_bid     = INTF``.bid;     \
    assign PORT``_bresp   = INTF``.bresp;   \
    assign PORT``_bvalid  = INTF``.bvalid;  \
    assign INTF``.bready  = PORT``_bready;  \
    assign INTF``.arid    = PORT``_arid;    \
    assign INTF``.araddr  = PORT``_araddr;  \
    assign INTF``.arburst = PORT``_arburst; \
    assign INTF``.arsize  = PORT``_arsize;  \
    assign INTF``.arlen   = PORT``_arlen;   \
    assign INTF``.arlock  = PORT``_arlock;  \
    assign INTF``.arcache = PORT``_arcache; \
    assign INTF``.arprot  = PORT``_arprot;  \
    assign INTF``.arvalid = PORT``_arvalid; \
    assign PORT``_arready = INTF``.arready; \
    assign PORT``_rid     = INTF``.rid;     \
    assign PORT``_rdata   = INTF``.rdata;   \
    assign PORT``_rresp   = INTF``.rresp;   \
    assign PORT``_rlast   = INTF``.rlast;   \
    assign PORT``_rvalid  = INTF``.rvalid;  \
    assign INTF``.rready  = PORT``_rready;


`define AXI_MST_INTF_TO_PORT(INTF, PORT)    \
    assign PORT``_awid    = INTF``.awid;    \
    assign PORT``_awaddr  = INTF``.awaddr;  \
    assign PORT``_awburst = INTF``.awburst; \
    assign PORT``_awsize  = INTF``.awsize;  \
    assign PORT``_awlen   = INTF``.awlen;   \
    assign PORT``_awlock  = INTF``.awlock;  \
    assign PORT``_awcache = INTF``.awcache; \
    assign PORT``_awprot  = INTF``.awprot;  \
    assign PORT``_awvalid = INTF``.awvalid; \
    assign INTF``.awready = PORT``_awready; \
    assign PORT``_wid     = INTF``.wid;     \
    assign PORT``_wstrb   = INTF``.wstrb;   \
    assign PORT``_wdata   = INTF``.wdata;   \
    assign PORT``_wlast   = INTF``.wlast;   \
    assign PORT``_wvalid  = INTF``.wvalid;  \
    assign INTF``.wready  = PORT``_wready;  \
    assign INTF``.bid     = PORT``_bid;     \
    assign INTF``.bresp   = PORT``_bresp;   \
    assign INTF``.bvalid  = PORT``_bvalid;  \
    assign PORT``_bready  = INTF``.bready;  \
    assign PORT``_arid    = INTF``.arid;    \
    assign PORT``_araddr  = INTF``.araddr;  \
    assign PORT``_arburst = INTF``.arburst; \
    assign PORT``_arsize  = INTF``.arsize;  \
    assign PORT``_arlen   = INTF``.arlen;   \
    assign PORT``_arlock  = INTF``.arlock;  \
    assign PORT``_arcache = INTF``.arcache; \
    assign PORT``_arprot  = INTF``.arprot;  \
    assign PORT``_arvalid = INTF``.arvalid; \
    assign INTF``.arready = PORT``_arready; \
    assign INTF``.rid     = PORT``_rid;     \
    assign INTF``.rdata   = PORT``_rdata;   \
    assign INTF``.rresp   = PORT``_rresp;   \
    assign INTF``.rlast   = PORT``_rlast;   \
    assign INTF``.rvalid  = PORT``_rvalid;  \
    assign PORT``_rready  = INTF``.rready;

`endif
`ifndef __AXI_DEFINE__
`define __AXI_DEFINE__

`define AXI_BURST_FIXED 2'b00
`define AXI_BURST_INCR  2'b01
`define AXI_BURST_WRAP  2'b10

`define AXI_RESP_OKAY   2'b00
`define AXI_RESP_EXOKAY 2'b01
`define AXI_RESP_SLVERR 2'b10
`define AXI_RESP_DECERR 2'b11

`endif
`ifndef __TLB_DEFINE__
`define __TLB_DEFINE__

`define BUS_WIDTH     34
`define TLB_WAY_NUM   4
`define TLB_IDX_WIDTH 1
`define TLB_DEPTH     (2 ** `TLB_IDX_WIDTH)
`define TLB_VPN_WIDTH 36
`define TLB_PTE_WIDTH 64
`define TLB_TAG_WIDTH (`TLB_VPN_WIDTH - `TLB_IDX_WIDTH)

`endif

module mmu (
    input                                    clk,
    input                                    rstn,
    
    // access type
    input                                    access_w,
    input                                    access_x,
    input                                    access_ex,

    // mpu csr
    input                                    pmp_v,
    input                                    pmp_l,
    input                                    pmp_x,
    input                                    pmp_w,
    input                                    pmp_r,

    input                                    pma_v,
    input                                    pma_l,
    input                                    pma_c,
    input                                    pma_e,

    // TLB control
    input                                    tlb_flush_req,
    input                                    tlb_flush_all_vaddr,
    input                                    tlb_flush_all_asid,
    input        [              `XLEN - 1:0] tlb_flush_vaddr,
    input        [              `XLEN - 1:0] tlb_flush_asid,

    // mmu csr
    input                                    rv64_mode,
    input        [    `SATP_PPN_WIDTH - 1:0] satp_ppn,
    input        [   `SATP_ASID_WIDTH - 1:0] satp_asid,
    input        [   `SATP_MODE_WIDTH - 1:0] satp_mode,
    input        [                      1:0] prv,
    input                                    sum,
    input                                    mprv,
    input        [                      1:0] mpp,

    // virtual address
    input                                    va_valid,
    input        [                     63:0] va,

    // Cache ctrl
    output logic                             cache_bypass,

    // physical address
    output logic                             pa_valid,
    output logic [                      1:0] pa_bad,
    output logic [                     55:0] pa,
    output logic                             pa_pre_vld,
    output logic                             pa_pre_wr,
    output logic                             pa_pre_rd,
    output logic                             pa_pre_ex,
    output logic [                     63:0] pa_pre,
    
    // AXI interface
    axi_intf.master                          m_axi_intf
);

parameter [1:0] STATE_IDLE  = 2'b00,
                STATE_CHECK = 2'b01,
                STATE_MREQ  = 2'b10,
                STATE_PTE   = 2'b11;

logic [                 1:0] cur_state;
logic [                 1:0] nxt_state;

logic                        va_en;
logic [                55:0] va_latch;
logic                        last_hit;
logic                        last_va_en;
logic [                35:0] last_vpn;
logic [                 2:0] last_spage;
logic [                35:0] vpn;
logic [                36:0] vpn_latch;
logic [                21:0] ppn_latch;
logic [`SATP_MODE_WIDTH-1:0] satp_mode_latch;
logic                        busy;
logic                        leaf;
logic                        sum_latch;
logic                        access_r_latch;
logic                        access_w_latch;
logic                        access_x_latch;
logic                        access_ex_latch;
logic [                63:0] pte_latch;
logic [                43:0] pte_ppn, tlb_pte_ppn, last_pte_ppn;
logic [                 1:0] pte_rsw, tlb_pte_rsw, last_pte_rsw;
logic                        pte_d,   tlb_pte_d  , last_pte_d  ;
logic                        pte_a,   tlb_pte_a  , last_pte_a  ;
logic                        pte_g,   tlb_pte_g  , last_pte_g  ;
logic                        pte_u,   tlb_pte_u  , last_pte_u  ;
logic                        pte_x,   tlb_pte_x  , last_pte_x  ;
logic                        pte_w,   tlb_pte_w  , last_pte_w  ;
logic                        pte_r,   tlb_pte_r  , last_pte_r  ;
logic                        pte_v,   tlb_pte_v  , last_pte_v  ;
logic                        tlb_data_sel;
logic [                 5:0] spage;
logic                        bus_boundary;
logic                        pmp_err;
logic                        pg_fault;
logic                        pg_fault_tlb;
logic                        pg_fault_pte;
logic                        bus_err;
logic                        ar_done;
logic [                 1:0] prv_post;
logic [                 1:0] prv_latch;

logic                        tlb_cs;
logic                        tlb_we;
logic                        tlb_hit;
logic [  `TLB_VPN_WIDTH-1:0] tlb_vpn;
logic [  `TLB_PTE_WIDTH-1:0] tlb_pte_in;
logic [  `TLB_PTE_WIDTH-1:0] tlb_pte_out;
logic [                 2:0] tlb_spage_in;
logic [                 2:0] tlb_spage_out;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) cur_state <= STATE_IDLE;
    else       cur_state <= nxt_state;
end

always_comb begin
    nxt_state = cur_state;
    case (cur_state)
        STATE_IDLE : begin
            nxt_state = (va_en && ~last_hit) && va_valid ? STATE_CHECK : STATE_IDLE;
        end
        STATE_CHECK: begin
            nxt_state = ~tlb_hit ? STATE_MREQ:
                                   STATE_IDLE;
        end
        STATE_MREQ : begin
            nxt_state = m_axi_intf.rvalid && m_axi_intf.rresp[1] ? STATE_IDLE:
                        m_axi_intf.rvalid && m_axi_intf.rlast    ? STATE_PTE :
                                                                   STATE_MREQ;
        end
        STATE_PTE  : begin
            nxt_state = leaf || pg_fault_pte ? STATE_IDLE:
                                               STATE_MREQ;
        end
    endcase
end

always_comb begin
    m_axi_intf.arvalid = 1'b0;
    tlb_cs             = 1'b0;
    tlb_we             = 1'b0;
    pa_pre_vld         = 1'b0;
    pa_pre_wr          = access_w_latch;
    pa_pre_rd          = access_r_latch;
    pa_pre_ex          = access_ex_latch;
    busy               = 1'b0;
    tlb_data_sel       = 1'b0;
    case (cur_state)
        STATE_IDLE : begin
            tlb_cs             = va_en;
            pa_pre_vld         = va_valid && (~va_en || last_hit);
            pa_pre_wr          = ~access_x &  access_w;
            pa_pre_rd          = ~access_x & ~access_w;
            pa_pre_ex          = access_ex;
            busy               = 1'b0;
        end
        STATE_CHECK: begin
            pa_pre_vld         = tlb_hit;
            busy               = 1'b1;
            tlb_data_sel       = 1'b1;
        end
        STATE_MREQ : begin
            m_axi_intf.arvalid = ~ar_done;
            pa_pre_vld         = m_axi_intf.rvalid && m_axi_intf.rresp[1];
            busy               = 1'b1;
        end
        STATE_PTE  : begin
            pa_pre_vld         = leaf ||  pg_fault_pte;
            tlb_cs             = leaf && ~pg_fault_pte;
            tlb_we             = 1'b1;
            busy               = 1'b1;
        end
    endcase
end

assign prv_post     = ~access_x && mprv ? mpp : prv;
assign leaf         = pte_v && (pte_r || pte_x);
assign pg_fault_pte = !pte_v || (!pte_r && pte_w) ||
                      (~leaf && ~spage[0]) ||
`ifdef RV32
                      ( leaf && spage[0] && |pte_ppn[9:0]) ||
`else
                      ( leaf && spage[0] && ~satp_mode_latch[3] && |pte_ppn[ 0+:10]) ||
                      ( leaf && spage[0] &&  satp_mode_latch[3] && |pte_ppn[ 0+: 9]) ||
                      ( leaf && spage[1] &&  satp_mode_latch[3] && |pte_ppn[ 9+: 9]) ||
                      ( leaf && spage[2] &&  satp_mode_latch[3] && |pte_ppn[18+: 9]) ||
`endif
                      ( leaf && access_x_latch      && ~pte_x) ||
                      ( leaf && access_r_latch      && ~pte_r) ||
                      ( leaf && access_w_latch      && ~pte_w) ||
                      ( leaf && prv_latch == `PRV_U && ~pte_u) ||
                      ( leaf && prv_latch == `PRV_S &&  pte_u && (~sum_latch || access_x_latch)) ||
                      ( leaf && access_w_latch      && ~pte_d) ||
                      ( leaf                        && ~pte_a);

assign pg_fault_tlb = (access_x_latch      && ~tlb_pte_x) ||
                      (access_r_latch      && ~tlb_pte_r) ||
                      (access_w_latch      && ~tlb_pte_w) ||
                      (prv_latch == `PRV_U && ~tlb_pte_u) ||
                      (prv_latch == `PRV_S &&  tlb_pte_u && (~sum_latch || access_x_latch)) ||
                      (access_w_latch      && ~tlb_pte_d) ||
                      (                       ~tlb_pte_a);

assign pg_fault_last = ( access_x              && ~last_pte_x) ||
                       (~access_w && ~access_x && ~last_pte_r) ||
                       ( access_w && ~access_x && ~last_pte_w) ||
                       ( prv_post == `PRV_U    && ~last_pte_u) ||
                       ( prv_post == `PRV_S    &&  last_pte_u && (~sum || access_x)) ||
                       ( access_w && ~access_x && ~last_pte_d) ||
                       (                          ~last_pte_a);

assign bus_boundary = |pa_pre[63:`BUS_WIDTH-1] & ~&pa_pre[63:`BUS_WIDTH-1];

assign pmp_err      = (!pmp_v && prv_latch != `PRV_M) ||
                      (( pmp_l || prv_latch != `PRV_M) &&
                      ((!pmp_x && access_x_latch) ||
                       (!pmp_w && access_w_latch) ||
                       (!pmp_r && access_r_latch)));
                    
assign tlb_spage_in = spage[2:0];
`ifdef RV32
assign tlb_vpn      = {16'b0, busy ? va_latch[12+:20] : va[12+:20]};
`else
assign tlb_vpn      = ({36{~satp_mode_latch[3]}} & {16'b0, busy ? va_latch[12+:20] : va[12+:20]}) |
                      ({36{ satp_mode_latch[3]}} & {       busy ? va_latch[12+:36] : va[12+:36]});
`endif
assign tlb_pte_in   = pte_latch;
assign {pte_ppn, pte_rsw, pte_d, pte_a, pte_g, pte_u, pte_x, pte_w, pte_r, pte_v} =
`ifdef RV32
       {22'b0, pte_latch[31:0]};
`else
       ({54{~satp_mode_latch[3]}} & {22'b0, pte_latch[31:0]}) |
       ({54{ satp_mode_latch[3]}} & {       pte_latch[53:0]});
`endif
assign {tlb_pte_ppn, tlb_pte_rsw, tlb_pte_d, tlb_pte_a, tlb_pte_g,
        tlb_pte_u,   tlb_pte_x,   tlb_pte_w, tlb_pte_r, tlb_pte_v} =
`ifdef RV32
       {22'b0, tlb_pte_out[31:0]};
`else
       ({54{~satp_mode_latch[3]}} & {22'b0, tlb_pte_out[31:0]}) |
       ({54{ satp_mode_latch[3]}} & {       tlb_pte_out[53:0]});
`endif

assign m_axi_intf.awid     = 10'b0;
assign m_axi_intf.awaddr   = 32'b0;
assign m_axi_intf.awburst  = `AXI_BURST_FIXED;
assign m_axi_intf.awsize   = 3'h0;
assign m_axi_intf.awlen    = 8'b0;
assign m_axi_intf.awlock   = 2'h0;
assign m_axi_intf.awcache  = 4'h0;
assign m_axi_intf.awprot   = 3'h0;
assign m_axi_intf.awvalid  = 1'b0;
assign m_axi_intf.wid      = 10'b0;
assign m_axi_intf.wstrb    = 4'b0;
assign m_axi_intf.wlast    = 1'b0;
assign m_axi_intf.wdata    = 32'b0;
assign m_axi_intf.wvalid   = 1'b0;
assign m_axi_intf.bready   = 1'b1;

assign m_axi_intf.arid     = 10'b0;
`ifdef RV32
assign m_axi_intf.araddr   = {ppn_latch[19:0], vpn_latch[9:0], 2'b0};
`else
assign m_axi_intf.araddr   = {ppn_latch[19:0], vpn_latch[9:1], vpn_latch[0] & ~satp_mode_latch[3], 2'b0};
`endif
assign m_axi_intf.arburst  = `AXI_BURST_INCR;
assign m_axi_intf.arsize   = 3'h2;
`ifdef RV32
assign m_axi_intf.arlen    = 8'h0;
`else
assign m_axi_intf.arlen    = {7'h0, satp_mode_latch[3]};
`endif
assign m_axi_intf.arlock   = 2'h0;
assign m_axi_intf.arcache  = 4'h0;
assign m_axi_intf.arprot   = 3'h0;
assign m_axi_intf.rready   = 1'b1;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        spage <= 6'b0;
    end
    else if (va_valid) begin
`ifdef RV32
        spage <= 6'b11;
`else
        spage <= ({3{satp_mode == `SATP_MODE_SV32}} & 6'b000011)|
                 ({3{satp_mode == `SATP_MODE_SV39}} & 6'b000111)|
                 ({3{satp_mode == `SATP_MODE_SV48}} & 6'b001111)|
                 ({3{satp_mode == `SATP_MODE_SV57}} & 6'b011111)|
                 ({3{satp_mode == `SATP_MODE_SV64}} & 6'b111111);
`endif
    end
    else if (m_axi_intf.rvalid && m_axi_intf.rlast) begin
        spage <= {1'b0, spage[5:1]};
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        ar_done <= 1'b0;
    end
    else if (cur_state == STATE_CHECK || cur_state == STATE_PTE) begin
        ar_done <= 1'b0;
    end
    else if (m_axi_intf.arready) begin
        ar_done <= 1'b1;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        vpn_latch <= 37'b0;
    end
    else if (cur_state == STATE_CHECK) begin
`ifdef RV32
        vpn_latch[19:0] <= {va_latch[12+:10], va_latch[22+:10]};
`else
        vpn_latch <= ({37{satp_mode_latch == `SATP_MODE_SV32}} & {17'b0, va_latch[12+:10], va_latch[22+:10]}) |
                     ({37{satp_mode_latch == `SATP_MODE_SV39}} & {9'b0, va_latch[12+:9], va_latch[21+:9], va_latch[30+:9], 1'b0}) |
                     ({37{satp_mode_latch == `SATP_MODE_SV48}} & {va_latch[12+:9], va_latch[21+:9], va_latch[30+:9], va_latch[39+:9], 1'b0});
`endif
    end
    else if (m_axi_intf.rvalid && m_axi_intf.rlast) begin
`ifdef RV32
        vpn_latch[19:0] <= {10'b0, vpn_latch[10+:10]};
`else
        vpn_latch <= ({37{~satp_mode_latch[3]}} & {10'b0, vpn_latch[36:10]}) |
                     ({37{ satp_mode_latch[3]}} & { 9'b0, vpn_latch[36:10], 1'b0});
`endif
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        ppn_latch <= 22'b0;
    end
    else if (cur_state == STATE_IDLE) begin
        ppn_latch <= va[33:12];
    end
    else if (cur_state == STATE_CHECK) begin
        ppn_latch <= satp_ppn;
    end
    else if (cur_state == STATE_PTE) begin
        ppn_latch <= pte_ppn;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        pte_latch <= 64'b0;
    end
    else if (m_axi_intf.rvalid) begin
`ifdef RV32
        pte_latch[31:0] <= m_axi_intf.rdata;
`else
        if (satp_mode_latch[3] && m_axi_intf.rlast) begin
            pte_latch[63:32] <= m_axi_intf.rdata;
        end
        else begin
            pte_latch[31: 0] <= m_axi_intf.rdata;
        end
`endif
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)         va_latch <= 56'b0;
    else if (va_valid) va_latch <= {8'b0, va};
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)           pa <= 56'b0;
    else if (pa_pre_vld) pa <= pa_pre[55:0];
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        prv_latch       <= 2'b0;
        sum_latch       <= 1'b0;
        access_r_latch  <= 1'b0;
        access_w_latch  <= 1'b0;
        access_x_latch  <= 1'b0;
        access_ex_latch <= 1'b0;
        satp_mode_latch <= `SATP_MODE_WIDTH'b0;
    end
    else if (va_valid) begin
        prv_latch       <= prv_post;
        sum_latch       <= sum;
        access_r_latch  <= ~access_x & ~access_w;
        access_w_latch  <= ~access_x &  access_w;
        access_x_latch  <=  access_x;
        access_ex_latch <=  access_ex;
        satp_mode_latch <= satp_mode;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        pa_valid <= 1'b0;
    end
    else begin
        pa_valid <= pa_pre_vld;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        pg_fault <= 1'b0;
    end
    else if (cur_state == STATE_IDLE) begin
        pg_fault <= last_hit ? pg_fault_last : 1'b0;
    end
    else if (cur_state == STATE_PTE) begin
        pg_fault <= pg_fault_pte;
    end
    else if (tlb_hit) begin
        pg_fault <= pg_fault_tlb;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        bus_err <= 1'b0;
    end
    else begin
        bus_err <= (m_axi_intf.rvalid && m_axi_intf.rresp[1]) || bus_boundary;
    end
end

assign cache_bypass = ~pma_c;
assign pa_bad       = {(bus_err | pmp_err) & ~pg_fault, pg_fault};

assign pa_pre       = ~va_en                  ? {{32{rv64_mode}} & va[32+:32], va[0+:32]}:
                      tlb_data_sel            ? {{32{tlb_pte_ppn[21]}}, tlb_pte_ppn, va_latch[11:0]}:
`ifdef RV32
                      cur_state == STATE_IDLE ? {{32{last_pte_ppn[21]}}, last_pte_ppn[21:10], last_spage[0] ? va[21:12] : last_pte_ppn[9:0], va[11:0]}:
                                                {{32{pte_ppn[21]}}, pte_ppn[21:10], spage[0] ? va_latch[21:12] : pte_ppn[9:0], va_latch[11:0]};
`else
                      cur_state == STATE_IDLE ? (({64{~satp_mode[3]}} & {{32{last_pte_ppn[21]}}, last_pte_ppn[21:10], last_spage[0] ? va[12+:10] : last_pte_ppn[0+:10], va[11:0]})|
                                                 ({64{ satp_mode[3]}} & {{ 8{last_pte_ppn[43]}}, last_pte_ppn[43:27],
                                                                         last_spage[2] ? va[30+: 9] : last_pte_ppn[18+: 9],
                                                                         last_spage[1] ? va[21+: 9] : last_pte_ppn[ 9+: 9],
                                                                         last_spage[0] ? va[12+: 9] : last_pte_ppn[ 0+: 9], va[11:0]})):
                                                (({64{~satp_mode[3]}} & {{32{pte_ppn[21]}}, pte_ppn[21:10], spage[0] ? va_latch[21:12] : pte_ppn[9:0], va_latch[11:0]})|
                                                 ({64{ satp_mode[3]}} & {{ 8{pte_ppn[43]}}, pte_ppn[43:27],
                                                                         spage[2] ? va_latch[30+: 9] : pte_ppn[18+: 9],
                                                                         spage[1] ? va_latch[21+: 9] : pte_ppn[ 9+: 9],
                                                                         spage[0] ? va_latch[12+: 9] : pte_ppn[ 0+: 9], va_latch[11:0]}));
`endif

assign va_en        = (prv_post  < `PRV_M && satp_mode       != `SATP_MODE_NONE && cur_state == STATE_IDLE)|
                      (prv_latch < `PRV_M && satp_mode_latch != `SATP_MODE_NONE && cur_state != STATE_IDLE);

`ifdef RV32
assign vpn[19:0]    = va[12+:20];
assign last_hit     = last_va_en && va_en && last_vpn[19:0] == {vpn[19:10], vpn[9:0] & {10{~last_spage[0]}}};
`else
assign vpn          = va[12+:36];
assign last_hit     = last_va_en && va_en &&
                      ((~satp_mode[3] && last_vpn[19:0] == {vpn[19:10], vpn[9:0] & {10{~last_spage[0]}}}) ||
                       ( satp_mode[3] && last_vpn == {vpn[27+:9],
                                                      vpn[18+:9] & {9{~last_spage[2]}},
                                                      vpn[ 9+:9] & {9{~last_spage[1]}},
                                                      vpn[ 0+:9] & {9{~last_spage[0]}}}));
`endif

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        last_va_en <= 1'b0;
    end
    else begin
        if (tlb_flush_req) begin
            last_va_en <= 1'b0;
        end
        else if (va_valid) begin
            last_va_en <= last_hit;
        end
        else if (cur_state ==STATE_CHECK && tlb_hit) begin
            last_va_en <= 1'b1;
        end
        else if (cur_state ==STATE_PTE   && leaf && ~pg_fault_pte) begin
            last_va_en <= 1'b1;
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        last_vpn       <= 36'b0;
        last_spage     <= 3'b0;
        last_pte_ppn   <= 44'b0;
        last_pte_rsw   <= 2'b0;
        last_pte_d     <= 1'b0;
        last_pte_a     <= 1'b0;
        last_pte_g     <= 1'b0;
        last_pte_u     <= 1'b0;
        last_pte_x     <= 1'b0;
        last_pte_w     <= 1'b0;
        last_pte_r     <= 1'b0;
        last_pte_v     <= 1'b0;
    end
    else begin
        if (cur_state ==STATE_CHECK && tlb_hit) begin
`ifdef RV32
            last_vpn[19:0] <= {va_latch[22+:10], va_latch[12+:10] & {10{~tlb_spage_out[0]}}};
`else
            last_vpn       <= ({36{~satp_mode_latch[3]}} & {va_latch[22+:10], va_latch[12+:10] & {10{~tlb_spage_out[0]}}}) |
                              ({36{ satp_mode_latch[3]}} & {va_latch[39+:9],
                                                            va_latch[30+:9] & {9{~tlb_spage_out[2]}},
                                                            va_latch[21+:9] & {9{~tlb_spage_out[1]}},
                                                            va_latch[12+:9] & {9{~tlb_spage_out[0]}}});
`endif
            last_spage     <= tlb_spage_out;
            last_pte_ppn   <= tlb_pte_ppn;
            last_pte_rsw   <= tlb_pte_rsw;
            last_pte_d     <= tlb_pte_d;
            last_pte_a     <= tlb_pte_a;
            last_pte_g     <= tlb_pte_g;
            last_pte_u     <= tlb_pte_u;
            last_pte_x     <= tlb_pte_x;
            last_pte_w     <= tlb_pte_w;
            last_pte_r     <= tlb_pte_r;
            last_pte_v     <= tlb_pte_v;
        end
        else if (cur_state == STATE_PTE   && leaf && ~pg_fault_pte) begin
`ifdef RV32
            last_vpn[19:0] <= {va_latch[22+:10], va_latch[12+:10] & {10{~tlb_spage_in[0]}}};
`else
            last_vpn       <= ({36{~satp_mode_latch[3]}} & {va_latch[22+:10], va_latch[12+:10] & {10{~tlb_spage_in[0]}}}) |
                              ({36{ satp_mode_latch[3]}} & {va_latch[39+:9],
                                                            va_latch[30+:9] & {9{~tlb_spage_in[2]}},
                                                            va_latch[21+:9] & {9{~tlb_spage_in[1]}},
                                                            va_latch[12+:9] & {9{~tlb_spage_in[0]}}});
`endif
            last_spage     <= tlb_spage_in;
            last_pte_ppn   <= pte_ppn;
            last_pte_rsw   <= pte_rsw;
            last_pte_d     <= pte_d;
            last_pte_a     <= pte_a;
            last_pte_g     <= pte_g;
            last_pte_u     <= pte_u;
            last_pte_x     <= pte_x;
            last_pte_w     <= pte_w;
            last_pte_r     <= pte_r;
            last_pte_v     <= pte_v;
        end
    end
end

tlb u_tlb(
    .clk                 ( clk                 ),
    .rstn                ( rstn                ),

`ifndef RV32
    .satp_mode           ( satp_mode           ),
`endif
    .cs                  ( tlb_cs              ),
    .vpn                 ( tlb_vpn             ),
    .we                  ( tlb_we              ),
    .pte_hit             ( tlb_hit             ),
    .spage_in            ( tlb_spage_in        ),
    .pte_in              ( tlb_pte_in          ),
    .spage_out           ( tlb_spage_out       ),
    .pte_out             ( tlb_pte_out         ),

    .tlb_flush_req       ( tlb_flush_req       ),
    .tlb_flush_all_vaddr ( tlb_flush_all_vaddr ),
    .tlb_flush_all_asid  ( tlb_flush_all_asid  ),
    .tlb_flush_vaddr     ( tlb_flush_vaddr     ),
    .tlb_flush_asid      ( tlb_flush_asid      ),

    .idx                 ( tlb_idx             )
);

logic [              31:0] total_cnt;
logic [              31:0] req_cnt [`TLB_DEPTH];
logic [              31:0] hit_cnt [`TLB_DEPTH];
logic [`TLB_IDX_WIDTH-1:0] idx_dly;
logic                      req_dly;
logic                      ovf;

assign ovf = &total_cnt;

always_ff @(posedge clk or negedge rstn) begin: reg_req_dly
    if (~rstn) req_dly <= 1'b0;
    else       req_dly <= va_valid & va_en;
end

always_ff @(posedge clk or negedge rstn) begin: reg_idx_dly
    if (~rstn) idx_dly <= {`TLB_IDX_WIDTH{1'b0}};
    else       idx_dly <= tlb_idx;
end

always_ff @(posedge clk or negedge rstn) begin: reg_total_cnt
    if (~rstn) total_cnt <= 32'b0;
    else       total_cnt <= (total_cnt >> ovf) + {31'b0, req_dly};
end

always_ff @(posedge clk or negedge rstn) begin: reg_req_cnt
    integer i;
    if (~rstn) begin
        for (i = 0; i < `TLB_DEPTH; i = i + 1)
            req_cnt[i] <= 32'b0;
    end
    else begin
        for (i = 0; i < `TLB_DEPTH; i = i + 1)
            req_cnt[i] <= (req_cnt[i] >> ovf) + {31'b0, (i == idx_dly && req_dly)};
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_hit_cnt
    integer i;
    if (~rstn) begin
        for (i = 0; i < `TLB_DEPTH; i = i + 1)
            hit_cnt[i] <= 32'b0;
    end
    else begin
        for (i = 0; i < `TLB_DEPTH; i = i + 1)
            hit_cnt[i] <= (hit_cnt[i] >> ovf) + {31'b0, (i == idx_dly && req_dly && tlb_hit)};
    end
end


endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/tlb.sv
/*--------------------------------------*/

`ifndef __TLB_DEFINE__
`define __TLB_DEFINE__

`define BUS_WIDTH     34
`define TLB_WAY_NUM   4
`define TLB_IDX_WIDTH 1
`define TLB_DEPTH     (2 ** `TLB_IDX_WIDTH)
`define TLB_VPN_WIDTH 36
`define TLB_PTE_WIDTH 64
`define TLB_TAG_WIDTH (`TLB_VPN_WIDTH - `TLB_IDX_WIDTH)

`endif

module tlb (
    input                               clk,
    input                               rstn,

`ifndef RV32
    input        [`SATP_MODE_WIDTH-1:0] satp_mode,
`endif
    input                               cs,
    input        [  `TLB_VPN_WIDTH-1:0] vpn,
    input                               we,
    output logic                        pte_hit,
    input        [                 2:0] spage_in,
    input        [  `TLB_PTE_WIDTH-1:0] pte_in,
    output logic [                 2:0] spage_out,
    output logic [  `TLB_PTE_WIDTH-1:0] pte_out,
    
    input                               tlb_flush_req,
    input                               tlb_flush_all_vaddr,
    input                               tlb_flush_all_asid,
    input        [         `XLEN - 1:0] tlb_flush_vaddr,
    input        [         `XLEN - 1:0] tlb_flush_asid,

    output       [`TLB_IDX_WIDTH - 1:0] idx
);

// logic [      `TLB_IDX_WIDTH-1:0] idx;
logic [          `TLB_DEPTH-1:0] valid   [`TLB_WAY_NUM];
logic [                     2:0] spg_bit [`TLB_WAY_NUM][`TLB_DEPTH];
logic [$clog2(`TLB_WAY_NUM)-1:0] order   [`TLB_WAY_NUM][`TLB_DEPTH];
logic [$clog2(`TLB_WAY_NUM)-1:0] victim_order;
logic [$clog2(`TLB_WAY_NUM)-1:0] hit_order;
logic [        `TLB_WAY_NUM-1:0] hit;
logic [      `TLB_TAG_WIDTH-1:0] tag_in;
logic [      `TLB_TAG_WIDTH-1:0] tag_latch;
logic                            cs_latch;
logic [                    26:0] vpn0_latch;
logic [                     2:0] spg_latch   [`TLB_WAY_NUM];
logic [        `TLB_WAY_NUM-1:0] victim;
logic [      `TLB_PTE_WIDTH-1:0] pte_out_arr [`TLB_WAY_NUM];

assign pte_hit   = |hit;
always_comb begin
    integer i;
    spage_out = 3'b0;
    for (i = 0; i < `TLB_WAY_NUM; i = i + 1) begin
        spage_out = spage_out | ({3{hit[i]}} & spg_latch[i]);
    end
end

`ifdef RV32
assign idx     = vpn[10+:`TLB_IDX_WIDTH];
assign tag_in  = {vpn[`TLB_VPN_WIDTH-1:`TLB_IDX_WIDTH+10], vpn[0+:10] & {10{~spage_in[0]}}};
`else
assign idx     = ({`TLB_IDX_WIDTH{satp_mode == `SATP_MODE_SV32}} & vpn[10+:`TLB_IDX_WIDTH])|
                 ({`TLB_IDX_WIDTH{satp_mode == `SATP_MODE_SV39}} & vpn[18+:`TLB_IDX_WIDTH])|
                 ({`TLB_IDX_WIDTH{satp_mode == `SATP_MODE_SV48}} & vpn[27+:`TLB_IDX_WIDTH]);
assign tag_in  = ({`TLB_TAG_WIDTH{satp_mode == `SATP_MODE_SV32}} & {vpn[`TLB_VPN_WIDTH-1:`TLB_IDX_WIDTH+10], vpn[0+10] & {10{~spage_in[0]}}})|
                 ({`TLB_TAG_WIDTH{satp_mode == `SATP_MODE_SV39}} & {vpn[`TLB_VPN_WIDTH-1:`TLB_IDX_WIDTH+18],
                                                                    vpn[ 9+:9] & {9{~spage_in[1]}},
                                                                    vpn[ 0+:9] & {9{~spage_in[0]}}})|
                 ({`TLB_TAG_WIDTH{satp_mode == `SATP_MODE_SV48}} & {vpn[`TLB_VPN_WIDTH-1:`TLB_IDX_WIDTH+27],
                                                                    vpn[18+:9] & {9{~spage_in[2]}},
                                                                    vpn[ 9+:9] & {9{~spage_in[1]}},
                                                                    vpn[ 0+:9] & {9{~spage_in[0]}}});
`endif

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) tag_latch <= {`TLB_TAG_WIDTH{1'b0}};
    else       tag_latch <=
`ifdef RV32
                            {vpn[`TLB_VPN_WIDTH-1:`TLB_IDX_WIDTH+10], vpn[9:0]};
`else
                            ({`TLB_TAG_WIDTH{satp_mode == `SATP_MODE_SV32}} & {vpn[`TLB_VPN_WIDTH-1:`TLB_IDX_WIDTH+10], vpn[ 9:0]})|
                            ({`TLB_TAG_WIDTH{satp_mode == `SATP_MODE_SV39}} & {vpn[`TLB_VPN_WIDTH-1:`TLB_IDX_WIDTH+18], vpn[17:0]})|
                            ({`TLB_TAG_WIDTH{satp_mode == `SATP_MODE_SV48}} & {vpn[`TLB_VPN_WIDTH-1:`TLB_IDX_WIDTH+27], vpn[26:0]});
`endif
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) cs_latch <= 1'b0;
    else       cs_latch <= cs && ~we;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) vpn0_latch <= 27'b0;
    else       vpn0_latch <= vpn[26:0];
end

always_comb begin
    integer i;

    victim_order = {$clog2(`TLB_WAY_NUM){1'b0}};
    for (i = 0; i < `TLB_WAY_NUM; i = i + 1) begin
        victim_order = victim_order | {$clog2(`TLB_WAY_NUM){victim[i]}} & order[i][idx];
    end

    hit_order    = {$clog2(`TLB_WAY_NUM){1'b0}};
    for (i = 0; i < `TLB_WAY_NUM; i = i + 1) begin
        hit_order    = hit_order    | {$clog2(`TLB_WAY_NUM){hit[i]}}    & order[i][idx];
    end
end

always_comb begin
    integer i;

    pte_out = `TLB_PTE_WIDTH'b0;
    for (i = 0; i < `TLB_WAY_NUM; i = i + 1) begin
        pte_out = pte_out | ({`TLB_PTE_WIDTH{hit[i]}} & pte_out_arr[i])
`ifdef RV32
                          | {{`TLB_PTE_WIDTH-10-10{1'b0}}, vpn0_latch[0+:10] & {10{|(hit[i] & spg_latch[i][0])}}, 10'b0};
`else
                          | ({`TLB_PTE_WIDTH{~satp_mode[3]}} &
                             {{`TLB_PTE_WIDTH-10-10{1'b0}}, vpn0_latch[0+:10] & {10{|(hit[i] & spg_latch[i][0])}}, 10'b0})
                          | ({`TLB_PTE_WIDTH{ satp_mode[3]}} &
                             {{`TLB_PTE_WIDTH-10-27{1'b0}},
                               vpn0_latch[18+:9] & {9{|(hit[i] & spg_latch[i][2])}},
                               vpn0_latch[ 9+:9] & {9{|(hit[i] & spg_latch[i][1])}},
                               vpn0_latch[ 0+:9] & {9{|(hit[i] & spg_latch[i][0])}}, 10'b0});
`endif
    end
end

genvar g;
generate
    for (g = 0; g < `TLB_WAY_NUM; g = g + 1) begin: g_tlb_array
        logic                            valid_latch;
        logic [      `TLB_TAG_WIDTH-1:0] tag_out;

        parameter [$clog2(`TLB_WAY_NUM)-1:0] DEFAULT_ORDER = {$clog2(`TLB_WAY_NUM){1'b0}} - {{($clog2(`TLB_WAY_NUM)-1){1'b0}}, 1'b1};

        always_ff @(posedge clk or negedge rstn) begin
            integer i;
            if (~rstn) begin
                for (i = 0; i < `TLB_DEPTH; i = i + 1) begin
                    valid[g][i]   <= 1'b0;
                    spg_bit[g][i] <= 3'b0;
                    order[g][i]   <= g[$clog2(`TLB_WAY_NUM)-1:0];
                end
            end
            else if (tlb_flush_req) begin
                for (i = 0; i < `TLB_DEPTH; i = i + 1) begin
                    valid[g][i]   <= 1'b0;
                    order[g][i]   <= g[$clog2(`TLB_WAY_NUM)-1:0];
                end
            end
            else if (cs && we) begin
                if (victim[g]) begin
                    valid[g][idx]   <= 1'b1;
                    spg_bit[g][idx] <= spage_in;
                    order[g][idx]   <= DEFAULT_ORDER;
                end
                else if (order[g][idx] > victim_order) begin
                    order[g][idx] <= order[g][idx] - {{($clog2(`TLB_WAY_NUM)-1){1'b0}}, 1'b1};
                end
            end
            else if (cs_latch && pte_hit) begin
                if (hit[g]) begin
                    order[g][idx] <= DEFAULT_ORDER;
                end
                else if (order[g][idx] > hit_order) begin
                    order[g][idx] <= order[g][idx] - {{($clog2(`TLB_WAY_NUM)-1){1'b0}}, 1'b1};
                end
            end
        end

        always_ff @(posedge clk or negedge rstn) begin
            if (~rstn) valid_latch <= 1'b0;
            else       valid_latch <= valid[g][idx] && ~tlb_flush_req;
        end

        always_ff @(posedge clk or negedge rstn) begin
            if (~rstn) spg_latch[g] <= 3'b0;
            else       spg_latch[g] <= spg_bit[g][idx];
        end

        assign victim[g] = cs && we && ~|(order[g][idx]);
        assign hit[g]    = valid_latch &&
                           tag_out ==
`ifdef RV32
                           {tag_latch[`TLB_TAG_WIDTH-1:10], tag_latch[0+:10] & {10{~spg_latch[g][0]}}};
`else
                           (({`TLB_PTE_WIDTH{~satp_mode[3]}} &
                             {tag_latch[`TLB_TAG_WIDTH-1:10], tag_latch[0+:10] & {10{~spg_latch[g][0]}}})|
                            ({`TLB_PTE_WIDTH{ satp_mode[3]}} &
                             {tag_latch[`TLB_TAG_WIDTH-1:27],
                              tag_latch[18+:9] & {9{~spg_latch[g][2]}},
                              tag_latch[ 9+:9] & {9{~spg_latch[g][1]}},
                              tag_latch[ 0+:9] & {9{~spg_latch[g][0]}}}));
`endif

        // sram32x31 u_tag_array (
        //     .CK ( clk                               ),
        //     .CS ( cs                                ),
        //     .WE ( we & victim[g]                    ),
        //     .A  ( {{(5-`TLB_IDX_WIDTH){1'b0}}, idx} ),
        //     .DI ( tag_in                            ),
        //     .DO ( tag_out                           )
        // );

        // sram32x64 u_pte_array (
        //     .CK ( clk                               ),
        //     .CS ( cs                                ),
        //     .WE ( we & victim[g]                    ),
        //     .A  ( {{(5-`TLB_IDX_WIDTH){1'b0}}, idx} ),
        //     .DI ( pte_in                            ),
        //     .DO ( pte_out_arr[g]                    )
        // );

        logic [`TLB_TAG_WIDTH-1:0] tag_array [`TLB_DEPTH];
        logic [`TLB_PTE_WIDTH-1:0] pte_array [`TLB_DEPTH];

        always_ff @(posedge clk or negedge rstn) begin
            integer i;
            if (~rstn)
                for (i = 0; i < `TLB_DEPTH; i = i + 1)
                    tag_array[i] <= {`TLB_TAG_WIDTH{1'b0}};
            else if (cs & we & victim[g])
                tag_array[idx] <= tag_in;
        end

        always_ff @(posedge clk or negedge rstn) begin
            if (~rstn) tag_out <= {`TLB_TAG_WIDTH{1'b0}};
            else       tag_out <= tag_array[idx];
        end

        always_ff @(posedge clk or negedge rstn) begin
            integer i;
            if (~rstn)
                for (i = 0; i < `TLB_DEPTH; i = i + 1)
                    pte_array[i] <= {`TLB_PTE_WIDTH{1'b0}};
            else if (cs & we & victim[g])
                pte_array[idx] <= pte_in;
        end

        always_ff @(posedge clk or negedge rstn) begin
            if (~rstn) pte_out_arr[g] <= {`TLB_PTE_WIDTH{1'b0}};
            else       pte_out_arr[g] <= pte_array[idx];
        end


    end
endgenerate

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/xmon.sv
/*--------------------------------------*/

module xmon (
    input               clk,
    input               rstn,

    input               ac,
    input               rl,
    input        [31:0] addr,
    output logic        xstate
);

`define MON_NWAY 4

logic [        `MON_NWAY-1:0] reserv_valid;
logic [                 31:0] reserv_addr [`MON_NWAY];
logic [        `MON_NWAY-1:0] hit;

always_comb begin
    integer i;
    for (i = 0; i < `MON_NWAY; i = i + 1) begin
        hit[i] = reserv_valid[i] && reserv_addr[i] == addr;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 0; i < `MON_NWAY; i = i + 1) begin
            reserv_valid[i] <= 1'b0;
            reserv_addr [i] <= 32'b0;
        end
    end
    else begin
        if (ac & ~|hit) begin
            reserv_valid[0] <= 1'b1;
            reserv_addr [0] <= addr;
            for (i = 1; i < `MON_NWAY - 1; i = i + 1) begin
                reserv_valid[i] <= reserv_valid[i-1];
                reserv_addr [i] <= reserv_addr [i-1];
            end
        end
        else if (rl & |hit) begin
            for (i = 0; i < `MON_NWAY - 1; i = i + 1) begin
                reserv_addr [i] <= |hit & (~`MON_NWAY'b0 >> (`MON_NWAY - 1 - i)) ?
                                    reserv_addr [i+1] : reserv_addr [i];
            end
            reserv_valid[`MON_NWAY - 1] <= 1'b0;
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) xstate <= 1'b0;
    else       xstate <= |hit;
end

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/l1c.sv
/*--------------------------------------*/

`ifndef __AXI_DEFINE__
`define __AXI_DEFINE__

`define AXI_BURST_FIXED 2'b00
`define AXI_BURST_INCR  2'b01
`define AXI_BURST_WRAP  2'b10

`define AXI_RESP_OKAY   2'b00
`define AXI_RESP_EXOKAY 2'b01
`define AXI_RESP_SLVERR 2'b10
`define AXI_RESP_DECERR 2'b11

`endif
`ifndef __CACHE_DEFINE__
`define __CACHE_DEFINE__

`ifdef RV32
`define CACHE_DATA_WIDTH 32
`define CACHE_ADDR_WIDTH 32
`else
`define CACHE_DATA_WIDTH 64
`define CACHE_ADDR_WIDTH 32
`endif
`define CACHE_BLK_WIDTH  4
`define CACHE_IDX_WIDTH  6
`define CACHE_TAG_WIDTH  (`CACHE_ADDR_WIDTH - `CACHE_BLK_WIDTH - `CACHE_IDX_WIDTH)
`define CACHE_TAG_REGION (`CACHE_BLK_WIDTH + `CACHE_IDX_WIDTH)+:`CACHE_TAG_WIDTH
`define CACHE_BLK_SIZE   2 ** (`CACHE_BLK_WIDTH + 3)

`endif

module l1c (
    input                                    clk,
    input                                    rstn,
    // Core side
    input                                    core_req,
    input                                    core_pa_vld,
    input        [                      1:0] core_pa_bad, // [0]: pg_fault, [1]: bus_err
    input        [  `CACHE_ADDR_WIDTH - 1:0] core_paddr,
    input                                    core_bypass,
    input                                    core_flush,
    input                                    core_wr,
    input                                    core_ex,
    output logic                             core_xstate,
    input        [  `CACHE_ADDR_WIDTH - 1:0] core_vaddr,
    input        [  `CACHE_DATA_WIDTH - 1:0] core_wdata,
    input        [`CACHE_DATA_WIDTH/8 - 1:0] core_byte,
    output logic [  `CACHE_DATA_WIDTH - 1:0] core_rdata,
    output logic [                      1:0] core_bad,    // [0]: pg_fault, [1]: bus_err
    output logic                             core_busy,
    input                                    xmon_xstate,

    // Snooping
    input        [  `CACHE_ADDR_WIDTH - 1:0] snp_addr,
    input                                    snp_valid,
    output logic                             snp_ready,

    // external
    axi_intf.master                          m_axi_intf
);

parameter [2:0] STATE_IDLE   = 3'b000,
                STATE_CMP    = 3'b001,
                STATE_MREQ   = 3'b010,
                STATE_REFILL = 3'b011,
                STATE_WRITE  = 3'b100,
                STATE_READ   = 3'b101;

logic [                      2:0] cur_state;
logic [                      2:0] nxt_state;
logic [                      2:0] state_latch;
logic                             hit;

logic                             valid_wr;
logic [                     63:0] valid;
logic [   `CACHE_IDX_WIDTH - 1:0] idx;

logic [  `CACHE_ADDR_WIDTH - 1:0] core_vaddr_latch;
logic                             core_ex_latch;
logic [  `CACHE_ADDR_WIDTH - 1:0] core_paddr_latch;
logic [  `CACHE_DATA_WIDTH - 1:0] core_wdata_latch;
logic [`CACHE_DATA_WIDTH/8 - 1:0] core_byte_latch;
logic [                      1:0] word_cnt;
logic [  `CACHE_DATA_WIDTH - 1:0] core_rdata_tmp;
logic [   `CACHE_BLK_SIZE/8 -1:0] refill_mask;
logic                             valid_latch;
logic                             tag_cs;
logic                             tag_we;
logic [   `CACHE_IDX_WIDTH - 1:0] tag_addr;
logic [   `CACHE_TAG_WIDTH - 1:0] tag_in;
logic [   `CACHE_TAG_WIDTH - 1:0] tag_out;

logic                             data_cs;
logic                             data_we;
logic [   `CACHE_IDX_WIDTH - 1:0] data_addr;
logic [   `CACHE_BLK_SIZE/8 -1:0] data_byte;
logic [     `CACHE_BLK_SIZE -1:0] data_in;
logic [     `CACHE_BLK_SIZE -1:0] data_out;

logic                             rdata_low_tmp_wr;
`ifndef RV32
logic                             rdata_high_tmp_wr;
`endif
logic                             burst_1st;
logic                             core_bypass_latch;
logic                             arvalid_tmp;
logic                             awvalid_tmp;
logic                             wvalid_tmp;

// snooping
logic                             sf_cs;
logic                             sf_we;
logic [   `CACHE_IDX_WIDTH - 1:0] sf_addr;
logic [   `CACHE_TAG_WIDTH - 1:0] sf_in;
logic [   `CACHE_TAG_WIDTH - 1:0] sf_out;
logic                             snp_hit;
logic                             snp_rd_latch;
logic [  `CACHE_ADDR_WIDTH - 1:0] snp_addr_latch;
logic                             valid_wr_mask;


always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) cur_state <= STATE_IDLE;
    else       cur_state <= nxt_state;
end

always_comb begin
    nxt_state = cur_state;
    case (cur_state)
        STATE_IDLE  : begin
            nxt_state = core_req ? core_wr     ? STATE_WRITE:
                                                 STATE_CMP:
                                   STATE_IDLE;
        end
        STATE_CMP   : begin
            nxt_state = ~core_pa_vld ? STATE_CMP :
                        |core_pa_bad ? STATE_IDLE:
                         core_bypass ? STATE_READ:
                         hit         ? core_req ? core_wr     ? STATE_WRITE:
                                                                STATE_CMP:
                                                  STATE_IDLE:
                                       STATE_MREQ;
        end
        STATE_MREQ  : begin
            nxt_state = m_axi_intf.arready ? STATE_REFILL : STATE_MREQ;
        end
        STATE_REFILL: begin
            nxt_state = (m_axi_intf.rlast && m_axi_intf.rvalid) ? STATE_IDLE : STATE_REFILL;
        end
        STATE_WRITE : begin
            nxt_state = m_axi_intf.bvalid ||
                        (core_pa_vld &&
                        (|core_pa_bad | (core_ex_latch && ~xmon_xstate))) ? STATE_IDLE : STATE_WRITE;
        end
        STATE_READ  : begin
            nxt_state = (m_axi_intf.rlast && m_axi_intf.rvalid) || (core_pa_vld && |core_pa_bad) ? STATE_IDLE : STATE_READ;
        end
    endcase
end

always_comb begin
    m_axi_intf.awvalid = 1'b0;
    m_axi_intf.wvalid  = 1'b0;
    m_axi_intf.arvalid = 1'b0;
    rdata_low_tmp_wr   = 1'b0;
`ifndef RV32
    rdata_high_tmp_wr  = 1'b0;
`endif
    valid_wr           = 1'b0;
    core_busy          = 1'b0;
    tag_cs             = 1'b0;
    tag_we             = 1'b0;
    data_cs            = 1'b0;
    data_we            = 1'b0;
    data_byte          = 16'b0;
    data_in            = 128'b0;
    case (cur_state)
        STATE_IDLE  : begin
            core_busy          = 1'b0;
            tag_cs             = core_req;
            data_cs            = core_req;
        end
        STATE_CMP   : begin
            core_busy          = ~hit || |core_pa_bad || |core_bypass;
            tag_cs             = ~core_pa_vld || (hit && core_req);
            data_cs            = ~core_pa_vld || (hit && core_req);
        end
        STATE_MREQ  : begin
            core_busy          = 1'b1;
            m_axi_intf.arvalid = 1'b1;
        end
        STATE_REFILL: begin
            core_busy          = 1'b1;
            data_cs            = m_axi_intf.rvalid;
            data_we            = m_axi_intf.rvalid;
            data_byte          = refill_mask;
            data_in            = {4{m_axi_intf.rdata}};
            tag_cs             = m_axi_intf.rlast && m_axi_intf.rvalid;
            tag_we             = m_axi_intf.rlast && m_axi_intf.rvalid;
            valid_wr           = m_axi_intf.rlast && m_axi_intf.rvalid;
`ifdef RV32
            rdata_low_tmp_wr   = m_axi_intf.rvalid && word_cnt == core_vaddr_latch[2+:2];
`else
            rdata_low_tmp_wr   = m_axi_intf.rvalid && word_cnt == {core_vaddr_latch[`CACHE_BLK_WIDTH-1:3], 1'b0};
            rdata_high_tmp_wr  = m_axi_intf.rvalid && word_cnt == {core_vaddr_latch[`CACHE_BLK_WIDTH-1:3], 1'b1};
`endif
        end
        STATE_WRITE : begin
            m_axi_intf.awvalid = awvalid_tmp;
            m_axi_intf.wvalid  = wvalid_tmp;
            core_busy          = 1'b1;
            tag_cs             = 1'b1;
            data_cs            = hit && core_pa_vld && ~|core_pa_bad && ~core_bypass && (~core_ex_latch | xmon_xstate);
            data_we            = 1'b1;
            data_byte          = {{`CACHE_BLK_SIZE/8-`CACHE_DATA_WIDTH/8{1'b0}}, core_byte_latch}
                                 << {core_vaddr_latch[`CACHE_BLK_WIDTH-1:$clog2(`CACHE_DATA_WIDTH/8)], {$clog2(`CACHE_DATA_WIDTH/8){1'b0}}};
            data_in            = {`CACHE_BLK_SIZE/`CACHE_DATA_WIDTH{core_wdata_latch}};
        end
        STATE_READ  : begin
            m_axi_intf.arvalid = arvalid_tmp;
            core_busy          = 1'b1;
            rdata_low_tmp_wr   =  burst_1st & m_axi_intf.rvalid;
`ifndef RV32
            rdata_high_tmp_wr  = (~burst_1st || core_vaddr_latch[2]) & m_axi_intf.rvalid;
`endif
        end
    endcase
end

assign idx        = core_vaddr[`CACHE_BLK_WIDTH+:`CACHE_IDX_WIDTH];
assign tag_addr   = core_busy ? core_vaddr_latch[`CACHE_BLK_WIDTH+:`CACHE_IDX_WIDTH]:
                                core_vaddr      [`CACHE_BLK_WIDTH+:`CACHE_IDX_WIDTH];
assign data_addr  = core_busy ? core_vaddr_latch[`CACHE_BLK_WIDTH+:`CACHE_IDX_WIDTH]:
                                core_vaddr      [`CACHE_BLK_WIDTH+:`CACHE_IDX_WIDTH];
assign tag_in     = core_paddr_latch[`CACHE_TAG_REGION];
assign hit        = valid_latch && core_pa_vld && (tag_out == core_paddr[`CACHE_TAG_REGION]);

assign core_rdata = cur_state == STATE_IDLE ? core_rdata_tmp:
                    data_out[{core_vaddr_latch[`CACHE_BLK_WIDTH-1:$clog2(`CACHE_DATA_WIDTH/8)], {3+$clog2(`CACHE_DATA_WIDTH/8){1'b0}}}+:`XLEN];
assign m_axi_intf.awid     = 10'b0;
assign m_axi_intf.awaddr   = core_paddr_latch;
assign m_axi_intf.awburst  = `AXI_BURST_INCR;
assign m_axi_intf.awsize   = 3'h2;
assign m_axi_intf.awlen    = 8'b0
`ifndef RV32
                             || {7'b0, ~core_vaddr_latch[2] && |core_byte_latch[7:4]}
`endif
                             ;
assign m_axi_intf.awlock   = 2'h0;
assign m_axi_intf.awcache  = 4'h0;
assign m_axi_intf.awprot   = 3'h0;
assign m_axi_intf.wid      = 10'b0;
`ifdef RV32
assign m_axi_intf.wdata    = core_wdata_latch;
assign m_axi_intf.wstrb    = core_byte_latch;
assign m_axi_intf.wlast    = 1'b1;
`else
assign m_axi_intf.wdata    = ~core_vaddr_latch[2] && burst_1st ? core_wdata_latch[31: 0] : core_wdata_latch[63:32];
assign m_axi_intf.wstrb    = ~core_vaddr_latch[2] && burst_1st ? core_byte_latch [ 3: 0] : core_byte_latch [ 7: 4];
assign m_axi_intf.wlast    = ~(~core_vaddr_latch[2] && |core_byte_latch[7:4]) || ~burst_1st;
`endif
assign m_axi_intf.bready   = 1'b1;
assign m_axi_intf.arid     = 10'b0;
assign m_axi_intf.araddr   = cur_state == STATE_READ ? core_paddr_latch :
                             {core_paddr_latch[`CACHE_ADDR_WIDTH-1:`CACHE_BLK_WIDTH], {`CACHE_BLK_WIDTH{1'b0}}};
assign m_axi_intf.arburst  = `AXI_BURST_INCR;
assign m_axi_intf.arsize   = 3'h2;
assign m_axi_intf.arlen    = cur_state == STATE_MREQ                       ? 8'h3:
`ifndef RV32
                             ~core_vaddr_latch[2] && |core_byte_latch[7:4] ? 8'h1:
`endif
                                                                             8'h0;
assign m_axi_intf.arlock   = 2'h0;
assign m_axi_intf.arcache  = 4'h0;
assign m_axi_intf.arprot   = 3'h0;
assign m_axi_intf.rready   = 1'b1;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) state_latch <= STATE_IDLE;
    else       state_latch <= cur_state; 
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)                                          core_bad <= 2'b00;
    else if (cur_state == STATE_IDLE)                   core_bad <= 2'b00;
    else if (m_axi_intf.bresp[1] && m_axi_intf.bvalid)  core_bad <= 2'b10;
    else if (m_axi_intf.rresp[1] && m_axi_intf.rvalid)  core_bad <= 2'b10;
    else if (core_pa_vld)                               core_bad <= core_pa_bad;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)            core_bypass_latch <= 1'b0;
    else if (core_pa_vld) core_bypass_latch <= core_bypass;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)           core_vaddr_latch <= `CACHE_ADDR_WIDTH'b0;
    else if (~core_busy) core_vaddr_latch <= core_vaddr;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)           core_ex_latch <= 1'b0;
    else if (~core_busy) core_ex_latch <= core_ex;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)            core_paddr_latch <= `CACHE_ADDR_WIDTH'b0;
    else if (core_pa_vld) core_paddr_latch <= core_paddr;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)           valid_latch <= 1'b0;
    else if (~core_busy) valid_latch <= ~core_flush && valid[idx] && core_req;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)                  refill_mask <= {12'b0, 4'hf};
    else if (m_axi_intf.rvalid) refill_mask <= m_axi_intf.rlast ? {12'b0, 4'hf} : {refill_mask[11:0], refill_mask[15:12]};
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)                  word_cnt <= 2'b0;
    else if (m_axi_intf.rvalid) word_cnt <= m_axi_intf.rlast ? 2'b0 : (word_cnt + 2'b1);
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        burst_1st <= 1'b1;
    end
`ifndef RV32
    else if (cur_state == STATE_IDLE) begin
        burst_1st <= 1'b1;
    end
    else if ((m_axi_intf.rvalid && m_axi_intf.rready) || (m_axi_intf.wvalid && m_axi_intf.wready)) begin
        burst_1st <= 1'b0;
    end
`endif
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        core_rdata_tmp <= `CACHE_DATA_WIDTH'b0;
    end
    else begin
        if (rdata_low_tmp_wr) begin
            core_rdata_tmp[0+:32]  <= m_axi_intf.rdata;
        end
`ifndef RV32
        if (rdata_high_tmp_wr) begin
            core_rdata_tmp[32+:32] <= m_axi_intf.rdata;
        end
`endif
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        valid <= 64'b0;
    end
    else begin
        if (core_flush)    valid <= 64'b0;
        else if (valid_wr) valid[core_vaddr_latch[`CACHE_BLK_WIDTH+:`CACHE_IDX_WIDTH]] <= ~m_axi_intf.rresp[1] && ~core_pa_bad[1] && ~valid_wr_mask;
        else if (snp_hit)  valid[snp_addr_latch  [`CACHE_BLK_WIDTH+:`CACHE_IDX_WIDTH]] <= 1'b0;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        core_wdata_latch <= `XLEN'b0;
        core_byte_latch  <= {`XLEN/8{1'b0}};
    end
    else if (~core_busy) begin
        core_wdata_latch <= core_wdata;
        core_byte_latch  <= core_byte;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        arvalid_tmp <= 1'b0;
        awvalid_tmp <= 1'b0;
        wvalid_tmp  <= 1'b0;
    end
    else begin
        if (core_pa_vld) begin
            arvalid_tmp <= 1'b1;
            awvalid_tmp <= cur_state == STATE_WRITE & (~core_ex_latch | xmon_xstate);
            wvalid_tmp  <= cur_state == STATE_WRITE & (~core_ex_latch | xmon_xstate);
        end
        else begin
            if ( m_axi_intf.arready                      || cur_state == STATE_IDLE) arvalid_tmp <= 1'b0;
            if ( m_axi_intf.awready                      || cur_state == STATE_IDLE) awvalid_tmp <= 1'b0;
            if ((m_axi_intf.wready  && m_axi_intf.wlast) || cur_state == STATE_IDLE) wvalid_tmp  <= 1'b0;
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        core_xstate <= 1'b0;
    end
    else if (core_pa_vld) begin
        core_xstate <= xmon_xstate & core_ex_latch;
    end
    else if (~core_busy) begin
        core_xstate <= 1'b0;
    end
end

sram64x22 u_tagram(
    .CK   ( clk      ),
    .CS   ( tag_cs   ),
    .WE   ( tag_we   ),
    .A    ( tag_addr ),
    .DI   ( tag_in   ),
    .DO   ( tag_out  )
);

sram64x128 u_dataram(
    .CK   ( clk       ),
    .CS   ( data_cs   ),
    .WE   ( data_we   ),
    .A    ( data_addr ),
    .BYTE ( data_byte ),
    .DI   ( data_in   ),
    .DO   ( data_out  )
);

// Snooping filter
assign sf_cs   = tag_we || (snp_valid && valid[snp_addr[`CACHE_BLK_WIDTH+:`CACHE_IDX_WIDTH]] &&
                            nxt_state != STATE_REFILL);
assign sf_we   = tag_we;
assign sf_addr = tag_we ? tag_addr : snp_addr[`CACHE_BLK_WIDTH+:`CACHE_IDX_WIDTH];
assign sf_in   = tag_in;

assign snp_hit = snp_addr_latch[`CACHE_TAG_REGION] == sf_out && snp_rd_latch;

// assign snp_ack   = ((invld || invld_latch) && cur_state != STATE_REFILL) || valid_miss;
assign snp_ready = ~tag_we;

always_ff @(posedge clk or negedge rstn) begin: reg_snp_latch
    if (~rstn) begin
        snp_rd_latch    <= 1'b0;
        snp_addr_latch  <= {`CACHE_ADDR_WIDTH{1'b0}};
    end
    else begin
        snp_rd_latch    <= sf_cs & ~sf_we;
        snp_addr_latch  <= snp_addr;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_invld
    if (~rstn) begin
        valid_wr_mask <= 1'b0;
    end
    else if (cur_state == STATE_REFILL && m_axi_intf.rlast && m_axi_intf.rvalid) begin
        valid_wr_mask <= 1'b0;
    end
    else begin
        valid_wr_mask <= (nxt_state == STATE_REFILL && cur_state == STATE_CMP &&
                          snp_addr  [`CACHE_ADDR_WIDTH-1:`CACHE_BLK_WIDTH] ==
                          core_paddr[`CACHE_ADDR_WIDTH-1:`CACHE_BLK_WIDTH]) ||
                         (cur_state == STATE_REFILL &&
                          snp_addr_latch  [`CACHE_ADDR_WIDTH-1:`CACHE_BLK_WIDTH] ==
                          core_paddr_latch[`CACHE_ADDR_WIDTH-1:`CACHE_BLK_WIDTH]);
    end
end

sram64x22 u_sfram(
    .CK   ( clk     ),
    .CS   ( sf_cs   ),
    .WE   ( sf_we   ),
    .A    ( sf_addr ),
    .DI   ( sf_in   ),
    .DO   ( sf_out  )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/cfgreg.sv
/*--------------------------------------*/

`ifndef __CFGREG_MMAP__
`define __CFGREG_MMAP__

// CFGREG_BASE

`define CFGREG_RSTN      12'h000
`define CFGREG_BOOTVEC   12'h004
`define CFGREG_DDROFFSET 12'h008
`define CFGREG_RSVREG0   12'h010
`define CFGREG_RSVREG1   12'h014

`endif

module cfgreg (
    input                     clk,
    input                     rstn,
    apb_intf.slave            apb_intf,

    output logic [`XLEN-1: 0] core_bootvec,
    output logic [     31: 0] ddr_offset,
    output logic              core_rstn
);


logic [31:0] reserved_reg0;
logic [31:0] reserved_reg1;

logic [31:0] prdata_t;
logic        apb_wr;

always_comb begin: comb_apb_wr
    apb_wr = ~apb_intf.penable & apb_intf.psel & apb_intf.pwrite;
end


always_ff @(posedge clk or negedge rstn) begin: reg_core_rstn
    if (~rstn) begin
        core_rstn <= 1'b0;
    end
    else if (apb_wr && apb_intf.paddr[11:0] == `CFGREG_RSTN) begin
        core_rstn <= apb_intf.pwdata[0];
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_core_bootvec
    if (~rstn) begin
        core_bootvec <= 32'b0;
    end
    else if (apb_wr && apb_intf.paddr[11:0] == `CFGREG_BOOTVEC) begin
        core_bootvec <= apb_intf.pwdata;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_ddr_offset
    if (~rstn) begin
        ddr_offset <= 32'h2000_0000;
    end
    else if (apb_wr && apb_intf.paddr[11:0] == `CFGREG_DDROFFSET) begin
        ddr_offset <= apb_intf.pwdata;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_reserved_reg0
    if (~rstn) begin
        reserved_reg0 <= 32'b0;
    end
    else if (apb_wr && apb_intf.paddr[11:0] == `CFGREG_RSVREG0) begin
        reserved_reg0 <= apb_intf.pwdata;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_reserved_reg1
    if (~rstn) begin
        reserved_reg1 <= 32'b0;
    end
    else if (apb_wr && apb_intf.paddr[11:0] == `CFGREG_RSVREG1) begin
        reserved_reg1 <= apb_intf.pwdata;
    end
end

always_comb begin: comb_prdata_t
    prdata_t = 32'b0;
    case (apb_intf.paddr[11:0])
        `CFGREG_RSTN:      prdata_t = {31'b0, core_rstn};
        `CFGREG_BOOTVEC:   prdata_t = core_bootvec;
        `CFGREG_DDROFFSET: prdata_t = ddr_offset;
        `CFGREG_RSVREG0:   prdata_t = reserved_reg0;
        `CFGREG_RSVREG1:   prdata_t = reserved_reg1;
    endcase
end

always_ff @(posedge clk or negedge rstn) begin: reg_prdata
    if (~rstn) begin
        apb_intf.prdata <= 32'b0;
    end
    else begin
        apb_intf.prdata <= prdata_t;
    end
end

assign apb_intf.pslverr = 1'b0;
assign apb_intf.pready  = 1'b1;

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/dbgmon.sv
/*--------------------------------------*/

`ifndef __CPUSTATREG_MMAP__
`define __CPUSTATREG_MMAP__

// CPUSTATREG_BASE

`define DBGMON_PC         13'h1000
`define DBGMON_X1         13'h1008
`define DBGMON_X2         13'h1010
`define DBGMON_X3         13'h1018
`define DBGMON_X4         13'h1020
`define DBGMON_X5         13'h1028
`define DBGMON_X6         13'h1030
`define DBGMON_X7         13'h1038
`define DBGMON_X8         13'h1040
`define DBGMON_X9         13'h1048
`define DBGMON_X10        13'h1050
`define DBGMON_X11        13'h1058
`define DBGMON_X12        13'h1060
`define DBGMON_X13        13'h1068
`define DBGMON_X14        13'h1070
`define DBGMON_X15        13'h1078
`define DBGMON_X16        13'h1080
`define DBGMON_X17        13'h1088
`define DBGMON_X18        13'h1090
`define DBGMON_X19        13'h1098
`define DBGMON_X20        13'h10a0
`define DBGMON_X21        13'h10a8
`define DBGMON_X22        13'h10b0
`define DBGMON_X23        13'h10b8
`define DBGMON_X24        13'h10c0
`define DBGMON_X25        13'h10c8
`define DBGMON_X26        13'h10d0
`define DBGMON_X27        13'h10d8
`define DBGMON_X28        13'h10e0
`define DBGMON_X29        13'h10e8
`define DBGMON_X30        13'h10f0
`define DBGMON_X31        13'h10f8
`define DBGMON_BP         13'h1100
`define DBGMON_STOP_TRACE 13'h1108

`endif

module dbgmon (
    input                 clk,
    input                 rstn,
    input                 srstn,

    apb_intf.slave        apb_intf,

    input         [ 63:0] pc,
    input         [ 63:0] gpr [32],

    input                 pkg_valid,
    input         [255:0] pkg
);

logic [ 31:0] prdata_trace;
logic [ 31:0] prdata_t;
logic [ 31:0] prdata_t_latch;

logic [ 63:0] breakpoint;

logic [255:0] pkg_out;
logic [  6:0] trace_ptr;
logic         trace_sram_we;
logic [  6:0] trace_sram_addr;
logic         stop_trace;
logic         stop_hit;

always_ff @(posedge clk or negedge rstn) begin: reg_bp
    if (~rstn) breakpoint <= 64'h21d62;
    else if (apb_intf.pwrite && apb_intf.psel && ~apb_intf.penable) begin
        if (apb_intf.paddr[12:0] == `DBGMON_BP)
            breakpoint[ 0+:32] <= apb_intf.pwdata;
        if (apb_intf.paddr[12:0] == `DBGMON_BP + 13'h4)
            breakpoint[32+:32] <= apb_intf.pwdata;
    end
end

assign stop_hit        = pkg_valid && (((breakpoint == pkg[160+:64]) && !pkg[255]) ||
                                       ((64'hffffffe00002a110 == pkg[160+:64]) && pkg[255] && ~pkg[95]) ||
                                       ((64'hffffffe00002a114 == pkg[160+:64]) && pkg[255] && ~pkg[95]));
assign trace_sram_we   = pkg_valid && ~stop_trace;
assign trace_sram_addr = ({7{stop_trace}} & apb_intf.paddr[11:5]) + trace_ptr;

always_ff @(posedge clk or negedge rstn) begin: reg_trace_ptr
    if (~rstn)              trace_ptr <= 7'b0;
    else if (trace_sram_we) trace_ptr <= trace_ptr + 7'b1;
end

always_ff @(posedge clk or negedge srstn) begin: reg_stop_trace
    if (~srstn)        stop_trace <= 1'b0;
    else if (stop_hit) stop_trace <= 1'b1;
    else if (apb_intf.pwrite && apb_intf.psel && ~apb_intf.penable &&
             apb_intf.paddr[12:0] == `DBGMON_STOP_TRACE) begin
        stop_trace <= apb_intf.pwdata[0];
    end
end

sram128x64 u_sram_0 (
    .CK   ( clk               ),
    .CS   ( 1'b1              ),
    .WE   ( trace_sram_we     ),
    .A    ( trace_sram_addr   ),
    .BYTE ( 8'hff             ),
    .DI   ( pkg[0+:64]        ),
    .DO   ( pkg_out[0+:64]    )
);

sram128x64 u_sram_1 (
    .CK   ( clk               ),
    .CS   ( 1'b1              ),
    .WE   ( trace_sram_we     ),
    .A    ( trace_sram_addr   ),
    .BYTE ( 8'hff             ),
    .DI   ( pkg[64+:64]       ),
    .DO   ( pkg_out[64+:64]   )
);

sram128x64 u_sram_2 (
    .CK   ( clk               ),
    .CS   ( 1'b1              ),
    .WE   ( trace_sram_we     ),
    .A    ( trace_sram_addr   ),
    .BYTE ( 8'hff             ),
    .DI   ( pkg[128+:64]      ),
    .DO   ( pkg_out[128+:64]  )
);

sram128x64 u_sram_3 (
    .CK   ( clk               ),
    .CS   ( 1'b1              ),
    .WE   ( trace_sram_we     ),
    .A    ( trace_sram_addr   ),
    .BYTE ( 8'hff             ),
    .DI   ( pkg[192+:64]      ),
    .DO   ( pkg_out[192+:64]  )
);

always_comb begin: comb_prdata_trace
    prdata_trace = 32'b0;
    case (apb_intf.paddr[4:2])
        3'h0: prdata_trace = pkg_out[  0+:32];
        3'h1: prdata_trace = pkg_out[ 32+:32];
        3'h2: prdata_trace = pkg_out[ 64+:32];
        3'h3: prdata_trace = pkg_out[ 96+:32];
        3'h4: prdata_trace = pkg_out[128+:32];
        3'h5: prdata_trace = pkg_out[160+:32];
        3'h6: prdata_trace = pkg_out[192+:32];
        3'h7: prdata_trace = pkg_out[224+:32];
    endcase
end

always_comb begin: comb_prdata_t
    prdata_t = 32'b0;
    case (apb_intf.paddr[12:0])
        `DBGMON_PC  + 13'h0: prdata_t = pc[31: 0];
        `DBGMON_PC  + 13'h4: prdata_t = pc[63:32];
        `DBGMON_X1  + 13'h0: prdata_t = gpr[1 ][31: 0];
        `DBGMON_X1  + 13'h4: prdata_t = gpr[1 ][63:32];
        `DBGMON_X2  + 13'h0: prdata_t = gpr[2 ][31: 0];
        `DBGMON_X2  + 13'h4: prdata_t = gpr[2 ][63:32];
        `DBGMON_X3  + 13'h0: prdata_t = gpr[3 ][31: 0];
        `DBGMON_X3  + 13'h4: prdata_t = gpr[3 ][63:32];
        `DBGMON_X4  + 13'h0: prdata_t = gpr[4 ][31: 0];
        `DBGMON_X4  + 13'h4: prdata_t = gpr[4 ][63:32];
        `DBGMON_X5  + 13'h0: prdata_t = gpr[5 ][31: 0];
        `DBGMON_X5  + 13'h4: prdata_t = gpr[5 ][63:32];
        `DBGMON_X6  + 13'h0: prdata_t = gpr[6 ][31: 0];
        `DBGMON_X6  + 13'h4: prdata_t = gpr[6 ][63:32];
        `DBGMON_X7  + 13'h0: prdata_t = gpr[7 ][31: 0];
        `DBGMON_X7  + 13'h4: prdata_t = gpr[7 ][63:32];
        `DBGMON_X8  + 13'h0: prdata_t = gpr[8 ][31: 0];
        `DBGMON_X8  + 13'h4: prdata_t = gpr[8 ][63:32];
        `DBGMON_X9  + 13'h0: prdata_t = gpr[9 ][31: 0];
        `DBGMON_X9  + 13'h4: prdata_t = gpr[9 ][63:32];
        `DBGMON_X10 + 13'h0: prdata_t = gpr[10][31: 0];
        `DBGMON_X10 + 13'h4: prdata_t = gpr[10][63:32];
        `DBGMON_X11 + 13'h0: prdata_t = gpr[11][31: 0];
        `DBGMON_X11 + 13'h4: prdata_t = gpr[11][63:32];
        `DBGMON_X12 + 13'h0: prdata_t = gpr[12][31: 0];
        `DBGMON_X12 + 13'h4: prdata_t = gpr[12][63:32];
        `DBGMON_X13 + 13'h0: prdata_t = gpr[13][31: 0];
        `DBGMON_X13 + 13'h4: prdata_t = gpr[13][63:32];
        `DBGMON_X14 + 13'h0: prdata_t = gpr[14][31: 0];
        `DBGMON_X14 + 13'h4: prdata_t = gpr[14][63:32];
        `DBGMON_X15 + 13'h0: prdata_t = gpr[15][31: 0];
        `DBGMON_X15 + 13'h4: prdata_t = gpr[15][63:32];
        `DBGMON_X16 + 13'h0: prdata_t = gpr[16][31: 0];
        `DBGMON_X16 + 13'h4: prdata_t = gpr[16][63:32];
        `DBGMON_X17 + 13'h0: prdata_t = gpr[17][31: 0];
        `DBGMON_X17 + 13'h4: prdata_t = gpr[17][63:32];
        `DBGMON_X18 + 13'h0: prdata_t = gpr[18][31: 0];
        `DBGMON_X18 + 13'h4: prdata_t = gpr[18][63:32];
        `DBGMON_X19 + 13'h0: prdata_t = gpr[19][31: 0];
        `DBGMON_X19 + 13'h4: prdata_t = gpr[19][63:32];
        `DBGMON_X20 + 13'h0: prdata_t = gpr[20][31: 0];
        `DBGMON_X20 + 13'h4: prdata_t = gpr[20][63:32];
        `DBGMON_X21 + 13'h0: prdata_t = gpr[21][31: 0];
        `DBGMON_X21 + 13'h4: prdata_t = gpr[21][63:32];
        `DBGMON_X22 + 13'h0: prdata_t = gpr[22][31: 0];
        `DBGMON_X22 + 13'h4: prdata_t = gpr[22][63:32];
        `DBGMON_X23 + 13'h0: prdata_t = gpr[23][31: 0];
        `DBGMON_X23 + 13'h4: prdata_t = gpr[23][63:32];
        `DBGMON_X24 + 13'h0: prdata_t = gpr[24][31: 0];
        `DBGMON_X24 + 13'h4: prdata_t = gpr[24][63:32];
        `DBGMON_X25 + 13'h0: prdata_t = gpr[25][31: 0];
        `DBGMON_X25 + 13'h4: prdata_t = gpr[25][63:32];
        `DBGMON_X26 + 13'h0: prdata_t = gpr[26][31: 0];
        `DBGMON_X26 + 13'h4: prdata_t = gpr[26][63:32];
        `DBGMON_X27 + 13'h0: prdata_t = gpr[27][31: 0];
        `DBGMON_X27 + 13'h4: prdata_t = gpr[27][63:32];
        `DBGMON_X28 + 13'h0: prdata_t = gpr[28][31: 0];
        `DBGMON_X28 + 13'h4: prdata_t = gpr[28][63:32];
        `DBGMON_X29 + 13'h0: prdata_t = gpr[29][31: 0];
        `DBGMON_X29 + 13'h4: prdata_t = gpr[29][63:32];
        `DBGMON_X30 + 13'h0: prdata_t = gpr[30][31: 0];
        `DBGMON_X30 + 13'h4: prdata_t = gpr[30][63:32];
        `DBGMON_X31 + 13'h0: prdata_t = gpr[31][31: 0];
        `DBGMON_X31 + 13'h4: prdata_t = gpr[31][63:32];
        `DBGMON_BP  + 13'h0: prdata_t = breakpoint[31: 0];
        `DBGMON_BP  + 13'h4: prdata_t = breakpoint[63:32];
        `DBGMON_STOP_TRACE:  prdata_t = {31'b0, stop_trace};
    endcase
end

always_ff @(posedge clk or negedge rstn) begin: reg_prdata
    if (~rstn) prdata_t_latch <= 32'b0;
    else       prdata_t_latch <= prdata_t;
end

assign apb_intf.pslverr = 1'b0;
assign apb_intf.pready  = 1'b1;
assign apb_intf.prdata  = ~apb_intf.paddr[12] ? prdata_trace : prdata_t_latch;


endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/intc.sv
/*--------------------------------------*/

`ifndef __SOC_DEFINE__
`define __SOC_DEFINE__

`define CPU_NUM 1
`define INT_NUM 32

`endif

module intc (
    input                        clk,
    input                        rstn,
    apb_intf.slave               s_apb_intf,

    input        [        63: 0] systime,
    output logic [`CPU_NUM-1: 0] msip,
    output logic [`CPU_NUM-1: 0] mtip,
    output logic [`CPU_NUM-1: 0] meip,
    output logic [`CPU_NUM-1: 0] seip,
    input        [`INT_NUM-1: 0] ints
);

apb_intf clint_apb();
apb_intf plic_apb();

intc_apb_conn u_intc_apb_conn (
    .intc_apb  ( s_apb_intf       ),
    .clint_apb ( clint_apb.master ),
    .plic_apb  ( plic_apb.master  )
);

clint u_clint (
    .clk      ( clk             ),
    .rstn     ( rstn            ),
    .apb_intf ( clint_apb.slave ),

    .systime  ( systime         ),
    .msip     ( msip            ),
    .mtip     ( mtip            )
);

plic u_plic(
    .clk      ( clk             ),
    .rstn     ( rstn            ),
    .apb_intf ( plic_apb.slave  ),

    .meip     ( meip            ),
    .seip     ( seip            ),
    .ints     ( ints            )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/clint.sv
/*--------------------------------------*/

`ifndef __SOC_DEFINE__
`define __SOC_DEFINE__

`define CPU_NUM 1
`define INT_NUM 32

`endif
`ifndef __CLINT_MMAP__
`define __CLINT_MMAP__

// CLINT_BASE

`define CLINT_MSIP    16'h0000
`define CLINT_TIMECMP 16'h4000
`define CLINT_TIME    16'hbff8

`endif

module clint (
    input                        clk,
    input                        rstn,
    apb_intf.slave               apb_intf,

    input        [        63: 0] systime,
    output logic [`CPU_NUM-1: 0] msip,
    output logic [`CPU_NUM-1: 0] mtip
);

logic        apb_wr;
logic [31:0] prdata_msip;
logic [31:0] prdata_timecmp;
logic [31:0] prdata_time;
logic [31:0] prdata_t;
logic [63:0] mtimecmp [`CPU_NUM];
logic [63:0] mtime;


always_comb begin: comb_apb_wr
    apb_wr = ~apb_intf.penable && apb_intf.psel && apb_intf.pwrite;
end

genvar g;
generate
    for (g = 0; g < `CPU_NUM; g = g + 1) begin: g_apb_reg
        always_ff @(posedge clk or negedge rstn) begin: reg_msip
            if (~rstn) begin
                msip[g] <= 1'b0;
            end
            else if (apb_wr && apb_intf.paddr[15:0] == `CLINT_MSIP + 16'h4 * g[15:0]) begin
                msip[g] <= apb_intf.pwdata[0];
            end
        end

        always_ff @(posedge clk or negedge rstn) begin: reg_mtimecmp
            if (~rstn) begin
                mtimecmp[g] <= 64'b0;
            end
            else if (apb_wr && apb_intf.paddr[15:0] == `CLINT_TIMECMP + 16'h8 * g[15:0]) begin
                mtimecmp[g][31:0] <= apb_intf.pwdata;
            end
            else if (apb_wr && apb_intf.paddr[15:0] == `CLINT_TIMECMP + 16'h8 * g[15:0] + 16'h4) begin
                mtimecmp[g][63:32] <= apb_intf.pwdata;
            end
        end
        
        always_ff @(posedge clk or negedge rstn) begin: reg_mtip
            if (~rstn) begin
                mtip[g] <= 1'b0;
            end
            else begin
                mtip[g] <= mtime >= mtimecmp[g];
            end
        end
    end
endgenerate

always_comb begin: comb_mtime
    mtime  = systime;
end

always_comb begin: comb_prdata_msip
    integer i;
    prdata_msip = 32'b0;
    for (i = 0; i < `CPU_NUM; i = i + 1) begin
        prdata_msip = prdata_msip | {31'b0, msip[i] & (apb_intf.paddr[7:2] == i[5:0])};
    end
    prdata_msip = prdata_msip & {32{apb_intf.paddr[15:12] == 4'h0}};
end

always_comb begin: comb_prdata_timecmp
    integer i;
    prdata_timecmp = 32'b0;
    for (i = 0; i < `CPU_NUM; i = i + 1) begin
        prdata_timecmp = prdata_timecmp |
                         (mtimecmp[i][31: 0] & {32{apb_intf.paddr[8:3] == i[5:0] && !apb_intf.paddr[2]}})|
                         (mtimecmp[i][63:32] & {32{apb_intf.paddr[8:3] == i[5:0] &&  apb_intf.paddr[2]}});
    end
    prdata_timecmp = prdata_timecmp & {32{apb_intf.paddr[15:12] == 4'h4}};
end


always_comb begin: comb_prdata_time
    prdata_time = (mtime[31: 0] & {32{apb_intf.paddr[15:0] == `CLINT_TIME}})|
                  (mtime[63:32] & {32{apb_intf.paddr[15:0] == `CLINT_TIME + 16'h4}});
end

assign prdata_t = prdata_msip | prdata_timecmp | prdata_time;

always_ff @(posedge clk or negedge rstn) begin: reg_prdata
    if (~rstn) begin
        apb_intf.prdata <= 32'b0;
    end
    else begin
        apb_intf.prdata <= prdata_t;
    end
end

assign apb_intf.pslverr = 1'b0;
assign apb_intf.pready  = 1'b1;


endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/plic.sv
/*--------------------------------------*/

`ifndef __SOC_DEFINE__
`define __SOC_DEFINE__

`define CPU_NUM 1
`define INT_NUM 32

`endif
`ifndef __PLIC_MMAP__
`define __PLIC_MMAP__

// PLIC_BASE

`define PLIC_INT_PRIOR   26'h000_0000
`define PLIC_INT_PEND    26'h000_1000
`define PLIC_INT_TYPE    26'h000_1080
`define PLIC_INT_POL     26'h000_1100
`define PLIC_INT_EN      26'h000_2000
`define PLIC_PRIOR_TH    26'h020_0000

`endif
`define CONTEXT_NUM (2*`CPU_NUM)

module plic (
    input                        clk,
    input                        rstn,
    apb_intf.slave               apb_intf,

    output logic [`CPU_NUM-1: 0] meip,
    output logic [`CPU_NUM-1: 0] seip,
    input        [`INT_NUM-1: 0] ints
);

logic [        31:0] claim_id    [`CONTEXT_NUM];
logic [        31:0] cmplet_id   [`CONTEXT_NUM];

logic [`INT_NUM-1:1] claim;
logic [`INT_NUM-1:1] cmplet;

logic [`INT_NUM-1:0] int_pend;
logic [`INT_NUM-1:0] int_type;
logic [`INT_NUM-1:0] int_pol;
logic [        31:0] int_prior   [    `INT_NUM];
logic [`INT_NUM-1:0] int_en      [`CONTEXT_NUM];
logic [        31:0] int_id      [`CONTEXT_NUM];
logic [        31:0] threshold   [`CONTEXT_NUM];

logic [        31:0] int_id_tmp  [`CONTEXT_NUM];
logic [        31:0] int_max_pri [`CONTEXT_NUM];

logic                apb_wr;

logic [        31:0] prdata_t;
logic [        31:0] prdata_pri;
logic [        31:0] prdata_ip;
logic [        31:0] prdata_ityp;
logic [        31:0] prdata_ipol;
logic [        31:0] prdata_ie;
logic [        31:0] prdata_id;
logic [        31:0] prdata_th;

`define CMP_TREE_L0_NUM  (`INT_NUM)                                  // MAX: 1024
`define CMP_TREE_L1_NUM  (`CMP_TREE_L0_NUM/2 + `CMP_TREE_L0_NUM%2)   // MAX:  512
`define CMP_TREE_L2_NUM  (`CMP_TREE_L1_NUM/2 + `CMP_TREE_L1_NUM%2)   // MAX:  256
`define CMP_TREE_L3_NUM  (`CMP_TREE_L2_NUM/2 + `CMP_TREE_L2_NUM%2)   // MAX:  128
`define CMP_TREE_L4_NUM  (`CMP_TREE_L3_NUM/2 + `CMP_TREE_L3_NUM%2)   // MAX:   64
`define CMP_TREE_L5_NUM  (`CMP_TREE_L4_NUM/2 + `CMP_TREE_L4_NUM%2)   // MAX:   32
`define CMP_TREE_L6_NUM  (`CMP_TREE_L5_NUM/2 + `CMP_TREE_L5_NUM%2)   // MAX:   16
`define CMP_TREE_L7_NUM  (`CMP_TREE_L6_NUM/2 + `CMP_TREE_L6_NUM%2)   // MAX:    8
`define CMP_TREE_L8_NUM  (`CMP_TREE_L7_NUM/2 + `CMP_TREE_L7_NUM%2)   // MAX:    4
`define CMP_TREE_L9_NUM  (`CMP_TREE_L8_NUM/2 + `CMP_TREE_L8_NUM%2)   // MAX:    2
`define CMP_TREE_L10_NUM (`CMP_TREE_L9_NUM/2 + `CMP_TREE_L9_NUM%2)   // MAX:    1

parameter int CMP_TREE_NUM [0:10] = {
    `CMP_TREE_L0_NUM, 
    `CMP_TREE_L1_NUM, 
    `CMP_TREE_L2_NUM, 
    `CMP_TREE_L3_NUM, 
    `CMP_TREE_L4_NUM, 
    `CMP_TREE_L5_NUM, 
    `CMP_TREE_L6_NUM, 
    `CMP_TREE_L7_NUM, 
    `CMP_TREE_L8_NUM, 
    `CMP_TREE_L9_NUM, 
    `CMP_TREE_L10_NUM
};

genvar gvar_i;
genvar gvar_j;
genvar gvar_k;
generate
    for (gvar_i = 1; gvar_i < `INT_NUM; gvar_i = gvar_i + 1) begin: g_gateway

        always_comb begin
            integer i;
            claim [gvar_i] = 1'b0;
            cmplet[gvar_i] = 1'b0;
            for (i = 0; i < `CONTEXT_NUM; i = i + 1) begin
                claim [gvar_i] = claim [gvar_i] | (claim_id [i][0+:$clog2(`INT_NUM)] == gvar_i[0+:$clog2(`INT_NUM)]);
                cmplet[gvar_i] = cmplet[gvar_i] | (cmplet_id[i][0+:$clog2(`INT_NUM)] == gvar_i[0+:$clog2(`INT_NUM)]);
            end
        end

        gateway u_gateway(
            .clk      ( clk    ),
            .rstn     ( rstn ),
            .src      ( ints    [gvar_i] ),
            .src_type ( int_type[gvar_i] ), // 0: edge, 1: level
            .src_pol  ( int_pol [gvar_i] ), // 0: high, 1: low
            .claim    ( claim   [gvar_i] ),
            .cmplet   ( cmplet  [gvar_i] ),
            .pend     ( int_pend[gvar_i] )
        );
    end

    assign int_pend[0] = 1'b0;

    for (gvar_i = 0; gvar_i < `CONTEXT_NUM; gvar_i = gvar_i + 1) begin: g_target
        logic [`INT_NUM-1:0] ip_ie_ints;
        logic [        31:0] en_ints_pri [11][`CMP_TREE_L0_NUM];
        logic [         9:0] id_sel      [11][`CMP_TREE_L0_NUM];
        
        assign ip_ie_ints = int_pend & int_en[gvar_i];

        always_comb begin
            integer i;
            for (i = 0; i < `INT_NUM; i = i + 1) begin
                en_ints_pri[0][i] = {32{ip_ie_ints[i]}} & int_prior[i];
            end
        end

        for (gvar_j = 0; gvar_j < 10; gvar_j = gvar_j + 1) begin: g_cmp_tree_lvl
            if (gvar_j % 3 == 2) begin: g_pipelining
                for (gvar_k = 0; gvar_k <= CMP_TREE_NUM[gvar_j] - 1; gvar_k = gvar_k + 2) begin: g_cmp
                    if (gvar_k == CMP_TREE_NUM[gvar_j] - 1) begin: g_remainder
                        always_ff @(posedge clk or negedge rstn) begin
                            if (~rstn) begin
                                en_ints_pri[gvar_j+1][gvar_k>>1]     <= 32'b0;
                                id_sel[gvar_j+1][gvar_k>>1][gvar_j]  <= 1'b0;
                            end
                            else begin
                                en_ints_pri[gvar_j+1][gvar_k>>1]     <= en_ints_pri[gvar_j][gvar_k];
                                id_sel[gvar_j+1][gvar_k>>1][gvar_j]  <= 1'b0;
                            end
                        end
                        if (gvar_j > 0) begin: g_non_first
                            always_ff @(posedge clk or negedge rstn) begin
                                if (~rstn) begin
                                    id_sel[gvar_j+1][gvar_k>>1][0+:gvar_j] <= {gvar_j{1'b0}};
                                end
                                else begin
                                    id_sel[gvar_j+1][gvar_k>>1][0+:gvar_j] <= id_sel[gvar_j][gvar_k][0+:gvar_j];
                                end
                            end
                        end
                    end
                    else begin: g_cmp
                        always_ff @(posedge clk or negedge rstn) begin
                            if (~rstn) begin
                                en_ints_pri[gvar_j+1][gvar_k>>1]     <= 32'b0;
                                id_sel[gvar_j+1][gvar_k>>1][gvar_j]  <= 1'b0;
                            end
                            else begin
                                if (en_ints_pri[gvar_j][gvar_k] < en_ints_pri[gvar_j][gvar_k + 1]) begin
                                    en_ints_pri[gvar_j+1][gvar_k>>1]     <= en_ints_pri[gvar_j][gvar_k + 1];
                                    id_sel[gvar_j+1][gvar_k>>1][gvar_j]  <= 1'b1;
                                end
                                else begin
                                    en_ints_pri[gvar_j+1][gvar_k>>1]     <= en_ints_pri[gvar_j][gvar_k];
                                    id_sel[gvar_j+1][gvar_k>>1][gvar_j]  <= 1'b0;
                                end
                            end
                        end
                        if (gvar_j > 0) begin: g_non_first
                            always_ff @(posedge clk or negedge rstn) begin
                                if (~rstn) begin
                                    id_sel[gvar_j+1][gvar_k>>1][0+:gvar_j] <= {gvar_j{1'b0}};
                                end
                                else begin
                                    if (en_ints_pri[gvar_j][gvar_k] < en_ints_pri[gvar_j][gvar_k + 1]) begin
                                        id_sel[gvar_j+1][gvar_k>>1][0+:gvar_j] <= id_sel[gvar_j][gvar_k+1][0+:gvar_j];
                                    end
                                    else begin
                                        id_sel[gvar_j+1][gvar_k>>1][0+:gvar_j] <= id_sel[gvar_j][gvar_k][0+:gvar_j];
                                    end
                                end
                            end
                        end
                    end
                end
            end
            else begin: g_non_pipelining
                for (gvar_k = 0; gvar_k <= CMP_TREE_NUM[gvar_j] - 1; gvar_k = gvar_k + 2) begin: g_cmp
                    if (gvar_k == CMP_TREE_NUM[gvar_j] - 1) begin: g_remainder
                        assign en_ints_pri[gvar_j+1][gvar_k>>1]     = en_ints_pri[gvar_j][gvar_k];
                        assign id_sel[gvar_j+1][gvar_k>>1][gvar_j]  = 1'b0;
                        if (gvar_j > 0) begin: g_non_first
                            assign id_sel[gvar_j+1][gvar_k>>1][0+:gvar_j] = id_sel[gvar_j][gvar_k][0+:gvar_j];
                        end
                    end
                    else begin: g_cmp
                        always_comb begin
                            if (en_ints_pri[gvar_j][gvar_k] < en_ints_pri[gvar_j][gvar_k + 1]) begin
                                en_ints_pri[gvar_j+1][gvar_k>>1]     = en_ints_pri[gvar_j][gvar_k + 1];
                                id_sel[gvar_j+1][gvar_k>>1][gvar_j]  = 1'b1;
                            end
                            else begin
                                en_ints_pri[gvar_j+1][gvar_k>>1]     = en_ints_pri[gvar_j][gvar_k];
                                id_sel[gvar_j+1][gvar_k>>1][gvar_j]  = 1'b0;
                            end
                        end
                        if (gvar_j > 0) begin: g_non_first
                            always_comb begin
                                if (en_ints_pri[gvar_j][gvar_k] < en_ints_pri[gvar_j][gvar_k + 1]) begin
                                    id_sel[gvar_j+1][gvar_k>>1][0+:gvar_j] = id_sel[gvar_j][gvar_k+1][0+:gvar_j];
                                end
                                else begin
                                    id_sel[gvar_j+1][gvar_k>>1][0+:gvar_j] = id_sel[gvar_j][gvar_k][0+:gvar_j];
                                end
                            end
                        end
                    end
                end
            end
        end
        
        assign int_id_tmp[gvar_i]  = {22'b0, id_sel[10][0][9:0]};
        assign int_max_pri[gvar_i] = en_ints_pri[10][0];
    end
endgenerate

always_comb begin: comb_meip
    integer i;
    for (i = 0; i < `CPU_NUM; i = i + 1) begin
        meip[i] = claim_id[i*2  ] != int_id[i*2  ];
        seip[i] = claim_id[i*2+1] != int_id[i*2+1];
    end
end

always_comb begin: comb_apb_wr
    apb_wr = ~apb_intf.penable & apb_intf.psel & apb_intf.pwrite;
end

always_ff @(posedge clk or negedge rstn) begin: reg_int_prior
    integer i;
    if (~rstn) begin
        for (i = 0; i < `INT_NUM; i = i + 1) begin
            int_prior[i] <= 32'b0;
        end
    end
    else if (apb_wr) begin
        for (i = 1; i < `INT_NUM; i = i + 1) begin
            if (apb_intf.paddr[25:0] == `PLIC_INT_PRIOR + 26'h4 * i[25:0]) begin
                int_prior[i] <= apb_intf.pwdata;
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_int_type
    integer i;
    if (~rstn) begin
        int_type <= {`INT_NUM{1'b1}};
    end
    else if (apb_wr) begin
        for (i = 0; i < `INT_NUM; i = i + 32) begin
            if (apb_intf.paddr[25:0] == `PLIC_INT_TYPE + i[28:3]) begin
                int_type[i+:32] <= apb_intf.pwdata;
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_int_pol
    integer i;
    if (~rstn) begin
        int_pol <= `INT_NUM'b0;
    end
    else if (apb_wr) begin
        for (i = 0; i < `INT_NUM; i = i + 32) begin
            if (apb_intf.paddr[25:0] == `PLIC_INT_POL + i[28:3]) begin
                int_pol[i+:32] <= apb_intf.pwdata;
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_int_en
    integer i, j;
    if (~rstn) begin
        for (j = 0; j < `CONTEXT_NUM; j = j + 1) begin
            int_en[j] <= `INT_NUM'b0;
        end
    end
    else if (apb_wr) begin
        for (j = 0; j < `CONTEXT_NUM; j = j + 1) begin
            for (i = 0; i < `INT_NUM; i = i + 32) begin
                if (apb_intf.paddr[25:0] == `PLIC_INT_EN + i[28:3] + 26'h80 * j[25:0]) begin
                    int_en[j][i+:32] <= apb_intf.pwdata;
                end
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_threshold
    integer i;
    if (~rstn) begin
        for (i = 0; i < `CONTEXT_NUM; i = i + 1) begin
            threshold[i] <= 32'b0;
        end
    end
    else if (apb_wr) begin
        for (i = 0; i < `CONTEXT_NUM; i = i + 1) begin
            if (apb_intf.paddr[25:0] == `PLIC_PRIOR_TH + 26'h1000 * i[25:0]) begin
                threshold[i] <= apb_intf.pwdata;
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_int_id
    integer i;
    if (~rstn) begin
        for (i = 0; i < `CONTEXT_NUM; i = i + 1) begin
            int_id   [i] <= 32'b0;
        end
    end
    else begin
        for (i = 0; i < `CONTEXT_NUM; i = i + 1) begin
            if (!(~apb_intf.penable && apb_intf.psel &&
                apb_intf.paddr[25:0] == `PLIC_PRIOR_TH + 26'h1000 * i[25:0] + 26'h4)) begin
                if (~|claim_id[i]) begin // non-preemptive
                    int_id   [i] <= int_max_pri[i] > threshold[i] ? int_id_tmp[i] : 32'b0;
                end
            end
            else if (apb_intf.pwrite) begin
                int_id   [i] <= 32'b0;
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_claim_id
    integer i;
    if (~rstn) begin
        for (i = 0; i < `CONTEXT_NUM; i = i + 1) begin
            claim_id [i] <= 32'b0;
        end
    end
    else begin
        for (i = 0; i < `CONTEXT_NUM; i = i + 1) begin
            if (~apb_intf.penable && apb_intf.psel &&
                apb_intf.paddr[25:0] == `PLIC_PRIOR_TH + 26'h1000 * i[25:0] + 26'h4) begin
                claim_id [i] <= apb_intf.pwrite ? 32'b0 : int_id[i];
            end
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_cmplet_id
    integer i;
    if (~rstn) begin
        for (i = 0; i < `CONTEXT_NUM; i = i + 1) begin
            cmplet_id[i] <= 32'b0;
        end
    end
    else begin
        for (i = 0; i < `CONTEXT_NUM; i = i + 1) begin
            if (apb_wr && apb_intf.paddr[25:0] == `PLIC_PRIOR_TH + 26'h1000 * i[25:0] + 26'h4) begin
                cmplet_id[i] <= claim_id[i];
            end
            else begin
                cmplet_id[i] <= 32'b0;
            end
        end
    end
end

always_comb begin: comb_prdata_pri
    integer i;
    prdata_pri = 32'b0;
    for (i = 0; i < `INT_NUM; i = i + 1) begin
        prdata_pri = prdata_pri |
                    (int_prior[i] & {32{apb_intf.paddr[25:0] == `PLIC_INT_PRIOR + 26'h4 * i[25:0]}});
    end
end

always_comb begin: comb_prdata_ip
    integer i;
    prdata_ip = 32'b0;
    for (i = 0; i < `INT_NUM; i = i + 32) begin
        prdata_ip = prdata_ip |
                    (int_pend[i+:32] & {32{apb_intf.paddr[25:0] == `PLIC_INT_PEND + i[28:3]}});
    end
end

always_comb begin: comb_prdata_ityp
    integer i;
    prdata_ityp = 32'b0;
    for (i = 0; i < `INT_NUM; i = i + 32) begin
        prdata_ityp = prdata_ityp |
                      (int_type[i+:32] & {32{apb_intf.paddr[25:0] == `PLIC_INT_TYPE + i[28:3]}});
    end
end

always_comb begin: comb_prdata_ipol
    integer i;
    prdata_ipol = 32'b0;
    for (i = 0; i < `INT_NUM; i = i + 32) begin
        prdata_ipol = prdata_ipol |
                      (int_pol[i+:32] & {32{apb_intf.paddr[25:0] == `PLIC_INT_POL + i[28:3]}});
    end
end

always_comb begin: comb_prdata_ie
    integer i, j;
    prdata_ie = 32'b0;
    for (j = 0; j < `CONTEXT_NUM; j = j + 1) begin
        for (i = 0; i < `INT_NUM; i = i + 32) begin
            prdata_ie = prdata_ie |
                        (int_en[j][i+:32] &
                         {32{apb_intf.paddr[25:0] == `PLIC_INT_EN + i[28:3] + 26'h80 * j[25:0]}});
        end
    end
end

always_comb begin: comb_prdata_th
    integer i;
    prdata_th = 32'b0;
    for (i = 0; i < `CONTEXT_NUM; i = i + 1) begin
        prdata_th = prdata_th |
                    (threshold[i] & {32{apb_intf.paddr[25:0] == `PLIC_PRIOR_TH + 26'h1000 * i[25:0]}});
    end
end

always_comb begin: comb_prdata_id
    integer i;
    prdata_id = 32'b0;
    for (i = 0; i < `CONTEXT_NUM; i = i + 1) begin
        prdata_id = prdata_id |
                    (int_id[i] & {32{apb_intf.paddr[25:0] == `PLIC_PRIOR_TH + 26'h1000 * i[25:0] + 26'h4}});
    end
end

assign prdata_t = prdata_pri | prdata_ip | prdata_ityp | prdata_ipol | prdata_ie | prdata_id | prdata_th;

always_ff @(posedge clk or negedge rstn) begin: reg_rdata
    if (~rstn) begin
        apb_intf.prdata <= 32'b0;
    end
    else begin
        apb_intf.prdata <= prdata_t;
    end
end

assign apb_intf.pslverr = 1'b0;
assign apb_intf.pready  = 1'b1;

endmodule


module gateway (
    input        clk,
    input        rstn,
    input        src,
    input        src_type, // 0: edge, 1: level
    input        src_pol,  // 0: high, 1: low
    input        claim,
    input        cmplet,
    output logic pend
);

parameter [1:0] STATE_IDLE  = 2'b00,
                STATE_PEND  = 2'b01,
                STATE_CLAIM = 2'b10;

logic [1:0] cur_state;
logic [1:0] nxt_state;

logic       src_pol_dly;
logic       src_lvl;
logic       src_edge;
logic       is_pend;
logic       is_claim;
logic       is_cancel;
logic       is_cmplet;

always_ff @(posedge clk or negedge rstn) begin: fsm
    if (~rstn) begin
        cur_state <= STATE_IDLE;
    end
    else begin
        cur_state <= nxt_state;
    end
end

always_comb begin: next_state
    nxt_state = cur_state;
    case (cur_state)
        STATE_IDLE : nxt_state = is_pend   ? STATE_PEND  : STATE_IDLE;
        STATE_PEND : nxt_state = is_claim  ? STATE_CLAIM :
                                 is_cancel ? STATE_IDLE  : STATE_PEND;
        STATE_CLAIM: nxt_state = is_cmplet ? STATE_IDLE  : STATE_CLAIM;
    endcase
end

assign src_tmp = src ^ src_pol;

always_ff @(posedge clk or negedge rstn) begin: reg_src_pol_dly
    if (~rstn) begin
        src_pol_dly  <= 1'b0;
    end
    else begin
        src_pol_dly  <= src_pol;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_src_lvl
    if (~rstn) begin
        src_lvl <= 1'b0;
    end
    else begin
        src_lvl <= src_tmp;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_src_edge
    if (~rstn) begin
        src_edge <= 1'b0;
    end
    else begin
        src_edge <= ~src_lvl & src_tmp;
    end
end

assign is_pend   = src_type ?  src_lvl : src_edge;
assign is_claim  = claim;
assign is_cancel = (src_type ? ~src_lvl : 1'b0) | (src_pol ^ src_pol_dly);
assign is_cmplet = cmplet;

assign pend      = cur_state == STATE_PEND;

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/dbgapb.sv
/*--------------------------------------*/

`ifndef __DBGAPB_DEFINE__
`define __DBGAPB_DEFINE__

`define INST_ATTACH     12'h000
`define INST_RESUME     12'h001

`define INST_INSTREG_WR 12'h002
`define INST_EXECUTE    12'h003
`define INST_STATUS_RD  12'h004
`define INST_PC_RD      12'h005
`define INST_GPR_RD     12'h006
`define INST_CSR_RD     12'h007
`define INST_GPR_WR     12'h008
`define INST_CSR_WR     12'h009

`endif
`ifndef __DBGAPB_MMAP__
`define __DBGAPB_MMAP__

`define DBGAPB_DBG_EN     12'h000
`define DBGAPB_INST       12'h004
`define DBGAPB_INST_WR    12'h008
`define DBGAPB_WDATA_L    12'h010
`define DBGAPB_WDATA_H    12'h014
`define DBGAPB_WDATA_WR   12'h01C
`define DBGAPB_RDATA_L    12'h020
`define DBGAPB_RDATA_H    12'h024

`endif

module dbgapb (
    input                       clk,
    input                       rstn,
    apb_intf.slave              apb_intf,

    output logic [       11: 0] addr_out,
    output logic [`XLEN - 1: 0] wdata_out,
    output logic                gpr_rd,
    output logic                gpr_wr,
    input        [`XLEN - 1: 0] gpr_in,
    output logic                csr_rd,
    output logic                csr_wr,
    input        [`XLEN - 1: 0] csr_in,
    input        [`XLEN - 1: 0] pc,
    output logic [       31: 0] insn_out,
    output logic                exec,
    input                       halted,
    output logic                attach
);

logic               dbg_en;
logic [       31:0] dbg_insn;
logic               dbg_insn_wr;
logic [`XLEN - 1:0] dbg_wdata;
logic               dbg_wdata_wr;
logic [`XLEN - 1:0] dbg_rdata;

logic [`XLEN - 1:0] wdata_reg;
logic [`XLEN - 1:0] rdata_reg;
logic [`XLEN - 1:0] status_reg;

logic               rdata_sel;
logic               pc_rd;

logic               nxt_attach;
logic [       31:0] nxt_insn_out;
logic               nxt_exec;
logic               nxt_rdata_sel;
logic               nxt_pc_rd;
logic [       11:0] nxt_addr_out;
logic               nxt_gpr_rd;
logic               nxt_csr_rd;
logic               nxt_gpr_wr;
logic               nxt_csr_wr;

logic [        9:0] nxt_ready_cnt;
logic [        9:0] ready_cnt;

assign status_reg = {{`XLEN-2{1'b0}}, halted, attach};

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        rdata_reg <= `XLEN'b0;
    end
    else if (pc_rd) begin
        rdata_reg <= pc;
    end
    else if (gpr_rd) begin
        rdata_reg <= gpr_in;
    end
    else if (csr_rd) begin
        rdata_reg <= csr_in;
    end
end

assign dbg_rdata = rdata_sel ? status_reg : rdata_reg;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        wdata_reg <= 32'b0;
    end
    else if (dbg_wdata_wr) begin
        wdata_reg <= dbg_wdata;
    end
end

assign wdata_out = wdata_reg;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        attach     <= 1'b0;
        insn_out   <= 32'b0;
        exec       <= 1'b0;
        rdata_sel  <= 1'b0;
        pc_rd      <= 1'b0;
        addr_out   <= 12'b0;
        gpr_rd     <= 1'b0;
        csr_rd     <= 1'b0;
        gpr_wr     <= 1'b0;
        csr_wr     <= 1'b0;
    end
    else if (dbg_insn_wr) begin
        attach     <= nxt_attach;
        insn_out   <= nxt_insn_out;
        exec       <= nxt_exec;
        rdata_sel  <= nxt_rdata_sel;
        pc_rd      <= nxt_pc_rd;
        addr_out   <= nxt_addr_out;
        gpr_rd     <= nxt_gpr_rd;
        csr_rd     <= nxt_csr_rd;
        gpr_wr     <= nxt_gpr_wr;
        csr_wr     <= nxt_csr_wr;
    end
    else begin
        exec       <= 1'b0;
        pc_rd      <= 1'b0;
        gpr_rd     <= 1'b0;
        csr_rd     <= 1'b0;
        gpr_wr     <= 1'b0;
        csr_wr     <= 1'b0;
    end
end

always_comb begin
    nxt_attach    = attach;
    nxt_insn_out  = insn_out;
    nxt_exec      = 1'b0;
    nxt_rdata_sel = rdata_sel;
    nxt_pc_rd     = 1'b0;
    nxt_addr_out  = addr_out;
    nxt_gpr_rd    = 1'b0;
    nxt_csr_rd    = 1'b0;
    nxt_gpr_wr    = 1'b0;
    nxt_csr_wr    = 1'b0;
    case (dbg_insn[11:0])
        `INST_ATTACH: begin
            nxt_attach    = 1'b1;
        end
        `INST_RESUME: begin
            nxt_attach    = 1'b0;
        end
        `INST_INSTREG_WR: begin
            nxt_insn_out  = wdata_reg[31:0];
        end
        `INST_EXECUTE: begin
            nxt_exec      = 1'b1;
        end
        `INST_STATUS_RD: begin
            nxt_rdata_sel = 1'b1;
        end
        `INST_PC_RD: begin
            nxt_rdata_sel = 1'b0;
            nxt_pc_rd     = 1'b1;
        end
        `INST_GPR_RD: begin
            nxt_rdata_sel = 1'b0;
            nxt_addr_out  = {4'b0, dbg_insn[23:16]};
            nxt_gpr_rd    = 1'b1;
        end
        `INST_CSR_RD: begin
            nxt_rdata_sel = 1'b0;
            nxt_addr_out  = dbg_insn[27:16];
            nxt_csr_rd    = 1'b1;
        end
        `INST_GPR_WR: begin
            nxt_addr_out  = {7'b0, dbg_insn[20:16]};
            nxt_gpr_wr    = 1'b1;
        end
        `INST_CSR_WR: begin
            nxt_addr_out  = dbg_insn[27:16];
            nxt_csr_wr    = 1'b1;
        end
    endcase
end

logic        apb_wr;
logic        dbgapb_wr;

assign apb_wr    = ~apb_intf.penable && apb_intf.psel && apb_intf.pwrite;
assign dbgapb_wr = dbg_en && apb_wr;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        dbg_en <= 1'b0;
    end
    else if (apb_wr && apb_intf.paddr[11:0] == `DBGAPB_DBG_EN) begin
        dbg_en <= apb_intf.pwdata[0];
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        dbg_insn <= 32'b0;
    end
    else if (dbgapb_wr && apb_intf.paddr[11:0] == `DBGAPB_INST) begin
        dbg_insn <= apb_intf.pwdata;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        dbg_insn_wr <= 1'b0;
    end
    else if (dbgapb_wr && apb_intf.paddr[11:0] == `DBGAPB_INST_WR) begin
        dbg_insn_wr <= 1'b1;
    end
    else begin
        dbg_insn_wr <= 1'b0;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        dbg_wdata <= `XLEN'b0;
    end
    else if (dbgapb_wr && apb_intf.paddr[11:0] == `DBGAPB_WDATA_L) begin
        dbg_wdata[ 0+:32] <= apb_intf.pwdata;
    end
`ifndef RV32
    else if (dbgapb_wr && apb_intf.paddr[11:0] == `DBGAPB_WDATA_H) begin
        dbg_wdata[32+:32] <= apb_intf.pwdata;
    end
`endif
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        dbg_wdata_wr <= 1'b0;
    end
    else if (dbgapb_wr && apb_intf.paddr[11:0] == `DBGAPB_WDATA_WR) begin
        dbg_wdata_wr <= 1'b1;
    end
    else begin
        dbg_wdata_wr <= 1'b0;
    end
end

logic [31:0] prdata_t;

always_comb begin
    prdata_t = 32'b0;
    case (apb_intf.paddr[11:0])
        `DBGAPB_DBG_EN  : prdata_t = {31'b0, dbg_en};
        `DBGAPB_INST    : prdata_t = dbg_insn;
        `DBGAPB_INST_WR : prdata_t = {31'b0, dbg_insn_wr};
        `DBGAPB_WDATA_L : prdata_t = dbg_wdata[ 0+:32];
`ifndef RV32
        `DBGAPB_WDATA_H : prdata_t = dbg_wdata[32+:32];
`endif
        `DBGAPB_WDATA_WR: prdata_t = {31'b0, dbg_wdata_wr};
        `DBGAPB_RDATA_L : prdata_t = dbg_rdata[ 0+:32];
`ifndef RV32
        `DBGAPB_RDATA_H : prdata_t = dbg_rdata[32+:32];
`endif
    endcase
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        apb_intf.prdata <= 32'b0;
    end
    else begin
        apb_intf.prdata <= dbg_en ? prdata_t : 32'b0;
    end
end

always_comb begin
    nxt_ready_cnt = 10'b0;
    case (apb_intf.paddr[11:0])
        `DBGAPB_INST_WR: begin
            case (dbg_insn[11:0])
                `INST_EXECUTE   : nxt_ready_cnt = 10'h5;
                `INST_STATUS_RD : nxt_ready_cnt = 10'h1;
                `INST_PC_RD     : nxt_ready_cnt = 10'h1;
                `INST_GPR_RD    : nxt_ready_cnt = 10'h1;
                `INST_CSR_RD    : nxt_ready_cnt = 10'h1;
                `INST_GPR_WR    : nxt_ready_cnt = 10'h1;
                `INST_CSR_WR    : nxt_ready_cnt = 10'h2;
            endcase
        end
    endcase
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        ready_cnt <= 10'b0;
    end
    else if (apb_wr) begin
        ready_cnt <= nxt_ready_cnt;
    end
    else if (|ready_cnt) begin
        ready_cnt <= ready_cnt - 10'b1;
    end
end

assign apb_intf.pslverr = 1'b0;
assign apb_intf.pready  = ~|ready_cnt;

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/util.sv
/*--------------------------------------*/

module CG (
    input  CK,
    input  EN,
    output CKEN
);

logic en_latch;

always_latch begin
    if (~CK) en_latch <= EN;
end

assign CKEN = CK & en_latch;

endmodule

module resetn_synchronizer (
    input  clk,
    input  rstn_async,
    output rstn_sync
);

logic rstn_async_d1;
logic rstn_async_d2;

always @(posedge clk or negedge rstn_async) begin
    if (~rstn_async) rstn_async_d1 <= 1'b0;
    else             rstn_async_d1 <= 1'b1;
end

always @(posedge clk or negedge rstn_async) begin
    if (~rstn_async) rstn_async_d2 <= 1'b0;
    else             rstn_async_d2 <= rstn_async_d1;
end

assign rstn_sync = rstn_async_d2;

endmodule

module clz_64 (
    input        [63:0] in,
    output logic [ 6:0] out
);

// logic [63:0] tmp5;
// logic [31:0] tmp4;
// logic [15:0] tmp3;
// logic [ 7:0] tmp2;
// logic [ 3:0] tmp1;
// logic [ 1:0] tmp0;
// 
// assign out[6] = ~|in;
// assign out[5] = ~|tmp5[63:32];
// assign out[4] = ~|tmp4[31:16];
// assign out[3] = ~|tmp3[15: 8];
// assign out[2] = ~|tmp2[ 7: 4];
// assign out[1] = ~|tmp1[ 3: 2];
// assign out[0] = ~ tmp0[ 1];
// 
// assign tmp5   = out[6] ? -64'b1     : in;
// assign tmp4   = out[5] ? tmp5[31:0] : tmp5[63:32];
// assign tmp3   = out[4] ? tmp4[15:0] : tmp4[31:16];
// assign tmp2   = out[3] ? tmp3[ 7:0] : tmp3[15: 8];
// assign tmp1   = out[2] ? tmp2[ 3:0] : tmp2[ 7: 4];
// assign tmp0   = out[1] ? tmp1[ 1:0] : tmp1[ 3: 2];

// assign out[6] = ~|in;
// assign out[5] = ~|in[63:32];
// assign out[4] = ~|in[31:16];
// assign out[3] = ~|tmp3[15: 8];
// assign out[2] = ~|tmp2[ 7: 4];
// assign out[1] = ~|tmp1[ 3: 2];
// assign out[0] = ~ tmp0[ 1];

logic [63:0] encode;
logic [47:0] tmp1;
logic [31:0] tmp2;
logic [19:0] tmp3;
logic [11:0] tmp4;
logic [ 6:0] tmp5;

always_comb begin
    integer i;
    for (i = 0; i < 64; i = i + 2) begin
        encode[i+:2] = {~|in[i+:2], ~in[i+1] & in[i]};
    end
    for (i = 0; i < 16; i = i + 1) begin
        tmp1[(i*3)+:3] = {encode[(i*4)+3] & encode[(i*4)+1], ~{2{encode[(i*4)+3] & encode[(i*4)+1]}} & (encode[(i*4)+3] ? {1'b1, encode[(i*4)]} : encode[((i*4)+2)+:2])};
    end
    for (i = 0; i < 8; i = i + 1) begin
        tmp2[(i*4)+:4] = {tmp1[(i*6)+5] & tmp1[(i*6)+2], ~{3{tmp1[(i*6)+5] & tmp1[(i*6)+2]}} & (tmp1[(i*6)+5] ? {1'b1, tmp1[(i*6)+:2]} : tmp1[((i*6)+3)+:3])};
    end
    for (i = 0; i < 4; i = i + 1) begin
        tmp3[(i*5)+:5] = {tmp2[(i*8)+7] & tmp2[(i*8)+3], ~{4{tmp2[(i*8)+7] & tmp2[(i*8)+3]}} & (tmp2[(i*8)+7] ? {1'b1, tmp2[(i*8)+:3]} : tmp2[((i*8)+4)+:4])};
    end
    for (i = 0; i < 2; i = i + 1) begin
        tmp4[(i*6)+:6] = {tmp3[(i*10)+9] & tmp3[(i*10)+4], ~{5{tmp3[(i*10)+9] & tmp3[(i*10)+4]}} & (tmp3[(i*10)+9] ? {1'b1, tmp3[(i*10)+:4]} : tmp3[((i*10)+5)+:5])};
    end
    for (i = 0; i < 1; i = i + 1) begin
        tmp5[(i*7)+:7] = {tmp4[(i*12)+11] & tmp4[(i*12)+5], ~{6{tmp4[(i*12)+11] & tmp4[(i*12)+5]}} & (tmp4[(i*12)+11] ? {1'b1, tmp4[(i*12)+:5]} : tmp4[((i*12)+6)+:6])};
    end
end

assign out = tmp5;

endmodule

module clz_32 (
    input        [31:0] in,
    output logic [ 5:0] out
);

logic [31:0] encode;
logic [23:0] tmp1;
logic [15:0] tmp2;
logic [ 9:0] tmp3;
logic [ 5:0] tmp4;

always_comb begin
    integer i;
    for (i = 0; i < 32; i = i + 2) begin
        encode[i+:2] = {~|in[i+:2], ~in[i+1] & in[i]};
    end
    for (i = 0; i < 8; i = i + 1) begin
        tmp1[(i*3)+:3] = {encode[(i*4)+3] & encode[(i*4)+1], ~{2{encode[(i*4)+3] & encode[(i*4)+1]}} & (encode[(i*4)+3] ? {1'b1, encode[(i*4)]} : encode[((i*4)+2)+:2])};
    end
    for (i = 0; i < 4; i = i + 1) begin
        tmp2[(i*4)+:4] = {tmp1[(i*6)+5] & tmp1[(i*6)+2], ~{3{tmp1[(i*6)+5] & tmp1[(i*6)+2]}} & (tmp1[(i*6)+5] ? {1'b1, tmp1[(i*6)+:2]} : tmp1[((i*6)+3)+:3])};
    end
    for (i = 0; i < 2; i = i + 1) begin
        tmp3[(i*5)+:5] = {tmp2[(i*8)+7] & tmp2[(i*8)+3], ~{4{tmp2[(i*8)+7] & tmp2[(i*8)+3]}} & (tmp2[(i*8)+7] ? {1'b1, tmp2[(i*8)+:3]} : tmp2[((i*8)+4)+:4])};
    end
    for (i = 0; i < 1; i = i + 1) begin
        tmp4[(i*6)+:6] = {tmp3[(i*10)+9] & tmp3[(i*10)+4], ~{5{tmp3[(i*10)+9] & tmp3[(i*10)+4]}} & (tmp3[(i*10)+9] ? {1'b1, tmp3[(i*10)+:4]} : tmp3[((i*10)+5)+:5])};
    end
end

assign out = tmp4;

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/peri.sv
/*--------------------------------------*/

`ifndef __SOC_DEFINE__
`define __SOC_DEFINE__

`define CPU_NUM 1
`define INT_NUM 32

`endif

module peri (
    input             clk,
    input             rstn,
    apb_intf.slave    s_apb_intf,

    // UART interface
    input             uart_rx,
    output            uart_tx,

    // SPI interface
    // inout             sclk,
    // inout             nss,
    // inout             mosi,
    // inout             miso
    output            sclk,
    output            nss,
    output            mosi,
    input             miso,

    // SPI DMA interface
    axi_intf.master   m_dma_axi_intf,

    // RMII interface
    input             rmii_refclk,
    input             rmii_crsdv,
    input    [ 1: 0]  rmii_rxd,
    output            rmii_txen,
    output   [ 1: 0]  rmii_txd,

    // IRQ
    output            uart_irq,
    output            spi_irq,
    output            mac_irq
);

apb_intf uart_apb();
apb_intf spi_apb();
apb_intf mac_apb();

peri_apb_conn u_peri_apb_conn (
    .peri_apb ( s_apb_intf      ),
    .uart_apb ( uart_apb.master ),
    .spi_apb  ( spi_apb.master  ),
    .mac_apb  ( mac_apb.master  )
);

uart u_uart(
    .clk        ( clk            ),
    .rstn       ( rstn           ),
    .s_apb_intf ( uart_apb.slave ),

    .irq_out    ( uart_irq       ),
    .uart_rx    ( uart_rx        ),
    .uart_tx    ( uart_tx        )
);


spi_core u_spi_core (
    .clk        ( clk            ),
    .rstn       ( rstn           ),
    .s_apb_intf ( spi_apb.slave  ),

    // SPI interface
    .sclk       ( sclk           ),
    .nss        ( nss            ),
    .mosi       ( mosi           ),
    .miso       ( miso           ),

    // DMA
    .m_axi_intf ( m_dma_axi_intf ),

    // Interrupt
    .irq_out    ( spi_irq        )
);

mac u_mac (
    .clk         ( clk           ),
    .rstn        ( rstn          ),
    .s_apb_intf  ( mac_apb.slave ),

    // RMII interface
    .rmii_refclk ( rmii_refclk   ),
    .rmii_crsdv  ( rmii_crsdv    ),
    .rmii_rxd    ( rmii_rxd      ),
    .rmii_txen   ( rmii_txen     ),
    .rmii_txd    ( rmii_txd      ),

    // Interrupt 
    .irq_out     ( mac_irq       )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/cpu/cpu_tracer.sv
/*--------------------------------------*/

module cpu_tracer (
    input                clk,
    input                srstn,
    input                xrstn,
    input                valid,
    input  [       63:0] cycle,
    input  [        1:0] misa_mxl,
    input                len_64,
    input  [  `XLEN-1:0] pc,
    input  [  `XLEN-1:0] epc,
    input  [       31:0] insn,
    input  [        1:0] prv,
    input                rd_wr,
    input  [        4:0] rd_addr,
    input  [  `XLEN-1:0] rd_data,
    input                csr_wr,
    input  [       11:0] csr_waddr,
    input  [  `XLEN-1:0] csr_wdata,
    input  [  `XLEN-1:0] mem_addr,
    input                mem_req,
    input                mem_wr,
    input  [`XLEN/8-1:0] mem_byte,
    input  [  `XLEN-1:0] mem_rdata,
    input  [  `XLEN-1:0] mem_wdata,
    input                trap_en,
    input  [  `XLEN-1:0] mcause,
    input  [  `XLEN-1:0] mtval,
    input                halted,
    output               pkg_valid,
    output [      255:0] pkg
);


assign pkg_valid = valid || trap_en;
assign pkg       = ~trap_en ? mem_req ? mem_wr ? {1'b0, prv[1:0], misa_mxl[1], cycle[27:0],  pc[63:0], insn[31:0],  mem_addr[63:0], mem_wdata[63:0]}:
                                                 {1'b0, prv[1:0], misa_mxl[1], cycle[27:0],  pc[63:0], insn[31:0],  mem_addr[63:0], mem_rdata[63:0]}:
                                                 {1'b0, prv[1:0], misa_mxl[1], cycle[27:0],  pc[63:0], insn[31:0], csr_wdata[63:0],   rd_data[63:0]}:
                                                 {1'b1, prv[1:0], misa_mxl[1], cycle[27:0], epc[63:0],      32'b0,    mcause[63:0],     mtval[63:0]};
                                           

`ifdef CPULOG
integer cpu_tracer_file;
logic   halted_dly;
logic   srstn_dly;
logic   xrstn_dly;

`include "cpu_define.h"

function string regs_name;
input [4:0] reg_id;

casex (reg_id)
    5'd0 :   return "zero";
    5'd1 :   return "ra";
    5'd2 :   return "sp";
    5'd3 :   return "gp";
    5'd4 :   return "tp";
    5'd5 :   return "t0";
    5'd6 :   return "t1";
    5'd7 :   return "t2";
    5'd8 :   return "s0";
    // 5'd8 :   return "fp";
    5'd9 :   return "s1";
    5'd10:   return "a0";
    5'd11:   return "a1";
    5'd12:   return "a2";
    5'd13:   return "a3";
    5'd14:   return "a4";
    5'd15:   return "a5";
    5'd16:   return "a6";
    5'd17:   return "a7";
    5'd18:   return "s2";
    5'd19:   return "s3";
    5'd20:   return "s4";
    5'd21:   return "s5";
    5'd22:   return "s6";
    5'd23:   return "s7";
    5'd24:   return "s8";
    5'd25:   return "s9";
    5'd26:   return "s10";
    5'd27:   return "s11";
    5'd28:   return "t3";
    5'd29:   return "t4";
    5'd30:   return "t5";
    5'd31:   return "t6";
    default: return "unknown reg";
endcase

endfunction

function string csr_name;
input [11:0] csr_addr;
string csr_id;
$sformat(csr_id, "0x%0x", csr_addr);

casex (csr_addr)
    `CSR_USTATUS_ADDR       : return "ustatus";       
    `CSR_UIE_ADDR           : return "uie";           
    `CSR_UTVEC_ADDR         : return "utvec";         
    `CSR_USCRATCH_ADDR      : return "uscratch";      
    `CSR_UEPC_ADDR          : return "uepc";          
    `CSR_UCAUSE_ADDR        : return "ucause";        
    `CSR_UTVAL_ADDR         : return "utval";         
    `CSR_UIP_ADDR           : return "uip";           
    `CSR_FFLAGS_ADDR        : return "fflags";        
    `CSR_FRM_ADDR           : return "frm";           
    `CSR_FCSR_ADDR          : return "fcsr";          
    `CSR_CYCLE_ADDR         : return "cycle";         
    `CSR_TIME_ADDR          : return "time";          
    `CSR_INSTRET_ADDR       : return "instret";       
    `CSR_HPMCOUNTER3_ADDR   : return "hpmcounter3";   
    `CSR_HPMCOUNTER4_ADDR   : return "hpmcounter4";   
    `CSR_HPMCOUNTER5_ADDR   : return "hpmcounter5";   
    `CSR_HPMCOUNTER6_ADDR   : return "hpmcounter6";   
    `CSR_HPMCOUNTER7_ADDR   : return "hpmcounter7";   
    `CSR_HPMCOUNTER8_ADDR   : return "hpmcounter8";   
    `CSR_HPMCOUNTER9_ADDR   : return "hpmcounter9";   
    `CSR_HPMCOUNTER10_ADDR  : return "hpmcounter10";  
    `CSR_HPMCOUNTER11_ADDR  : return "hpmcounter11";  
    `CSR_HPMCOUNTER12_ADDR  : return "hpmcounter12";  
    `CSR_HPMCOUNTER13_ADDR  : return "hpmcounter13";  
    `CSR_HPMCOUNTER14_ADDR  : return "hpmcounter14";  
    `CSR_HPMCOUNTER15_ADDR  : return "hpmcounter15";  
    `CSR_HPMCOUNTER16_ADDR  : return "hpmcounter16";  
    `CSR_HPMCOUNTER17_ADDR  : return "hpmcounter17";  
    `CSR_HPMCOUNTER18_ADDR  : return "hpmcounter18";  
    `CSR_HPMCOUNTER19_ADDR  : return "hpmcounter19";  
    `CSR_HPMCOUNTER20_ADDR  : return "hpmcounter20";  
    `CSR_HPMCOUNTER21_ADDR  : return "hpmcounter21";  
    `CSR_HPMCOUNTER22_ADDR  : return "hpmcounter22";  
    `CSR_HPMCOUNTER23_ADDR  : return "hpmcounter23";  
    `CSR_HPMCOUNTER24_ADDR  : return "hpmcounter24";  
    `CSR_HPMCOUNTER25_ADDR  : return "hpmcounter25";  
    `CSR_HPMCOUNTER26_ADDR  : return "hpmcounter26";  
    `CSR_HPMCOUNTER27_ADDR  : return "hpmcounter27";  
    `CSR_HPMCOUNTER28_ADDR  : return "hpmcounter28";  
    `CSR_HPMCOUNTER29_ADDR  : return "hpmcounter29";  
    `CSR_HPMCOUNTER30_ADDR  : return "hpmcounter30";  
    `CSR_HPMCOUNTER31_ADDR  : return "hpmcounter31";  
    `CSR_CYCLEH_ADDR        : return "cycleh";        
    `CSR_TIMEH_ADDR         : return "timeh";         
    `CSR_INSTRETH_ADDR      : return "instreth";      
    `CSR_HPMCOUNTER3H_ADDR  : return "hpmcounter3h";  
    `CSR_HPMCOUNTER4H_ADDR  : return "hpmcounter4h";  
    `CSR_HPMCOUNTER5H_ADDR  : return "hpmcounter5h";  
    `CSR_HPMCOUNTER6H_ADDR  : return "hpmcounter6h";  
    `CSR_HPMCOUNTER7H_ADDR  : return "hpmcounter7h";  
    `CSR_HPMCOUNTER8H_ADDR  : return "hpmcounter8h";  
    `CSR_HPMCOUNTER9H_ADDR  : return "hpmcounter9h";  
    `CSR_HPMCOUNTER10H_ADDR : return "hpmcounter10h"; 
    `CSR_HPMCOUNTER11H_ADDR : return "hpmcounter11h"; 
    `CSR_HPMCOUNTER12H_ADDR : return "hpmcounter12h"; 
    `CSR_HPMCOUNTER13H_ADDR : return "hpmcounter13h"; 
    `CSR_HPMCOUNTER14H_ADDR : return "hpmcounter14h"; 
    `CSR_HPMCOUNTER15H_ADDR : return "hpmcounter15h"; 
    `CSR_HPMCOUNTER16H_ADDR : return "hpmcounter16h"; 
    `CSR_HPMCOUNTER17H_ADDR : return "hpmcounter17h"; 
    `CSR_HPMCOUNTER18H_ADDR : return "hpmcounter18h"; 
    `CSR_HPMCOUNTER19H_ADDR : return "hpmcounter19h"; 
    `CSR_HPMCOUNTER20H_ADDR : return "hpmcounter20h"; 
    `CSR_HPMCOUNTER21H_ADDR : return "hpmcounter21h"; 
    `CSR_HPMCOUNTER22H_ADDR : return "hpmcounter22h"; 
    `CSR_HPMCOUNTER23H_ADDR : return "hpmcounter23h"; 
    `CSR_HPMCOUNTER24H_ADDR : return "hpmcounter24h"; 
    `CSR_HPMCOUNTER25H_ADDR : return "hpmcounter25h"; 
    `CSR_HPMCOUNTER26H_ADDR : return "hpmcounter26h"; 
    `CSR_HPMCOUNTER27H_ADDR : return "hpmcounter27h"; 
    `CSR_HPMCOUNTER28H_ADDR : return "hpmcounter28h"; 
    `CSR_HPMCOUNTER29H_ADDR : return "hpmcounter29h"; 
    `CSR_HPMCOUNTER30H_ADDR : return "hpmcounter30h"; 
    `CSR_HPMCOUNTER31H_ADDR : return "hpmcounter31h"; 
                                                     
    `CSR_SSTATUS_ADDR       : return "sstatus";       
    `CSR_SEDELEG_ADDR       : return "sedeleg";       
    `CSR_SIDELEG_ADDR       : return "sideleg";       
    `CSR_SIE_ADDR           : return "sie";           
    `CSR_STVEC_ADDR         : return "stvec";         
    `CSR_SCOUNTEREN_ADDR    : return "scounteren";    
    `CSR_SSCRATCH_ADDR      : return "sscratch";      
    `CSR_SEPC_ADDR          : return "sepc";          
    `CSR_SCAUSE_ADDR        : return "scause";        
    `CSR_STVAL_ADDR         : return "stval";         
    `CSR_SIP_ADDR           : return "sip";           
    `CSR_SATP_ADDR          : return "satp";          
                                                     
    `CSR_MVENDORID_ADDR     : return "mvendorid";     
    `CSR_MARCHID_ADDR       : return "marchid";       
    `CSR_MIMPID_ADDR        : return "mimpid";        
    `CSR_MHARTID_ADDR       : return "mhartid";       
    `CSR_MSTATUS_ADDR       : return "mstatus";       
    `CSR_MISA_ADDR          : return "misa";          
    `CSR_MEDELEG_ADDR       : return "medeleg";       
    `CSR_MIDELEG_ADDR       : return "mideleg";       
    `CSR_MIE_ADDR           : return "mie";           
    `CSR_MTVEC_ADDR         : return "mtvec";         
    `CSR_MCOUNTEREN_ADDR    : return "mcounteren";    
    `CSR_MSCRATCH_ADDR      : return "mscratch";      
    `CSR_MEPC_ADDR          : return "mepc";          
    `CSR_MCAUSE_ADDR        : return "mcause";        
    `CSR_MTVAL_ADDR         : return "mtval";         
    `CSR_MIP_ADDR           : return "mip";           
    `CSR_PMPCFG0_ADDR       : return "pmpcfg0";       
    `CSR_PMPCFG1_ADDR       : return "pmpcfg1";       
    `CSR_PMPCFG2_ADDR       : return "pmpcfg2";       
    `CSR_PMPCFG3_ADDR       : return "pmpcfg3";       
    `CSR_PMPADDR0_ADDR      : return "pmpaddr0";      
    `CSR_PMPADDR1_ADDR      : return "pmpaddr1";      
    `CSR_PMPADDR2_ADDR      : return "pmpaddr2";      
    `CSR_PMPADDR3_ADDR      : return "pmpaddr3";      
    `CSR_PMPADDR4_ADDR      : return "pmpaddr4";      
    `CSR_PMPADDR5_ADDR      : return "pmpaddr5";      
    `CSR_PMPADDR6_ADDR      : return "pmpaddr6";      
    `CSR_PMPADDR7_ADDR      : return "pmpaddr7";      
    `CSR_PMPADDR8_ADDR      : return "pmpaddr8";      
    `CSR_PMPADDR9_ADDR      : return "pmpaddr9";      
    `CSR_PMPADDR10_ADDR     : return "pmpaddr10";     
    `CSR_PMPADDR11_ADDR     : return "pmpaddr11";     
    `CSR_PMPADDR12_ADDR     : return "pmpaddr12";     
    `CSR_PMPADDR13_ADDR     : return "pmpaddr13";     
    `CSR_PMPADDR14_ADDR     : return "pmpaddr14";     
    `CSR_PMPADDR15_ADDR     : return "pmpaddr15";     
    `CSR_PMACFG0_ADDR       : return "pmacfg0";       
    `CSR_PMACFG1_ADDR       : return "pmacfg1";       
    `CSR_PMACFG2_ADDR       : return "pmacfg2";       
    `CSR_PMACFG3_ADDR       : return "pmacfg3";       
    `CSR_PMAADDR0_ADDR      : return "pmaaddr0";      
    `CSR_PMAADDR1_ADDR      : return "pmaaddr1";      
    `CSR_PMAADDR2_ADDR      : return "pmaaddr2";      
    `CSR_PMAADDR3_ADDR      : return "pmaaddr3";      
    `CSR_PMAADDR4_ADDR      : return "pmaaddr4";      
    `CSR_PMAADDR5_ADDR      : return "pmaaddr5";      
    `CSR_PMAADDR6_ADDR      : return "pmaaddr6";      
    `CSR_PMAADDR7_ADDR      : return "pmaaddr7";      
    `CSR_PMAADDR8_ADDR      : return "pmaaddr8";      
    `CSR_PMAADDR9_ADDR      : return "pmaaddr9";      
    `CSR_PMAADDR10_ADDR     : return "pmaaddr10";     
    `CSR_PMAADDR11_ADDR     : return "pmaaddr11";     
    `CSR_PMAADDR12_ADDR     : return "pmaaddr12";     
    `CSR_PMAADDR13_ADDR     : return "pmaaddr13";     
    `CSR_PMAADDR14_ADDR     : return "pmaaddr14";     
    `CSR_PMAADDR15_ADDR     : return "pmaaddr15";     
    `CSR_MCYCLE_ADDR        : return "mcycle";        
    `CSR_MINSTRET_ADDR      : return "minstret";      
    `CSR_MHPMCOUNTER3_ADDR  : return "mhpmcounter3";  
    `CSR_MHPMCOUNTER4_ADDR  : return "mhpmcounter4";  
    `CSR_MHPMCOUNTER5_ADDR  : return "mhpmcounter5";  
    `CSR_MHPMCOUNTER6_ADDR  : return "mhpmcounter6";  
    `CSR_MHPMCOUNTER7_ADDR  : return "mhpmcounter7";  
    `CSR_MHPMCOUNTER8_ADDR  : return "mhpmcounter8";  
    `CSR_MHPMCOUNTER9_ADDR  : return "mhpmcounter9";  
    `CSR_MHPMCOUNTER10_ADDR : return "mhpmcounter10"; 
    `CSR_MHPMCOUNTER11_ADDR : return "mhpmcounter11"; 
    `CSR_MHPMCOUNTER12_ADDR : return "mhpmcounter12"; 
    `CSR_MHPMCOUNTER13_ADDR : return "mhpmcounter13"; 
    `CSR_MHPMCOUNTER14_ADDR : return "mhpmcounter14"; 
    `CSR_MHPMCOUNTER15_ADDR : return "mhpmcounter15"; 
    `CSR_MHPMCOUNTER16_ADDR : return "mhpmcounter16"; 
    `CSR_MHPMCOUNTER17_ADDR : return "mhpmcounter17"; 
    `CSR_MHPMCOUNTER18_ADDR : return "mhpmcounter18"; 
    `CSR_MHPMCOUNTER19_ADDR : return "mhpmcounter19"; 
    `CSR_MHPMCOUNTER20_ADDR : return "mhpmcounter20"; 
    `CSR_MHPMCOUNTER21_ADDR : return "mhpmcounter21"; 
    `CSR_MHPMCOUNTER22_ADDR : return "mhpmcounter22"; 
    `CSR_MHPMCOUNTER23_ADDR : return "mhpmcounter23"; 
    `CSR_MHPMCOUNTER24_ADDR : return "mhpmcounter24"; 
    `CSR_MHPMCOUNTER25_ADDR : return "mhpmcounter25"; 
    `CSR_MHPMCOUNTER26_ADDR : return "mhpmcounter26"; 
    `CSR_MHPMCOUNTER27_ADDR : return "mhpmcounter27"; 
    `CSR_MHPMCOUNTER28_ADDR : return "mhpmcounter28"; 
    `CSR_MHPMCOUNTER29_ADDR : return "mhpmcounter29"; 
    `CSR_MHPMCOUNTER30_ADDR : return "mhpmcounter30"; 
    `CSR_MHPMCOUNTER31_ADDR : return "mhpmcounter31"; 
    `CSR_MCYCLEH_ADDR       : return "mcycleh";       
    `CSR_MINSTRETH_ADDR     : return "minstreth";     
    `CSR_MHPMCOUNTER3H_ADDR : return "mhpmcounter3h"; 
    `CSR_MHPMCOUNTER4H_ADDR : return "mhpmcounter4h"; 
    `CSR_MHPMCOUNTER5H_ADDR : return "mhpmcounter5h"; 
    `CSR_MHPMCOUNTER6H_ADDR : return "mhpmcounter6h"; 
    `CSR_MHPMCOUNTER7H_ADDR : return "mhpmcounter7h"; 
    `CSR_MHPMCOUNTER8H_ADDR : return "mhpmcounter8h"; 
    `CSR_MHPMCOUNTER9H_ADDR : return "mhpmcounter9h"; 
    `CSR_MHPMCOUNTER10H_ADDR: return "mhpmcounter10h";
    `CSR_MHPMCOUNTER11H_ADDR: return "mhpmcounter11h";
    `CSR_MHPMCOUNTER12H_ADDR: return "mhpmcounter12h";
    `CSR_MHPMCOUNTER13H_ADDR: return "mhpmcounter13h";
    `CSR_MHPMCOUNTER14H_ADDR: return "mhpmcounter14h";
    `CSR_MHPMCOUNTER15H_ADDR: return "mhpmcounter15h";
    `CSR_MHPMCOUNTER16H_ADDR: return "mhpmcounter16h";
    `CSR_MHPMCOUNTER17H_ADDR: return "mhpmcounter17h";
    `CSR_MHPMCOUNTER18H_ADDR: return "mhpmcounter18h";
    `CSR_MHPMCOUNTER19H_ADDR: return "mhpmcounter19h";
    `CSR_MHPMCOUNTER20H_ADDR: return "mhpmcounter20h";
    `CSR_MHPMCOUNTER21H_ADDR: return "mhpmcounter21h";
    `CSR_MHPMCOUNTER22H_ADDR: return "mhpmcounter22h";
    `CSR_MHPMCOUNTER23H_ADDR: return "mhpmcounter23h";
    `CSR_MHPMCOUNTER24H_ADDR: return "mhpmcounter24h";
    `CSR_MHPMCOUNTER25H_ADDR: return "mhpmcounter25h";
    `CSR_MHPMCOUNTER26H_ADDR: return "mhpmcounter26h";
    `CSR_MHPMCOUNTER27H_ADDR: return "mhpmcounter27h";
    `CSR_MHPMCOUNTER28H_ADDR: return "mhpmcounter28h";
    `CSR_MHPMCOUNTER29H_ADDR: return "mhpmcounter29h";
    `CSR_MHPMCOUNTER30H_ADDR: return "mhpmcounter30h";
    `CSR_MHPMCOUNTER31H_ADDR: return "mhpmcounter31h";
    `CSR_MHPMEVENT3_ADDR    : return "mhpmevent3";    
    `CSR_MHPMEVENT4_ADDR    : return "mhpmevent4";    
    `CSR_MHPMEVENT5_ADDR    : return "mhpmevent5";    
    `CSR_MHPMEVENT6_ADDR    : return "mhpmevent6";    
    `CSR_MHPMEVENT7_ADDR    : return "mhpmevent7";    
    `CSR_MHPMEVENT8_ADDR    : return "mhpmevent8";    
    `CSR_MHPMEVENT9_ADDR    : return "mhpmevent9";    
    `CSR_MHPMEVENT10_ADDR   : return "mhpmevent10";   
    `CSR_MHPMEVENT11_ADDR   : return "mhpmevent11";   
    `CSR_MHPMEVENT12_ADDR   : return "mhpmevent12";   
    `CSR_MHPMEVENT13_ADDR   : return "mhpmevent13";   
    `CSR_MHPMEVENT14_ADDR   : return "mhpmevent14";   
    `CSR_MHPMEVENT15_ADDR   : return "mhpmevent15";   
    `CSR_MHPMEVENT16_ADDR   : return "mhpmevent16";   
    `CSR_MHPMEVENT17_ADDR   : return "mhpmevent17";   
    `CSR_MHPMEVENT18_ADDR   : return "mhpmevent18";   
    `CSR_MHPMEVENT19_ADDR   : return "mhpmevent19";   
    `CSR_MHPMEVENT20_ADDR   : return "mhpmevent20";   
    `CSR_MHPMEVENT21_ADDR   : return "mhpmevent21";   
    `CSR_MHPMEVENT22_ADDR   : return "mhpmevent22";   
    `CSR_MHPMEVENT23_ADDR   : return "mhpmevent23";   
    `CSR_MHPMEVENT24_ADDR   : return "mhpmevent24";   
    `CSR_MHPMEVENT25_ADDR   : return "mhpmevent25";   
    `CSR_MHPMEVENT26_ADDR   : return "mhpmevent26";   
    `CSR_MHPMEVENT27_ADDR   : return "mhpmevent27";   
    `CSR_MHPMEVENT28_ADDR   : return "mhpmevent28";   
    `CSR_MHPMEVENT29_ADDR   : return "mhpmevent29";   
    `CSR_MHPMEVENT30_ADDR   : return "mhpmevent30";   
    `CSR_MHPMEVENT31_ADDR   : return "mhpmevent31";   
                                                     
    `CSR_TSELECT_ADDR       : return "tselect";       
    `CSR_TDATA1_ADDR        : return "tdata1";        
    `CSR_TDATA2_ADDR        : return "tdata2";        
    `CSR_TDATA3_ADDR        : return "tdata3";        
    `CSR_DCSR_ADDR          : return "dcsr";          
    `CSR_DPC_ADDR           : return "dpc";           
    `CSR_DSCRATCH_ADDR      : return "dscratch";      
    default: return csr_id;
endcase

endfunction

function string fence_flag;
input [3:0] arg;

string str;
str = "";

if (arg[3])
    str = {str, "i"};
if (arg[2])
    str = {str, "o"};
if (arg[1])
    str = {str, "r"};
if (arg[0])
    str = {str, "w"};
if (str == "")
    str = {str, "-"};

return str;

endfunction

function string insn_dis;
input [31:0] pc;
input [31:0] insn;
input [ 1:0] misa_mxl;

string result;
`include "opcode.sv"
`include "funct.sv"

parameter [4:0] REG_ZERO = 5'd0;
parameter [4:0] REG_RA   = 5'd1;
parameter [4:0] REG_SP   = 5'd2;
parameter [4:0] REG_GP   = 5'd3;
parameter [4:0] REG_TP   = 5'd4;
parameter [4:0] REG_T0   = 5'd5;
parameter [4:0] REG_T1   = 5'd6;
parameter [4:0] REG_T2   = 5'd7;
parameter [4:0] REG_S0   = 5'd8;
parameter [4:0] REG_FP   = 5'd8;
parameter [4:0] REG_S1   = 5'd9;
parameter [4:0] REG_A0   = 5'd10;
parameter [4:0] REG_A1   = 5'd11;
parameter [4:0] REG_A2   = 5'd12;
parameter [4:0] REG_A3   = 5'd13;
parameter [4:0] REG_A4   = 5'd14;
parameter [4:0] REG_A5   = 5'd15;
parameter [4:0] REG_A6   = 5'd16;
parameter [4:0] REG_A7   = 5'd17;
parameter [4:0] REG_S2   = 5'd18;
parameter [4:0] REG_S3   = 5'd19;
parameter [4:0] REG_S4   = 5'd20;
parameter [4:0] REG_S5   = 5'd21;
parameter [4:0] REG_S6   = 5'd22;
parameter [4:0] REG_S7   = 5'd23;
parameter [4:0] REG_S8   = 5'd24;
parameter [4:0] REG_S9   = 5'd25;
parameter [4:0] REG_S10  = 5'd26;
parameter [4:0] REG_S11  = 5'd27;
parameter [4:0] REG_T3   = 5'd28;
parameter [4:0] REG_T4   = 5'd29;
parameter [4:0] REG_T5   = 5'd30;
parameter [4:0] REG_T6   = 5'd31;

logic [        4: 0] rs1;
logic [        4: 0] rs2;
logic [        4: 0] rd;
logic [       11: 0] csr_addr;

logic [`XLEN - 1:0] imm_i;
logic [`XLEN - 1:0] imm_s;
logic [`XLEN - 1:0] imm_b;
logic [`XLEN - 1:0] imm_u;
logic [`XLEN - 1:0] imm_j;

logic [`XLEN - 1:0] imm_ci_lwsp;
logic [`XLEN - 1:0] imm_ci_ldsp;
logic [`XLEN - 1:0] imm_ci_li;
logic [`XLEN - 1:0] imm_ci_lui;
logic [`XLEN - 1:0] imm_ci_addi16sp;
logic [`XLEN - 1:0] imm_css;
logic [`XLEN - 1:0] imm_css64;
logic [`XLEN - 1:0] imm_ciw;
logic [`XLEN - 1:0] imm_cl;
logic [`XLEN - 1:0] imm_cl64;
logic [`XLEN - 1:0] imm_cs;
logic [`XLEN - 1:0] imm_cb;
logic [`XLEN - 1:0] imm_cj;

logic [       2: 0] funct3;
logic [       4: 0] funct5;
logic [       6: 0] funct7;

logic               aq;
logic               rl;

logic [      15:13] funct3_16;
logic [      15:13] funct2_16_op_imm;
logic [      15:13] funct2_16_op;

logic [       6: 2] opcode_32;
logic [       1: 0] opcode_16;

logic [       3: 0] pred;
logic [       3: 0] succ;
logic [       5: 0] shamt;

rs1      = insn[19:15];
rs2      = insn[24:20];
rd       = insn[11: 7];
csr_addr = insn[31:20];

imm_i     = {{(`XLEN-11){insn[31]}}, insn[30:25], insn[24:21], insn[20]};
imm_s     = {{(`XLEN-11){insn[31]}}, insn[30:25], insn[11:8],  insn[7]};
imm_b     = {{(`XLEN-12){insn[31]}}, insn[7],     insn[30:25], insn[11:8], 1'b0};
imm_u     = {{(`XLEN-31){insn[31]}}, insn[30:20], insn[19:12], 12'b0};
imm_j     = {{(`XLEN-20){insn[31]}}, insn[19:12], insn[20],    insn[30:25], insn[24:21], 1'b0};

imm_ci_lwsp     = {{(`XLEN-8){1'b0}},      insn[3:2], insn[12], insn[6:4], 2'b0};
imm_ci_ldsp     = {{(`XLEN-9){1'b0}},      insn[4:2], insn[12], insn[6:5], 3'b0};
imm_ci_li       = {{(`XLEN-5){insn[12]}},  insn[6:2]};
imm_ci_lui      = {{(`XLEN-17){insn[12]}}, insn[6:2], 12'b0};
imm_ci_addi16sp = {{(`XLEN-9){insn[12]}},  insn[4:3], insn[5], insn[2], insn[6], 4'b0};
imm_css         = {{(`XLEN-8){1'b0}},      insn[8:7], insn[12:9], 2'b0};
imm_css64       = {{(`XLEN-9){1'b0}},      insn[9:7], insn[12:10], 3'b0};
imm_ciw         = {{(`XLEN-10){1'b0}},     insn[10:7], insn[12:11], insn[5], insn[6], 2'b0};
imm_cl          = {{(`XLEN-7){1'b0}},      insn[5], insn[12:10], insn[6], 2'b0};
imm_cl64        = {{(`XLEN-8){1'b0}},      insn[6], insn[5], insn[12:10], 3'b0};
imm_cs          = {{(`XLEN-7){1'b0}},      insn[5], insn[12:10], insn[6], 2'b0};
imm_cb          = {{(`XLEN-8){insn[12]}},  insn[6:5], insn[2], insn[11:10], insn[4:3], 1'b0};
imm_cj          = {{(`XLEN-11){insn[12]}}, insn[8], insn[10:9], insn[6], insn[7], insn[2], insn[11], insn[5:3], 1'b0};

funct3           = insn[14:12];
funct5           = insn[31:27];
funct7           = insn[31:25];

aq               = insn[26];
rl               = insn[25];

funct3_16        = insn[15:13];
funct2_16_op_imm = insn[11:10];
funct2_16_op     = insn[ 6: 5];

opcode_16 = insn[1:0];
opcode_32 = insn[6:2];

pred   = insn[27:24];
succ   = insn[23:20];

shamt  = insn[25:20];

result = "unknown insn";
case (opcode_16)
    OP16_C0: begin
        rs1            = {2'b1, insn[ 9: 7]};
        rs2            = {2'b1, insn[ 4: 2]};
        rd             = {2'b1, insn[ 4: 2]};
        case (funct3_16)
            FUNCT3_C0_ADDI4SPN: $sformat(result, "c.addi4spn %s,%s,%0d", regs_name(rd), regs_name(REG_SP), $signed(imm_ciw));
            FUNCT3_C0_FLD     : return "illigal insn";
            FUNCT3_C0_LW      : $sformat(result, "c.lw %s,%0d(%s)", regs_name(rd), $signed(imm_cl), regs_name(rs1));
            FUNCT3_C0_FLW     : $sformat(result, "c.ld %s,%0d(%s)", regs_name(rd), $signed(imm_cl64), regs_name(rs1));
            FUNCT3_C0_FSD     : return "illigal insn";
            FUNCT3_C0_SW      : $sformat(result, "c.sw %s,%0d(%s)", regs_name(rs2), $signed(imm_cs), regs_name(rs1));
            FUNCT3_C0_FSW     : $sformat(result, "c.sd %s,%0d(%s)", regs_name(rs2), $signed(imm_cl64), regs_name(rs1));
            default           : return "illigal insn";
        endcase
    end
    OP16_C1: begin
        rs1            = {2'b1, insn[ 9: 7]};
        rs2            = {2'b1, insn[ 4: 2]};
        rd             = {2'b1, insn[ 9: 7]};
        case (funct3_16)
            FUNCT3_C1_ADDI: begin
                rs1     = insn[ 11: 7];
                rd      = insn[ 11: 7];
                if (~|rd && ~|imm_ci_li) $sformat(result, "c.nop");
                else                     $sformat(result, "c.addi %s,%0d", regs_name(rd), $signed(imm_ci_li));
            end
            FUNCT3_C1_JAL : begin
                rs1     = insn[ 11: 7];
                rd      = insn[ 11: 7];
                case (misa_mxl)
                    `MISA_MXL_XLEN_32: $sformat(result, "c.jal %08x", pc + imm_cj);
                    `MISA_MXL_XLEN_64: $sformat(result, "c.addiw %s,%0d", regs_name(rd), $signed(imm_ci_li));
                    default          : return "illigal insn";
                endcase
            end
            FUNCT3_C1_LI  : begin
                rd      = insn[ 11: 7];
                $sformat(result, "c.li %s,%0d", regs_name(rd), $signed(imm_ci_li));
            end
            FUNCT3_C1_LUI : begin
                rs1     = insn[ 11: 7];
                rd      = insn[ 11: 7];
                if (rd == REG_SP) $sformat(result, "c.addi16sp %s,%0d", regs_name(REG_SP), $signed(imm_ci_addi16sp));
                else              $sformat(result, "c.lui %s,0x%0x", regs_name(rd), imm_ci_lui >> 12 & 20'hfffff);
            end
            FUNCT3_C1_OP  : begin
                case (funct2_16_op_imm)
                    FUNCT2_OP_IMM_C_SRLI: $sformat(result, "c.srli %s,0x%0x", regs_name(rd), imm_ci_li[4:0]);
                    FUNCT2_OP_IMM_C_SRAI: $sformat(result, "c.srai %s,0x%0x", regs_name(rd), imm_ci_li[4:0]);
                    FUNCT2_OP_IMM_C_ANDI: $sformat(result, "c.andi %s,0x%0x", regs_name(rd), imm_ci_li);
                    FUNCT2_OP_IMM_C_OP  : begin
                        if (insn[12] == 1'b0) begin
                            case (funct2_16_op)
                                FUNCT2_OP_C_SUB: $sformat(result, "c.sub %s,%s", regs_name(rd), regs_name(rs2));
                                FUNCT2_OP_C_XOR: $sformat(result, "c.xor %s,%s", regs_name(rd), regs_name(rs2));
                                FUNCT2_OP_C_OR : $sformat(result, "c.or %s,%s", regs_name(rd), regs_name(rs2));
                                FUNCT2_OP_C_AND: $sformat(result, "c.and %s,%s", regs_name(rd), regs_name(rs2));
                                default        : return "illigal insn";
                            endcase
                        end
                        else begin
                            case (funct2_16_op)
                                FUNCT2_OP_C_SUBW: $sformat(result, "c.subw %s,%s", regs_name(rd), regs_name(rs2));
                                FUNCT2_OP_C_ADDW: $sformat(result, "c.addw %s,%s", regs_name(rd), regs_name(rs2));
                                default         : return "illigal insn";
                            endcase
                        end
                    end
                    default             : return "illigal insn";
                endcase
            end
            FUNCT3_C1_J   : $sformat(result, "c.j %08x", pc + imm_cj & -32'b1);
            FUNCT3_C1_BEQZ: $sformat(result, "c.beqz %s,%08x", regs_name(rs1), pc + imm_cb & -32'b1);
            FUNCT3_C1_BNEZ: $sformat(result, "c.bnez %s,%08x", regs_name(rs1), pc + imm_cb & -32'b1);
            default       : return "illigal insn";
        endcase
    end
    OP16_C2: begin
        rs1            = {insn[11: 7]};
        rs2            = {insn[ 6: 2]};
        rd             = {insn[11: 7]};
        case (funct3_16)
            FUNCT3_C2_SLLI : $sformat(result, "c.slli %s,0x%0x", regs_name(rd), imm_ci_li[4:0]);
            FUNCT3_C2_FLDSP: return "illigal insn";
            FUNCT3_C2_LWSP : $sformat(result, "c.lwsp %s,%0d(%s)", regs_name(rd), $signed(imm_ci_lwsp), regs_name(REG_SP));
            FUNCT3_C2_FLWSP: begin
                case (misa_mxl)
                    `MISA_MXL_XLEN_32: return "illigal insn";
                    `MISA_MXL_XLEN_64: $sformat(result, "c.ldsp %s,%0d(%s)", regs_name(rd), $signed(imm_ci_ldsp), regs_name(REG_SP));
                    default          : return "illigal insn";
                endcase
            end
            FUNCT3_C2_OP   : begin
                if (~insn[12]) begin
                    if (rs2 == REG_ZERO) $sformat(result, "c.jr %s", regs_name(rs1));
                    else                 $sformat(result, "c.mv %s,%s", regs_name(rd), regs_name(rs2));
                end
                else begin
                    if (rs2 == REG_ZERO) begin
                        if (rs1 == REG_ZERO) $sformat(result, "c.ebreak");
                        else                 $sformat(result, "c.jalr %s", regs_name(rs1));
                    end
                    else $sformat(result, "c.add %s,%s", regs_name(rd), regs_name(rs2));
                end
            end
            FUNCT3_C2_FSDSP: return "illigal insn";
            FUNCT3_C2_SWSP : $sformat(result, "c.swsp %s,%0d(%s)", regs_name(rs2), $signed(imm_css), regs_name(REG_SP));
            FUNCT3_C2_FSWSP: begin
                case (misa_mxl)
                    `MISA_MXL_XLEN_32: return "illigal insn";
                    `MISA_MXL_XLEN_64: $sformat(result, "c.sdsp %s,%0d(%s)", regs_name(rs2), $signed(imm_css64), regs_name(REG_SP));
                    default          : return "illigal insn";
                endcase
            end
            default        : return "illigal insn";
        endcase
    end
    default: begin
        case (opcode_32)
            OP_LOAD     : begin
                case (funct3)
                    FUNCT3_LB : $sformat(result, "lb %s,%0d(%s)",  regs_name(rd), $signed(imm_i), regs_name(rs1));
                    FUNCT3_LH : $sformat(result, "lh %s,%0d(%s)",  regs_name(rd), $signed(imm_i), regs_name(rs1));
                    FUNCT3_LW : $sformat(result, "lw %s,%0d(%s)",  regs_name(rd), $signed(imm_i), regs_name(rs1));
                    FUNCT3_LBU: $sformat(result, "lbu %s,%0d(%s)", regs_name(rd), $signed(imm_i), regs_name(rs1));
                    FUNCT3_LHU: $sformat(result, "lhu %s,%0d(%s)", regs_name(rd), $signed(imm_i), regs_name(rs1));
                    FUNCT3_LWU: $sformat(result, "lwu %s,%0d(%s)", regs_name(rd), $signed(imm_i), regs_name(rs1));
                    FUNCT3_LD : $sformat(result, "ld %s,%0d(%s)",  regs_name(rd), $signed(imm_i), regs_name(rs1));
                    default   : return "illigal insn";
                endcase
            end
            OP_LOAD_FP  : begin
            end
            OP_CUST_0   : begin
            end
            OP_MISC_MEM : begin
                case ({funct3, insn[11:7], insn[19:15], insn[31:28]})
                    {FUNCT3_FENCE  , 5'b0, 5'b0, 4'b0}: begin
                        if (pred != 4'hf | succ != 4'hf)
                            $sformat(result, "fence %s,%s", fence_flag(pred), fence_flag(succ));
                        else
                            $sformat(result, "fence");
                    end
                    {FUNCT3_FENCE_I, 5'b0, 5'b0, 4'b0}: begin
                        if (insn[27:20] == 8'b0) begin
                            $sformat(result, "fence.i");
                        end
                        else return "illigal insn";
                    end
                    default       : begin
                        return "illigal insn";
                    end
                endcase
            end
            OP_OP_IMM   : begin
                case (funct3)
                    FUNCT3_ADDI : begin
                        if (!rd && !rs1 && !imm_i)
                            $sformat(result, "nop");
                        else if (!rs1)
                            $sformat(result, "li %s,%0d", regs_name(rd), $signed(imm_i));
                        else if (!imm_i)
                            $sformat(result, "mv %s,%s", regs_name(rd), regs_name(rs1));
                        else
                            $sformat(result, "addi %s,%s,%0d", regs_name(rd), regs_name(rs1), $signed(imm_i));
                    end
                    FUNCT3_SLTI : begin
                        $sformat(result, "slti %s,%s,%0d", regs_name(rd), regs_name(rs1), imm_i);
                    end
                    FUNCT3_SLTIU: begin
                        $sformat(result, "sltiu %s,%s,%0d", regs_name(rd), regs_name(rs1), imm_i);
                    end
                    FUNCT3_XORI : begin
                        if (imm_i == -`XLEN'd1)
                            $sformat(result, "not %s,%s", regs_name(rd), regs_name(rs1));
                        else
                            $sformat(result, "xori %s,%s,0x%0x", regs_name(rd), regs_name(rs1), imm_i);
                    end
                    FUNCT3_ORI  : begin
                        $sformat(result, "ori %s,%s,0x%0x", regs_name(rd), regs_name(rs1), imm_i);
                    end
                    FUNCT3_ANDI : begin
                        $sformat(result, "andi %s,%s,0x%0x", regs_name(rd), regs_name(rs1), imm_i);
                    end
                    FUNCT3_SLLI : begin
                        case (funct7[6:1])
                            FUNCT7_SLLI[6:1]: begin
                                $sformat(result, "slli %s,%s,0x%0x", regs_name(rd), regs_name(rs1), shamt);
                            end
                            default         : begin
                                return "illigal insn";
                            end
                        endcase
                    end
                    FUNCT3_SRLI : begin
                        case (funct7[6:1])
                            FUNCT7_SRLI[6:1]: $sformat(result, "srli %s,%s,0x%0x", regs_name(rd), regs_name(rs1), shamt);
                            FUNCT7_SRAI[6:1]: $sformat(result, "srai %s,%s,0x%0x", regs_name(rd), regs_name(rs1), shamt);
                            default         : return "illigal insn";
                        endcase
                    end
                    default     : begin
                        return "illigal insn";
                    end
                endcase
            end
            OP_AUIPC    : begin
                $sformat(result, "auipc %s,0x%0x", regs_name(rd), imm_u >> 12 & 20'hfffff);
            end
            OP_OP_IMM_32: begin
                case (funct3)
                    FUNCT3_ADDI : begin
                        if (!imm_i)
                            $sformat(result, "sext.w %s,%s", regs_name(rd), regs_name(rs1));
                        else
                            $sformat(result, "addiw %s,%s,%0d", regs_name(rd), regs_name(rs1), $signed(imm_i));
                    end
                    FUNCT3_SLLI : begin
                        case (funct7[6:1])
                            FUNCT7_SLLI[6:1]: $sformat(result, "slliw %s,%s,0x%0x", regs_name(rd), regs_name(rs1), shamt);
                            default         : return "illigal insn";
                        endcase
                    end
                    FUNCT3_SRLI : begin
                        case (funct7[6:1])
                            FUNCT7_SRLI[6:1]: $sformat(result, "srliw %s,%s,0x%0x", regs_name(rd), regs_name(rs1), shamt);
                            FUNCT7_SRAI[6:1]: $sformat(result, "sraiw %s,%s,0x%0x", regs_name(rd), regs_name(rs1), shamt);
                            default         : return "illigal insn";
                        endcase
                    end
                    default     : return "illigal insn";
                endcase
            end
            OP_STORE    : begin
                case (funct3)
                    FUNCT3_SB: $sformat(result, "sb %s,%0d(%s)", regs_name(rs2), $signed(imm_s), regs_name(rs1));
                    FUNCT3_SH: $sformat(result, "sh %s,%0d(%s)", regs_name(rs2), $signed(imm_s), regs_name(rs1));
                    FUNCT3_SW: $sformat(result, "sw %s,%0d(%s)", regs_name(rs2), $signed(imm_s), regs_name(rs1));
                    FUNCT3_SD: $sformat(result, "sd %s,%0d(%s)", regs_name(rs2), $signed(imm_s), regs_name(rs1));
                    default  : return "illigal insn";
                endcase
            end
            OP_STORE_FP : begin
            end
            OP_CUST_1   : begin
            end
            OP_AMO      : begin
                case (funct5)
                    FUNCT5_LR     : $sformat(result, "lr%0s%0s%0s %s,(%s)",         (funct3==3'b10)?".w":".d", aq?".aq":"", rl?".rl":"", regs_name(rd), regs_name(rs1));
                    FUNCT5_SC     : $sformat(result, "sc%0s%0s%0s %s,%s,(%s)",      (funct3==3'b10)?".w":".d", aq?".aq":"", rl?".rl":"", regs_name(rd), regs_name(rs2), regs_name(rs1));
                    FUNCT5_AMOSWAP: $sformat(result, "amoswap%0s%0s%0s %s,%s,(%s)", (funct3==3'b10)?".w":".d", aq?".aq":"", rl?".rl":"", regs_name(rd), regs_name(rs2), regs_name(rs1));
                    FUNCT5_AMOADD : $sformat(result, "amoadd%0s%0s%0s %s,%s,(%s)",  (funct3==3'b10)?".w":".d", aq?".aq":"", rl?".rl":"", regs_name(rd), regs_name(rs2), regs_name(rs1));
                    FUNCT5_AMOXOR : $sformat(result, "amoxor%0s%0s%0s %s,%s,(%s)",  (funct3==3'b10)?".w":".d", aq?".aq":"", rl?".rl":"", regs_name(rd), regs_name(rs2), regs_name(rs1));
                    FUNCT5_AMOAND : $sformat(result, "amoand%0s%0s%0s %s,%s,(%s)",  (funct3==3'b10)?".w":".d", aq?".aq":"", rl?".rl":"", regs_name(rd), regs_name(rs2), regs_name(rs1));
                    FUNCT5_AMOOR  : $sformat(result, "amoor%0s%0s%0s %s,%s,(%s)",   (funct3==3'b10)?".w":".d", aq?".aq":"", rl?".rl":"", regs_name(rd), regs_name(rs2), regs_name(rs1));
                    FUNCT5_AMOMIN : $sformat(result, "amomin%0s%0s%0s %s,%s,(%s)",  (funct3==3'b10)?".w":".d", aq?".aq":"", rl?".rl":"", regs_name(rd), regs_name(rs2), regs_name(rs1));
                    FUNCT5_AMOMAX : $sformat(result, "amomax%0s%0s%0s %s,%s,(%s)",  (funct3==3'b10)?".w":".d", aq?".aq":"", rl?".rl":"", regs_name(rd), regs_name(rs2), regs_name(rs1));
                    FUNCT5_AMOMINU: $sformat(result, "amominu%0s%0s%0s %s,%s,(%s)", (funct3==3'b10)?".w":".d", aq?".aq":"", rl?".rl":"", regs_name(rd), regs_name(rs2), regs_name(rs1));
                    FUNCT5_AMOMAXU: $sformat(result, "amomaxu%0s%0s%0s %s,%s,(%s)", (funct3==3'b10)?".w":".d", aq?".aq":"", rl?".rl":"", regs_name(rd), regs_name(rs2), regs_name(rs1));
                    default       : return "illigal insn";
                endcase
            end
            OP_OP       : begin
                case (funct7)
                    FUNCT7_OP0: begin
                        case (funct3)
                            FUNCT3_ADD : $sformat(result, "add %s,%s,%s",  regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_SLL : $sformat(result, "sll %s,%s,%s",  regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_SLT : $sformat(result, "slt %s,%s,%s",  regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_SLTU: $sformat(result, "sltu %s,%s,%s", regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_XOR : $sformat(result, "xor %s,%s,%s",  regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_SRL : $sformat(result, "srl %s,%s,%s",  regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_OR  : $sformat(result, "or %s,%s,%s",   regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_AND : $sformat(result, "and %s,%s,%s",  regs_name(rd), regs_name(rs1), regs_name(rs2));
                            default    : return "illigal insn";
                        endcase
                    end
                    FUNCT7_OP1: begin
                        case (funct3)
                            FUNCT3_ADD : $sformat(result, "sub %s,%s,%s", regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_SRL : $sformat(result, "sra %s,%s,%s", regs_name(rd), regs_name(rs1), regs_name(rs2));
                            default    : return "illigal insn";
                        endcase
                    end
                    FUNCT7_MULDIV: begin
                        case (funct3)
                            FUNCT3_MUL   : $sformat(result, "mul %s,%s,%s",    regs_name(rd), regs_name(rs1), regs_name(rs2)); 
                            FUNCT3_MULH  : $sformat(result, "mulh %s,%s,%s",   regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_MULHSU: $sformat(result, "mulhsu %s,%s,%s", regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_MULHU : $sformat(result, "mulhu %s,%s,%s",  regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_DIV   : $sformat(result, "div %s,%s,%s",    regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_DIVU  : $sformat(result, "divu %s,%s,%s",   regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_REM   : $sformat(result, "rem %s,%s,%s",    regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_REMU  : $sformat(result, "remu %s,%s,%s",   regs_name(rd), regs_name(rs1), regs_name(rs2));
                            default      : return "illigal insn";
                        endcase
                    end
                    default    : return "illigal insn";
                endcase
            end
            OP_LUI      : begin
                $sformat(result, "lui %s,0x%0x", regs_name(rd), imm_u >> 12 & 20'hfffff);
            end
            OP_OP_32    : begin
                case (funct7)
                    FUNCT7_OP0   : begin
                        case (funct3)
                            FUNCT3_ADD : $sformat(result, "addw %s,%s,%s",  regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_SLL : $sformat(result, "sllw %s,%s,%s",  regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_SRL : $sformat(result, "srlw %s,%s,%s",  regs_name(rd), regs_name(rs1), regs_name(rs2));
                            default    : return "illigal insn";
                        endcase
                    end
                    FUNCT7_OP1   : begin
                        case (funct3)
                            FUNCT3_ADD : $sformat(result, "subw %s,%s,%s", regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_SRL : $sformat(result, "sraw %s,%s,%s", regs_name(rd), regs_name(rs1), regs_name(rs2));
                            default    : return "illigal insn";
                        endcase
                    end
                    FUNCT7_MULDIV: begin
                        case (funct3)
                            FUNCT3_MUL   : $sformat(result, "mulw %s,%s,%s",  regs_name(rd), regs_name(rs1), regs_name(rs2)); 
                            FUNCT3_DIV   : $sformat(result, "divw %s,%s,%s",  regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_DIVU  : $sformat(result, "divuw %s,%s,%s", regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_REM   : $sformat(result, "remw %s,%s,%s",  regs_name(rd), regs_name(rs1), regs_name(rs2));
                            FUNCT3_REMU  : $sformat(result, "remuw %s,%s,%s", regs_name(rd), regs_name(rs1), regs_name(rs2));
                            default      : return "illigal insn";
                        endcase
                    end
                    default      : return "illigal insn";
                endcase
            end
            OP_MADD     : begin
            end
            OP_MSUB     : begin
            end
            OP_NMSUB    : begin
            end
            OP_NMADD    : begin
            end
            OP_OP_FP    : begin
            end
            OP_CUST_2   : begin
            end
            OP_BRANCH   : begin
                case (funct3)
                    FUNCT3_BEQ : begin
                        if (rs2)
                            $sformat(result, "beq %s,%s,%08x", regs_name(rs1), regs_name(rs2), pc + imm_b & -32'b1);
                        else
                            $sformat(result, "beqz %s,%08x", regs_name(rs1), pc + imm_b & -32'b1);
                    end
                    FUNCT3_BNE : begin
                        if (rs2)
                            $sformat(result, "bne %s,%s,%08x", regs_name(rs1), regs_name(rs2), pc + imm_b & -32'b1);
                        else
                            $sformat(result, "bnez %s,%08x", regs_name(rs1), pc + imm_b & -32'b1);
                    end
                    FUNCT3_BLT : begin
                        if (!rs1)
                            $sformat(result, "bgtz %s,%08x", regs_name(rs2), pc + imm_b & -32'b1);
                        else if (!rs2)
                            $sformat(result, "bltz %s,%08x", regs_name(rs1), pc + imm_b & -32'b1);
                        else
                            $sformat(result, "blt %s,%s,%08x", regs_name(rs1), regs_name(rs2), pc + imm_b & -32'b1);
                    end
                    FUNCT3_BGE : begin
                        if (!rs1)
                            $sformat(result, "blez %s,%08x", regs_name(rs2), pc + imm_b & -32'b1);
                        else if (!rs2)
                            $sformat(result, "bgez %s,%08x", regs_name(rs1), pc + imm_b & -32'b1);
                        else
                            $sformat(result, "bge %s,%s,%08x", regs_name(rs1), regs_name(rs2), pc + imm_b & -32'b1);
                    end
                    FUNCT3_BLTU: begin
                        $sformat(result, "bltu %s,%s,%08x", regs_name(rs1), regs_name(rs2), pc + imm_b & -32'b1);
                    end
                    FUNCT3_BGEU: begin
                        $sformat(result, "bgeu %s,%s,%08x", regs_name(rs1), regs_name(rs2), pc + imm_b & -32'b1);
                    end
                    default    : begin
                        return "illigal insn";
                    end
                endcase
            end
            OP_JALR     : begin
                if (imm_i || !(rd == REG_ZERO || rd == REG_RA))
                    $sformat(result, "jalr %s,%0d(%s)", regs_name(rd), imm_i, regs_name(rs1));
                else if (rd == REG_RA)
                    $sformat(result, "jalr %s", regs_name(rs1));
                else if (rs1 == REG_RA)
                    $sformat(result, "ret");
                else
                    $sformat(result, "jr %s", regs_name(rs1));
            end
            OP_JAL      : begin
                if (!rd)
                    $sformat(result, "j %08x", pc + imm_j & -32'b1);
                else if (rd == REG_RA)
                    $sformat(result, "jal %08x", pc + imm_j & -32'b1);
                else
                    $sformat(result, "jal %s,%08x", regs_name(rd), pc + imm_j & -32'b1);
            end
            OP_SYSTEM   : begin
                case (funct3)
                    FUNCT3_PRIV  : begin
                        if (funct7 == FUNCT7_SFENCE_VMA) begin
                            if (!rs1 & !rs2)
                                $sformat(result, "sfence.vma");
                            else if (!rs2)
                                $sformat(result, "sfence.vma %s", regs_name(rs1));
                            else
                                $sformat(result, "sfence.vma %s,%s", regs_name(rs1), regs_name(rs2));
                        end
                        else if ({insn[11:7], insn[19:15]} == {5'b0, 5'b0}) begin
                            case (insn[31:20])
                                FUNCT12_ECALL: begin
                                    $sformat(result, "ecall");
                                end
                                FUNCT12_EBREAK: begin
                                    $sformat(result, "ebreak");
                                end
                                FUNCT12_WFI   : begin
                                    $sformat(result, "wfi");
                                end
                                FUNCT12_SRET  : begin
                                    $sformat(result, "sret");
                                end
                                FUNCT12_MRET  : begin
                                    $sformat(result, "mret");
                                end
                                default       : begin
                                    return "illigal insn";
                                end
                            endcase
                        end
                        else begin
                            return "illigal insn";
                        end
                    end
                    FUNCT3_CSRRW : begin
                        if (rd)
                            $sformat(result, "csrrw %s,%s,%s", regs_name(rd), csr_name(csr_addr), regs_name(rs1));
                        else
                            $sformat(result, "csrw %s,%s", csr_name(csr_addr), regs_name(rs1));
                    end
                    FUNCT3_CSRRS : begin
                        if (!rs1)
                            $sformat(result, "csrr %s,%s", regs_name(rd), csr_name(csr_addr));
                        else if (!rd)
                            $sformat(result, "csrs %s,%s", csr_name(csr_addr), regs_name(rs1));
                        else
                            $sformat(result, "csrrs %s,%s,%s", regs_name(rd), csr_name(csr_addr), regs_name(rs1));
                    end
                    FUNCT3_CSRRC : begin
                        if (rd)
                            $sformat(result, "csrrc %s,%s,%s", regs_name(rd), csr_name(csr_addr), regs_name(rs1));
                        else
                            $sformat(result, "csrc %s,%s", csr_name(csr_addr), regs_name(rs1));
                    end
                    FUNCT3_CSRRWI: begin
                        if (rd)
                            $sformat(result, "csrrwi %s,%s,%0d", regs_name(rd), csr_name(csr_addr), rs1);
                        else
                            $sformat(result, "csrwi %s,%0d", csr_name(csr_addr), rs1);
                    end
                    FUNCT3_CSRRSI: begin
                        if (rd)
                            $sformat(result, "csrrsi %s,%s,%0d", regs_name(rd), csr_name(csr_addr), rs1);
                        else
                            $sformat(result, "csrsi %s,%0d", csr_name(csr_addr), rs1);
                    end
                    FUNCT3_CSRRCI: begin
                        if (rd)
                            $sformat(result, "csrrci %s,%s,%0d", regs_name(rd), csr_name(csr_addr), rs1);
                        else
                            $sformat(result, "csrci %s,%0d", csr_name(csr_addr), rs1);
                    end
                    default       : begin
                        return "illigal insn";
                    end
                endcase
            end
            OP_CUST_3   : begin
            end
            default     : begin
                return "illigal insn";
            end
        endcase
    end
endcase

return result;

endfunction

initial begin
    cpu_tracer_file = $fopen("cpu_tracer.log", "w");
end

always_ff @(posedge clk) begin
    halted_dly <= halted;
end

always_ff @(posedge clk) begin
    srstn_dly <= srstn;
    xrstn_dly <= xrstn;
end

always_ff @(posedge clk) begin
    string str, tmp;
    logic [`XLEN-1:0] tmp_data;
    integer i;

    if (~srstn_dly & srstn) begin
        if (~xrstn_dly & xrstn)
            $fdisplay(cpu_tracer_file, "(%0d ns) Cold reset assert", $time);
        else 
            $fdisplay(cpu_tracer_file, "(%0d ns) Warm reset assert", $time);
    end
    if (halted_dly === 1'b0 && halted === 1'b1) begin
        $fdisplay(cpu_tracer_file, "(%0d ns) Enter halted mode", $time);
    end
    else if (halted_dly === 1'b1 && halted === 1'b0) begin
        $fdisplay(cpu_tracer_file, "(%0d ns) Leave halted mode", $time);
    end

    if (valid) begin
        str = prv === `PRV_M ? "M":
              prv === `PRV_H ? "H":
              prv === `PRV_S ? "S":
              prv === `PRV_U ? "U":
                               "X";
        $fwrite(cpu_tracer_file, "(%0d ns) %0s[%s]", $time, halted ? "[DBG]" : "", str);
        if (misa_mxl[1]) $fwrite(cpu_tracer_file, " %016x:", pc);
        else             $fwrite(cpu_tracer_file, " %08x:", pc[31:0]);
        if (insn[1:0] == 2'b11) $fwrite(cpu_tracer_file, "%08x", insn);
        else                    $fwrite(cpu_tracer_file, "----%04x", insn[15:0]);
        $fwrite(cpu_tracer_file, " %s\n", insn_dis(pc, insn, misa_mxl));
    end
    if (valid & mem_req & ~mem_wr) begin
        str = "";
        tmp_data = mem_rdata;
        for (i = 0; i < `XLEN/8; i = i + 1) begin
            if (mem_byte[i]) begin
                $sformat(tmp, "%02x", tmp_data & `XLEN'hff);
                tmp_data = tmp_data >> 8;
            end
            else tmp = "--";
            if (i == 4) str = {" ", str};
            str = {tmp, str};
        end
        $fdisplay(cpu_tracer_file, "  LOAD  MEM[%08x]: %s", mem_addr & ~32'h3, str);
    end
    if (valid & mem_req & mem_wr) begin
        str = "";
        tmp_data = mem_wdata;
        for (i = 0; i < `XLEN/8; i = i + 1) begin
            if (mem_byte[i]) begin
                $sformat(tmp, "%02x", tmp_data & `XLEN'hff);
                tmp_data = tmp_data >> 8;
            end
            else begin
                tmp = "--";
                tmp_data = tmp_data >> 8;
            end
            if (i == 4) str = {" ", str};
            str = {tmp, str};
        end
        $fdisplay(cpu_tracer_file, "  STORE MEM[%08x]: %s", mem_addr & ~32'h3, str);
    end
    if (rd_wr) begin
        if (misa_mxl[1]) $fdisplay(cpu_tracer_file, "  %-8s  %016x", regs_name(rd_addr), rd_addr ? len_64 ? rd_data : {{32{rd_data[31]}}, rd_data[31:0]} : 64'b0);
        else             $fdisplay(cpu_tracer_file, "  %-8s  %08x",  regs_name(rd_addr), rd_addr ? rd_data : 32'b0);
    end
    if (csr_wr) begin
        if (misa_mxl[1]) $fdisplay(cpu_tracer_file, "  %-8s  %016x", csr_name(csr_waddr), csr_wdata);
        else             $fdisplay(cpu_tracer_file, "  %-8s  %08x", csr_name(csr_waddr), csr_wdata);
    end
    if (trap_en) begin
        if (mcause[31]) begin
            $fdisplay(cpu_tracer_file, "(%0d ns) Interrupt #%0d, epc = 0x%08x, tval = 0x%08x",
                      $time, mcause[30:0], epc, mtval);
        end
        else begin
            str = "";
            case (mcause)
                `XLEN`CAUSE_MISALIGNED_FETCH      : str = "InstructionAddressMisaligned"; 
                `XLEN`CAUSE_INSTRUCTION_ACCESS    : str = "InstructionAccessFault";
                `XLEN`CAUSE_ILLEGAL_INSTRUCTION   : str = "IllegalInstruction";
                `XLEN`CAUSE_BREAKPOINT            : str = "Breakpoint";
                `XLEN`CAUSE_MISALIGNED_LOAD       : str = "LoadAddressMisaligned";
                `XLEN`CAUSE_LOAD_ACCESS           : str = "LoadAccessFault";
                `XLEN`CAUSE_MISALIGNED_STORE      : str = "StoreAddressMisaligned";
                `XLEN`CAUSE_STORE_ACCESS          : str = "StoreAccessFault";
                `XLEN`CAUSE_USER_ECALL            : str = "UserEcall";
                `XLEN`CAUSE_SUPERVISOR_ECALL      : str = "SupervisorEcall";
                `XLEN`CAUSE_HYPERVISOR_ECALL      : str = "HypervisorEcall";
                `XLEN`CAUSE_MACHINE_ECALL         : str = "MachineEcall";
                `XLEN`CAUSE_INSTRUCTION_PAGE_FAULT: str = "InstructionPageFault";
                `XLEN`CAUSE_LOAD_PAGE_FAULT       : str = "LoadPageFault";
                `XLEN`CAUSE_STORE_PAGE_FAULT      : str = "StorePageFault";
                default:
                    $sformat(str, "Unknown exception #%0d", mcause);
            endcase
            $fdisplay(cpu_tracer_file, "(%0d ns) %s, epc = 0x%08x, tval = 0x%08x",
                      $time, str, epc, mtval);
        end
    end
end
`endif

endmodule

/*--------------------------------------*/
// FILE: ../src/peri/systimer.sv
/*--------------------------------------*/

module systimer (
    input               clk_sys,
    input               clk_32k,
    input               rstn,
    output logic [63:0] systime
);

logic        rstn_32k;
logic        rstn_sys;
logic [63:0] timer_gray;
logic [63:0] timer_bin;
logic [63:0] nxt_timer_gray;
logic [63:0] nxt_timer_bin;
logic [63:0] gray_32k;
logic [63:0] timer_gray_d1;
logic [63:0] timer_gray_d2;
logic [63:0] gray_sys;
logic [63:0] systime_pre;

resetn_synchronizer u_rst_sync_32k(
    .clk        ( clk_32k  ),
    .rstn_async ( rstn     ),
    .rstn_sync  ( rstn_32k )
);

resetn_synchronizer u_rst_sync_sys(
    .clk        ( clk_sys  ),
    .rstn_async ( rstn     ),
    .rstn_sync  ( rstn_sys )
);

assign nxt_timer_bin = timer_bin + 64'b1;

bin2gray u_bin2gray_32k (
    .in  ( nxt_timer_bin  ),
    .out ( nxt_timer_gray )
);

always_ff @(posedge clk_32k or negedge rstn_32k) begin: reg_timer_32k
    if (~rstn_32k) timer_gray <= 64'b0;
    else           timer_gray <= nxt_timer_gray;
end

gray2bin u_gray2bin_32k (
    .in  ( timer_gray ),
    .out ( timer_bin  )
);

always_ff @(posedge clk_sys or negedge rstn_sys) begin: timer_sync
    if (~rstn_sys) begin
        timer_gray_d1 <= 64'b0;
        timer_gray_d2 <= 64'b0;
    end
    else begin
        timer_gray_d1 <= timer_gray;
        timer_gray_d2 <= timer_gray_d1;
    end
end

assign gray_sys = timer_gray_d2;

gray2bin u_gray2bin (
    .in  ( gray_sys    ),
    .out ( systime_pre )
);

always_ff @(posedge clk_sys or negedge rstn_sys) begin: reg_systime
    if (~rstn_sys) systime <= 64'b0;
    else           systime <= systime_pre;
end

endmodule

module gray2bin (
    input        [63:0] in,
    output logic [63:0] out
);

always_comb begin: comb_g2b
    integer i;
    out[63] = in[63];
    for (i = 62; i >= 0; i = i - 1) begin
        out[i] = out[i+1] ^ in[i];
    end
end

endmodule

module bin2gray (
    input        [63:0] in,
    output logic [63:0] out
);

always_comb begin: comb_b2g
    integer i;
    out[63] = in[63];
    for (i = 62; i >= 0; i = i - 1) begin
        out[i] = in[i+1] ^ in[i];
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/peri/uart.sv
/*--------------------------------------*/

`define CLK_PRIOD 22
`ifndef __UART_DEFINE__
`define __UART_DEFINE__

`define UART_FIFO_DEPTH 16
`define UART_DATA_WIDTH 8
`define UART_N_SYNC     2

`endif
`ifndef __UART_MMAP__
`define __UART_MMAP__

// UART_BASE

`define UART_TXFIFO 12'h00
`define UART_RXFIFO 12'h04
`define UART_TXCTRL 12'h08
`define UART_RXCTRL 12'h0C
`define UART_IE     12'h10
`define UART_IP     12'h14
`define UART_IC     12'h18
`define UART_DIV    12'h1C
`define UART_LCR    12'h20

`endif

module uart (
    input                 clk,
    input                 rstn,
    apb_intf.slave        s_apb_intf,

    output logic          irq_out,
    input                 uart_rx,
    output logic          uart_tx
);

logic [                31:0] prdata_t;
logic                        txen;
logic                        nstop;
logic [                 2:0] txcnt;
logic                        rxen;
logic [                 2:0] rxcnt;
logic [                15:0] div;
logic                        apb_wr;
logic                        apb_rd;

logic                        tx_fifo_wr;
logic [`UART_DATA_WIDTH-1:0] tx_fifo_wdata;
logic                        tx_fifo_rd;
logic [`UART_DATA_WIDTH-1:0] tx_fifo_rdata;
logic                        tx_fifo_full;
logic                        tx_fifo_empty;

logic                        rx_fifo_wr;
logic [`UART_DATA_WIDTH-1:0] rx_fifo_wdata;
logic                        rx_fifo_rd;
logic [`UART_DATA_WIDTH-1:0] rx_fifo_rdata;
logic                        rx_fifo_full;
logic                        rx_fifo_empty;

logic                        txwm_ie;
logic                        rxwm_ie;
logic                        perror_ie;
logic                        txwm_ip;
logic                        rxwm_ip;
logic                        perror_ip;
logic                        txwm_ip_tmp;
logic                        rxwm_ip_tmp;
logic                        perror_ip_tmp;

logic [                 2:0] lcr;

assign irq_out    = (txwm_ip   && txwm_ie  ) ||
                    (rxwm_ip   && rxwm_ie  ) ||
                    (perror_ip && perror_ie);

assign apb_wr     = ~s_apb_intf.penable && s_apb_intf.psel &&  s_apb_intf.pwrite;
assign apb_rd     = ~s_apb_intf.penable && s_apb_intf.psel && ~s_apb_intf.pwrite;

`ifndef FAKE_UART
assign tx_fifo_wr    = apb_wr && s_apb_intf.paddr[11:0] == `UART_TXFIFO && ~tx_fifo_full && ~s_apb_intf.pwdata[31];
assign tx_fifo_wdata = s_apb_intf.pwdata[`UART_DATA_WIDTH-1:0];
`else
assign tx_fifo_wr    = 1'b0;
assign tx_fifo_wdata = s_apb_intf.pwdata[`UART_DATA_WIDTH-1:0];
always @(posedge clk or negedge rstn) begin: fake_uart_tx
    if (~rstn) begin
    end
    else if (apb_wr && s_apb_intf.paddr[11:0] == `UART_TXFIFO && ~s_apb_intf.pwdata[31]) begin
        $write("%c", tx_fifo_wdata[7:0]);
    end
end
`endif

uart_fifo u_tx_fifo(
    .clk          ( clk              ),
    .rstn         ( rstn             ),
    .wr           ( tx_fifo_wr       ),
    .wdata        ( tx_fifo_wdata    ),
    .rd           ( tx_fifo_rd       ),
    .rdata        ( tx_fifo_rdata    ),
    .full         ( tx_fifo_full     ),
    .empty        ( tx_fifo_empty    ),
    .full_th      ( 3'b0             ),
    .empty_th     ( txcnt            ),
    .almost_empty ( txwm_ip_tmp      )
);

tx_ctrl u_tx_ctrl(
    .clk      ( clk              ),
    .rstn     ( rstn             ),
    .enable   ( txen             ),
    .lcr      ( lcr              ),
    .nstop    ( nstop            ),
    .div      ( div              ),
    .data_vld ( ~tx_fifo_empty   ),
    .data_in  ( tx_fifo_rdata    ),
    .pop      ( tx_fifo_rd       ),
    .uart_tx  ( uart_tx          )
);

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        txen  <= 1'b0;
        nstop <= 1'b0;
        txcnt <= 3'b0;
    end
    else if (apb_wr && s_apb_intf.paddr[11:0] == `UART_TXCTRL) begin
        txen  <= s_apb_intf.pwdata[0];
        nstop <= s_apb_intf.pwdata[1];
        txcnt <= s_apb_intf.pwdata[18:16];
    end
end

assign rx_fifo_rd = apb_rd && s_apb_intf.paddr[11:0] == `UART_RXFIFO;

uart_fifo u_rx_fifo(
    .clk          ( clk              ),
    .rstn         ( rstn             ),
    .wr           ( rx_fifo_wr       ),
    .wdata        ( rx_fifo_wdata    ),
    .rd           ( rx_fifo_rd       ),
    .rdata        ( rx_fifo_rdata    ),
    .full         ( rx_fifo_full     ),
    .empty        ( rx_fifo_empty    ),
    .full_th      ( rxcnt            ),
    .almost_full  ( rxwm_ip_tmp      ),
    .empty_th     ( 3'b0             )
);

rx_ctrl u_rx_ctrl (
    .clk      ( clk              ),
    .rstn     ( rstn             ),
    .enable   ( rxen             ),
    .lcr      ( lcr              ),
    .div      ( div              ),
    .push     ( rx_fifo_wr       ),
    .data_out ( rx_fifo_wdata    ),
    .perror   ( perror_ip_tmp    ),
    .uart_rx  ( uart_rx          )
);

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        rxen  <= 1'b0;
        rxcnt <= 3'b0;
    end
    else if (apb_wr && s_apb_intf.paddr[11:0] == `UART_RXCTRL) begin
        rxen  <= s_apb_intf.pwdata[0];
        rxcnt <= s_apb_intf.pwdata[18:16];
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        txwm_ie   <= 1'b0;
        rxwm_ie   <= 1'b0;
        perror_ie <= 1'b0;
    end
    else if (apb_wr && s_apb_intf.paddr[11:0] == `UART_IE) begin
        txwm_ie   <= s_apb_intf.pwdata[0];
        rxwm_ie   <= s_apb_intf.pwdata[1];
        perror_ie <= s_apb_intf.pwdata[2];
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        txwm_ip   <= 1'b0;
        rxwm_ip   <= 1'b0;
        perror_ip <= 1'b0;
    end
    else if (apb_wr && s_apb_intf.paddr[11:0] == `UART_IC) begin
        txwm_ip   <= txwm_ip   && ~s_apb_intf.pwdata[0];
        rxwm_ip   <= rxwm_ip   && ~s_apb_intf.pwdata[1];
        perror_ip <= perror_ip && ~s_apb_intf.pwdata[2];
    end
    else begin
        txwm_ip   <= txwm_ip_tmp;
        rxwm_ip   <= rxwm_ip_tmp;
        perror_ip <= perror_ip_tmp;
        // txwm_ip   <= txwm_ip_tmp   || txwm_ip;
        // rxwm_ip   <= rxwm_ip_tmp   || rxwm_ip;
        // perror_ip <= perror_ip_tmp || perror_ip;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        div <= 1000000000/22/115200; // baurd rate = 115200
    end
    else if (apb_wr && s_apb_intf.paddr[11:0] == `UART_DIV) begin
        div <= s_apb_intf.pwdata[15:0];
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        lcr <= 3'b0;
    end
    else if (apb_wr && s_apb_intf.paddr[11:0] == `UART_LCR) begin
        lcr <= s_apb_intf.pwdata[5:3];
    end
end

always_comb begin
    prdata_t = 32'b0;
    case (s_apb_intf.paddr[11:0])
        `UART_TXFIFO: prdata_t = {tx_fifo_full,  31'b0};
        `UART_RXFIFO: prdata_t = {rx_fifo_empty, 23'b0, rx_fifo_rdata & {8{~rx_fifo_empty}}};
        `UART_TXCTRL: prdata_t = {13'b0, txcnt, 14'b0, nstop, txen};
        `UART_RXCTRL: prdata_t = {13'b0, rxcnt, 14'b0,  1'b0, rxen};
        `UART_IE    : prdata_t = {29'b0, perror_ie, rxwm_ie, txwm_ie};
        `UART_IP    : prdata_t = {29'b0, perror_ip, rxwm_ip, txwm_ip};
        `UART_IC    : prdata_t = {29'b0, perror_ip, rxwm_ip, txwm_ip};
        `UART_DIV   : prdata_t = {16'b0, div};
        `UART_LCR   : prdata_t = {26'b0, lcr, 3'b0};
    endcase
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        s_apb_intf.prdata <= 32'b0;
    end
    else begin
        s_apb_intf.prdata <= prdata_t;
    end
end

assign s_apb_intf.pslverr = 1'b0;
assign s_apb_intf.pready  = 1'b1;

endmodule

module uart_fifo (
    input                               clk,
    input                               rstn,
    input                               wr,
    input        [`UART_DATA_WIDTH-1:0] wdata,
    input                               rd,
    output logic [`UART_DATA_WIDTH-1:0] rdata,
    output logic                        full,
    output logic                        empty,
    input        [                 2:0] full_th,
    output logic                        almost_full,
    input        [                 2:0] empty_th,
    output logic                        almost_empty
);

localparam PTR_WIDTH = $clog2(`UART_FIFO_DEPTH);

logic [`UART_DATA_WIDTH-1:0] fifo [`UART_FIFO_DEPTH];
logic [       PTR_WIDTH-1:0] wptr;
logic [       PTR_WIDTH-1:0] rptr;
logic [       PTR_WIDTH  :0] ndata;

assign rdata        = fifo[rptr];
assign full         = ndata[PTR_WIDTH];
assign almost_full  = ndata >  {1'b0, full_th, {PTR_WIDTH-3{1'b0}}};
assign empty        = ~|ndata;
assign almost_empty = ndata <= {1'b0, empty_th, {PTR_WIDTH-3{1'b0}}};

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        wptr  <= {PTR_WIDTH  {1'b0}};
        rptr  <= {PTR_WIDTH  {1'b0}};
        ndata <= {PTR_WIDTH+1{1'b0}};
    end
    else begin
        wptr  <= wptr  + {{PTR_WIDTH-1{1'b0}}, (wr && ~full)};
        rptr  <= rptr  + {{PTR_WIDTH-1{1'b0}}, (rd && ~empty)};
        ndata <= ndata + {{PTR_WIDTH  {1'b0}}, (wr && ~full)} - {{PTR_WIDTH  {1'b0}}, (rd && ~empty)};
    end
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 0; i < `UART_FIFO_DEPTH; i = i + 1) begin
            fifo[i] <= `UART_DATA_WIDTH'b0;
        end
    end
    else begin
        if (wr && ~ full) begin
            fifo[wptr] <= wdata;
        end
    end
end

endmodule

module tx_ctrl (
    input               clk,
    input               rstn,
    input               enable,
    input        [ 2:0] lcr,
    input               nstop,
    input        [15:0] div,
    input               data_vld,
    input        [ 7:0] data_in,
    output logic        pop,
    output logic        uart_tx
);

localparam STATE_IDLE   = 3'b000;
localparam STATE_START  = 3'b001;
localparam STATE_DATA   = 3'b010;
localparam STATE_PARITY = 3'b011;
localparam STATE_STOP   = 3'b100;

logic [ 2:0] cur_state;
logic [ 2:0] nxt_state;

logic [15:0] cnt;
logic [15:0] rept;
logic [15:0] nxt_rept;
logic        uart_tx_tmp;
logic [ 7:0] data_sft;
logic        data_par;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) cur_state <= STATE_IDLE;
    else       cur_state <= nxt_state;
end

always_comb begin
    nxt_state = cur_state;
    case (cur_state)
        STATE_IDLE  : nxt_state = enable && data_vld ? STATE_START : STATE_IDLE;
        STATE_START : nxt_state = ~|cnt ? STATE_DATA : STATE_START;
        STATE_DATA  : nxt_state = ~|cnt && ~|rept ? lcr[0] ? STATE_PARITY : STATE_STOP : STATE_DATA;
        STATE_PARITY: nxt_state = ~|cnt ? STATE_STOP : STATE_PARITY;
        STATE_STOP  : nxt_state = ~|cnt && ~|rept ? STATE_IDLE : STATE_STOP;
    endcase
end

always_comb begin
    nxt_rept    = 16'b0;
    uart_tx_tmp = 1'b1;
    pop         = 1'b0;
    case (cur_state)
        STATE_IDLE  : begin
            nxt_rept    = 16'b0;
            uart_tx_tmp = 1'b1;
            pop         = enable && data_vld;
        end
        STATE_START : begin
            nxt_rept    = 16'h7;
            uart_tx_tmp = 1'b0;
        end
        STATE_DATA  : begin
            nxt_rept    = nxt_state == STATE_PARITY ? 16'b0 : {15'b0, nstop};
            uart_tx_tmp = data_sft[0];
        end
        STATE_PARITY: begin
            nxt_rept    = {15'b0, nstop};
            uart_tx_tmp = data_par;
        end
        STATE_STOP  : begin
            uart_tx_tmp = 1'b1;
        end
    endcase
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) uart_tx <= 1'b1;
    else       uart_tx <= uart_tx_tmp;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        data_sft <= 8'b0;
        data_par <= 1'b0;
    end
    else begin
        if (pop) begin
            data_sft <=  data_in;
            data_par <= ^data_in;
        end
        else if (cur_state == STATE_DATA && ~|cnt) begin
            data_sft <= {1'b0, data_sft[7:1]};
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        cnt <= 16'b0;
    end
    else begin
        if (cur_state == STATE_IDLE) begin
            cnt <= div;
        end
        else begin
            cnt <= |cnt ? cnt - 16'b1 : div;
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        rept <= 16'b0;
    end
    else begin
        if (~|cnt) begin
            rept <= |rept ? rept - 16'b1 : nxt_rept;
        end
    end
end

endmodule

module rx_ctrl (
    input               clk,
    input               rstn,
    input               enable,
    input        [ 2:0] lcr,
    input        [15:0] div,
    output logic        push,
    output logic [ 7:0] data_out,
    output logic        perror,
    input               uart_rx
);

localparam STATE_IDLE   = 3'b000;
localparam STATE_START  = 3'b001;
localparam STATE_DATA   = 3'b010;
localparam STATE_PARITY = 3'b011;
localparam STATE_STOP   = 3'b100;
localparam STATE_ERROR  = 3'b101;

logic [             2:0] cur_state;
logic [             2:0] nxt_state;

logic [`UART_N_SYNC-1:0] uart_tx_dly;
logic                    uart_tx_sync;

logic [            15:0] cnt;
logic [            15:0] rept;
logic [            15:0] nxt_rept;
logic                    data_par;
logic                    perror_tmp;
logic                    err_detect;
logic                    sample_data;
logic                    sample_parity;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) uart_tx_dly <= `UART_N_SYNC'b0;
    else       uart_tx_dly <= {uart_rx, uart_tx_dly[`UART_N_SYNC-1:1]};
end

assign uart_tx_sync = uart_tx_dly[0];

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) cur_state <= STATE_IDLE;
    else       cur_state <= nxt_state;
end

always_comb begin
    nxt_state = cur_state;
    if (err_detect) begin
        nxt_state = STATE_ERROR;
    end
    else begin
        case (cur_state)
            STATE_IDLE  : nxt_state = enable && ~uart_tx_sync ? STATE_START : STATE_IDLE;
            STATE_START : nxt_state = ~|cnt ? STATE_DATA : STATE_START;
            STATE_DATA  : nxt_state = ~|cnt && ~|rept ? lcr[0] ? STATE_PARITY : STATE_STOP : STATE_DATA;
            STATE_PARITY: nxt_state = ~|cnt ? STATE_STOP : STATE_PARITY;
            STATE_STOP  : nxt_state = ~|cnt && ~|rept ? STATE_IDLE : STATE_STOP;
            STATE_ERROR : nxt_state = STATE_IDLE;
        endcase
    end
end

always_comb begin
    push          = 1'b0;
    perror        = 1'b0;
    nxt_rept      = 16'b0;
    err_detect    = 1'b0;
    sample_data   = 1'b0;
    sample_parity = 1'b0;
    case (cur_state)
        STATE_IDLE  : begin
        end
        STATE_START : begin
            err_detect    = (cnt == {1'b0, div[15:1]}) && uart_tx_sync;
            nxt_rept      = 16'h7;
        end
        STATE_DATA  : begin
            sample_data   = cnt == {1'b0, div[15:1]};
        end
        STATE_PARITY: begin
            sample_parity = cnt == {1'b0, div[15:1]};
        end
        STATE_STOP  : begin
            err_detect    = (cnt == {1'b0, div[15:1]}) && ~uart_tx_sync;
            push          = (cnt == {1'b0, div[15:1]}) &&  uart_tx_sync && ~perror_tmp;
            perror        = (cnt == {1'b0, div[15:1]}) &&  perror_tmp;
        end
    endcase
end

assign perror_tmp = lcr[0] && (^data_out ^ data_par);

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        data_out <= 8'b0;
        data_par <= 1'b0;
    end
    else begin
        if (sample_data) begin
            data_out <= {uart_tx_sync, data_out[7:1]};
        end
        if (sample_parity) begin
            data_par <= uart_tx_sync;
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        cnt <= 16'b0;
    end
    else begin
        if (cur_state == STATE_IDLE) begin
            cnt <= div;
        end
        else begin
            cnt <= |cnt ? cnt - 16'b1 : div;
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        rept <= 16'b0;
    end
    else begin
        if (~|cnt) begin
            rept <= |rept ? rept - 16'b1 : nxt_rept;
        end
    end
end


endmodule

/*--------------------------------------*/
// FILE: ../src/peri/spi_core.sv
/*--------------------------------------*/

module spi_core(
    input               clk,
    input               rstn,
    apb_intf.slave      s_apb_intf,

    // SPI interface
    // inout               sclk,
    // inout               nss,
    // inout               mosi,
    // inout               miso
    output              sclk,
    output              nss,
    output              mosi,
    input               miso,

    // DMA signal
    axi_intf.master     m_axi_intf,

    // Interrupt
    output logic        irq_out
);

apb_intf spi_apb();
apb_intf dma_apb();

logic        spi_dff;
logic        dma_rxreq;
logic        dma_rxne;
logic [15:0] dma_rxbuff;
logic        dma_txreq;
logic        dma_txe;
logic [15:0] dma_txbuff;
logic        spi_irq;
logic        dma_irq;

assign irq_out = spi_irq | dma_irq;

spi_core_apb_conn u_spi_core_apb_conn (
    .spi_core_apb ( s_apb_intf     ),
    .spi_apb      ( spi_apb.master ),
    .dma_apb      ( dma_apb.master )
);

spi u_spi (
    .clk        ( clk           ),
    .rstn       ( rstn          ),
    .s_apb_intf ( spi_apb.slave ),

    // SPI interface
    .sclk       ( sclk          ),
    .nss        ( nss           ),
    .mosi       ( mosi          ),
    .miso       ( miso          ),

    // DMA signal
    .dma_rxreq  ( dma_rxreq     ),
    .dma_rxne   ( dma_rxne      ),
    .dma_rxbuff ( dma_rxbuff    ),
    .dma_txreq  ( dma_txreq     ),
    .dma_txe    ( dma_txe       ),
    .dma_txbuff ( dma_txbuff    ),

    .spi_dff    ( spi_dff       ),

    // Interrupt
    .irq_out    ( spi_irq       )
);

dma u_dma (
    .clk        ( clk           ),
    .rstn       ( rstn          ),
                               
    .spi_dff    ( spi_dff       ),

    .dma_rxreq  ( dma_rxreq     ),
    .dma_rxne   ( dma_rxne      ),
    .dma_rxbuff ( dma_rxbuff    ),
    .dma_txreq  ( dma_txreq     ),
    .dma_txe    ( dma_txe       ),
    .dma_txbuff ( dma_txbuff    ),
    
    .irq_out    ( dma_irq       ),
                               
    .m_axi_intf ( m_axi_intf    ),
    .s_apb_intf ( dma_apb.slave )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/peri/spi.sv
/*--------------------------------------*/

`ifndef __SPI_MMAP__
`define __SPI_MMAP__

// MAC_BASE

`define SPI_CR1 12'h00
`define SPI_CR2 12'h04
`define SPI_SR  12'h08
`define SPI_DR  12'h0C

`endif

module spi (
    input               clk,
    input               rstn,
    apb_intf.slave      s_apb_intf,

    // SPI interface
    // inout               sclk,
    // inout               nss,
    // inout               mosi,
    // inout               miso
    output              sclk,
    output              nss,
    output              mosi,
    input               miso,

    // DMA signal
    input               dma_rxreq,
    output logic        dma_rxne,
    output logic [15:0] dma_rxbuff,
    input               dma_txreq,
    output logic        dma_txe,
    input        [15:0] dma_txbuff,

    output logic        spi_dff,

    // Interrupt
    output logic        irq_out
);

localparam STATE_OFF   = 2'b00;
localparam STATE_IDLE  = 2'b01;
localparam STATE_START = 2'b10;
localparam STATE_DATA  = 2'b11;

logic [ 1:0] cur_state;
logic [ 1:0] nxt_state;

logic        sclk_o;
logic        nss_o;
logic        mosi_o;
logic        sclk_pre;
logic        nss_pre;
logic        mosi_pre;
logic        bsy_pre;
logic [ 7:0] sclk_cnt;
logic        sclk_cnt_rst;
logic        sclk_cnt_zero;
logic        sclk_cnt_half;
logic [ 4:0] sft_cnt;
logic        sft_cnt_zero;
logic        sft_cnt_start;
logic [15:0] sft_data_reg1;
logic [15:0] sft_data_reg2;
logic        sft_en1;
logic        sft_en2;
logic        sft_en2_latch;
logic        apb_wr;
logic        apb_rd;
logic [31:0] spi_cr1;
logic        spi_cr1_cpha;
logic        spi_cr1_cpol;
logic        spi_cr1_mstr;
logic [ 2:0] spi_cr1_br;
logic        spi_cr1_spe;
logic        spi_cr1_lsbfirst;
logic        spi_cr1_ssi;
logic        spi_cr1_ssm;
logic        spi_cr1_rxonly;
logic        spi_cr1_dff;
logic        spi_cr1_crcnext;
logic        spi_cr1_crcen;
logic        spi_cr1_bidioe;
logic        spi_cr1_bidimode;
logic        spi_cr1_del;
logic [31:0] spi_cr2;
logic        spi_cr2_rxdmaen;
logic        spi_cr2_txdmaen;
logic        spi_cr2_ssoe;
logic        spi_cr2_errie;
logic        spi_cr2_rxneie;
logic        spi_cr2_txeie;
logic [31:0] spi_sr;
logic        spi_sr_txe;
logic        spi_sr_rxne;
logic        spi_sr_chside;
logic        spi_sr_udr;
logic        spi_sr_crcerr;
logic        spi_sr_modf;
logic        spi_sr_ovr;
logic        spi_sr_bsy;
logic        tx_pop;
logic        rx_pop;
logic        rx_pop_latch;
logic        rx_pop_tmp_latch;
logic [15:0] spi_tx_buff;
logic [15:0] spi_rx_buff;
logic [31:0] prdata_t;

// APB interface

assign apb_wr = ~s_apb_intf.penable && s_apb_intf.psel &&  s_apb_intf.pwrite;
assign apb_rd = ~s_apb_intf.penable && s_apb_intf.psel && ~s_apb_intf.pwrite;

assign spi_cr1 = {15'b0, spi_cr1_del,
                         spi_cr1_bidimode, spi_cr1_bidioe, spi_cr1_crcen, spi_cr1_crcnext,
                         spi_cr1_dff, spi_cr1_rxonly, spi_cr1_ssm, spi_cr1_ssi,
                         spi_cr1_lsbfirst, spi_cr1_spe, spi_cr1_br, spi_cr1_mstr,
                         spi_cr1_cpol, spi_cr1_cpha};

always_ff @(posedge clk or negedge rstn) begin: reg_spi_cr1
    if (~rstn) begin
        spi_cr1_cpha     <= 1'b0;
        spi_cr1_cpol     <= 1'b0;
        spi_cr1_mstr     <= 1'b1;
        spi_cr1_br       <= 3'b0;
        spi_cr1_spe      <= 1'b0;
        spi_cr1_lsbfirst <= 1'b0;
        spi_cr1_ssi      <= 1'b0;
        spi_cr1_ssm      <= 1'b0;
        spi_cr1_rxonly   <= 1'b0;
        spi_cr1_dff      <= 1'b0;
        spi_cr1_crcnext  <= 1'b0;
        spi_cr1_crcen    <= 1'b0;
        spi_cr1_bidioe   <= 1'b0;
        spi_cr1_bidimode <= 1'b0;
        spi_cr1_del      <= 1'b0;
    end
    else if (apb_wr && s_apb_intf.paddr[11:0] == `SPI_CR1) begin
        spi_cr1_cpha     <= s_apb_intf.pwdata[0];
        spi_cr1_cpol     <= s_apb_intf.pwdata[1];
        // spi_cr1_mstr     <= s_apb_intf.pwdata[2];
        spi_cr1_br       <= ~spi_cr1_spe ? s_apb_intf.pwdata[5:3] : spi_cr1_br;
        spi_cr1_spe      <= s_apb_intf.pwdata[6];
        spi_cr1_lsbfirst <= ~spi_cr1_spe ? s_apb_intf.pwdata[7] : spi_cr1_lsbfirst;
        // spi_cr1_ssi      <= s_apb_intf.pwdata[8];
        // spi_cr1_ssm      <= s_apb_intf.pwdata[9];
        // spi_cr1_rxonly   <= s_apb_intf.pwdata[10];
        spi_cr1_dff      <= ~spi_cr1_spe ? s_apb_intf.pwdata[11] : spi_cr1_dff;
        // spi_cr1_crcnext  <= s_apb_intf.pwdata[12];
        // spi_cr1_crcen    <= ~spi_cr1_spe ? s_apb_intf.pwdata[13] : spi_cr1_crcen;
        // spi_cr1_bidioe   <= s_apb_intf.pwdata[14];
        // spi_cr1_bidimode <= s_apb_intf.pwdata[15];
        spi_cr1_del      <= ~spi_cr1_spe ? s_apb_intf.pwdata[16] : spi_cr1_del;
    end
end

assign spi_dff = spi_cr1_dff;
assign spi_cr2 = {24'b0, spi_cr2_txeie, spi_cr2_rxneie, spi_cr2_errie,
                  2'b0,  spi_cr2_ssoe, spi_cr2_txdmaen, spi_cr2_rxdmaen};

always_ff @(posedge clk or negedge rstn) begin: reg_spi_cr2
    if (~rstn) begin
        spi_cr2_rxdmaen <= 1'b0;
        spi_cr2_txdmaen <= 1'b0;
        spi_cr2_ssoe    <= 1'b1;
        spi_cr2_errie   <= 1'b0;
        spi_cr2_rxneie  <= 1'b0;
        spi_cr2_txeie   <= 1'b0;
    end
    else if (apb_wr && s_apb_intf.paddr[11:0] == `SPI_CR2) begin
        spi_cr2_rxdmaen <= s_apb_intf.pwdata[0];
        spi_cr2_txdmaen <= s_apb_intf.pwdata[1];
        spi_cr2_ssoe    <= s_apb_intf.pwdata[2];
        spi_cr2_errie   <= s_apb_intf.pwdata[5];
        spi_cr2_rxneie  <= s_apb_intf.pwdata[6];
        spi_cr2_txeie   <= s_apb_intf.pwdata[7];
    end
end

assign dma_rxne = spi_sr_rxne;
assign dma_txe  = spi_sr_txe;

assign spi_sr = {24'b0, spi_sr_bsy, spi_sr_ovr,    spi_sr_modf, spi_sr_crcerr,
                        spi_sr_udr, spi_sr_chside, spi_sr_rxne, spi_sr_txe};

assign spi_sr_chside = 1'b0;
assign spi_sr_udr    = 1'b0;
assign spi_sr_crcerr = 1'b0;
assign spi_sr_modf   = 1'b0;
assign spi_sr_ovr    = 1'b0;

always_ff @(posedge clk or negedge rstn) begin: reg_spi_sr
    if (~rstn) begin
        spi_sr_bsy <= 1'b0;
    end
    else begin
        spi_sr_bsy <= bsy_pre;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_spi_dr
    if (~rstn) begin
        spi_tx_buff <= 16'b0;
    end
    else if (apb_wr && s_apb_intf.paddr[11:0] == `SPI_DR && spi_sr_txe) begin
        spi_tx_buff <= s_apb_intf.pwdata[15:0];
    end
    else if (dma_txreq && spi_sr_txe) begin
        spi_tx_buff <= dma_txbuff;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_spi_txe
    if (~rstn) begin
        spi_sr_txe <= 1'b1;
    end
    else if (spi_sr_txe && ((apb_wr && s_apb_intf.paddr[11:0] == `SPI_DR) || dma_txreq)) begin
        spi_sr_txe <= 1'b0;
    end
    else if (tx_pop) begin
        spi_sr_txe <= 1'b1;
    end
end

always_ff @(posedge clk or negedge rstn) begin: shift_data1
    if (~rstn) begin
        sft_data_reg1 <= 16'b0;
    end
    else if (tx_pop) begin
        sft_data_reg1 <= {spi_tx_buff[15:8] & {8{spi_cr1_dff}}, spi_tx_buff[7:0]};
    end
    else if (sft_en1) begin
        if (~spi_cr1_lsbfirst) begin
            sft_data_reg1[ 7:0] <= {sft_data_reg1[6:0], 1'b0};
            sft_data_reg1[15:8] <= spi_cr1_dff ? sft_data_reg1[14:7] : 8'b0;
        end
        else begin
            sft_data_reg1[ 7:0] <= spi_cr1_dff ? sft_data_reg1[ 8:1]         : {1'b0, sft_data_reg1[7:1]};
            sft_data_reg1[15:8] <= spi_cr1_dff ? {1'b0, sft_data_reg1[15:9]} : 8'b0;
        end
    end
end

always_ff @(posedge clk or negedge rstn) begin: sft_data2_ctrl
    if (~rstn) begin
        sft_en2_latch     <= 1'b0;
        rx_pop_latch      <= 1'b0;
        rx_pop_tmp_latch  <= 1'b0;
    end
    else begin
        sft_en2_latch     <= sft_en2;
        rx_pop_latch      <= (rx_pop && ~sft_en2) || rx_pop_tmp_latch;
        rx_pop_tmp_latch  <= rx_pop && sft_en2;
    end
end

always_ff @(posedge clk or negedge rstn) begin: shift_data2
    if (~rstn) begin
        sft_data_reg2 <= 16'b0;
    end
    else if (rx_pop_latch) begin
        sft_data_reg2 <= 16'b0;
    end
    else if (sft_en2_latch) begin
        if (~spi_cr1_lsbfirst) begin
            sft_data_reg2[ 7:0] <= {sft_data_reg2[6:0], miso};
            sft_data_reg2[15:8] <= spi_cr1_dff ? sft_data_reg2[14:7] : 8'b0;
        end
        else begin
            sft_data_reg2[ 7:0] <= spi_cr1_dff ? sft_data_reg2[ 8:1]         : {miso, sft_data_reg2[7:1]};
            sft_data_reg2[15:8] <= spi_cr1_dff ? {miso, sft_data_reg2[15:9]} : 8'b0;
        end
    end
end

always_comb begin: mosi_pre_comb
    case ({spi_cr1_lsbfirst, spi_cr1_dff})
        2'b00:   mosi_pre = sft_data_reg1[ 7];
        2'b01:   mosi_pre = sft_data_reg1[15];
        default: mosi_pre = sft_data_reg1[ 0];
    endcase
end

assign dma_rxbuff = spi_rx_buff;

always_ff @(posedge clk or negedge rstn) begin: reg_rx_buff
    if (~rstn) begin
        spi_rx_buff <= 16'b0;
    end
    else if (rx_pop_latch) begin
        spi_rx_buff <= sft_data_reg2;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_spi_rxne
    if (~rstn) begin
        spi_sr_rxne <= 1'b0;
    end
    else if (spi_sr_rxne && ((apb_rd && s_apb_intf.paddr[11:0] == `SPI_DR) || dma_rxreq)) begin
        spi_sr_rxne <= 1'b0;
    end
    else if (rx_pop_latch) begin
        spi_sr_rxne <= 1'b1;
    end
end

always_comb begin: prdata_tmp
    prdata_t = 32'b0;
    case (s_apb_intf.paddr[11:0])
        `SPI_CR1: prdata_t = spi_cr1;
        `SPI_CR2: prdata_t = spi_cr2;
        `SPI_SR:  prdata_t = spi_sr;
        `SPI_DR:  prdata_t = {16'b0, spi_rx_buff};
    endcase
end

// SPI internal control

// assign sclk =  spi_cr1_mstr ? sclk_o : 1'bz;
// assign nss  =  spi_cr2_ssoe ? nss_o  : 1'bz;
// assign mosi =  spi_cr1_mstr ? mosi_o : 1'bz;
// assign miso = ~spi_cr1_mstr ? 1'b1   : 1'bz;

assign sclk =  sclk_o;
assign mosi =  mosi_o;
assign nss  =  spi_cr2_ssoe ? nss_o  : 1'b1;

always_ff @(posedge clk or negedge rstn) begin: apb_rdata
    if (~rstn) s_apb_intf.prdata <= 32'b0;
    else       s_apb_intf.prdata <= apb_rd ? prdata_t : 32'b0;
end

assign s_apb_intf.pslverr = 1'b0;
assign s_apb_intf.pready  = 1'b1;

always_ff @(posedge clk or negedge rstn) begin: baud_rate_cnt
    if (~rstn) begin
        sclk_cnt <= 8'b0;
    end
    else begin
        if (sclk_cnt_rst)
            sclk_cnt <= (8'b1 << {1'b0, spi_cr1_br + 4'b1}) - 8'b1;
        else
            sclk_cnt <= ~sclk_cnt_zero ? sclk_cnt - 8'b1 : 8'b0;
    end
end

always_comb begin: sclk_cnt_zero_comb
    sclk_cnt_zero = ~|sclk_cnt;
end

always_comb begin: sclk_cnt_half_comb
    sclk_cnt_half = sclk_cnt == (8'b1 << spi_cr1_br);
end

always_ff @(posedge clk or negedge rstn) begin: data_shift_cnt
    if (~rstn) begin
        sft_cnt <= 5'b0;
    end
    else begin
        if (tx_pop)
            sft_cnt <= (spi_cr1_dff ? 5'hf : 5'h7) + {4'b0, spi_cr1_del};
        else if (sclk_cnt_zero && cur_state == STATE_DATA)
            sft_cnt <= ~sft_cnt_zero ? sft_cnt - 5'b1 : 4'b0;
    end
end

always_comb begin: sft_cnt_zero_comb
    sft_cnt_zero = ~|sft_cnt;
end

always_comb begin: sft_cnt_start_comb
    sft_cnt_start = spi_cr1_dff ? sft_cnt[4] : sft_cnt[3];
end

always_ff @(posedge clk or negedge rstn) begin: reg_sclk_o
    if (~rstn) sclk_o <= 1'b0;
    else       sclk_o <= sclk_pre ^ spi_cr1_cpol;
end

always_ff @(posedge clk or negedge rstn) begin: reg_nss_o
    if (~rstn) nss_o <= 1'b1;
    else       nss_o <= nss_pre;
end

always_ff @(posedge clk or negedge rstn) begin: reg_mosi_o
    if (~rstn) mosi_o <= 1'b0;
    else       mosi_o <= mosi_pre;
end


always_ff @(posedge clk or negedge rstn) begin: fsm
    if (~rstn) cur_state <= STATE_OFF;
    else       cur_state <= nxt_state;
end

always_comb begin: nxt_state_comb
    nxt_state = cur_state;
    case (cur_state)
        STATE_OFF:   nxt_state = spi_cr1_spe ? STATE_IDLE : STATE_OFF;
        STATE_IDLE:  nxt_state = ~spi_cr1_spe                 ? STATE_OFF :
                                 sclk_cnt_zero && ~spi_sr_txe ? STATE_START:
                                                                STATE_IDLE;
        STATE_START: nxt_state = sclk_cnt_half ? STATE_DATA : STATE_START;
        STATE_DATA:  nxt_state = sclk_cnt_zero && sft_cnt_zero ? ~spi_sr_txe ? ~spi_cr1_cpha ? STATE_IDLE:
                                                                                               STATE_DATA:
                                                                               STATE_IDLE:
                                                                 STATE_DATA;
    endcase
end

always_comb begin: ctrl_signal
    tx_pop       = 1'b0;
    rx_pop       = 1'b0;
    sft_en1      = 1'b0;
    sft_en2      = 1'b0;
    sclk_cnt_rst = 1'b0;
    sclk_pre     = 1'b0;
    nss_pre      = 1'b0;
    bsy_pre      = 1'b1;
    case (cur_state)
        STATE_OFF:  begin
            sclk_cnt_rst = spi_cr1_spe;
            nss_pre      = 1'b1;
        end
        STATE_IDLE:  begin
            tx_pop       = sclk_cnt_zero && spi_cr1_spe && ~spi_sr_txe;
            sclk_cnt_rst = sclk_cnt_zero && spi_cr1_spe && ~spi_sr_txe;
            bsy_pre      = 1'b0;
        end
        STATE_START: begin
            sclk_cnt_rst = sclk_cnt_half;
            // sft_en2      = spi_cr1_cpha && sclk_cnt_half;
        end
        STATE_DATA:  begin
            tx_pop       = sclk_cnt_zero && sft_cnt_zero && ~spi_sr_txe && spi_cr1_cpha;
            rx_pop       = sclk_cnt_zero && sft_cnt_zero;
            sft_en1      = (spi_cr1_cpha ? sclk_cnt_zero : sclk_cnt_half) && ~(spi_cr1_del && sft_cnt_zero);
            sft_en2      = (spi_cr1_cpha ? sclk_cnt_zero : sclk_cnt_half) && ~(spi_cr1_del && sft_cnt_start);
            sclk_cnt_rst = sclk_cnt_zero;
            sclk_pre     = sclk_cnt[spi_cr1_br] && ~(spi_cr1_del && sft_cnt_zero);
        end
    endcase
end

assign irq_out = (spi_cr2_txeie  && spi_sr_txe ) ||
                 (spi_cr2_rxneie && spi_sr_rxne) ||
                 (spi_cr2_errie  && (spi_sr_crcerr || spi_sr_ovr || spi_sr_modf));

endmodule

/*--------------------------------------*/
// FILE: ../src/peri/dma.sv
/*--------------------------------------*/

`ifndef __DMA_MMAP__
`define __DMA_MMAP__

// DMA_BASE

`define DMA_SRC     8'h00
`define DMA_DEST    8'h04
`define DMA_LEN     8'h08
`define DMA_CON     8'h0C
`define DMA_IE      8'h10
`define DMA_IP      8'h14
`define DMA_IC      8'h18
`define DMA_WDT_CNT 8'h1C

`endif

`define DMA_FIFO_DEPTH 5
`define DMA_FIFO_SIZE  (1 << `DMA_FIFO_DEPTH)

module dma (
    input               clk,
    input               rstn,

    input               spi_dff,

    output logic        dma_rxreq,
    input               dma_rxne,
    input        [15:0] dma_rxbuff,
    output logic        dma_txreq,
    input               dma_txe,
    output logic [15:0] dma_txbuff,

    output logic        irq_out,

    axi_intf.master     m_axi_intf,
    apb_intf.slave      s_apb_intf
);

localparam TYPE_FIXED   = 2'b00;
localparam TYPE_INCR    = 2'b01;
// localparam TYPE_SPI     = 2'b10;
localparam TYPE_CONST   = 2'b10;
localparam TYPE_UNKNOWN = 2'b11;

localparam SIZE_BYTE  = 2'b00;
localparam SIZE_HWORD = 2'b01;
localparam SIZE_WORD  = 2'b10;
localparam SIZE_DWORD = 2'b11;

logic        wdt_timeout;
logic [30:0] wdt_cnt;
logic [30:0] wdt_cnt_config;
logic        wdt_trigger;
logic        wdt_rst_b;
logic        apb_wr;
logic        apb_rd;
logic [31:0] dma_src;
logic [31:0] dma_dest;
logic [31:0] dma_len;
logic [31:0] dma_con;
logic        dma_con_en;
logic        dma_con_bypass;
logic [ 1:0] dma_con_src_type;
logic [ 1:0] dma_con_dest_type;
logic [ 1:0] dma_con_src_size;
logic [ 1:0] dma_con_dest_size;
logic        dma_ie;
logic        dma_ip;
logic        dma_busy;
logic [31:0] prdata_t;
logic        dma_done;

assign irq_out = dma_ie & dma_ip;

assign apb_wr = s_apb_intf.psel && ~s_apb_intf.penable &&  s_apb_intf.pwrite;
assign apb_rd = s_apb_intf.psel && ~s_apb_intf.penable && ~s_apb_intf.pwrite;

always_ff @(posedge clk or negedge rstn) begin: reg_dma_src
    if (~rstn) begin
        dma_src <= 32'b0;
    end
    else if (apb_wr && s_apb_intf.paddr[7:0] == `DMA_SRC) begin
        dma_src <= s_apb_intf.pwdata;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_dma_dest
    if (~rstn) begin
        dma_dest <= 32'b0;
    end
    else if (apb_wr && s_apb_intf.paddr[7:0] == `DMA_DEST) begin
        dma_dest <= s_apb_intf.pwdata;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_dma_src_addr
    if (~rstn) begin
        dma_len <= 32'b0;
    end
    else if (apb_wr && s_apb_intf.paddr[7:0] == `DMA_LEN) begin
        dma_len <= s_apb_intf.pwdata;
    end
end


assign dma_con_err = ~|dma_len ||
                     dma_con_src_size  > SIZE_WORD ||
                     dma_con_dest_size > SIZE_WORD ||
                     // dma_con_dest_type == TYPE_CONST ||
                     dma_con_src_type == TYPE_UNKNOWN || dma_con_dest_type == TYPE_UNKNOWN ||
                     (dma_con_src_type  == TYPE_FIXED && dma_con_src_size  >= SIZE_HWORD && dma_src [0]) ||
                     (dma_con_src_type  == TYPE_FIXED && dma_con_src_size  >= SIZE_WORD  && dma_src [1]) ||
                     (dma_con_dest_type == TYPE_FIXED && dma_con_dest_size >= SIZE_HWORD && dma_dest[0]) ||
                     (dma_con_dest_type == TYPE_FIXED && dma_con_dest_size >= SIZE_WORD  && dma_dest[1]);
                     // (dma_con_src_type  == TYPE_SPI   && dma_con_dest_type == TYPE_SPI)   ||
                     // (dma_con_src_type  == TYPE_SPI   && dma_con_src_size  >  SIZE_HWORD) ||
                     // (dma_con_dest_type == TYPE_SPI   && dma_con_dest_size >  SIZE_HWORD);
                     // (dma_con_src_type  == TYPE_INCR &&
                     //  {20'b0, dma_src [11:0]} + dma_len > 32'h1000) ||
                     // (dma_con_dest_type == TYPE_INCR &&
                     //  {20'b0, dma_dest[11:0]} + dma_len > 32'h1000);
assign dma_con = {dma_busy,
                  19'b0,
                  dma_con_dest_size,
                  dma_con_src_size,
                  dma_con_dest_type,
                  dma_con_src_type,
                  2'b0,
                  dma_con_bypass,
                  dma_con_en};

always_ff @(posedge clk or negedge rstn) begin: reg_dma_con
    if (~rstn) begin
        dma_con_en        <= 1'b0;
        dma_con_src_type  <= 2'b0;
        dma_con_dest_type <= 2'b0;
        dma_con_src_size  <= 2'b0;
        dma_con_dest_size <= 2'b0;
        dma_con_bypass    <= 1'b0;
        dma_busy          <= 1'b0;
    end
    else if (~dma_busy && apb_wr && s_apb_intf.paddr[7:0] == `DMA_CON) begin
        dma_con_en        <= s_apb_intf.pwdata[ 0];
        dma_con_bypass    <= s_apb_intf.pwdata[ 1];
        dma_con_src_type  <= s_apb_intf.pwdata[ 5: 4];
        dma_con_dest_type <= s_apb_intf.pwdata[ 7: 6];
        dma_con_src_size  <= s_apb_intf.pwdata[ 9: 8];
        dma_con_dest_size <= s_apb_intf.pwdata[11:10];
        dma_busy          <= s_apb_intf.pwdata[ 0];
    end
    else if (dma_con_err || dma_done || ~wdt_rst_b) begin
        dma_busy          <= 1'b0;
        dma_con_en        <= 1'b0;
    end
    else begin
        dma_con_en        <= 1'b0;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_dma_ie
    if (~rstn) begin
        dma_ie <= 1'b0;
    end
    else if (apb_wr && s_apb_intf.paddr[7:0] == `DMA_IE) begin
        dma_ie <= s_apb_intf.pwdata[0];
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_dma_ip
    if (~rstn) begin
        dma_ip <= 1'b0;
    end
    else if (dma_done) begin
        dma_ip <= 1'b1;
    end
    else if (apb_wr && s_apb_intf.paddr[7:0] == `DMA_IC) begin
        dma_ip <= dma_ip & ~s_apb_intf.pwdata[0];
    end
end

always_comb begin: comb_prdata_t
    prdata_t = 32'b0;
    case (s_apb_intf.paddr[7:0])
        `DMA_SRC:     prdata_t = dma_src;
        `DMA_DEST:    prdata_t = dma_dest;
        `DMA_LEN:     prdata_t = dma_len;
        `DMA_CON:     prdata_t = dma_con;
        `DMA_IE:      prdata_t = {31'b0, dma_ie};
        `DMA_IP:      prdata_t = {31'b0, dma_ip};
        `DMA_IC:      prdata_t = {31'b0, dma_ip};
        `DMA_WDT_CNT: prdata_t = {wdt_timeout, wdt_cnt_config[30:0]};
    endcase
end

always_ff @(posedge clk or negedge rstn) begin: reg_prdata
    if (~rstn) s_apb_intf.prdata <= 32'b0;
    else       s_apb_intf.prdata <= prdata_t;
end

assign s_apb_intf.pready  = 1'b1;
assign s_apb_intf.pslverr = 1'b0;

// =========== Data transfer ===========
logic [             31:0] dest_burst_byte;
logic [             31:0] src_burst_byte;
logic [             31:0] dest_addr;
logic [             31:0] src_addr;
logic [             31:0] dest_len_cnt;
logic [             31:0] dest_cnt;
logic [              7:0] dest_len;
logic [             31:0] src_len_cnt;
logic [             31:0] src_cnt;
logic [              7:0] src_len;
logic [             31:0] int_rcnt;
logic [             31:0] int_wcnt;
logic                     awvalid;
logic [              2:0] wburst_cnt;
logic                     wvalid;
logic                     arvalid;

logic                     fifo_push_pre;
logic [              1:0] fifo_wsize_pre;
logic [             31:0] fifo_wdata_pre;
logic                     fifo_full_pre;
logic [`DMA_FIFO_DEPTH:0] fifo_cnt_pre;

logic                     fifo_push_int;
logic [              1:0] fifo_wsize_int;
logic [             31:0] fifo_wdata_int;
logic                     fifo_full_int;
logic [`DMA_FIFO_DEPTH:0] fifo_cnt_int;
logic                     fifo_pop_int;
logic [              1:0] fifo_rsize_int;
logic [             31:0] fifo_rdata_int;
logic                     fifo_empty_int;

logic                     fifo_pop_post;
logic [              1:0] fifo_rsize_post;
logic [             31:0] fifo_rdata_post;
logic                     fifo_empty_post;

assign fifo_wsize_pre = ({2{dma_con_src_size == SIZE_BYTE }} & 2'h0)|
                        ({2{dma_con_src_size == SIZE_HWORD}} & ((32'h1 - {31'b0, src_addr[0]}) < src_cnt ?
                                                                (2'h1 - {1'b0, src_addr[0]}):
                                                                (src_cnt[1:0] - 2'h1)))|
                        ({2{dma_con_src_size == SIZE_WORD }} & ((32'h3 - {30'b0, src_addr[1:0]}) < src_cnt ?
                                                                (2'h3 - src_addr[1:0]):
                                                                (src_cnt[1:0] - 2'h1)));
assign fifo_rsize_post = dma_con_dest_type == TYPE_CONST ?
                         |fifo_cnt_int[`DMA_FIFO_DEPTH:2] ? 2'h3 : (fifo_cnt_int[1:0] - 2'h1) :
                         (({2{dma_con_dest_size == SIZE_BYTE }} & 2'h0)|
                          ({2{dma_con_dest_size == SIZE_HWORD}} & ((32'h1 - {31'b0, dest_addr[0]}) < dest_cnt ?
                                                                   (2'h1 - {1'b0, dest_addr[0]}):
                                                                   (dest_cnt[1:0] - 2'h1)))|
                          ({2{dma_con_dest_size == SIZE_WORD }} & ((32'h3 - {30'b0, dest_addr[1:0]}) < dest_cnt ?
                                                                   (2'h3 - dest_addr[1:0]):
                                                                   (dest_cnt[1:0] - 2'h1))));
assign fifo_push_pre  = (((dma_con_src_type  == TYPE_FIXED) & (m_axi_intf.rvalid && m_axi_intf.rready)) |
                         ((dma_con_src_type  == TYPE_INCR ) & (m_axi_intf.rvalid && m_axi_intf.rready)) |
                         ((dma_con_src_type  == TYPE_CONST) & (|src_cnt && ~fifo_full_pre))) &&
                        dma_busy;
assign fifo_pop_post  = (((dma_con_dest_type == TYPE_FIXED) & (m_axi_intf.wvalid && m_axi_intf.wready)) |
                         ((dma_con_dest_type == TYPE_INCR ) & (m_axi_intf.wvalid && m_axi_intf.wready)) |
                         ((dma_con_dest_type == TYPE_CONST) & (|dest_cnt && ~fifo_empty_post))) &&
                        dma_busy;
assign fifo_wdata_pre = ({32{dma_con_src_type  == TYPE_FIXED}} & m_axi_intf.rdata >> {src_addr[1:0], 3'b0})|
                        ({32{dma_con_src_type  == TYPE_INCR }} & m_axi_intf.rdata >> {src_addr[1:0], 3'b0})|
                        ({32{dma_con_src_type  == TYPE_CONST}} & dma_src);

assign dma_done   = ((dma_con_dest_type == TYPE_CONST && ~dma_con_en && dma_busy) ||
                     (m_axi_intf.bvalid && m_axi_intf.bready)) && ~|dest_cnt;

// SPI mode
assign fifo_wsize_int = dma_con_bypass ? |fifo_cnt_pre[`DMA_FIFO_DEPTH:2] ? 2'h3 : (fifo_cnt_pre[1:0] - 2'h1) :
                        spi_dff & |int_wcnt[31:1] ? 2'h1 : 2'h0;
assign fifo_rsize_int = dma_con_bypass ? |fifo_cnt_pre[`DMA_FIFO_DEPTH:2] ? 2'h3 : (fifo_cnt_pre[1:0] - 2'h1) :
                        spi_dff & |fifo_cnt_pre[`DMA_FIFO_DEPTH:1] ? 2'h1 : 2'h0;
assign fifo_push_int  = (dma_con_bypass && dma_busy &&  ~fifo_full_int && ~fifo_empty_int) || dma_rxreq;
assign fifo_pop_int   = (dma_con_bypass && dma_busy &&  ~fifo_full_int && ~fifo_empty_int) || dma_txreq;
assign fifo_wdata_int =  dma_con_bypass                  ? fifo_rdata_int:
                        ~spi_dff                         ? {16'b0, dma_rxbuff}:
                                                           {16'b0, dma_rxbuff[7:0], dma_rxbuff[15:8]};
assign dma_txreq = dma_busy && ~dma_con_en && ~dma_con_err && dma_txe  &&
                   |int_rcnt && ~dma_con_bypass && ~fifo_empty_int;
assign dma_rxreq = dma_busy && ~dma_con_en && ~dma_con_err && dma_rxne &&
                   |int_wcnt && ~dma_con_bypass && ~fifo_full_int;

assign dma_txbuff[15:8] = fifo_rdata_int[7:0];
assign dma_txbuff[ 7:0] = ~spi_dff                         ? fifo_rdata_int[ 7:0] :
                          |fifo_cnt_pre[`DMA_FIFO_DEPTH:1] ? fifo_rdata_int[15:8] :
                                                             8'hff;

// AXI mode
assign m_axi_intf.awid    = 9'b0;
assign m_axi_intf.awaddr  = dest_addr;
assign m_axi_intf.awburst = dma_con_dest_type;
assign m_axi_intf.awsize  = dma_con_dest_size;
assign m_axi_intf.awlen   = {24'b0, dest_len} < dest_len_cnt ? dest_len : (dest_len_cnt[7:0] - 8'h1);
assign m_axi_intf.awlock  = 2'b0;
assign m_axi_intf.awcache = 4'b0;
assign m_axi_intf.awprot  = 3'b0;
assign m_axi_intf.awvalid = awvalid && ({{(31-`DMA_FIFO_DEPTH){1'b0}}, fifo_cnt_int} >= dest_burst_byte || ~|int_wcnt);
assign m_axi_intf.wid     = 9'b0;
assign m_axi_intf.wstrb   = (4'b1 << ({1'b0, fifo_rsize_post} + 3'b1)) - 4'b1 << dest_addr[1:0];
assign m_axi_intf.wdata   = fifo_rdata_post << {dest_addr[1:0], 3'b0};
assign m_axi_intf.wlast   = ~|wburst_cnt;
assign m_axi_intf.wvalid  = wvalid;
assign m_axi_intf.bready  = 1'b1;
assign m_axi_intf.arid    = 9'b0;
assign m_axi_intf.araddr  = src_addr;
assign m_axi_intf.arburst = dma_con_src_type;
assign m_axi_intf.arsize  = dma_con_src_size;
assign m_axi_intf.arlen   = {24'b0, src_len} < src_len_cnt ? src_len : (src_len_cnt[7:0] - 8'h1);
assign m_axi_intf.arlock  = 2'b0;
assign m_axi_intf.arcache = 4'b0;
assign m_axi_intf.arprot  = 3'b0;
assign m_axi_intf.arvalid = arvalid && ({{(31-`DMA_FIFO_DEPTH){1'b0}}, fifo_cnt_pre} <= (`DMA_FIFO_SIZE - src_burst_byte));
assign m_axi_intf.rready  = ~fifo_full_pre;

always_ff @(posedge clk or negedge rstn) begin: reg_src_addr
    if (~rstn) begin
        src_addr <= 32'b0;
    end
    else if (dma_con_en && ~dma_con_err) begin
        src_addr <= dma_src;
    end
    else if (m_axi_intf.rvalid && m_axi_intf.rready && dma_con_src_type  == TYPE_INCR) begin
        src_addr <= (src_addr + (32'b1 << dma_con_src_size)) & ~((32'b1 << dma_con_src_size) - 32'b1);
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_dest_addr
    if (~rstn) begin
        dest_addr <= 32'b0;
    end
    else if (dma_con_en && ~dma_con_err) begin
        dest_addr <= dma_dest;
    end
    else if (m_axi_intf.wvalid && m_axi_intf.wready && dma_con_dest_type  == TYPE_INCR) begin
        dest_addr <= (dest_addr + (32'b1 << dma_con_dest_size)) & ~((32'b1 << dma_con_dest_size) - 32'b1);
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_src_len
    if (~rstn) begin
        src_len <= 8'b0;
    end
    else if (dma_con_en && ~dma_con_err) begin
        src_len <= 8'h3 - ((dma_src[7:0] >> dma_con_src_size) & 8'h3);
    end
    else if (m_axi_intf.arvalid && m_axi_intf.arready) begin
        src_len <= 8'h3;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_src_len_cnt
    if (~rstn) begin
        src_len_cnt <= 32'b0;
    end
    else if (dma_con_en && ~dma_con_err) begin
        src_len_cnt <= ({32{dma_con_src_size == SIZE_BYTE }} &  dma_len)|
                       ({32{dma_con_src_size == SIZE_HWORD}} & (dma_len + {31'b0, dma_src[0]}   + 32'h1) >> 1)|
                       ({32{dma_con_src_size == SIZE_WORD }} & (dma_len + {30'b0, dma_src[1:0]} + 32'h3) >> 2);
    end
    else if (m_axi_intf.arvalid && m_axi_intf.arready && |src_len_cnt) begin
        src_len_cnt <= src_len_cnt - {24'b0, m_axi_intf.arlen} - 32'b1;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_src_burst_byte
    if (~rstn) begin
        src_burst_byte <= 32'b0;
    end
    else if (dma_con_en && ~dma_con_err) begin
        src_burst_byte <= 32'h4 << dma_con_src_size;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_src_cnt
    if (~rstn) begin
        src_cnt <= 32'b0;
    end
    else if (dma_con_en && ~dma_con_err) begin
        src_cnt <= dma_len;
    end
    else if (fifo_push_pre && |src_cnt) begin
        src_cnt <= src_cnt - {30'b0, fifo_wsize_pre} - 32'b1;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_int_rcnt
    if (~rstn) begin
        int_rcnt <= 32'b0;
    end
    else if (dma_con_en && ~dma_con_err) begin
        int_rcnt <= dma_len;
    end
    else if (fifo_pop_int && |int_rcnt) begin
        int_rcnt <= int_rcnt - {30'b0, fifo_rsize_int} - 32'b1;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_int_cnt
    if (~rstn) begin
        int_wcnt <= 32'b0;
    end
    else if (dma_con_en && ~dma_con_err) begin
        int_wcnt <= dma_len;
    end
    else if (fifo_push_int && |int_wcnt) begin
        int_wcnt <= int_wcnt - {30'b0, fifo_wsize_int} - 32'b1;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_dest_len
    if (~rstn) begin
        dest_len <= 8'b0;
    end
    else if (dma_con_en && ~dma_con_err) begin
        dest_len <= 8'h3 - ((dma_dest[7:0] >> dma_con_dest_size) & 8'h3);
    end
    else if (m_axi_intf.awvalid && m_axi_intf.awready) begin
        dest_len <= 8'h3;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_dest_len_cnt
    if (~rstn) begin
        dest_len_cnt <= 32'b0;
    end
    else if (dma_con_en && ~dma_con_err) begin
        dest_len_cnt <= dma_len + {31'b0, dma_con_dest_type == TYPE_INCR && |dma_dest[1:0]};
        dest_len_cnt <= ({32{dma_con_dest_size == SIZE_BYTE }} &  dma_len)|
                        ({32{dma_con_dest_size == SIZE_HWORD}} & (dma_len + {31'b0, dma_dest[0]}   + 32'h1) >> 1)|
                        ({32{dma_con_dest_size == SIZE_WORD }} & (dma_len + {30'b0, dma_dest[1:0]} + 32'h3) >> 2);
    end
    else if (m_axi_intf.awvalid && m_axi_intf.awready && |dest_len_cnt) begin
        dest_len_cnt <= dest_len_cnt - {24'b0, m_axi_intf.awlen} - 32'b1;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_dest_cnt
    if (~rstn) begin
        dest_cnt <= 32'b0;
    end
    else if (dma_con_en && ~dma_con_err) begin
        dest_cnt <= dma_len;
    end
    else if (fifo_pop_post && |dest_cnt) begin
        dest_cnt <= dest_cnt - {30'b0, fifo_rsize_post} - 32'b1;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_dest_burst_byte
    if (~rstn) begin
        dest_burst_byte <= 32'b0;
    end
    else if (dma_con_en && ~dma_con_err) begin
        dest_burst_byte <= 32'h4 << dma_con_dest_size;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_wburst_cnt
    if (~rstn) begin
        wburst_cnt <= 3'b0;
    end
    else if (m_axi_intf.awvalid && m_axi_intf.awready) begin
        wburst_cnt <= m_axi_intf.awlen;
    end
    else if (~m_axi_intf.wlast && m_axi_intf.wvalid && m_axi_intf.wready) begin
        wburst_cnt <= wburst_cnt - 3'b1;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_awvalid
    if (~rstn) begin
        awvalid <= 1'b0;
    end
    else if (dma_con_en && ~dma_con_err) begin
        awvalid <= ~dma_con_err && (dma_con_dest_type == TYPE_INCR || dma_con_dest_type == TYPE_FIXED);
    end
    else if (m_axi_intf.wlast && m_axi_intf.wvalid && m_axi_intf.wready) begin
        awvalid <= |dest_len_cnt;
    end
    else if (m_axi_intf.awvalid && m_axi_intf.awready) begin
        awvalid <= 1'b0;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_wvalid
    if (~rstn) begin
        wvalid <= 1'b0;
    end
    else if (m_axi_intf.awvalid && m_axi_intf.awready) begin
        wvalid <= 1'b1;
    end
    else if (m_axi_intf.wlast && m_axi_intf.wvalid && m_axi_intf.wready) begin
        wvalid <= 1'b0;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_arvalid
    if (~rstn) begin
        arvalid <= 1'b0;
    end
    else if (dma_con_en && ~dma_con_err) begin
        arvalid <= ~dma_con_err && (dma_con_src_type == TYPE_INCR || dma_con_src_type == TYPE_FIXED);
    end
    else if (m_axi_intf.rlast && m_axi_intf.rvalid && m_axi_intf.rready) begin
        arvalid <= |src_len_cnt;
    end
    else if (m_axi_intf.arvalid && m_axi_intf.arready) begin
        arvalid <= 1'b0;
    end
end

// FIFO
dma_fifo u_dma_fifo_1 (
    .clk   ( clk              ),
    .rstn  ( rstn & wdt_rst_b ),

    .push  ( fifo_push_pre    ),
    .wsize ( fifo_wsize_pre   ),
    .wdata ( fifo_wdata_pre   ),
    .full  ( fifo_full_pre    ),
    .cnt   ( fifo_cnt_pre     ),

    .pop   ( fifo_pop_int     ),
    .rsize ( fifo_rsize_int   ),
    .rdata ( fifo_rdata_int   ),
    .empty ( fifo_empty_int   )
);

dma_fifo u_dma_fifo_2 (
    .clk   ( clk              ),
    .rstn  ( rstn & wdt_rst_b ),

    .push  ( fifo_push_int    ),
    .wsize ( fifo_wsize_int   ),
    .wdata ( fifo_wdata_int   ),
    .full  ( fifo_full_int    ),
    .cnt   ( fifo_cnt_int     ),

    .pop   ( fifo_pop_post    ),
    .rsize ( fifo_rsize_post  ),
    .rdata ( fifo_rdata_post  ),
    .empty ( fifo_empty_post  )
);

assign wdt_trigger = dma_con_en | fifo_push_pre | fifo_pop_int | fifo_push_int | fifo_pop_post | ~wdt_rst_b;
assign wdt_rst_b   = ~(dma_busy & ~|wdt_cnt);

always_ff @(posedge clk or negedge rstn) begin: reg_wdt
    if (~rstn) begin
        wdt_cnt <= 31'h1;
    end
    else if (wdt_trigger) begin
        wdt_cnt <= wdt_cnt_config;
    end
    else if (dma_busy && |wdt_cnt) begin
        wdt_cnt <= wdt_cnt - 31'h1;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_wdt_config
    if (~rstn) begin
        wdt_cnt_config <= 31'h400;
    end
    else if (apb_wr && s_apb_intf.paddr[7:0] == `DMA_WDT_CNT) begin
        wdt_cnt_config <= s_apb_intf.pwdata[30:0];
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_wdt_timeout
    if (~rstn) begin
        wdt_timeout <= 1'b0;
    end
    else if (~wdt_rst_b) begin
        wdt_timeout <= 1'b1;
    end
    else if (apb_wr && s_apb_intf.paddr[7:0] == `DMA_WDT_CNT) begin
        wdt_timeout <= wdt_timeout && s_apb_intf.pwdata[31];
    end
end

endmodule

module dma_fifo (
    input                            clk,
    input                            rstn,

    input                            push,
    input        [              1:0] wsize,
    input        [             31:0] wdata,
    output logic                     full,
    output logic [`DMA_FIFO_DEPTH:0] cnt,

    input                            pop,
    input        [              1:0] rsize,
    output logic [             31:0] rdata,
    output logic                     empty

);


logic [                7:0] buff [`DMA_FIFO_SIZE];
logic [`DMA_FIFO_DEPTH-1:0] rptr;
logic [`DMA_FIFO_DEPTH-1:0] wptr;

assign empty = cnt <= rsize;
assign full  = cnt >= (({{`DMA_FIFO_DEPTH{1'b0}}, 1'b1} << (`DMA_FIFO_DEPTH)) - wsize);
assign rdata = {{8{rsize >= 2'h3}} & buff[rptr + `DMA_FIFO_DEPTH'h3],
                {8{rsize >= 2'h2}} & buff[rptr + `DMA_FIFO_DEPTH'h2],
                {8{rsize >= 2'h1}} & buff[rptr + `DMA_FIFO_DEPTH'h1],
                {8{rsize >= 2'h0}} & buff[rptr + `DMA_FIFO_DEPTH'h0]};

always_ff @(posedge clk or negedge rstn) begin: reg_wptr
    if (~rstn) begin
        wptr <= `DMA_FIFO_DEPTH'b0;
    end
    else if (push && ~full) begin
        wptr <= wptr + {{`DMA_FIFO_DEPTH-2{1'b0}}, wsize} + `DMA_FIFO_DEPTH'b1;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_rptr
    if (~rstn) begin
        rptr <= `DMA_FIFO_DEPTH'b0;
    end
    else if (pop && ~empty) begin
        rptr <= rptr + {{`DMA_FIFO_DEPTH-2{1'b0}}, rsize} + `DMA_FIFO_DEPTH'b1;
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_cnt
    if (~rstn) begin
        cnt  <= {`DMA_FIFO_DEPTH+1{1'b0}};
    end
    else begin
        cnt  <= cnt +
                ({`DMA_FIFO_DEPTH+1{push && ~full }} & ({{`DMA_FIFO_DEPTH-1{1'b0}}, wsize} + {`DMA_FIFO_DEPTH'b0, 1'b1})) -
                ({`DMA_FIFO_DEPTH+1{pop  && ~empty}} & ({{`DMA_FIFO_DEPTH-1{1'b0}}, rsize} + {`DMA_FIFO_DEPTH'b0, 1'b1}));
    end
end

always_ff @(posedge clk or negedge rstn) begin: reg_buff
    integer i;
    if (~rstn) begin
        for (i = 0; i < `DMA_FIFO_SIZE; i = i + 1) begin
            buff[i] <= 8'b0;
        end
    end
    else begin
        if (push && ~full) begin
            if (wsize >= 2'h0) buff[wptr            ] <= wdata[ 0+:8];
            if (wsize >= 2'h1) buff[wptr + `DMA_FIFO_DEPTH'h1] <= wdata[ 8+:8];
            if (wsize >= 2'h2) buff[wptr + `DMA_FIFO_DEPTH'h2] <= wdata[16+:8];
            if (wsize >= 2'h3) buff[wptr + `DMA_FIFO_DEPTH'h3] <= wdata[24+:8];
        end
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/peri/mac.sv
/*--------------------------------------*/

`ifndef __MAC_MMAP__
`define __MAC_MMAP__

// MAC_BASE

`define MAC_RESET  12'h00
`define MAC_TXLEN  12'h04
`define MAC_TXFIFO 12'h08
`define MAC_TXCTRL 12'h0C
`define MAC_TXDIS  12'h10
`define MAC_RXLEN  12'h14
`define MAC_RXFIFO 12'h18
`define MAC_RXCTRL 12'h1C
`define MAC_RXDIS  12'h20
`define MAC_IE     12'h24
`define MAC_IP     12'h28
`define MAC_IC     12'h2C
`define MAC_MAC0   12'h30
`define MAC_MAC1   12'h34

`endif

module mac #(
    parameter [47:0] MAC_ADDR = {8'hfe,
                                 8'hca,
                                 8'hfe,
                                 8'hca,
                                 8'h50,
                                 8'h00}
)(
    input               clk,
    input               rstn,
    apb_intf.slave      s_apb_intf,

    // RMII interface
    input               rmii_refclk,
    input               rmii_crsdv,
    input        [1:0]  rmii_rxd,
    output logic        rmii_txen,
    output logic [1:0]  rmii_txd,

    // Interrupt
    output logic        irq_out
);

logic        apb_wr;
logic        apb_rd;
logic [31:0] prdata_t;

logic        rmii_rstn;
logic        afifo_rx_wr;
logic [34:0] afifo_rx_wdata;
logic        afifo_rx_empty;
logic [34:0] afifo_rx_rdata;

logic        afifo_tx_wr;
logic        afifo_tx_full;
logic        afifo_tx_nxt_full;
logic [34:0] afifo_tx_wdata;
logic        afifo_tx_empty;
logic        afifo_tx_nxt_empty;
logic        afifo_tx_rd;
logic [34:0] afifo_tx_rdata;

logic        rx_en;
logic        rx_en_pre;
logic        rx_busy_async;
logic        rx_busy_d1;
logic        rx_busy_d2;
logic        rx_busy;
logic        rx_ovf;
logic        rx_discar;
logic        rx_len_cnt_upd;
logic        rx_len_cnt_upd_dly;
logic [10:0] rx_len;
logic [10:0] rx_len_cnt;
logic [ 9:0] rx_ram_wptr;
logic [ 9:0] rx_ram_rptr;
logic [ 9:0] rx_ram_rptr_tail;
logic        rx_ram_read_busy;
logic        rx_ram_do_valid;
logic        rx_ram_wr;
logic        rx_ram_rd;
logic        rx_ram_rd_dly;
logic        rx_ram_cs;
logic        rx_ram_we;
logic [ 8:0] rx_ram_a;
logic [31:0] rx_ram_di;
logic [31:0] rx_ram_do;
logic [31:0] rx_data;
logic        rx_len_fifo_full;
logic        rx_len_fifo_wr;
logic [10:0] rx_len_fifo_wdata;
logic        rx_len_fifo_empty;
logic        rx_len_fifo_rd;
logic [10:0] rx_len_fifo_rdata;

logic        afifo_tx_empty_d1;
logic        afifo_tx_empty_d2;
logic        tx_done;
logic        tx_busy;
logic        tx_en;
logic [10:0] tx_len;
logic        tx_discar;
logic [ 8:0] tx_ram_rptr;
logic [ 8:0] tx_ram_wptr;
logic [ 8:0] tx_ram_wlen;
logic        tx_ram_rd;
logic        tx_ram_wr;
logic        tx_ram_cs;
logic        tx_ram_we;
logic [ 8:0] tx_ram_a;
logic [31:0] tx_ram_di;
logic [31:0] tx_ram_do;
logic [10:0] tx_len_cnt;
logic [10:0] tx_len_cnt_nxt;

logic        txeie;
logic        rxneie;

logic        txe;
logic        rxne;

assign apb_wr = ~s_apb_intf.penable && s_apb_intf.psel &&  s_apb_intf.pwrite;
assign apb_rd = ~s_apb_intf.penable && s_apb_intf.psel && ~s_apb_intf.pwrite;

always_comb begin
    prdata_t = 32'b0;
    case (s_apb_intf.paddr[11:0])
        `MAC_RESET : prdata_t = {tx_busy, rx_busy, 30'b0};
        `MAC_TXLEN : prdata_t = {21'b0, tx_len};
        `MAC_TXFIFO: prdata_t = {32{~|tx_len}};
        `MAC_TXCTRL: prdata_t = {31'b0, tx_en};
        `MAC_RXLEN : prdata_t = {21'b0, rx_len};
        `MAC_RXFIFO: prdata_t = rx_data;
        `MAC_RXCTRL: prdata_t = {31'b0, rx_en};
        `MAC_IE    : prdata_t = {30'b0, rxneie, txeie};
        `MAC_IP    : prdata_t = {30'b0, rxne, txe};
        `MAC_IC    : prdata_t = {30'b0, rxne, txe};
        `MAC_MAC0  : prdata_t = MAC_ADDR[32:0];
        `MAC_MAC1  : prdata_t = {16'b0, MAC_ADDR[47:32]};
    endcase
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) s_apb_intf.prdata <= 32'b0;
    else       s_apb_intf.prdata <= prdata_t;
end

assign s_apb_intf.pslverr = 1'b0;
assign s_apb_intf.pready = 1'b1;

assign rxne = !rx_len_fifo_empty;
assign txe  = !tx_busy;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        txeie  <= 1'b0;
        rxneie <= 1'b0;
    end
    else begin
        if (apb_wr && s_apb_intf.paddr[11:0] == `MAC_IE) begin
            txeie  <= s_apb_intf.pwdata[0];
            rxneie <= s_apb_intf.pwdata[1];
        end
    end
end

assign irq_out = (rxne && rxneie) || (txe && txeie);

resetn_synchronizer u_sync_srstn (
    .clk        ( rmii_refclk ),
    .rstn_async ( rstn        ),
    .rstn_sync  ( rmii_rstn   )
);

mac_rmii_intf u_mac_rmii_intf (
    // reset
    .rstn              ( rmii_rstn          ),

    // RMII interface
    .rmii_refclk       ( rmii_refclk        ),
    .rmii_crsdv        ( rmii_crsdv         ),
    .rmii_rxd          ( rmii_rxd           ),
    .rmii_txen         ( rmii_txen          ),
    .rmii_txd          ( rmii_txd           ),

    .fifo_rx_wr        ( afifo_rx_wr        ),
    .fifo_rx_wdata     ( afifo_rx_wdata     ),
    .fifo_tx_empty     ( afifo_tx_empty     ),
    .fifo_tx_nxt_empty ( afifo_tx_nxt_empty ),
    .fifo_tx_rd        ( afifo_tx_rd        ),
    .fifo_tx_rdata     ( afifo_tx_rdata     ),

    .rx_busy           ( rx_busy_async      )
);

mac_afifo u_mac_afifo_rx (
    .rclk      ( clk            ),
    .rrstn     ( rstn           ),
    .wclk      ( rmii_refclk    ),
    .wrstn     ( rmii_rstn      ),

    .write     ( afifo_rx_wr    ),
    .wdata     ( afifo_rx_wdata ),

    .empty     ( afifo_rx_empty ),
    .read      ( 1'b1           ),
    .rdata     ( afifo_rx_rdata )
);

mac_afifo u_mac_afifo_tx (
    .rclk      ( rmii_refclk        ),
    .rrstn     ( rmii_rstn          ),
    .wclk      ( clk                ),
    .wrstn     ( rstn               ),

    .full      ( afifo_tx_full      ),
    .nxt_full  ( afifo_tx_nxt_full  ),
    .write     ( afifo_tx_wr        ),
    .wdata     ( afifo_tx_wdata     ),

    .empty     ( afifo_tx_empty     ),
    .nxt_empty ( afifo_tx_nxt_empty ),
    .read      ( afifo_tx_rd        ),
    .rdata     ( afifo_tx_rdata     )
);

// RX
assign rx_discar = apb_wr && s_apb_intf.paddr[11:0] == `MAC_RXDIS;
assign rx_len    = {11{!rx_len_fifo_empty && rx_ram_read_busy}} & rx_len_fifo_rdata;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        rx_busy_d1 <= 1'b0;
        rx_busy_d2 <= 1'b0;
    end
    else begin
        rx_busy_d1 <= rx_busy_async;
        rx_busy_d2 <= rx_busy_d1;
    end
end

assign rx_busy = rx_busy_d2;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) rx_en_pre <= 1'b0;
    else begin
        if (apb_wr && s_apb_intf.paddr[11:0] == `MAC_RXCTRL)
            rx_en_pre <= s_apb_intf.pwdata[0];
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) rx_en <= 1'b0;
    else       rx_en <= !rx_busy ? rx_en_pre : rx_en;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn)              rx_data <= 32'b0;
    else if (rx_ram_rd_dly) rx_data <= rx_ram_do;
end

// always_ff @(posedge clk or negedge rstn) begin
//     if (~rstn) rx_busy <= 1'b0;
//     else       rx_busy <= !rx_en || rx_len_cnt_upd_dly ? 1'b0:
//                           rx_ram_wr                    ? 1'b1:
//                                                          rx_busy;
// end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) rx_ram_read_busy <= 1'b0;
    else       rx_ram_read_busy <= rx_len_fifo_rd                          ? 1'b0:
                                   !rx_ram_read_busy && !rx_len_fifo_empty ? 1'b1:
                                                                             rx_ram_read_busy;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) rx_ram_rptr_tail <= 10'b0;
    else begin
        if (!rx_ram_read_busy && !rx_len_fifo_empty)
            rx_ram_rptr_tail <= rx_ram_rptr_tail +
                                {1'b0, rx_len_fifo_rdata[10:2]} + {9'b0, |rx_len_fifo_rdata[1:0]};
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) rx_ram_wptr <= 10'b0;
    else begin
        if (rx_len_cnt_upd && rx_ovf)
            rx_ram_wptr <= rx_ram_wptr - {1'b0, rx_len_cnt[10:2]} - {9'b0, |rx_len_cnt[1:0]};
        else
            rx_ram_wptr <= rx_ram_wptr + {9'b0, rx_ram_wr};
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) rx_ram_rptr <= 10'b0;
    else begin
        if (rx_len_fifo_rd) rx_ram_rptr <= rx_ram_rptr_tail;
        else                rx_ram_rptr <= rx_ram_rptr + {9'b0, rx_ram_rd & ~rx_ram_wr};
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) rx_ram_do_valid <= 1'b0;
    else       rx_ram_do_valid <= rx_ram_rd && !rx_ram_wr                         ? 1'b1:
                                  apb_rd && s_apb_intf.paddr[11:0] == `MAC_RXFIFO ? 1'b0:
                                                                                    rx_ram_do_valid;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) rx_ram_rd_dly <= 1'b0;
    else       rx_ram_rd_dly <= rx_ram_rd && !rx_ram_wr;
end

assign rx_ram_full = rx_ram_wptr[8:0] == rx_ram_rptr[8:0] && (rx_ram_wptr[9] ^ rx_ram_rptr[9]);
assign rx_ram_rd   = !rx_ram_do_valid && rx_ram_rptr_tail != rx_ram_rptr;
assign rx_ram_wr   = rx_en && !afifo_rx_empty && |afifo_rx_rdata[34:32];
assign rx_ram_cs   = rx_ram_wr || rx_ram_rd;
assign rx_ram_we   = rx_ram_wr;
assign rx_ram_a    = rx_ram_wr ? rx_ram_wptr[8:0] : rx_ram_rptr[8:0];
assign rx_ram_di   = afifo_rx_rdata[31:0];

sram512x32 u_rx_ram (
    .CK ( clk       ),
    .CS ( rx_ram_cs ),
    .WE ( rx_ram_we ),
    .A  ( rx_ram_a  ),
    .DI ( rx_ram_di ),
    .DO ( rx_ram_do )
);

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        rx_len_cnt_upd     <= 1'b0;
        rx_len_cnt_upd_dly <= 1'b0;
    end
    else begin
        rx_len_cnt_upd     <= !afifo_rx_empty && !afifo_rx_rdata[34];
        rx_len_cnt_upd_dly <= rx_len_cnt_upd;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) rx_len_cnt <= 11'b0;
    else       rx_len_cnt <= rx_len_cnt_upd_dly  ? 11'b0:
                             !afifo_rx_empty     ? rx_len_cnt + {8'b0, afifo_rx_rdata[34:32]}:
                                                   rx_len_cnt;
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) rx_ovf <= 1'b0;
    else       rx_ovf <= rx_len_cnt_upd                                 ? 1'b0:
                         rx_ram_wr && (rx_ram_full || rx_len_fifo_full) ? 1'b1: rx_ovf;
end

assign rx_len_fifo_rd    = rx_discar && !rx_len_fifo_empty;
assign rx_len_fifo_wr    = rx_len_cnt_upd && !rx_ovf;
assign rx_len_fifo_wdata = rx_len_cnt;

mac_fifo u_rx_len_fifo (
    .clk   ( clk               ),
    .rstn  ( rstn              ),

    // Write side
    .full  ( rx_len_fifo_full  ),
    .write ( rx_len_fifo_wr    ),
    .wdata ( rx_len_fifo_wdata ),

    // Read side
    .empty ( rx_len_fifo_empty ),
    .read  ( rx_len_fifo_rd    ),
    .rdata ( rx_len_fifo_rdata )
);

// TX
assign tx_done   = tx_busy && ~|tx_len_cnt && afifo_tx_empty_d2;
assign tx_discar = !tx_busy && apb_wr && s_apb_intf.paddr[11:0] == `MAC_TXDIS;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        tx_en <= 1'b0;
    end
    else begin
        if (~|tx_len && apb_wr && s_apb_intf.paddr[11:0] == `MAC_TXCTRL)
            tx_en <= s_apb_intf.pwdata[0];
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        tx_len <= 11'b0;
    end
    else begin
        if (~|tx_len && apb_wr && s_apb_intf.paddr[11:0] == `MAC_TXLEN)
            tx_len <= s_apb_intf.pwdata[10:0];
        else if (tx_done || tx_discar)
            tx_len <= 11'b0;
    end
end

assign tx_ram_wr = tx_en && |tx_ram_wlen && apb_wr && s_apb_intf.paddr[11:0] == `MAC_TXFIFO;
always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) tx_ram_wlen <= 9'b0;
    else begin
        if (tx_en && ~|tx_len && apb_wr && s_apb_intf.paddr[11:0] == `MAC_TXLEN)
            tx_ram_wlen <= s_apb_intf.pwdata[10:2] + {8'b0, |s_apb_intf.pwdata[10:2]};
        else if (tx_discar)
            tx_ram_wlen <= 9'b0;
        else
            tx_ram_wlen <= tx_ram_wlen - {8'b0, tx_ram_wr};
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) tx_ram_wptr <= 9'b0;
    else       tx_ram_wptr <= tx_discar ? tx_ram_rptr:
                                          tx_ram_wptr + {8'b0, tx_ram_wr};
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) tx_ram_rptr <= 9'b0;
    else       tx_ram_rptr <= tx_ram_rptr + {8'b0, tx_ram_rd};
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) tx_len_cnt <= 11'b0;
    else begin
        if (tx_en && ~|tx_len && apb_wr && s_apb_intf.paddr[11:0] == `MAC_TXLEN)
            tx_len_cnt <= s_apb_intf.pwdata[10:0];
        else if (tx_discar)
            tx_len_cnt <= 11'b0;
        else
            tx_len_cnt <= !afifo_tx_wr ? tx_len_cnt : tx_len_cnt_nxt;
    end
end
assign tx_len_cnt_nxt = |tx_len_cnt[10:2] ? tx_len_cnt - 11'h4 : 11'b0;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        afifo_tx_empty_d1 <= 1'b0;
        afifo_tx_empty_d2 <= 1'b0;
    end
    else begin
        afifo_tx_empty_d1 <= afifo_tx_empty;
        afifo_tx_empty_d2 <= afifo_tx_empty_d1;
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) tx_busy <= 1'b0;
    else       tx_busy <= |tx_len_cnt && ~|tx_ram_wlen && !tx_discar ? 1'b1:
                          tx_done                                    ? 1'b0:
                                                                       tx_busy;
end

assign afifo_tx_wdata[34:32] = |tx_len_cnt[10:2] ? 3'h4 : {1'b0, tx_len_cnt[1:0]};
assign afifo_tx_wdata[31: 0] = tx_ram_do;
assign tx_ram_rd             = ((afifo_tx_wr && |tx_len_cnt_nxt) || (!afifo_tx_wr && |tx_len_cnt)) &&
                               (!afifo_tx_nxt_full || !(afifo_tx_full || afifo_tx_wr)) &&
                               tx_busy;

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) afifo_tx_wr <= 1'b0;
    else       afifo_tx_wr <= tx_ram_rd;
end

assign tx_ram_cs = tx_ram_rd || tx_ram_wr;
assign tx_ram_we = tx_ram_wr;
assign tx_ram_a  = tx_ram_wr ? tx_ram_wptr : tx_ram_rptr;
assign tx_ram_di = s_apb_intf.pwdata;

sram512x32 u_tx_ram (
    .CK ( clk       ),
    .CS ( tx_ram_cs ),
    .WE ( tx_ram_we ),
    .A  ( tx_ram_a  ),
    .DI ( tx_ram_di ),
    .DO ( tx_ram_do )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/peri/mac_afifo.sv
/*--------------------------------------*/

module mac_afifo (
    input               rclk,
    input               rrstn,
    input               wclk,
    input               wrstn,

    output logic        full,
    output logic        nxt_full,
    input               write,
    input        [34:0] wdata,

    output logic        empty,
    output logic        nxt_empty,
    input               read,
    output logic [34:0] rdata
);

logic [34:0] mem [1:0];
logic        rptr;
logic        wptr;
logic [ 1:0] rflag;
logic [ 1:0] rflag_d1;
logic [ 1:0] rflag_d2;
logic [ 1:0] wflag;
logic [ 1:0] wflag_d1;
logic [ 1:0] wflag_d2;

always_ff @(posedge rclk or negedge rrstn) begin
    if (~rrstn) rptr <= 1'b0;
    else        rptr <= rptr + (~empty && read);
end

always_ff @(posedge wclk or negedge wrstn) begin
    if (~wrstn) wptr <= 1'b0;
    else        wptr <= wptr + (~full && write);
end

always_ff @(posedge wclk or negedge wrstn) begin
    if (~wrstn) begin
        rflag_d1 <= 2'b0;
        rflag_d2 <= 2'b0;
    end
    else begin
        rflag_d1 <= rflag;
        rflag_d2 <= rflag_d1;
    end
end

always_ff @(posedge rclk or negedge rrstn) begin
    if (~rrstn) begin
        wflag_d1 <= 2'b0;
        wflag_d2 <= 2'b0;
    end
    else begin
        wflag_d1 <= wflag;
        wflag_d2 <= wflag_d1;
    end
end

always_ff @(posedge rclk or negedge rrstn) begin
    if (~rrstn) begin
        rflag <= 2'b0;
    end
    else begin
        if (~empty && read)
            rflag[rptr] <= ~rflag[rptr];
    end
end

always_ff @(posedge wclk or negedge wrstn) begin
    if (~wrstn) begin
        wflag <= 2'b0;
    end
    else begin
        if (~full && write)
            wflag[wptr] <= ~wflag[wptr];
    end
end

always_ff @(posedge wclk or negedge wrstn) begin
    integer i;
    if (~wrstn) begin
        for (i = 0; i < 2; i = i + 1)
            mem[i] <= 35'b0;
    end
    else begin
        if (~full && write)
            mem[wptr] <= wdata;
    end
end

assign rdata     = mem[rptr];
assign empty     = !(rflag[rptr] ^ wflag_d2[rptr]);
assign full      =  (wflag[wptr] ^ rflag_d2[wptr]);
assign nxt_empty = !(rflag[rptr + 1'b1] ^ wflag_d2[rptr + 1'b1]);
assign nxt_full  =  (wflag[wptr + 1'b1] ^ rflag_d2[wptr + 1'b1]);

endmodule

module mac_fifo (
    input               clk,
    input               rstn,

    // Write side
    output logic        full,
    input               write,
    input        [10:0] wdata,

    // Read side
    output logic        empty,
    input               read,
    output logic [10:0] rdata
);

logic [10:0] mem [16];
logic [ 4:0] rptr;
logic [ 4:0] wptr;

assign empty = rptr == wptr;
assign full  = rptr[3:0] == wptr[3:0] && (rptr[4] ^ wptr[4]);

assign rdata = mem[rptr[3:0]];

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) rptr <= 5'b0;
    else       rptr <= rptr + {4'b0, ~empty & read};
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) wptr <= 5'b0;
    else       wptr <= wptr + {4'b0, ~full & write};
end

always_ff @(posedge clk or negedge rstn) begin
    integer i;
    if (~rstn) begin
        for (i = 0; i < 16; i = i + 1)
            mem[i] <= 11'b0;
    end
    else begin
        if (~full & write)
            mem[wptr[3:0]] <= wdata;
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/peri/mac_rmii_intf.sv
/*--------------------------------------*/

module mac_rmii_intf (
    // reset
    input                rstn,

    // RMII interface
    input                rmii_refclk,
    input                rmii_crsdv,
    input        [ 1:0]  rmii_rxd,
    output logic         rmii_txen,
    output logic [ 1:0]  rmii_txd,

    output logic         fifo_rx_wr,
    output logic [34:0]  fifo_rx_wdata,
    input                fifo_tx_empty,
    input                fifo_tx_nxt_empty,
    output logic         fifo_tx_rd,
    input        [34:0]  fifo_tx_rdata,

    output logic         rx_busy
);

logic        crsdv_d1;
logic [31:0] rx_data;
logic        rx_data_nz;
logic        rx_cnt_rst;
logic [ 1:0] rx_cnt;
logic [ 1:0] rx_byte_cnt;
logic [ 1:0] rx_byte_cnt_latch;
logic        rx_crs;
logic        rx_sfd;

always_ff @(posedge rmii_refclk or negedge rstn) begin
    if (~rstn) begin
        crsdv_d1 <= 1'b0;
        rx_data  <= 32'b0;
    end
    else begin
        crsdv_d1 <= rmii_crsdv;
        rx_data  <= {rmii_rxd, rx_data[31:2]};
    end
end

always_ff @(posedge rmii_refclk or negedge rstn) begin
    if (~rstn) begin
        rx_cnt <= 2'b0;
    end
    else begin
        if (rx_cnt_rst)
            rx_cnt <= 2'b0;
        else
            rx_cnt <= rx_cnt + 2'b1;
    end
end

assign rx_data_nz = |rx_data[31:30] && |rx_data[29:28] && |rx_data[27:26] && |rx_data[25:24];
assign rx_cnt_rst = (~rx_busy && crsdv_d1 && rx_data_nz) ||
                    ( rx_busy && ~rx_sfd && rx_cnt[0] && rx_data[31:24] == 8'hd5);

always_ff @(posedge rmii_refclk or negedge rstn) begin
    if (~rstn) rx_busy <= 1'b0;
    else begin
        if (~rx_busy) rx_busy <= crsdv_d1 && rx_data_nz;
        else          rx_busy <= crsdv_d1 || ~rx_cnt[0];
    end
end

always_ff @(posedge rmii_refclk or negedge rstn) begin
    if (~rstn) rx_crs <= 1'b0;
    else       rx_crs <= ~rx_busy || ~rx_cnt[0] ? crsdv_d1 : rx_crs;
end

always_ff @(posedge rmii_refclk or negedge rstn) begin
    if (~rstn) rx_sfd <= 1'b0;
    else       rx_sfd <= rx_sfd ? rx_busy || ~fifo_rx_wr : (rx_busy && rx_cnt[0] && rx_data[31:24] == 8'hd5);
end

always_ff @(posedge rmii_refclk or negedge rstn) begin
    if (~rstn) rx_byte_cnt <= 2'b0;
    else       rx_byte_cnt <= ~rx_sfd ? 2'b0:
                                        rx_byte_cnt + {1'b0, rx_sfd && rx_cnt == 2'h3};
end

always_ff @(posedge rmii_refclk or negedge rstn) begin
    if (~rstn) rx_byte_cnt_latch <= 2'b0;
    else       rx_byte_cnt_latch <= ~rx_sfd                          ? 2'b0:
                                    rx_byte_cnt_latch != rx_byte_cnt ? rx_byte_cnt_latch:
                                                                       rx_byte_cnt + {1'b0, rx_busy && rx_cnt == 2'h3};
end

assign fifo_rx_wr    = rx_sfd && rx_cnt == 2'h3 && rx_byte_cnt == 2'h3; 
assign fifo_rx_wdata = {{1'b0, rx_byte_cnt_latch} + {2'b0, rx_busy}, rx_data};

logic [5:0] tx_sfd_cnt;
logic       tx_cnt_rst;
logic [5:0] tx_cnt;
logic       tx_busy;

logic       nxt_txen;
logic [1:0] nxt_txd;

always_ff @(posedge rmii_refclk or negedge rstn) begin
    if (~rstn) tx_busy <= 1'b0;
    else begin
        if (~tx_busy) tx_busy <= nxt_txen;
        else          tx_busy <= &tx_cnt[3:0] ? !(tx_cnt[5] && fifo_tx_nxt_empty):
                                  tx_cnt[5]   ? fifo_tx_rdata[34:32] > tx_cnt[3:2] + {1'b0, &tx_cnt[1:0]}:
                                                tx_busy;
    end
end

assign tx_cnt_rst = ~nxt_txen;

always_ff @(posedge rmii_refclk or negedge rstn) begin
    if (~rstn) begin
        tx_cnt <= 6'b0;
    end
    else begin
        if (tx_cnt_rst)
            tx_cnt <= 6'b0;
        else 
            tx_cnt <= (tx_cnt + 6'b1) | {tx_cnt[5], 5'b0};
    end
end

assign nxt_txen = !(crsdv_d1 || rx_crs) &&
                  ((rmii_txen && !fifo_tx_nxt_empty) || (!rmii_txen && !fifo_tx_empty)) || tx_busy;
assign nxt_txd  = ~nxt_txen    ? 2'b0:
                  tx_cnt[5]    ? fifo_tx_rdata[tx_cnt[3:0]*2+:2]:
                  &tx_cnt[4:0] ? 2'h3 : 2'h1;

assign fifo_tx_rd = nxt_txen ? &tx_cnt[3:0] && tx_cnt[5]:
                               |tx_cnt[3:2];

always_ff @(posedge rmii_refclk or negedge rstn) begin
    if (~rstn) begin
        rmii_txen <= 1'b0;
        rmii_txd  <= 2'b0;
    end
    else begin
        rmii_txen <= nxt_txen;
        rmii_txd  <= nxt_txd;
    end
end

endmodule


/*--------------------------------------*/
// FILE: ../src/dbg/dap.sv
/*--------------------------------------*/

`define APB_AP_SEL  8'h00
`define AHB_AP_SEL  8'h01
`define AXI_AP_SEL  8'h02
`define JTAG_AP_SEL 8'h03

module dap (
    // clock and reset
    input        clk,
    input        rstn,

    // DP port
    input        tck,
    input        trstn,
    input        tms,
    input        tdi,
    output logic tdo,
    
    // other
    input        apb_spiden,
    input        apb_deviceen,
    input        axi_spiden,
    input        axi_deviceen,

    // APB_AP port
    apb_intf.master m_apb_intf,

    // AXI_AP port
    axi_intf.master m_axi_intf

);

logic        dbgrstn;

logic        ap_upd;
logic [ 7:0] ap_sel;
logic [31:0] ap_wdata;
logic [ 7:2] ap_addr;
logic        ap_rnw;
logic        ap_busy;
logic [31:0] ap_rdata;
logic        ap_slverr;
logic [ 2:0] ap_ack;

logic        ap_rbuf_rrstn;
logic        ap_rbuf_dpop;
logic [31:0] ap_rbuf_rdata;
logic        ap_rbuf_rpop;
logic [31:0] ap_rbuf_rresp;
logic        ap_rbuf_push;
logic [31:0] ap_rbuf_wdata;
logic [ 1:0] ap_rbuf_wresp;
logic        ap_wbuf_wrstn;
logic        ap_wbuf_push;
logic [31:0] ap_wbuf_wdata;
logic        ap_wbuf_pop;
logic [31:0] ap_wbuf_rdata;
logic [ 5:0] ap_wbuf_rsize;

logic [ 7:0] ap_sel_latch;

logic        apb_ap_upd;
logic [31:0] apb_ap_rdata;
logic        apb_ap_slverr;
logic        apb_ap_busy;

logic        apb_ap_rbuf_push;
logic [31:0] apb_ap_rbuf_wdata;
logic [ 1:0] apb_ap_rbuf_wresp;

logic        apb_ap_wbuf_pop;
logic [31:0] apb_ap_wbuf_rdata;
logic [ 5:0] apb_ap_wbuf_rsize;

logic        axi_ap_upd;
logic [31:0] axi_ap_rdata;
logic        axi_ap_slverr;
logic        axi_ap_busy;

logic        axi_ap_rbuf_push;
logic [31:0] axi_ap_rbuf_wdata;
logic [ 1:0] axi_ap_rbuf_wresp;

logic        axi_ap_wbuf_pop;
logic [31:0] axi_ap_wbuf_rdata;
logic [ 5:0] axi_ap_wbuf_rsize;


always_ff @(posedge tck or negedge dbgrstn) begin: reg_ap_rdata
    if (~dbgrstn)    ap_sel_latch <= 8'b0;
    else if (ap_upd) ap_sel_latch <= ap_sel;
end

assign ap_ack     = 3'h2;

assign ap_rdata   = ({32{ap_sel_latch == `APB_AP_SEL}} & apb_ap_rdata)|
                    ({32{ap_sel_latch == `AXI_AP_SEL}} & axi_ap_rdata);

assign ap_busy    = ((ap_sel_latch == `APB_AP_SEL) & apb_ap_busy)|
                    ((ap_sel_latch == `AXI_AP_SEL) & axi_ap_busy);

assign ap_slverr  = ((ap_sel_latch == `APB_AP_SEL) & apb_ap_slverr)|
                    ((ap_sel_latch == `AXI_AP_SEL) & axi_ap_slverr);

assign apb_ap_upd = (ap_sel == `APB_AP_SEL) & ap_upd;
assign axi_ap_upd = (ap_sel == `AXI_AP_SEL) & ap_upd;

assign ap_rbuf_push  = axi_ap_rbuf_push;
assign ap_rbuf_wdata = axi_ap_rbuf_wdata;
assign ap_rbuf_wresp = axi_ap_rbuf_wresp;

assign ap_wbuf_pop   = axi_ap_wbuf_pop;

assign axi_ap_wbuf_rdata = ap_wbuf_rdata;
assign axi_ap_wbuf_rsize = ap_wbuf_rsize;

assign apb_ap_wbuf_rdata = 32'b0;
assign apb_ap_wbuf_rsize = 6'b0;

jtag_dp u_jtag_dp (
    .tck           ( tck           ),
    .trstn         ( trstn         ),
    .tms           ( tms           ),
    .tdi           ( tdi           ),
    .tdo           ( tdo           ),
    
    .ap_upd        ( ap_upd        ),
    .ap_sel        ( ap_sel        ),
    .ap_wdata      ( ap_wdata      ),
    .ap_addr       ( ap_addr       ),
    .ap_rnw        ( ap_rnw        ),
    .ap_busy       ( ap_busy       ),
    .ap_rdata      ( ap_rdata      ),
    .ap_slverr     ( ap_slverr     ),
    .ap_ack        ( ap_ack        ),

    .ap_rbuf_rrstn ( ap_rbuf_rrstn ),
    .ap_rbuf_dpop  ( ap_rbuf_dpop  ),
    .ap_rbuf_rdata ( ap_rbuf_rdata ),
    .ap_rbuf_rpop  ( ap_rbuf_rpop  ),
    .ap_rbuf_rresp ( ap_rbuf_rresp ),

    .ap_wbuf_wrstn ( ap_wbuf_wrstn ),
    .ap_wbuf_push  ( ap_wbuf_push  ),
    .ap_wbuf_wdata ( ap_wbuf_wdata ),

    .dbgrstn       ( dbgrstn       )
);

apb_ap u_apb_ap (
    .tck           ( tck               ),
    .dbgrstn       ( dbgrstn           ),

    .sysclk        ( clk               ),
    .sysrstn       ( rstn              ),

    .ap_upd        ( apb_ap_upd        ),
    .ap_wdata      ( ap_wdata          ),
    .ap_addr       ( ap_addr           ),
    .ap_rnw        ( ap_rnw            ),
    .ap_rdata      ( apb_ap_rdata      ),
    .ap_slverr     ( apb_ap_slverr     ),
    .ap_busy       ( apb_ap_busy       ),

    .ap_rbuf_push  ( apb_ap_rbuf_push  ),
    .ap_rbuf_wdata ( apb_ap_rbuf_wdata ),
    .ap_rbuf_wresp ( apb_ap_rbuf_wresp ),

    .ap_wbuf_pop   ( apb_ap_wbuf_pop   ),
    .ap_wbuf_rdata ( apb_ap_wbuf_rdata ),
    .ap_wbuf_rsize ( apb_ap_wbuf_rsize ),

    .spiden        ( apb_spiden        ),
    .deviceen      ( apb_deviceen      ),

    .m_apb_intf    ( m_apb_intf        )
);

axi_ap u_axi_ap (
    .tck           ( tck               ),
    .dbgrstn       ( dbgrstn           ),

    .sysclk        ( clk               ),
    .sysrstn       ( rstn              ),

    .ap_upd        ( axi_ap_upd        ),
    .ap_wdata      ( ap_wdata          ),
    .ap_addr       ( ap_addr           ),
    .ap_rnw        ( ap_rnw            ),
    .ap_rdata      ( axi_ap_rdata      ),
    .ap_slverr     ( axi_ap_slverr     ),
    .ap_busy       ( axi_ap_busy       ),

    .ap_rbuf_push  ( axi_ap_rbuf_push  ),
    .ap_rbuf_wdata ( axi_ap_rbuf_wdata ),
    .ap_rbuf_wresp ( axi_ap_rbuf_wresp ),

    .ap_wbuf_pop   ( axi_ap_wbuf_pop   ),
    .ap_wbuf_rdata ( axi_ap_wbuf_rdata ),
    .ap_wbuf_rsize ( axi_ap_wbuf_rsize ),

    .spiden        ( axi_spiden        ),
    .deviceen      ( axi_deviceen      ),

    .m_axi_intf    ( m_axi_intf        )
);

dap_wdata_fifo u_wdata_fifo (
    .rclk      ( clk           ),
    .wclk      ( tck           ),
    .rrstn     ( dbgrstn       ),
    .wrstn     ( ap_wbuf_wrstn ),
    .push      ( ap_wbuf_push  ),
    .wdata     ( ap_wbuf_wdata ),
    .pop       ( ap_wbuf_pop   ),
    .rdata     ( ap_wbuf_rdata ),
    .rsize     ( ap_wbuf_rsize )
);

dap_rdata_fifo u_rdata_rdata_fifo (
    .rclk      ( tck           ),
    .wclk      ( clk           ),
    .rrstn     ( ap_rbuf_rrstn ),
    .wrstn     ( dbgrstn       ),
    .push      ( ap_rbuf_push  ),
    .wdata     ( ap_rbuf_wdata ),
    .pop       ( ap_rbuf_dpop  ),
    .rdata     ( ap_rbuf_rdata )
);

dap_resp_fifo u_resp_fifo (
    .rclk      ( tck           ),
    .wclk      ( clk           ),
    .rrstn     ( ap_rbuf_rrstn ),
    .wrstn     ( dbgrstn       ),
    .push      ( ap_rbuf_push  ),
    .wdata     ( ap_rbuf_wresp ),
    .pop       ( ap_rbuf_rpop  ),
    .rdata     ( ap_rbuf_rresp )
);

endmodule

module dap_wdata_fifo (
    input               rclk,
    input               wclk,
    input               rrstn,
    input               wrstn,
    input               push,
    input        [31:0] wdata,
    input               pop,
    output logic [31:0] rdata,
    output logic [ 5:0] rsize
);

logic [31:0] fifo [64];
logic [ 5:0] rptr;
logic [ 5:0] wptr;
logic        rrstn_sync;
logic        wrstn_sync;

resetn_synchronizer u_rst_sync_0 (
    .clk        ( rclk          ),
    .rstn_async ( wrstn & rrstn ),
    .rstn_sync  ( rrstn_sync    )
);

resetn_synchronizer u_rst_sync_1 (
    .clk        ( wclk          ),
    .rstn_async ( wrstn & rrstn ),
    .rstn_sync  ( wrstn_sync    )
);

/* ========================================= */
/*  The wptr always used when it is stable,  */
/*  so we bypass this signal to read clock   */
/*  domain without synchronizor.             */
/* ========================================= */
assign rsize = wptr;

assign rdata = fifo[rptr];
// always_ff @(posedge rclk or negedge rrstn_sync) begin: reg_rdata
//     if (~rrstn_sync) rdata <= 32'b0;
//     else             rdata = fifo[rptr];
// end

always_ff @(posedge rclk or negedge rrstn_sync) begin: reg_rptr
    if (~rrstn_sync) rptr <= 6'b0;
    else             rptr <= rptr + {5'b0, pop};
end

always_ff @(posedge wclk or negedge wrstn_sync) begin: reg_wptr
    if (~wrstn_sync) wptr <= 6'b0;
    else             wptr <= wptr + {5'b0, push};
end

always_ff @(posedge wclk) begin: fifo_arr
    if (push) fifo[wptr] <= wdata;
end

endmodule

module dap_rdata_fifo (
    input               rclk,
    input               wclk,
    input               rrstn,
    input               wrstn,
    input               push,
    input        [31:0] wdata,
    input               pop,
    output logic [31:0] rdata
);

logic [31:0] fifo [64];
logic [ 5:0] rptr;
logic [ 5:0] wptr;
logic        rrstn_sync;
logic        wrstn_sync;

resetn_synchronizer u_rst_sync_0 (
    .clk        ( rclk          ),
    .rstn_async ( wrstn & rrstn ),
    .rstn_sync  ( rrstn_sync    )
);

resetn_synchronizer u_rst_sync_1 (
    .clk        ( wclk          ),
    .rstn_async ( wrstn & rrstn ),
    .rstn_sync  ( wrstn_sync    )
);

always_ff @(posedge rclk) begin: reg_rdata
    rdata <= fifo[rptr];
end

always_ff @(posedge rclk or negedge rrstn_sync) begin: reg_rptr
    if (~rrstn_sync) rptr <= 6'b0;
    else             rptr <= rptr + {5'b0, pop};
end

always_ff @(posedge wclk or negedge wrstn_sync) begin: reg_wptr
    if (~wrstn_sync) wptr <= 6'b0;
    else             wptr <= wptr + {5'b0, push};
end

always_ff @(posedge wclk) begin: fifo_arr
    if (push) fifo[wptr] <= wdata;
end

endmodule

module dap_resp_fifo (
    input               rclk,
    input               wclk,
    input               wrstn,
    input               rrstn,
    input               push,
    input        [ 1:0] wdata,
    input               pop,
    output logic [31:0] rdata
);

logic [127:0] fifo;
logic [  1:0] rptr;
logic [  5:0] wptr;
logic         rrstn_sync;
logic         wrstn_sync;

resetn_synchronizer u_rst_sync_0 (
    .clk        ( rclk          ),
    .rstn_async ( wrstn & rrstn ),
    .rstn_sync  ( rrstn_sync    )
);

resetn_synchronizer u_rst_sync_1 (
    .clk        ( wclk          ),
    .rstn_async ( wrstn & rrstn ),
    .rstn_sync  ( wrstn_sync    )
);

always_ff @(posedge rclk) begin: reg_rdata
    rdata <= fifo[{rptr, 5'b0}+:32];
end

always_ff @(posedge rclk or negedge rrstn_sync) begin: reg_rptr
    if (~rrstn_sync) rptr <= 2'b0;
    else             rptr <= rptr + {1'b0, pop};
end

always_ff @(posedge wclk or negedge wrstn_sync) begin: reg_wptr
    if (~wrstn_sync) wptr <= 6'b0;
    else             wptr <= wptr + {5'b0, push};
end

always_ff @(posedge wclk) begin: fifo_arr
    if (push) fifo[{wptr, 1'b0}+:2] <= wdata;
end

endmodule

/*--------------------------------------*/
// FILE: ../src/dbg/jtag_dp.sv
/*--------------------------------------*/

`define DAP_VER       'h0
`define DAP_PARTNUM   'h0
`define DAP_MANID     'h0
`define UNPREDICTABLE 32'hdead_dead

module jtag_dp (
    input               tck,
    input               trstn,
    input               tms,
    input               tdi,
    output logic        tdo,

    output logic        ap_upd,
    output logic [ 7:0] ap_sel,
    output logic [31:0] ap_wdata,
    output logic [ 7:2] ap_addr,
    output logic        ap_rnw,
    input               ap_busy,
    input        [31:0] ap_rdata,
    input               ap_slverr,
    input        [ 2:0] ap_ack,

    output logic        ap_rbuf_rrstn,
    output logic        ap_rbuf_dpop,
    input        [31:0] ap_rbuf_rdata,
    output logic        ap_rbuf_rpop,
    input        [31:0] ap_rbuf_rresp,

    output logic        ap_wbuf_wrstn,
    output logic        ap_wbuf_push,
    output logic [31:0] ap_wbuf_wdata,

    output logic        dbgrstn
);

logic [34:0] sfter;
logic [ 4:0] ir;
logic [34:0] dr_abort;

logic        err;
logic [31:0] datain;
logic [ 1:0] addr;
logic        rnw;
logic [34:0] dr_dpacc;
logic [31:0] dpacc_res;
logic [31:0] dpacc_csr;
logic        dpacc_csr_csyspwrupack;
logic        dpacc_csr_csyspwrupreq;
logic        dpacc_csr_cdbgpwrupack;
logic        dpacc_csr_cdbgpwrupreq;
logic        dpacc_csr_cdbgrstack;
logic        dpacc_csr_cdbgrstreq;
logic [11:0] dpacc_csr_trncnt;
logic [ 3:0] dpacc_csr_masklane;
logic        dpacc_csr_stickyerr;
logic        dpacc_csr_stickycmp;
logic [ 1:0] dpacc_csr_trnmode;
logic        dpacc_csr_stickyorun;
logic        dpacc_csr_orundetect;
logic [31:0] dpacc_apsel;
logic [ 7:0] dpacc_apsel_apsel;
logic [ 3:0] dpacc_apsel_apaddrh;

logic [34:0] dapacc_cap_data;
logic        dpacc_sel_latch;
logic        ap_busy_latch;
logic [31:0] ap_cmp_data;
logic        ap_cmp_en;

logic [ 4:0] ap_buf_cnt;
logic        buf_pop;

logic [ 3:0] cur_state;
logic [ 3:0] nxt_state;

logic        rstn_trig;

logic        ap_wbuf_push_pre;

localparam STATE_RESET   = 4'hf,
           STATE_RUN     = 4'hc,
           STATE_SEL_DR  = 4'h7,
           STATE_CAP_DR  = 4'h6,
           STATE_SFT_DR  = 4'h2,
           STATE_EX1_DR  = 4'h1,
           STATE_PAU_DR  = 4'h3,
           STATE_EX2_DR  = 4'h0,
           STATE_UPD_DR  = 4'h5,
           STATE_SEL_IR  = 4'h4,
           STATE_CAP_IR  = 4'he,
           STATE_SFT_IR  = 4'ha,
           STATE_EX1_IR  = 4'h9,
           STATE_PAU_IR  = 4'hb,
           STATE_EX2_IR  = 4'h8,
           STATE_UPD_IR  = 4'hd;

localparam RG_ABORT      = 5'h8,
           RG_DPACC      = 5'ha,
           RG_APACC      = 5'hb,
           RG_IDCODE     = 5'he,
           RG_BYPASS     = 5'hf,
           RG_APDBUF     = 5'h10,
           RG_APRBUF     = 5'h11,
           RG_APWBUF     = 5'h12;

localparam RESP_OK_FAULT = 3'h2,
           RESP_WAIT     = 3'h1;

assign dbgrstn   = ~(~dpacc_csr_cdbgrstack & dpacc_csr_cdbgrstreq) && rstn_trig;
assign rstn_trig = ~(cur_state == STATE_RESET);

always_ff @(posedge tck or negedge trstn) begin: dp_fsm
    if (~trstn) cur_state <= STATE_RESET;
    else        cur_state <= nxt_state;
end

always_comb begin: next_state
    nxt_state = cur_state;
    case (cur_state)
        STATE_RESET : nxt_state = tms ? STATE_RESET  : STATE_RUN;
        STATE_RUN   : nxt_state = tms ? STATE_SEL_DR : STATE_RUN;
        STATE_SEL_DR: nxt_state = tms ? STATE_SEL_IR : STATE_CAP_DR;
        STATE_CAP_DR: nxt_state = tms ? STATE_EX1_DR : STATE_SFT_DR;
        STATE_SFT_DR: nxt_state = tms ? STATE_EX1_DR : STATE_SFT_DR;
        STATE_EX1_DR: nxt_state = tms ? STATE_UPD_DR : STATE_PAU_DR;
        STATE_PAU_DR: nxt_state = tms ? STATE_EX2_DR : STATE_PAU_DR;
        STATE_EX2_DR: nxt_state = tms ? STATE_UPD_DR : STATE_SFT_DR;
        STATE_UPD_DR: nxt_state = tms ? STATE_SEL_DR : STATE_RUN;
        STATE_SEL_IR: nxt_state = tms ? STATE_RESET  : STATE_CAP_IR;
        STATE_CAP_IR: nxt_state = tms ? STATE_EX1_IR : STATE_SFT_IR;
        STATE_SFT_IR: nxt_state = tms ? STATE_EX1_IR : STATE_SFT_IR;
        STATE_EX1_IR: nxt_state = tms ? STATE_UPD_IR : STATE_PAU_IR;
        STATE_PAU_IR: nxt_state = tms ? STATE_EX2_IR : STATE_PAU_IR;
        STATE_EX2_IR: nxt_state = tms ? STATE_UPD_IR : STATE_SFT_IR;
        STATE_UPD_IR: nxt_state = tms ? STATE_SEL_DR : STATE_RUN;
    endcase
end

assign tdo = sfter[0];

always_ff @(posedge tck or negedge trstn) begin: reg_ap_busy_latch
    if (~trstn)                         ap_busy_latch <= 1'b0;
    else if (~rstn_trig)                ap_busy_latch <= 1'b0;
    else if (~tms &&
             cur_state == STATE_SEL_DR) ap_busy_latch <= ap_busy && (ir == RG_DPACC || ir == RG_APACC);
end

always_ff @(posedge tck or negedge trstn) begin: reg_dpacc_sel_latch
    if (~trstn)                         dpacc_sel_latch <= 1'b0;
    else if (~rstn_trig)                dpacc_sel_latch <= 1'b0;
    else if (cur_state == STATE_CAP_DR) dpacc_sel_latch <= ir == RG_DPACC ? 1'b1:
                                                           ir == RG_APACC ? 1'b0:
                                                                            dpacc_sel_latch;
end

assign dapacc_cap_data = {(dpacc_sel_latch ? dpacc_res : ap_rdata), (~ap_busy_latch ? RESP_OK_FAULT : RESP_WAIT)};
always_ff @(posedge tck or negedge trstn) begin: reg_sfter
    if (~trstn)                         sfter      <= 35'b0;
    else if (~rstn_trig)                sfter      <= 35'b0;
    else if (cur_state == STATE_CAP_IR) sfter[4:0] <= 4'b1;
    else if (cur_state == STATE_SFT_IR) sfter[4:0] <= {tdi, sfter[4:1]};
    else if (cur_state == STATE_CAP_DR) sfter      <= ({35{ir == RG_ABORT }} & {3'b0, `UNPREDICTABLE})|
                                                      ({35{ir == RG_DPACC ||
                                                           ir == RG_APACC }} & dapacc_cap_data)|
                                                      ({35{ir == RG_IDCODE}} & {3'b0,
                                                                                4`DAP_VER,
                                                                                16`DAP_PARTNUM,
                                                                                11`DAP_MANID,
                                                                                1'b1})|
                                                      ({35{ir == RG_BYPASS}} & 35'b0)|
                                                      ({35{ir == RG_APDBUF}} & {3'b0, ap_rbuf_rdata})|
                                                      ({35{ir == RG_APRBUF}} & {3'b0, ap_rbuf_rresp})|
                                                      ({35{ir == RG_APWBUF}} & 35'b0);
    else if (cur_state == STATE_SFT_DR) begin
        if (ir == RG_ABORT ||
            ir == RG_DPACC ||
            ir == RG_APACC)             sfter       <= {tdi, sfter[34:1]};
        else if (ir == RG_IDCODE)       sfter[31:0] <= {tdi, sfter[31:1]};
        else if (ir == RG_BYPASS)       sfter[0]    <=  tdi;
        else if (ir == RG_APDBUF)       sfter[31:0] <= ap_rbuf_dpop ? ap_rbuf_rdata:
                                                                      {1'b0, sfter[31:1]};
        else if (ir == RG_APRBUF)       sfter[31:0] <= ap_rbuf_rpop ? ap_rbuf_rresp:
                                                                      {1'b0, sfter[31:1]};
        else if (ir == RG_APWBUF)       sfter[31:0] <= {tdi, sfter[31:1]};
    end
end

always_ff @(posedge tck or negedge trstn) begin: reg_ir
    if (~trstn)                         ir <= RG_IDCODE;
    else if (~rstn_trig)                ir <= RG_IDCODE;
    else if (cur_state == STATE_UPD_IR) ir <= sfter[4:0];
end

always_ff @(posedge tck or negedge trstn) begin: reg_dr_abort
    if (~trstn)                         dr_abort <= 35'b0;
    else if (~rstn_trig)                dr_abort <= 35'b0;
    else if (ir == RG_ABORT &&
             cur_state == STATE_UPD_DR) dr_abort <= sfter[34:0];
end

assign datain = sfter[34:3];
assign addr   = sfter[ 2:1];
assign rnw    = sfter[0];
assign err    = datain[ 3: 2] == 2'b11 && addr == 2'b1;

assign dpacc_csr_stickycmp    = (((dpacc_csr_masklane[0] && ap_cmp_data[ 0+:8] != ap_rdata[ 0+:8])||
                                  (dpacc_csr_masklane[1] && ap_cmp_data[ 8+:8] != ap_rdata[ 8+:8])||
                                  (dpacc_csr_masklane[2] && ap_cmp_data[16+:8] != ap_rdata[16+:8])||
                                  (dpacc_csr_masklane[3] && ap_cmp_data[24+:8] != ap_rdata[24+:8]))
                                 ^ (dpacc_csr_trnmode == 2'h2)) && dpacc_csr_trnmode != 2'h0 && ap_cmp_en;
assign dpacc_csr_stickyerr    = ap_slverr;
assign dpacc_csr_stickyorun   = 1'b0;

assign dpacc_csr = {
    dpacc_csr_csyspwrupack,
    dpacc_csr_csyspwrupreq,
    dpacc_csr_cdbgpwrupack,
    dpacc_csr_cdbgpwrupreq,
    dpacc_csr_cdbgrstack,
    dpacc_csr_cdbgrstreq,
    2'b0,
    dpacc_csr_trncnt,
    dpacc_csr_masklane,
    2'b0,
    dpacc_csr_stickyerr,
    dpacc_csr_stickycmp,
    dpacc_csr_trnmode,
    dpacc_csr_stickyorun,
    dpacc_csr_orundetect
};
assign dpacc_apsel = {dpacc_apsel_apsel, 16'h0, dpacc_apsel_apaddrh, 4'h0};

always_ff @(posedge tck or negedge trstn) begin: reg_dr_dpacc
    if (~trstn) begin
        dpacc_res              <= 32'b0;
        dpacc_csr_csyspwrupack <= 1'b0;
        dpacc_csr_csyspwrupreq <= 1'b0;
        dpacc_csr_cdbgpwrupack <= 1'b0;
        dpacc_csr_cdbgpwrupreq <= 1'b0;
        dpacc_csr_cdbgrstack   <= 1'b0;
        dpacc_csr_cdbgrstreq   <= 1'b0;
        dpacc_csr_trncnt       <= 12'b0;
        dpacc_csr_masklane     <= 4'b0;
        dpacc_csr_trnmode      <= 2'b0;
        dpacc_csr_orundetect   <= 1'b0;
        dpacc_apsel_apsel      <= 8'b0;
        dpacc_apsel_apaddrh    <= 4'b0;
    end
    else if (~rstn_trig) begin
        dpacc_res              <= 32'b0;
        dpacc_csr_csyspwrupack <= 1'b0;
        dpacc_csr_csyspwrupreq <= 1'b0;
        dpacc_csr_cdbgpwrupack <= 1'b0;
        dpacc_csr_cdbgpwrupreq <= 1'b0;
        dpacc_csr_cdbgrstack   <= 1'b0;
        dpacc_csr_cdbgrstreq   <= 1'b0;
        dpacc_csr_trncnt       <= 12'b0;
        dpacc_csr_masklane     <= 4'b0;
        dpacc_csr_trnmode      <= 2'b0;
        dpacc_csr_orundetect   <= 1'b0;
        dpacc_apsel_apsel      <= 8'b0;
        dpacc_apsel_apaddrh    <= 4'b0;
    end
    else if (ir == RG_DPACC && cur_state == STATE_UPD_DR && ~ap_busy_latch) begin
        if (rnw) begin // Read
            dpacc_csr_csyspwrupack <= 1'b0;
            dpacc_csr_cdbgpwrupack <= 1'b0;
            dpacc_csr_cdbgrstack   <= 1'b0;
            dpacc_res              <= ({32{addr == 2'h0}} & `UNPREDICTABLE)|
                                      ({32{addr == 2'h1}} & dpacc_csr     )|
                                      ({32{addr == 2'h2}} & dpacc_apsel   )|
                                      ({32{addr == 2'h3}} & 32'b0         );
        end
        else begin // Write
            dpacc_res              <= `UNPREDICTABLE;
            dpacc_csr_csyspwrupreq <= addr == 2'h1 && datain[30];
            dpacc_csr_cdbgpwrupreq <= addr == 2'h1 && datain[28];
            dpacc_csr_cdbgrstreq   <= addr == 2'h1 && datain[26];
            dpacc_csr_trncnt       <= addr == 2'h1 ? datain[23:12] : dpacc_csr_trncnt;
            dpacc_csr_masklane     <= addr == 2'h1 ? datain[11: 8] : dpacc_csr_masklane;
            dpacc_csr_trnmode      <= datain[ 3: 2] != 2'b11 &&
                                      addr == 2'h1 ? datain[ 3: 2] : dpacc_csr_trnmode;
            dpacc_csr_orundetect   <= addr == 2'h1 ? datain[0]     : dpacc_csr_orundetect;
            dpacc_apsel_apsel      <= addr == 2'h2 ? datain[31:24] : dpacc_apsel_apsel;
            dpacc_apsel_apaddrh    <= addr == 2'h2 ? datain[ 7: 4] : dpacc_apsel_apaddrh;
        end
    end
    else begin
            dpacc_csr_csyspwrupack <= dpacc_csr_csyspwrupreq;
            dpacc_csr_cdbgpwrupack <= dpacc_csr_cdbgpwrupreq;
            dpacc_csr_cdbgrstack   <= dpacc_csr_cdbgrstreq;
            dpacc_csr_csyspwrupreq <= 1'b0;
            dpacc_csr_cdbgpwrupreq <= 1'b0;
            dpacc_csr_cdbgrstreq   <= 1'b0;
    end
end

assign ap_upd       = ir == RG_APACC && cur_state == STATE_UPD_DR && ~ap_busy_latch
                      /* && ~dpacc_csr_stickycmp && ~dpacc_csr_stickyerr && ~dpacc_csr_stickyorun */;
assign ap_sel       = dpacc_apsel_apsel;
assign ap_wdata     = datain;
assign ap_addr[7:4] = dpacc_apsel_apaddrh;
assign ap_addr[3:2] = addr;
assign ap_rnw       = rnw;

always_ff @(posedge tck or negedge trstn) begin: reg_ap_cmp_data
    if (~trstn) begin
        ap_cmp_data <= 32'b0;
        ap_cmp_en   <= 1'b0;
    end
    else if (~rstn_trig) begin
        ap_cmp_data <= 32'b0;
        ap_cmp_en   <= 1'b0;
    end
    else if (ir == RG_APACC && cur_state == STATE_UPD_DR && ~ap_busy_latch) begin
        if (ap_upd && rnw && ap_addr == 6'h3) begin // Read DRW
            ap_cmp_data <= datain;
            ap_cmp_en   <= 1'b1;
        end
        else begin
            ap_cmp_en   <= 1'b0;
        end
    end
    else if (ir == RG_DPACC && cur_state == STATE_UPD_DR && ~ap_busy_latch) begin
        ap_cmp_en   <= 1'b0;
    end
end

assign ap_rbuf_rrstn = ~((ir == RG_APDBUF || ir == RG_APRBUF) && cur_state == STATE_UPD_DR);
assign ap_rbuf_dpop  = (ir == RG_APDBUF && cur_state == STATE_CAP_DR) ||
                       (ir == RG_APDBUF && cur_state == STATE_SFT_DR && ~|ap_buf_cnt);
assign ap_rbuf_rpop  = (ir == RG_APRBUF && cur_state == STATE_CAP_DR) ||
                       (ir == RG_APRBUF && cur_state == STATE_SFT_DR && ~|ap_buf_cnt);

assign ap_wbuf_wrstn     = ~(ir == RG_APWBUF && cur_state == STATE_CAP_DR);
assign ap_wbuf_push_pre  = ir == RG_APWBUF && cur_state == STATE_SFT_DR && ~|ap_buf_cnt;
assign ap_wbuf_wdata     = sfter[31:0];

always_ff @(posedge tck or negedge trstn) begin: reg_ap_wbuf_push
    if (~trstn) ap_wbuf_push <= 1'b0;
    else        ap_wbuf_push <= ap_wbuf_push_pre;
end

always_ff @(posedge tck or negedge trstn) begin: reg_ap_buf
    if (~trstn) begin
        ap_buf_cnt <= 5'b0;
    end
    else if (~rstn_trig) begin
        ap_buf_cnt <= 5'b0;
    end
    else if (ir == RG_APDBUF || ir == RG_APRBUF || ir == RG_APWBUF) begin
        if (cur_state == STATE_CAP_DR) begin
            ap_buf_cnt <= -5'b1;
        end
        else if (cur_state == STATE_SFT_DR) begin
            ap_buf_cnt <= ap_buf_cnt - 5'b1;
        end
        else if (cur_state == STATE_UPD_DR) begin
            ap_buf_cnt <= 5'b0;
        end
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/dbg/apb_ap.sv
/*--------------------------------------*/

module apb_ap (
    input               tck,
    input               dbgrstn,
    input               sysclk,
    input               sysrstn,

    input               ap_upd,
    input        [31:0] ap_wdata,
    input        [ 7:2] ap_addr,
    input               ap_rnw,
    output logic [31:0] ap_rdata,
    output logic        ap_slverr,
    output logic        ap_busy,

    output logic        ap_rbuf_push,
    output logic [31:0] ap_rbuf_wdata,
    output logic [ 1:0] ap_rbuf_wresp,

    output logic        ap_wbuf_pop,
    input        [31:0] ap_wbuf_rdata,
    input        [ 5:0] ap_wbuf_rsize,

    input               spiden,
    input               deviceen,

    apb_intf.master     m_apb_intf
);

logic        tx_tog;
logic        tx_mem_sector;
logic [31:0] tx_mem_addr;
logic        tx_mem_write;
logic [31:0] tx_mem_wdata;
logic [ 2:0] tx_mem_size;
logic [ 6:0] tx_mem_prot;
logic        tx_mem_secen;
logic        rx_tog;
logic [31:0] rx_mem_rdata;
logic        rx_mem_slverr;
logic        rx_rstn_async;
logic        rx_rstn;
logic        rx_en;

assign rstn_async = dbgrstn & sysrstn;

resetn_synchronizer u_resetn_sync (
    .clk        ( sysclk     ),
    .rstn_async ( rstn_async ),
    .rstn_sync  ( rx_rstn    )
);

mem_ap u_mem_ap (
    .tck           ( tck           ),
    .dbgrstn       ( dbgrstn       ),
                                 
    .ap_upd        ( ap_upd        ),
    .ap_wdata      ( ap_wdata      ),
    .ap_addr       ( ap_addr       ),
    .ap_rnw        ( ap_rnw        ),
    .ap_rdata      ( ap_rdata      ),
    .ap_slverr     ( ap_slverr     ),
    .ap_busy       ( ap_busy       ),
                                 
    .tx_tog        ( tx_tog        ),
    .tx_mem_sector ( tx_mem_sector ),
    .tx_mem_addr   ( tx_mem_addr   ),
    .tx_mem_write  ( tx_mem_write  ),
    .tx_mem_wdata  ( tx_mem_wdata  ),
    .tx_mem_size   ( tx_mem_size   ),
    .tx_mem_prot   ( tx_mem_prot   ),
    .tx_mem_secen  ( tx_mem_secen  ),
    .rx_tog        ( rx_tog        ),
    .rx_mem_rdata  ( rx_mem_rdata  ),
    .rx_mem_slverr ( rx_mem_slverr ),

    .fixedsz       ( 1'b1          ),
    .spiden        ( spiden        ),
    .deviceen      ( deviceen      )
);

apb_rx u_apb_rx (
    .rx_clk        ( sysclk        ),
    .rx_rstn       ( rx_rstn       ),

    .tx_tog        ( tx_tog        ),
    .tx_mem_addr   ( tx_mem_addr   ),
    .tx_mem_write  ( tx_mem_write  ),
    .tx_mem_wdata  ( tx_mem_wdata  ),
    .tx_mem_size   ( tx_mem_size   ),
    .tx_mem_prot   ( tx_mem_prot   ),
    .tx_mem_secen  ( tx_mem_secen  ),
    .rx_tog        ( rx_tog        ),
    .rx_mem_rdata  ( rx_mem_rdata  ),
    .rx_mem_slverr ( rx_mem_slverr ),

    .m_apb_intf    ( m_apb_intf    )
);

assign ap_rbuf_push  = 1'b0;
assign ap_rbuf_wdata = 32'b0;
assign ap_rbuf_wresp = 2'b0;

assign ap_wbuf_pop   = 1'b0;

endmodule

/*--------------------------------------*/
// FILE: ../src/dbg/apb_rx.sv
/*--------------------------------------*/

module apb_rx (
    input               rx_clk,
    input               rx_rstn,

    input               tx_tog,
    input        [31:0] tx_mem_addr,
    input               tx_mem_write,
    input        [31:0] tx_mem_wdata,
    input        [ 2:0] tx_mem_size,
    input        [ 6:0] tx_mem_prot,
    input               tx_mem_secen,
    output logic        rx_tog,
    output logic [31:0] rx_mem_rdata,
    output logic        rx_mem_slverr,

    apb_intf.master     m_apb_intf
);

logic        tx_rec_dly;
logic [31:0] rx_mem_addr;
logic        rx_mem_write;
logic [31:0] rx_mem_wdata;
logic [ 2:0] rx_mem_size;
logic [ 6:0] rx_mem_prot;
logic        rx_mem_secen;

logic        rx_tog_pre;
logic        tx_tog_s1;
logic        tx_tog_s2;
logic        tx_tog_s3;
logic [ 3:0] ignore_tx_cnt;
logic        ignore_tx;
logic        tx_rec;

assign ignore_tx = ignore_tx_cnt[3];
assign tx_rec    = (tx_tog_s2 ^ tx_tog_s3) & ~ignore_tx;

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_ignore_tx_cnt
    if (~rx_rstn) ignore_tx_cnt <= 4'hf;
    else          ignore_tx_cnt <= |ignore_tx_cnt ? ignore_tx_cnt - 4'h1 : ignore_tx_cnt;
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_tx_tog
    if (~rx_rstn) begin
        tx_tog_s1 <= 1'b0;
        tx_tog_s2 <= 1'b0;
        tx_tog_s3 <= 1'b0;
    end
    else begin
        tx_tog_s1 <= tx_tog;
        tx_tog_s2 <= tx_tog_s1;
        tx_tog_s3 <= tx_tog_s2;
    end
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_tx2rx
    if (~rx_rstn) begin
        rx_mem_addr  <= 32'b0;
        rx_mem_write <= 1'b0;
        rx_mem_wdata <= 32'b0;
        rx_mem_size  <= 3'b0;
        rx_mem_prot  <= 7'b0;
        rx_mem_secen <= 1'b0;
    end
    else if (tx_rec) begin
        rx_mem_addr  <= tx_mem_addr;
        rx_mem_write <= tx_mem_write;
        rx_mem_wdata <= tx_mem_wdata;
        rx_mem_size  <= tx_mem_size;
        rx_mem_prot  <= tx_mem_prot;
        rx_mem_secen <= tx_mem_secen;
    end
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_tx_rec_dly
    if (~rx_rstn) tx_rec_dly <= 1'b0;
    else          tx_rec_dly <= tx_rec;
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_psel
    if (~rx_rstn)                   m_apb_intf.psel <= 1'b0;
    else if (tx_rec_dly)            m_apb_intf.psel <= 1'b1;
    else if (m_apb_intf.penable &&
             m_apb_intf.pready)     m_apb_intf.psel <= 1'b0;
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_penable
    if (~rx_rstn)                 m_apb_intf.penable <= 1'b0;
    else if ( m_apb_intf.psel &&
             ~m_apb_intf.penable) m_apb_intf.penable <= 1'b1;
    else if (m_apb_intf.pready)   m_apb_intf.penable <= 1'b0;
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_apb_addr_data
    if (~rx_rstn) begin
        m_apb_intf.paddr  <= 32'b0;
        m_apb_intf.pwrite <= 1'b0;
        m_apb_intf.pstrb  <= 4'b0;
        m_apb_intf.pprot  <= 3'b0;
        m_apb_intf.pwdata <= 32'b0;
    end
    else if (tx_rec_dly) begin
        m_apb_intf.paddr  <= rx_mem_addr;
        m_apb_intf.pwrite <= rx_mem_write;
        m_apb_intf.pstrb  <= 4'hf;
        m_apb_intf.pprot  <= rx_mem_prot[2:0] & {1'b1, rx_mem_secen, 1'b1};
        m_apb_intf.pwdata <= rx_mem_wdata;
    end
end

// always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_rx_tog
//     if (~rx_rstn) begin
//         rx_tog_pre <= 1'b0;
//         rx_tog     <= 1'b0;
//     end
//     else begin
//         rx_tog_pre <= (m_apb_intf.penable && m_apb_intf.pready) ^ rx_tog_pre;
//         rx_tog     <= rx_tog_pre;
//     end
// end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_rx_tog
    if (~rx_rstn) begin
        rx_tog <= 1'b0;
    end
    else begin
        rx_tog <= (m_apb_intf.penable && m_apb_intf.pready) ^ rx_tog;
    end
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_rx_resp
    if (~rx_rstn) begin
        rx_mem_rdata  <= 32'b0;
        rx_mem_slverr <= 1'b0;
    end
    else if (m_apb_intf.penable && m_apb_intf.pready) begin
        rx_mem_rdata  <= m_apb_intf.prdata;
        rx_mem_slverr <= m_apb_intf.pslverr;
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/dbg/axi_ap.sv
/*--------------------------------------*/

module axi_ap (
    input               tck,
    input               dbgrstn,
    input               sysclk,
    input               sysrstn,

    input               ap_upd,
    input        [31:0] ap_wdata,
    input        [ 7:2] ap_addr,
    input               ap_rnw,
    output logic [31:0] ap_rdata,
    output logic        ap_slverr,
    output logic        ap_busy,

    output logic        ap_rbuf_push,
    output logic [31:0] ap_rbuf_wdata,
    output logic [ 1:0] ap_rbuf_wresp,

    output logic        ap_wbuf_pop,
    input        [31:0] ap_wbuf_rdata,
    input        [ 5:0] ap_wbuf_rsize,

    input               spiden,
    input               deviceen,

    axi_intf.master     m_axi_intf
);

logic        tx_tog;
logic        tx_mem_sector;
logic [31:0] tx_mem_addr;
logic        tx_mem_write;
logic [31:0] tx_mem_wdata;
logic [ 2:0] tx_mem_size;
logic [ 6:0] tx_mem_prot;
logic        tx_mem_secen;
logic        rx_tog;
logic [31:0] rx_mem_rdata;
logic        rx_mem_slverr;
logic        rx_rstn_async;
logic        rx_rstn;
logic        rx_en;

assign rstn_async = dbgrstn & sysrstn;

resetn_synchronizer u_resetn_sync (
    .clk        ( sysclk     ),
    .rstn_async ( rstn_async ),
    .rstn_sync  ( rx_rstn    )
);

mem_ap u_mem_ap (
    .tck           ( tck           ),
    .dbgrstn       ( dbgrstn       ),
                                 
    .ap_upd        ( ap_upd        ),
    .ap_wdata      ( ap_wdata      ),
    .ap_addr       ( ap_addr       ),
    .ap_rnw        ( ap_rnw        ),
    .ap_rdata      ( ap_rdata      ),
    .ap_slverr     ( ap_slverr     ),
    .ap_busy       ( ap_busy       ),
                                 
    .tx_tog        ( tx_tog        ),
    .tx_mem_sector ( tx_mem_sector ),
    .tx_mem_addr   ( tx_mem_addr   ),
    .tx_mem_write  ( tx_mem_write  ),
    .tx_mem_wdata  ( tx_mem_wdata  ),
    .tx_mem_size   ( tx_mem_size   ),
    .tx_mem_prot   ( tx_mem_prot   ),
    .tx_mem_secen  ( tx_mem_secen  ),
    .rx_tog        ( rx_tog        ),
    .rx_mem_rdata  ( rx_mem_rdata  ),
    .rx_mem_slverr ( rx_mem_slverr ),

    .fixedsz       ( 1'b0          ),
    .spiden        ( spiden        ),
    .deviceen      ( deviceen      )
);

axi_rx u_axi_rx (
    .rx_clk        ( sysclk        ),
    .rx_rstn       ( rx_rstn       ),

    .tx_tog        ( tx_tog        ),
    .tx_mem_sector ( tx_mem_sector ),
    .tx_mem_addr   ( tx_mem_addr   ),
    .tx_mem_write  ( tx_mem_write  ),
    .tx_mem_wdata  ( tx_mem_wdata  ),
    .tx_mem_size   ( tx_mem_size   ),
    .tx_mem_prot   ( tx_mem_prot   ),
    .tx_mem_secen  ( tx_mem_secen  ),
    .rx_tog        ( rx_tog        ),
    .rx_mem_rdata  ( rx_mem_rdata  ),
    .rx_mem_slverr ( rx_mem_slverr ),

    .ap_rbuf_push  ( ap_rbuf_push  ),
    .ap_rbuf_wdata ( ap_rbuf_wdata ),
    .ap_rbuf_wresp ( ap_rbuf_wresp ),

    .ap_wbuf_pop   ( ap_wbuf_pop   ),
    .ap_wbuf_rdata ( ap_wbuf_rdata ),
    .ap_wbuf_rsize ( ap_wbuf_rsize ),

    .m_axi_intf    ( m_axi_intf    )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/dbg/axi_rx.sv
/*--------------------------------------*/

`ifndef __AXI_DEFINE__
`define __AXI_DEFINE__

`define AXI_BURST_FIXED 2'b00
`define AXI_BURST_INCR  2'b01
`define AXI_BURST_WRAP  2'b10

`define AXI_RESP_OKAY   2'b00
`define AXI_RESP_EXOKAY 2'b01
`define AXI_RESP_SLVERR 2'b10
`define AXI_RESP_DECERR 2'b11

`endif

module axi_rx (
    input               rx_clk,
    input               rx_rstn,

    input               tx_tog,
    input               tx_mem_sector,
    input        [31:0] tx_mem_addr,
    input               tx_mem_write,
    input        [31:0] tx_mem_wdata,
    input        [ 2:0] tx_mem_size,
    input        [ 6:0] tx_mem_prot,
    input               tx_mem_secen,
    output logic        rx_tog,
    output logic [31:0] rx_mem_rdata,
    output logic        rx_mem_slverr,

    output logic        ap_rbuf_push,
    output logic [31:0] ap_rbuf_wdata,
    output logic [ 1:0] ap_rbuf_wresp,

    output logic        ap_wbuf_pop,
    input        [31:0] ap_wbuf_rdata,
    input        [ 5:0] ap_wbuf_rsize,

    axi_intf.master     m_axi_intf
);

logic        tx_rec_dly;
logic        rx_mem_sector;
logic [31:0] rx_mem_addr;
logic        rx_mem_write;
logic [31:0] rx_mem_wdata;
logic [ 2:0] rx_mem_size;
logic [ 6:0] rx_mem_prot;
logic        rx_mem_secen;

logic        rx_tog_pre;
logic        tx_tog_s1;
logic        tx_tog_s2;
logic        tx_tog_s3;
logic [ 3:0] ignore_tx_cnt;
logic        ignore_tx;
logic        tx_rec;

logic [ 5:0] sector_send_cnt;
logic [ 3:0] sector_rec_cnt;

logic        burst;
logic [ 3:0] bmask;

assign ignore_tx = ignore_tx_cnt[3];
assign tx_rec    = (tx_tog_s2 ^ tx_tog_s3) & ~ignore_tx;

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_ignore_tx_cnt
    if (~rx_rstn) ignore_tx_cnt <= 4'hf;
    else          ignore_tx_cnt <= |ignore_tx_cnt ? ignore_tx_cnt - 4'h1 : ignore_tx_cnt;
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_tx_tog
    if (~rx_rstn) begin
        tx_tog_s1 <= 1'b0;
        tx_tog_s2 <= 1'b0;
        tx_tog_s3 <= 1'b0;
    end
    else begin
        tx_tog_s1 <= tx_tog;
        tx_tog_s2 <= tx_tog_s1;
        tx_tog_s3 <= tx_tog_s2;
    end
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_tx2rx
    if (~rx_rstn) begin
        rx_mem_sector <= 1'b0;
        rx_mem_addr   <= 32'b0;
        rx_mem_write  <= 1'b0;
        rx_mem_wdata  <= 32'b0;
        rx_mem_size   <= 3'b0;
        rx_mem_prot   <= 7'b0;
        rx_mem_secen  <= 1'b0;
    end
    else if (tx_rec) begin
        rx_mem_sector <= tx_mem_sector;
        rx_mem_addr   <= tx_mem_addr;
        rx_mem_write  <= tx_mem_write;
        rx_mem_wdata  <= tx_mem_wdata;
        rx_mem_size   <= tx_mem_size;
        rx_mem_prot   <= tx_mem_prot;
        rx_mem_secen  <= tx_mem_secen;
    end
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_tx_rec_dly
    if (~rx_rstn) tx_rec_dly <= 1'b0;
    else          tx_rec_dly <= tx_rec;
end

assign m_axi_intf.awid    = 8'h0;
assign m_axi_intf.awburst = `AXI_BURST_INCR;
assign m_axi_intf.awsize  = 2'h2;
assign m_axi_intf.awlock  = 2'h0;
assign m_axi_intf.awcache = 4'h0;
assign m_axi_intf.wid     = 8'h0;
assign m_axi_intf.bready  = 1'b1;
assign m_axi_intf.arid    = 8'h0;
assign m_axi_intf.arburst = `AXI_BURST_INCR;
assign m_axi_intf.arsize  = 2'h2;
assign m_axi_intf.arlock  = 2'h0;
assign m_axi_intf.arcache = 4'h0;
assign m_axi_intf.rready  = 1'b1;

assign burst = ({1'b0, rx_mem_addr[1:0]} + (3'h1 << rx_mem_size)) > 3'h4;
assign bmask = ((4'b1 << (3'h1 << rx_mem_size)) - 4'b1);

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_axi_aw
    if (~rx_rstn) begin
        m_axi_intf.awaddr  <= 32'b0;
        m_axi_intf.awlen   <= 8'b0;
        m_axi_intf.awprot  <= 3'b0;
    end
    else if (tx_rec_dly && rx_mem_write) begin
        m_axi_intf.awaddr  <= rx_mem_sector ? {rx_mem_addr[31:4], 4'b0} : {rx_mem_addr[31:2], 2'b0};
        m_axi_intf.awlen   <= rx_mem_sector ? 8'h3 : {7'b0, burst};
        m_axi_intf.awprot  <= rx_mem_prot[2:0] & {1'b1, rx_mem_secen, 1'b1};;
    end
    else if (rx_mem_sector && ((~m_axi_intf.wlast && m_axi_intf.wvalid && m_axi_intf.wready)||
                               (m_axi_intf.awvalid && m_axi_intf.awready))) begin
        m_axi_intf.awaddr  <= m_axi_intf.awaddr + 32'h4;
    end
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_axi_aw_vld
    if (~rx_rstn) begin
        m_axi_intf.awvalid <= 1'b0;
    end
    else if ((tx_rec_dly && rx_mem_write) ||
             (rx_mem_sector && (|sector_send_cnt[5:1]) &&
              m_axi_intf.wlast && m_axi_intf.wvalid && m_axi_intf.wready)) begin
        m_axi_intf.awvalid <= 1'b1;
    end
    else if (m_axi_intf.awready) begin
        m_axi_intf.awvalid <= 1'b0;
    end
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_axi_w
    if (~rx_rstn) begin
        m_axi_intf.wstrb   <= 4'b0;
        m_axi_intf.wdata   <= 32'b0;
        m_axi_intf.wlast   <= 1'b0;
    end
    else if (~rx_mem_sector) begin
        if (tx_rec_dly && rx_mem_write) begin
            m_axi_intf.wstrb   <= bmask << rx_mem_addr[1:0];
            m_axi_intf.wdata   <= rx_mem_wdata << {rx_mem_addr[1:0], 3'b0};
            m_axi_intf.wlast   <= ~burst;
        end
        else if (~m_axi_intf.wlast && m_axi_intf.wvalid && m_axi_intf.wready) begin
            m_axi_intf.wstrb   <= bmask >> -rx_mem_addr[1:0];
            m_axi_intf.wdata   <= rx_mem_wdata >> {-rx_mem_addr[1:0], 3'b0};
            m_axi_intf.wlast   <= 1'b1;
        end
    end
    else begin
        m_axi_intf.wstrb <= m_axi_intf.awvalid || m_axi_intf.wready ? {4{|sector_send_cnt & ap_wbuf_pop}}:
                                                                      m_axi_intf.wstrb;
        m_axi_intf.wdata <= m_axi_intf.awvalid || m_axi_intf.wready ? ap_wbuf_rdata : m_axi_intf.wdata;
        m_axi_intf.wlast <= m_axi_intf.awaddr[3:2] == 2'h3 && m_axi_intf.wready;
    end
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_axi_w_vld
    if (~rx_rstn) begin
        m_axi_intf.wvalid <= 1'b0;
    end
    else if (rx_mem_sector && rx_mem_write && m_axi_intf.awvalid && m_axi_intf.awready) begin
        m_axi_intf.wvalid <= 1'b1;
    end
    else if (tx_rec_dly && ~rx_mem_sector && rx_mem_write) begin
        m_axi_intf.wvalid <= 1'b1;
    end
    else if (m_axi_intf.wlast && m_axi_intf.wready) begin
        m_axi_intf.wvalid <= 1'b0;
    end
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_axi_ar
    if (~rx_rstn) begin
        m_axi_intf.araddr  <= 32'b0;
        m_axi_intf.arlen   <= 8'b0;
        m_axi_intf.arprot  <= 3'b0;
    end
    else if (tx_rec_dly && ~rx_mem_write) begin
        m_axi_intf.araddr  <= rx_mem_sector ? {rx_mem_addr[31:4], 4'b0} : {rx_mem_addr[31:2], 2'b0};
        m_axi_intf.arlen   <= rx_mem_sector ? 8'h3 : {7'b0, burst};
        m_axi_intf.arprot  <= rx_mem_prot[2:0] & {1'b1, rx_mem_secen, 1'b1};;
    end
    else if (|sector_send_cnt && m_axi_intf.arready) begin
        m_axi_intf.araddr  <= m_axi_intf.araddr + 32'h10;
    end
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_sector_rec_cnt
    if (~rx_rstn) begin
        sector_rec_cnt <= 4'b0;
    end
    else if (tx_rec_dly && ~rx_mem_write) begin
        sector_rec_cnt <= rx_mem_sector ? 4'hf : 4'b0;
    end
    else if (tx_rec_dly &&  rx_mem_write) begin
        sector_rec_cnt <= rx_mem_sector ? ap_wbuf_rsize[5:2] -
                                          (~({2'b0, rx_mem_addr[3:2]} + {2'b0, ap_wbuf_rsize[1:0]}) >> 2):
                                          4'b0;
    end
    else if ((m_axi_intf.rlast && m_axi_intf.rvalid && m_axi_intf.rready) ||
             (                    m_axi_intf.bvalid && m_axi_intf.bready)) begin
        sector_rec_cnt <= |sector_rec_cnt ? sector_rec_cnt - 4'b1 : 4'b0;
    end
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_sector_send_cnt
    if (~rx_rstn) begin
        sector_send_cnt <= 6'b0;
    end
    else if (tx_rec_dly && ~rx_mem_write) begin
        sector_send_cnt <= rx_mem_sector ? 6'hf : 6'b0;
    end
    else if (tx_rec_dly &&  rx_mem_write) begin
        sector_send_cnt <= rx_mem_sector ? ap_wbuf_rsize - 6'h1 : 6'b0;
    end
    else if (m_axi_intf.arvalid && m_axi_intf.arready) begin
        sector_send_cnt <= |sector_send_cnt ? sector_send_cnt - 6'b1 : 6'b0;
    end
    else if (m_axi_intf.wvalid && m_axi_intf.wready) begin
        sector_send_cnt <= |sector_send_cnt ? sector_send_cnt - {5'b0, |m_axi_intf.wstrb}:
                                              6'b0;
    end
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_axi_ar_vld
    if (~rx_rstn) begin
        m_axi_intf.arvalid <= 1'b0;
    end
    else if (tx_rec_dly && ~rx_mem_write) begin
        m_axi_intf.arvalid <= 1'b1;
    end
    else if (m_axi_intf.arready && ~|sector_send_cnt) begin
        m_axi_intf.arvalid <= 1'b0;
    end
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_rx_tog
    if (~rx_rstn) begin
        rx_tog <= 1'b0;
    end
    else begin
        rx_tog <= ((~rx_mem_sector && m_axi_intf.rlast && m_axi_intf.rvalid && m_axi_intf.rready)||
                   ( rx_mem_sector && m_axi_intf.rlast && m_axi_intf.rvalid && m_axi_intf.rready && ~|sector_rec_cnt)||
                   (~rx_mem_sector && m_axi_intf.bvalid && m_axi_intf.bready)||
                   ( rx_mem_sector && m_axi_intf.bvalid && m_axi_intf.bready && ~|sector_rec_cnt)) ^ rx_tog;
    end
end

always_ff @(posedge rx_clk or negedge rx_rstn) begin: reg_rx_resp
    if (~rx_rstn) begin
        rx_mem_rdata  <= 32'b0;
        rx_mem_slverr <= 1'b0;
    end
    else if (m_axi_intf.rvalid && m_axi_intf.rready) begin
        rx_mem_rdata  <= rx_mem_sector ?
                             (&sector_rec_cnt ? m_axi_intf.rdata : rx_mem_rdata): // record 1st rdata
                         (~m_axi_intf.rlast || ~burst ?
                             m_axi_intf.rdata >> {rx_mem_addr[1:0], 3'b0}:
                             (rx_mem_rdata | (m_axi_intf.rdata << {-rx_mem_addr[1:0], 3'b0}))) &
                             {{8{bmask[3]}}, {8{bmask[2]}}, {8{bmask[1]}}, {8{bmask[0]}}};
        rx_mem_slverr <= ~m_axi_intf.rlast || ~burst ?
                             m_axi_intf.rresp[1]:
                             (rx_mem_slverr || m_axi_intf.rresp[1]);
    end
    else if (m_axi_intf.bvalid && m_axi_intf.bready) begin
        rx_mem_rdata  <= 32'b0;
        rx_mem_slverr <= m_axi_intf.bresp[1];
    end
end

assign ap_rbuf_push  = rx_mem_sector && m_axi_intf.rvalid && m_axi_intf.rready;
assign ap_rbuf_wdata = m_axi_intf.rdata;
assign ap_rbuf_wresp = m_axi_intf.rresp;

assign ap_wbuf_pop   = rx_mem_sector && (m_axi_intf.awaddr >= rx_mem_addr) &&
                       ((~m_axi_intf.wlast && m_axi_intf.wvalid && m_axi_intf.wready)||
                        (m_axi_intf.awvalid && m_axi_intf.awready));

endmodule

/*--------------------------------------*/
// FILE: ../src/dbg/mem_ap.sv
/*--------------------------------------*/

module mem_ap (
    input               tck,
    input               dbgrstn,

    input               ap_upd,
    input        [31:0] ap_wdata,
    input        [ 7:2] ap_addr,
    input               ap_rnw,
    output logic [31:0] ap_rdata,
    output logic        ap_slverr,
    output logic        ap_busy,

    output logic        tx_tog,
    output logic        tx_mem_sector,
    output logic [31:0] tx_mem_addr,
    output logic        tx_mem_write,
    output logic [31:0] tx_mem_wdata,
    output logic [ 2:0] tx_mem_size,
    output logic [ 6:0] tx_mem_prot,
    output logic        tx_mem_secen,
    input               rx_tog,
    input        [31:0] rx_mem_rdata,
    input               rx_mem_slverr,

    input               fixedsz,
    input               spiden,
    input               deviceen
);

logic [31:0] mem_ap_csw;
logic        mem_ap_csw_dbgswen;
logic [ 6:0] mem_ap_csw_prot;
logic [ 3:0] mem_ap_csw_mode;
logic        mem_ap_csw_sector;
logic [ 1:0] mem_ap_csw_addrinc;
logic [ 2:0] mem_ap_csw_size;
logic [31:0] mem_ap_tar;
logic [31:0] mem_ap_bd0;
logic [31:0] mem_ap_bd1;
logic [31:0] mem_ap_bd2;
logic [31:0] mem_ap_bd3;

logic        tx_tog_pre;
logic        rx_tog_s1;
logic        rx_tog_s2;
logic        rx_tog_s3;
logic        rx_rec;
logic        rx_rec_dly;

logic [31:0] tx_mem_rdata;
logic        tx_mem_slverr;

logic [ 3:0] cnt;

always_ff @(posedge tck or negedge dbgrstn) begin: reg_rdata
    if (~dbgrstn) begin
        ap_rdata  <= 32'b0;
        ap_slverr <= 1'b0;
    end
    else if (~ap_busy && ap_upd) begin
        ap_rdata  <= ({32{ap_addr == 6'h0 && ap_rnw}} & mem_ap_csw)|
                     ({32{ap_addr == 6'h1 && ap_rnw}} & mem_ap_tar);
        ap_slverr <= 1'b0;
    end
    else if (rx_rec_dly) begin
        ap_rdata  <= tx_mem_rdata;
        ap_slverr <= tx_mem_slverr;
    end
end

always_ff @(posedge tck or negedge dbgrstn) begin: reg_busy
    if (~dbgrstn) begin
        ap_busy <= 1'b0;
    end
    else if (~ap_busy) begin
        if (ap_upd) begin
            ap_busy <= ap_addr == 6'h3 || ap_addr == 6'h4 ||
                       ap_addr == 6'h5 || ap_addr == 6'h6 ||
                       ap_addr == 6'h7;
        end
    end
    else if (rx_rec_dly) begin
        ap_busy <= 1'b0;
    end
end

assign mem_ap_csw = {mem_ap_csw_dbgswen,
                     mem_ap_csw_prot,
                     spiden,
                     11'b0,
                     mem_ap_csw_mode,
                     ap_busy,
                     deviceen,
                     mem_ap_csw_addrinc,
                     mem_ap_csw_sector,
                     mem_ap_csw_size};

always_ff @(posedge tck or negedge dbgrstn) begin: reg_csw
    if (~dbgrstn) begin
        mem_ap_csw_dbgswen <= 1'b0;
        mem_ap_csw_prot    <= 7'b0;
        mem_ap_csw_mode    <= 4'b0;
        mem_ap_csw_addrinc <= 2'h0;
        mem_ap_csw_sector  <= 1'b0;
        mem_ap_csw_size    <= 3'h2;
    end
    else if (ap_upd && ap_addr == 6'h0) begin
        if (~ap_rnw) begin
            mem_ap_csw_dbgswen <= ap_wdata[31:31];
            mem_ap_csw_prot    <= ap_wdata[30:24];
            mem_ap_csw_addrinc <= ap_wdata[ 5: 4];
            mem_ap_csw_sector  <= ap_wdata[ 3: 3];
            mem_ap_csw_size    <= ~fixedsz ? ap_wdata[2:0] : mem_ap_csw_size;
        end
    end
end

always_ff @(posedge tck or negedge dbgrstn) begin: reg_tar
    if (~dbgrstn) begin
        mem_ap_tar <= 32'b0;
    end
    else if (ap_upd && ap_addr == 6'h1) begin
        if (~ap_rnw) begin
            mem_ap_tar <= ap_wdata & {{30{1'b1}}, {2{~fixedsz}}};
        end
    end
    else if (ap_upd && ap_addr == 6'h3 && mem_ap_csw_addrinc == 2'h1) begin
        mem_ap_tar <= mem_ap_tar + (32'b1 << mem_ap_csw_size);
    end
end

always_ff @(posedge tck or negedge dbgrstn) begin: reg_bd0
    if (~dbgrstn) begin
        mem_ap_bd0 <= 32'b0;
    end
    else if (ap_upd && ap_addr == 6'h4) begin
        if (~ap_rnw) begin
            mem_ap_bd0 <= ap_wdata;
        end
    end
end

always_ff @(posedge tck or negedge dbgrstn) begin: reg_bd1
    if (~dbgrstn) begin
        mem_ap_bd1 <= 32'b0;
    end
    else if (ap_upd && ap_addr == 6'h5) begin
        if (~ap_rnw) begin
            mem_ap_bd1 <= ap_wdata;
        end
    end
end

always_ff @(posedge tck or negedge dbgrstn) begin: reg_bd2
    if (~dbgrstn) begin
        mem_ap_bd2 <= 32'b0;
    end
    else if (ap_upd && ap_addr == 6'h6) begin
        if (~ap_rnw) begin
            mem_ap_bd2 <= ap_wdata;
        end
    end
end

always_ff @(posedge tck or negedge dbgrstn) begin: reg_bd3
    if (~dbgrstn) begin
        mem_ap_bd3 <= 32'b0;
    end
    else if (ap_upd && ap_addr == 6'h7) begin
        if (~ap_rnw) begin
            mem_ap_bd3 <= ap_wdata;
        end
    end
end

// always_ff @(posedge tck or negedge dbgrstn) begin: reg_tx_tog
//     if (~dbgrstn) begin
//         tx_tog_pre <= 1'b0;
//         tx_tog     <= 1'b0;
//     end
//     else begin
//         tx_tog_pre <= ((ap_addr == 6'h3 || ap_addr == 6'h4 ||
//                         ap_addr == 6'h5 || ap_addr == 6'h6 ||
//                         ap_addr == 6'h7) && ap_upd && ~ap_busy) ^ tx_tog_pre;
//         tx_tog     <= tx_tog_pre;
//     end
// end

always_ff @(posedge tck or negedge dbgrstn) begin: reg_tx_tog
    if (~dbgrstn) begin
        tx_tog <= 1'b0;
    end
    else begin
        tx_tog <= ((ap_addr == 6'h3 || ap_addr == 6'h4 ||
                    ap_addr == 6'h5 || ap_addr == 6'h6 ||
                    ap_addr == 6'h7) && ap_upd && ~ap_busy && deviceen) ^ tx_tog;
    end
end

always_ff @(posedge tck or negedge dbgrstn) begin: reg_tx_req
    if (~dbgrstn) begin
        tx_mem_sector <= 1'b0;
        tx_mem_addr   <= 32'b0;
        tx_mem_write  <= 1'b0;
        tx_mem_wdata  <= 32'b0;
        tx_mem_size   <= 3'b0;
        tx_mem_prot   <= 7'b0;
        tx_mem_secen  <= 1'b0;
    end
    else if (~ap_busy) begin
        if (ap_upd) begin
            tx_mem_sector      <= mem_ap_csw_sector;
            tx_mem_addr[31:4]  <= mem_ap_tar[31:4];
            tx_mem_addr[ 3:0]  <= ({4{ap_addr == 6'h3}} & mem_ap_tar[3:0])|
                                  ({4{ap_addr == 6'h4}} & 4'h0           )|
                                  ({4{ap_addr == 6'h4}} & 4'h4           )|
                                  ({4{ap_addr == 6'h4}} & 4'h8           )|
                                  ({4{ap_addr == 6'h4}} & 4'hc           );
            tx_mem_write       <= ~ap_rnw;
            tx_mem_wdata       <= ap_wdata;
            tx_mem_size        <= mem_ap_csw_size;
            tx_mem_prot        <= mem_ap_csw_prot;
            tx_mem_secen       <= spiden;
        end
    end
end

always_ff @(posedge tck or negedge dbgrstn) begin: reg_rx_tog
    if (~dbgrstn) begin
        rx_tog_s1 <= 1'b0;
        rx_tog_s2 <= 1'b0;
        rx_tog_s3 <= 1'b0;
    end
    else begin
        rx_tog_s1 <= rx_tog;
        rx_tog_s2 <= rx_tog_s1;
        rx_tog_s3 <= rx_tog_s2;
    end
end

assign rx_rec = rx_tog_s2 ^ rx_tog_s3;

always_ff @(posedge tck or negedge dbgrstn) begin: reg_rx_rec_dly
    if (~dbgrstn) rx_rec_dly <= 1'b0;
    else          rx_rec_dly <= rx_rec;
end

always_ff @(posedge tck or negedge dbgrstn) begin: reg_rx2tx
    if (~dbgrstn) begin
        tx_mem_rdata  <= 32'b0;
        tx_mem_slverr <= 1'b0;
    end
    else if (rx_rec) begin
        tx_mem_rdata  <= rx_mem_rdata;
        tx_mem_slverr <= rx_mem_slverr;
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/scu.sv
/*--------------------------------------*/

module scu (
    input                                    clk,
    input                                    rstn,

    axi_intf.slave                           s_axi_intf,
    axi_intf.master                          m_axi_intf,

    output logic [  `CACHE_ADDR_WIDTH - 1:0] m0_snp_addr,
    output logic                             m0_snp_valid,
    input                                    m0_snp_ready,

    output logic [  `CACHE_ADDR_WIDTH - 1:0] m1_snp_addr,
    output logic                             m1_snp_valid,
    input                                    m1_snp_ready
);

logic        m0_fifo_push;
logic [31:0] m0_fifo_wdata;
logic        m0_fifo_full;
logic        m0_fifo_pop;
logic [31:0] m0_fifo_rdata;
logic        m0_fifo_empty;
logic        m1_fifo_push;
logic [31:0] m1_fifo_wdata;
logic        m1_fifo_full;
logic        m1_fifo_pop;
logic [31:0] m1_fifo_rdata;
logic        m1_fifo_empty;
logic        stall;

assign m_axi_intf.awid    = s_axi_intf.awid;
assign m_axi_intf.awaddr  = s_axi_intf.awaddr;
assign m_axi_intf.awburst = s_axi_intf.awburst;
assign m_axi_intf.awsize  = s_axi_intf.awsize;
assign m_axi_intf.awlen   = s_axi_intf.awlen;
assign m_axi_intf.awlock  = s_axi_intf.awlock;
assign m_axi_intf.awcache = s_axi_intf.awcache;
assign m_axi_intf.awprot  = s_axi_intf.awprot;
assign m_axi_intf.awvalid = s_axi_intf.awvalid && ~stall;
assign s_axi_intf.awready = m_axi_intf.awready && ~stall;
assign m_axi_intf.wid     = s_axi_intf.wid;
assign m_axi_intf.wstrb   = s_axi_intf.wstrb;
assign m_axi_intf.wdata   = s_axi_intf.wdata;
assign m_axi_intf.wlast   = s_axi_intf.wlast;
assign m_axi_intf.wvalid  = s_axi_intf.wvalid;
assign s_axi_intf.wready  = m_axi_intf.wready;
assign s_axi_intf.bid     = m_axi_intf.bid;
assign s_axi_intf.bresp   = m_axi_intf.bresp;
assign s_axi_intf.bvalid  = m_axi_intf.bvalid;
assign m_axi_intf.bready  = s_axi_intf.bready;
assign m_axi_intf.arid    = s_axi_intf.arid;
assign m_axi_intf.araddr  = s_axi_intf.araddr;
assign m_axi_intf.arburst = s_axi_intf.arburst;
assign m_axi_intf.arsize  = s_axi_intf.arsize;
assign m_axi_intf.arlen   = s_axi_intf.arlen;
assign m_axi_intf.arlock  = s_axi_intf.arlock;
assign m_axi_intf.arcache = s_axi_intf.arcache;
assign m_axi_intf.arprot  = s_axi_intf.arprot;
assign m_axi_intf.arvalid = s_axi_intf.arvalid;
assign s_axi_intf.arready = m_axi_intf.arready;
assign s_axi_intf.rid     = m_axi_intf.rid;
assign s_axi_intf.rdata   = m_axi_intf.rdata;
assign s_axi_intf.rresp   = m_axi_intf.rresp;
assign s_axi_intf.rlast   = m_axi_intf.rlast;
assign s_axi_intf.rvalid  = m_axi_intf.rvalid;
assign m_axi_intf.rready  = s_axi_intf.rready;

assign stall = m0_fifo_full || m1_fifo_full;

assign m0_fifo_push  = s_axi_intf.awvalid && s_axi_intf.awready;
assign m0_fifo_wdata = s_axi_intf.awaddr;
assign m0_fifo_pop   = m0_snp_valid && m0_snp_ready;
assign m1_fifo_push  = s_axi_intf.awvalid && s_axi_intf.awready;
assign m1_fifo_wdata = s_axi_intf.awaddr;
assign m1_fifo_pop   = m1_snp_valid && m1_snp_ready;

assign m0_snp_addr  =  m0_fifo_rdata;
assign m0_snp_valid = ~m0_fifo_empty;
assign m1_snp_addr  =  m1_fifo_rdata;
assign m1_snp_valid = ~m1_fifo_empty;

scu_fifo u_m0_fifo (
    .clk   ( clk           ),
    .rstn  ( rstn          ),

    .push  ( m0_fifo_push  ),
    .wdata ( m0_fifo_wdata ),
    .full  ( m0_fifo_full  ),

    .pop   ( m0_fifo_pop   ),
    .rdata ( m0_fifo_rdata ),
    .empty ( m0_fifo_empty )
);

scu_fifo u_m1_fifo (
    .clk   ( clk           ),
    .rstn  ( rstn          ),

    .push  ( m1_fifo_push  ),
    .wdata ( m1_fifo_wdata ),
    .full  ( m1_fifo_full  ),

    .pop   ( m1_fifo_pop   ),
    .rdata ( m1_fifo_rdata ),
    .empty ( m1_fifo_empty )
);

endmodule

module scu_fifo (
    input               clk,
    input               rstn,

    input               push,
    input        [31:0] wdata,
    output logic        full,

    input               pop,
    output logic [31:0] rdata,
    output logic        empty
);

parameter DEPTH = 2;
parameter SIZE  = 2 ** DEPTH;

logic [   31:0] fifo [SIZE];
logic [DEPTH:0] rptr;
logic [DEPTH:0] wptr;

assign empty = rptr == wptr;
assign full  = rptr[0+:DEPTH] == wptr[0+:DEPTH] &&
               (rptr[DEPTH] ^ wptr[DEPTH]);

assign rdata = fifo[rptr[0+:DEPTH]];

always_ff @(posedge clk or negedge rstn) begin: reg_rptr
    if (~rstn) rptr <= {DEPTH+1{1'b0}};
    else       rptr <= rptr + {{DEPTH{1'b0}}, pop & ~empty};
end

always_ff @(posedge clk or negedge rstn) begin: reg_wptr
    if (~rstn) wptr <= {DEPTH+1{1'b0}};
    else       wptr <= wptr + {{DEPTH{1'b0}}, push & ~full};
end

always_ff @(posedge clk or negedge rstn) begin: reg_fifo
    integer i;
    if (~rstn) begin
        for (i = 0; i < SIZE; i = i + 1)
            fifo[i] <= 32'b0;
    end
    else if (push && ~full) begin
        fifo[wptr[0+:DEPTH]] <= wdata;
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/iommu.sv
/*--------------------------------------*/

module iommu_ext (
    axi_intf.slave  s_axi_intf,
    axi_intf.master m_axi_intf
);

assign s_axi_intf.awready = m_axi_intf.awready;
assign s_axi_intf.wready  = m_axi_intf.wready ;
assign s_axi_intf.bid     = m_axi_intf.bid    ;
assign s_axi_intf.bresp   = m_axi_intf.bresp  ;
assign s_axi_intf.bvalid  = m_axi_intf.bvalid ;
assign s_axi_intf.arready = m_axi_intf.arready;
assign s_axi_intf.rdata   = m_axi_intf.rdata  ;
assign s_axi_intf.rresp   = m_axi_intf.rresp  ;
assign s_axi_intf.rid     = m_axi_intf.rid    ;
assign s_axi_intf.rlast   = m_axi_intf.rlast  ;
assign s_axi_intf.rvalid  = m_axi_intf.rvalid ;

assign m_axi_intf.awburst = s_axi_intf.awburst;
assign m_axi_intf.awid    = s_axi_intf.awid   ;
assign m_axi_intf.awaddr  = {2'b0, s_axi_intf.awaddr[29:0]};
assign m_axi_intf.awsize  = s_axi_intf.awsize ;
assign m_axi_intf.awlen   = s_axi_intf.awlen  ;
assign m_axi_intf.awlock  = s_axi_intf.awlock ;
assign m_axi_intf.awcache = s_axi_intf.awcache;
assign m_axi_intf.awprot  = s_axi_intf.awprot ;
assign m_axi_intf.awvalid = s_axi_intf.awvalid;
assign m_axi_intf.wstrb   = s_axi_intf.wstrb  ;
assign m_axi_intf.wid     = s_axi_intf.wid    ;
assign m_axi_intf.wdata   = s_axi_intf.wdata  ;
assign m_axi_intf.wlast   = s_axi_intf.wlast  ;
assign m_axi_intf.wvalid  = s_axi_intf.wvalid ;
assign m_axi_intf.bready  = s_axi_intf.bready ;
assign m_axi_intf.araddr  = {2'b0, s_axi_intf.araddr[29:0]};
assign m_axi_intf.arburst = s_axi_intf.arburst;
assign m_axi_intf.arsize  = s_axi_intf.arsize ;
assign m_axi_intf.arid    = s_axi_intf.arid   ;
assign m_axi_intf.arlen   = s_axi_intf.arlen  ;
assign m_axi_intf.arlock  = s_axi_intf.arlock ;
assign m_axi_intf.arcache = s_axi_intf.arcache;
assign m_axi_intf.arprot  = s_axi_intf.arprot ;
assign m_axi_intf.arvalid = s_axi_intf.arvalid;
assign m_axi_intf.rready  = s_axi_intf.rready ;

endmodule

module iommu_ddr (
    axi_intf.slave  s_axi_intf,
    axi_intf.master m_axi_intf,
    input [31:0]    offset
);

assign s_axi_intf.awready = m_axi_intf.awready;
assign s_axi_intf.wready  = m_axi_intf.wready ;
assign s_axi_intf.bid     = {6'b0, m_axi_intf.bid};
assign s_axi_intf.bresp   = m_axi_intf.bresp  ;
assign s_axi_intf.bvalid  = m_axi_intf.bvalid ;
assign s_axi_intf.arready = m_axi_intf.arready;
assign s_axi_intf.rdata   = m_axi_intf.rdata  ;
assign s_axi_intf.rresp   = m_axi_intf.rresp  ;
assign s_axi_intf.rid     = {6'b0, m_axi_intf.rid};
assign s_axi_intf.rlast   = m_axi_intf.rlast  ;
assign s_axi_intf.rvalid  = m_axi_intf.rvalid ;

assign m_axi_intf.awburst = s_axi_intf.awburst;
assign m_axi_intf.awid    = s_axi_intf.awid[5:0];
assign m_axi_intf.awaddr  = s_axi_intf.awaddr + offset + 32'h8000_0000;
assign m_axi_intf.awsize  = s_axi_intf.awsize ;
assign m_axi_intf.awlen   = s_axi_intf.awlen  ;
assign m_axi_intf.awlock  = s_axi_intf.awlock ;
assign m_axi_intf.awcache = s_axi_intf.awcache;
assign m_axi_intf.awprot  = s_axi_intf.awprot ;
assign m_axi_intf.awvalid = s_axi_intf.awvalid;
assign m_axi_intf.wstrb   = s_axi_intf.wstrb  ;
assign m_axi_intf.wid     = s_axi_intf.wid[5:0];
assign m_axi_intf.wdata   = s_axi_intf.wdata  ;
assign m_axi_intf.wlast   = s_axi_intf.wlast  ;
assign m_axi_intf.wvalid  = s_axi_intf.wvalid ;
assign m_axi_intf.bready  = s_axi_intf.bready ;
assign m_axi_intf.araddr  = s_axi_intf.araddr + offset + 32'h8000_0000;
assign m_axi_intf.arburst = s_axi_intf.arburst;
assign m_axi_intf.arsize  = s_axi_intf.arsize ;
assign m_axi_intf.arid    = s_axi_intf.arid[5:0];
assign m_axi_intf.arlen   = s_axi_intf.arlen  ;
assign m_axi_intf.arlock  = s_axi_intf.arlock ;
assign m_axi_intf.arcache = s_axi_intf.arcache;
assign m_axi_intf.arprot  = s_axi_intf.arprot ;
assign m_axi_intf.arvalid = s_axi_intf.arvalid;
assign m_axi_intf.rready  = s_axi_intf.rready ;

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/axi2mem_bridge.sv
/*--------------------------------------*/

`ifndef __AXI_DEFINE__
`define __AXI_DEFINE__

`define AXI_BURST_FIXED 2'b00
`define AXI_BURST_INCR  2'b01
`define AXI_BURST_WRAP  2'b10

`define AXI_RESP_OKAY   2'b00
`define AXI_RESP_EXOKAY 2'b01
`define AXI_RESP_SLVERR 2'b10
`define AXI_RESP_DECERR 2'b11

`endif

module axi2mem_bridge (
    input                  aclk,
    input                  aresetn,
    // AXI slave port
    axi_intf.slave         s_axi_intf,

    // Memory intface master port
    output logic           m_cs, 
    output logic           m_we, 
    output logic  [ 31: 0] m_addr,
    output logic  [  3: 0] m_byte,
    output logic  [ 31: 0] m_di,
    input         [ 31: 0] m_do,
    input                  m_busy

);

parameter [1:0] STATE_IDLE = 2'b00,
                STATE_WR   = 2'b01,
                SIATE_RESP = 2'b10,
                STATE_RD   = 2'b11;

logic [  1: 0] cur_state;
logic [  1: 0] nxt_state;

logic          req_latch;
logic          rsend_latch;
logic [ 12: 0] id_latch;
logic [  7: 0] cnt;
logic [ 31: 0] addr_latch;
logic [ 31: 0] addr_mask_latch;
logic [  2: 0] size_latch;
logic          id_upd;
logic          cnt_upd;
logic          addr_upd;
logic          size_upd;
logic          cnt_nxt;
logic          addr_nxt;
logic          rdata_latch_en;
logic [ 31: 0] rdata_latch;


always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        cur_state <= STATE_IDLE;
    end
    else begin
        cur_state <= nxt_state;
    end
end

always_comb begin
    nxt_state = cur_state;
    case (cur_state)
        STATE_IDLE: begin
            nxt_state = s_axi_intf.arvalid ? STATE_RD:
                        s_axi_intf.awvalid ? STATE_WR:
                                    STATE_IDLE;
        end
        STATE_WR  : begin
            nxt_state = ~|cnt & s_axi_intf.wvalid & s_axi_intf.wready ? SIATE_RESP : STATE_WR;
        end
        SIATE_RESP: begin
            nxt_state = s_axi_intf.bready ? STATE_IDLE : SIATE_RESP;
        end
        STATE_RD  : begin
            nxt_state = ~|cnt & s_axi_intf.rready & s_axi_intf.rvalid ? STATE_IDLE : STATE_RD;
        end
    endcase
end

assign s_axi_intf.bid   = id_latch;
assign s_axi_intf.bresp = `AXI_RESP_OKAY;
assign s_axi_intf.rid   = id_latch;
assign s_axi_intf.rdata = rdata_latch_en ? rdata_latch : m_do;
assign s_axi_intf.rresp = `AXI_RESP_OKAY;
assign s_axi_intf.rlast = ~|cnt;
assign m_addr  = addr_latch;
assign m_byte  = s_axi_intf.wstrb;
assign m_di    = s_axi_intf.wdata;

always_comb begin
    s_axi_intf.awready = 1'b0;
    s_axi_intf.wready  = 1'b0;
    s_axi_intf.bvalid  = 1'b0;
    s_axi_intf.arready = 1'b0;
    s_axi_intf.rvalid  = 1'b0;
    m_cs      = 1'b0;
    m_we      = 1'b0;
    id_upd    = 1'b0;
    cnt_upd   = 1'b0;
    addr_upd  = 1'b0;
    size_upd  = 1'b0;
    cnt_nxt   = 1'b0;
    addr_nxt  = 1'b0;
    case (cur_state)
        STATE_IDLE: begin
            s_axi_intf.awready = ~s_axi_intf.arvalid;
            s_axi_intf.arready = 1'b1;
            id_upd    = s_axi_intf.arvalid | s_axi_intf.awvalid;
            cnt_upd   = s_axi_intf.arvalid | s_axi_intf.awvalid;
            addr_upd  = s_axi_intf.arvalid | s_axi_intf.awvalid;
            size_upd  = s_axi_intf.arvalid | s_axi_intf.awvalid;
        end
        STATE_WR  : begin
            s_axi_intf.wready = ~m_busy;
            m_cs     = ~m_busy & s_axi_intf.wvalid;
            m_we     = 1'b1;
            cnt_nxt  = ~m_busy & s_axi_intf.wvalid;
            addr_nxt = ~m_busy & s_axi_intf.wvalid;
        end
        SIATE_RESP: begin
            s_axi_intf.bvalid = 1'b1;
        end
        STATE_RD  : begin
            s_axi_intf.rvalid = (~m_busy & req_latch) | rdata_latch_en;
            m_cs     = ~m_busy & ~(s_axi_intf.rlast & req_latch) & rsend_latch & ~rdata_latch_en;
            cnt_nxt  = ((~m_busy & req_latch) | rdata_latch_en) & s_axi_intf.rready;
            addr_nxt = ~m_busy/* & req_latch*/ & s_axi_intf.rready;
        end
    endcase
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        rsend_latch <= 1'b1;
    end
    else begin
        if (cur_state == STATE_RD) begin
            rsend_latch <= addr_nxt;
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        req_latch   <= 1'b0;
    end
    else begin
        if (cur_state == STATE_RD) begin
            if (~m_busy) req_latch <= m_cs;
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        rdata_latch_en <= 1'b0;
    end
    else begin
        if (cur_state == STATE_RD) begin
            if (s_axi_intf.rvalid & s_axi_intf.rready) begin
                rdata_latch_en <= 1'b0;
            end
            else if (req_latch & ~m_busy) begin
                rdata_latch_en <= 1'b1;
            end
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        rdata_latch <= 32'b0;
    end
    else begin
        if (cur_state == STATE_RD) begin
            if (req_latch & ~m_busy) begin
                rdata_latch <= m_do;
            end
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        id_latch <= 13'b0;
    end
    else begin
        if (id_upd) begin
            id_latch <= s_axi_intf.arvalid ? s_axi_intf.arid : s_axi_intf.awid;
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        cnt <= 8'b0;
    end
    else begin
        if (cnt_upd) begin
            cnt <= s_axi_intf.arvalid ? s_axi_intf.arlen : s_axi_intf.awlen;
        end
        else if (cnt_nxt) begin
            cnt <= cnt - 8'b1;
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        addr_mask_latch <= 32'b0;
    end
    else begin
        if (addr_upd) begin
            if (s_axi_intf.arvalid) begin
                case (s_axi_intf.arburst)
                    `AXI_BURST_FIXED: begin
                        addr_mask_latch <= ~32'b0;
                    end
                    `AXI_BURST_INCR : begin
                        addr_mask_latch <= 32'b0;
                    end
                    `AXI_BURST_WRAP : begin
                        addr_mask_latch <= ~((({{(32-8){1'b0}}, s_axi_intf.arlen} + 32'b1) << s_axi_intf.arsize) - 32'b1);
                    end
                endcase
            end
            else begin
            end
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        addr_latch <= 32'b0;
    end
    else begin
        if (addr_upd) begin
            addr_latch <= s_axi_intf.arvalid ? s_axi_intf.araddr : s_axi_intf.awaddr;
        end
        else if (addr_nxt) begin
            addr_latch <= (addr_latch & addr_mask_latch) | ((addr_latch + (32'b1 << size_latch)) & ~addr_mask_latch);
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        size_latch <= 3'b0;
    end
    else begin
        if (id_upd) begin
            size_latch <= s_axi_intf.arvalid ? s_axi_intf.arsize : s_axi_intf.awsize;
        end
    end
end



endmodule

/*--------------------------------------*/
// FILE: ../src/bus/axi2apb_bridge.sv
/*--------------------------------------*/

`ifndef __AXI_DEFINE__
`define __AXI_DEFINE__

`define AXI_BURST_FIXED 2'b00
`define AXI_BURST_INCR  2'b01
`define AXI_BURST_WRAP  2'b10

`define AXI_RESP_OKAY   2'b00
`define AXI_RESP_EXOKAY 2'b01
`define AXI_RESP_SLVERR 2'b10
`define AXI_RESP_DECERR 2'b11

`endif

module axi2apb_bridge (
    input                  aclk,
    input                  aresetn,
    // AXI slave port
    axi_intf.slave         s_axi_intf,

    // APB master port
    apb_intf.master        m_apb_intf
);

parameter [2:0] STATE_IDLE  = 3'b000,
                STATE_WR    = 3'b001,
                SIATE_BRESP = 3'b010,
                STATE_RD    = 3'b011,
                STATE_RRESP = 3'b100;

logic [  2: 0] cur_state;
logic [  2: 0] nxt_state;

logic [ 12: 0] id_latch;
logic [  7: 0] cnt;
logic [ 31: 0] addr_latch;
logic [ 31: 0] addr_mask_latch;
logic [  2: 0] size_latch;
logic          id_upd;
logic          cnt_upd;
logic          addr_upd;
logic          size_upd;
logic          cnt_nxt;
logic          addr_nxt;
logic [ 31: 0] rdata_latch;
logic [  1: 0] resp_latch;


always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        cur_state <= STATE_IDLE;
    end
    else begin
        cur_state <= nxt_state;
    end
end

always_comb begin
    nxt_state = cur_state;
    case (cur_state)
        STATE_IDLE: begin
            nxt_state = s_axi_intf.arvalid ? STATE_RD:
                        s_axi_intf.awvalid ? STATE_WR:
                                             STATE_IDLE;
        end
        STATE_WR  : begin
            nxt_state = ~|cnt & s_axi_intf.wvalid & s_axi_intf.wready ? SIATE_BRESP : STATE_WR;
        end
        SIATE_BRESP: begin
            nxt_state = s_axi_intf.bready ? STATE_IDLE : SIATE_BRESP;
        end
        STATE_RD  : begin
            nxt_state = m_apb_intf.penable & m_apb_intf.pready ? STATE_RRESP : STATE_RD;
        end
        STATE_RRESP: begin
            nxt_state = ~|cnt & s_axi_intf.rready ? STATE_IDLE:
                        s_axi_intf.rready         ? STATE_RD:
                                                    STATE_RRESP;
        end
    endcase
end

assign s_axi_intf.bid     = id_latch;
assign s_axi_intf.bresp   = resp_latch;
assign s_axi_intf.rid     = id_latch;
assign s_axi_intf.rdata   = rdata_latch;
assign s_axi_intf.rresp   = resp_latch;
assign s_axi_intf.rlast   = ~|cnt;
assign m_apb_intf.paddr   = addr_latch;
assign m_apb_intf.pstrb   = s_axi_intf.wstrb;
assign m_apb_intf.pprot   = 3'b0;
assign m_apb_intf.pwdata  = s_axi_intf.wdata;



always_comb begin
    s_axi_intf.awready = 1'b0;
    s_axi_intf.wready  = 1'b0;
    s_axi_intf.bvalid  = 1'b0;
    s_axi_intf.arready = 1'b0;
    s_axi_intf.rvalid  = 1'b0;
    m_apb_intf.psel    = 1'b0;
    m_apb_intf.pwrite  = 1'b0;
    id_upd             = 1'b0;
    cnt_upd            = 1'b0;
    addr_upd           = 1'b0;
    size_upd           = 1'b0;
    cnt_nxt            = 1'b0;
    addr_nxt           = 1'b0;
    case (cur_state)
        STATE_IDLE: begin
            s_axi_intf.awready = ~s_axi_intf.arvalid;
            s_axi_intf.arready = 1'b1;
            id_upd             = s_axi_intf.arvalid | s_axi_intf.awvalid;
            cnt_upd            = s_axi_intf.arvalid | s_axi_intf.awvalid;
            addr_upd           = s_axi_intf.arvalid | s_axi_intf.awvalid;
            size_upd           = s_axi_intf.arvalid | s_axi_intf.awvalid;
        end
        STATE_WR  : begin
            m_apb_intf.psel    = s_axi_intf.wvalid;
            m_apb_intf.pwrite  = 1'b1;
            s_axi_intf.wready  = m_apb_intf.pready & m_apb_intf.penable;
            cnt_nxt            = m_apb_intf.pready & m_apb_intf.penable & s_axi_intf.wvalid;
            addr_nxt           = m_apb_intf.pready & m_apb_intf.penable & s_axi_intf.wvalid;
        end
        SIATE_BRESP: begin
            s_axi_intf.bvalid  = 1'b1;
        end
        STATE_RD  : begin
            m_apb_intf.psel    = 1'b1;
        end
        STATE_RRESP: begin
            s_axi_intf.rvalid  = 1'b1;
            cnt_nxt            = s_axi_intf.rready;
            addr_nxt           = s_axi_intf.rready;
        end
    endcase
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        resp_latch <= 2'b0;
    end
    else begin
        if (m_apb_intf.pready & m_apb_intf.penable & m_apb_intf.pslverr) begin
            resp_latch <= `AXI_RESP_SLVERR;
        end
        else if ((s_axi_intf.bready & s_axi_intf.bvalid) | (s_axi_intf.rready & s_axi_intf.rvalid)) begin
            resp_latch <= `AXI_RESP_OKAY;
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        m_apb_intf.penable <= 1'b0;
    end
    else begin
        if (m_apb_intf.pready & m_apb_intf.penable) begin
            m_apb_intf.penable <= 1'b0;
        end
        else if (m_apb_intf.psel) begin
            m_apb_intf.penable <= 1'b1;
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        rdata_latch <= 32'b0;
    end
    else begin
        if (cur_state == STATE_RD) begin
            if (m_apb_intf.pready & m_apb_intf.penable) begin
                rdata_latch <= m_apb_intf.prdata;
            end
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        id_latch <= 13'b0;
    end
    else begin
        if (id_upd) begin
            id_latch <= s_axi_intf.arvalid ? s_axi_intf.arid : s_axi_intf.awid;
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        cnt <= 8'b0;
    end
    else begin
        if (cnt_upd) begin
            cnt <= s_axi_intf.arvalid ? s_axi_intf.arlen : s_axi_intf.awlen;
        end
        else if (cnt_nxt) begin
            cnt <= cnt - 8'b1;
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        addr_mask_latch <= 32'b0;
    end
    else begin
        if (addr_upd) begin
            if (s_axi_intf.arvalid) begin
                case (s_axi_intf.arburst)
                    `AXI_BURST_FIXED: begin
                        addr_mask_latch <= ~32'b0;
                    end
                    `AXI_BURST_INCR : begin
                        addr_mask_latch <= 32'b0;
                    end
                    `AXI_BURST_WRAP : begin
                        addr_mask_latch <= ~((({{(32-8){1'b0}}, s_axi_intf.arlen} + 32'b1) << s_axi_intf.arsize) - 32'b1);
                    end
                endcase
            end
            else begin
            end
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        addr_latch <= 32'b0;
    end
    else begin
        if (addr_upd) begin
            addr_latch <= s_axi_intf.arvalid ? s_axi_intf.araddr : s_axi_intf.awaddr;
        end
        else if (addr_nxt) begin
            addr_latch <= (addr_latch & addr_mask_latch) | ((addr_latch + (32'b1 << size_latch)) & ~addr_mask_latch);
        end
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        size_latch <= 3'b0;
    end
    else begin
        if (id_upd) begin
            size_latch <= s_axi_intf.arvalid ? s_axi_intf.arsize : s_axi_intf.awsize;
        end
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/axi_5to5_biu.sv
/*--------------------------------------*/

/*-----------------------------------------------------*/
// axi_5to5_biu.sv is generated by ../../script/gen_axi_biu.sh
//
//                                         2023-03-24
//                                           00:30:46
/*-----------------------------------------------------*/

module axi_5to5_biu (
    input                  aclk,
    input                  aresetn,
    input         [  1: 0] s0_awburst,
    input         [  2: 0] s0_awprot,
    input         [  9: 0] s0_awid,
    input         [  3: 0] s0_awcache,
    input         [ 31: 0] s0_awaddr,
    input         [  2: 0] s0_awsize,
    input         [  1: 0] s0_awlock,
    input         [  7: 0] s0_awlen,
    input                  s0_awvalid,
    output logic           s0_awready,
    input         [  3: 0] s0_wstrb,
    input         [  9: 0] s0_wid,
    input         [ 31: 0] s0_wdata,
    input                  s0_wlast,
    input                  s0_wvalid,
    output logic           s0_wready,
    output logic  [  9: 0] s0_bid,
    output logic  [  1: 0] s0_bresp,
    output logic           s0_bvalid,
    input                  s0_bready,
    input         [ 31: 0] s0_araddr,
    input         [  1: 0] s0_arburst,
    input         [  2: 0] s0_arprot,
    input         [  3: 0] s0_arcache,
    input         [  2: 0] s0_arsize,
    input         [  9: 0] s0_arid,
    input         [  1: 0] s0_arlock,
    input         [  7: 0] s0_arlen,
    input                  s0_arvalid,
    output logic           s0_arready,
    output logic  [ 31: 0] s0_rdata,
    output logic  [  1: 0] s0_rresp,
    output logic  [  9: 0] s0_rid,
    output logic           s0_rlast,
    output logic           s0_rvalid,
    input                  s0_rready,
    input         [  1: 0] s1_awburst,
    input         [  2: 0] s1_awprot,
    input         [  9: 0] s1_awid,
    input         [  3: 0] s1_awcache,
    input         [ 31: 0] s1_awaddr,
    input         [  2: 0] s1_awsize,
    input         [  1: 0] s1_awlock,
    input         [  7: 0] s1_awlen,
    input                  s1_awvalid,
    output logic           s1_awready,
    input         [  3: 0] s1_wstrb,
    input         [  9: 0] s1_wid,
    input         [ 31: 0] s1_wdata,
    input                  s1_wlast,
    input                  s1_wvalid,
    output logic           s1_wready,
    output logic  [  9: 0] s1_bid,
    output logic  [  1: 0] s1_bresp,
    output logic           s1_bvalid,
    input                  s1_bready,
    input         [ 31: 0] s1_araddr,
    input         [  1: 0] s1_arburst,
    input         [  2: 0] s1_arprot,
    input         [  3: 0] s1_arcache,
    input         [  2: 0] s1_arsize,
    input         [  9: 0] s1_arid,
    input         [  1: 0] s1_arlock,
    input         [  7: 0] s1_arlen,
    input                  s1_arvalid,
    output logic           s1_arready,
    output logic  [ 31: 0] s1_rdata,
    output logic  [  1: 0] s1_rresp,
    output logic  [  9: 0] s1_rid,
    output logic           s1_rlast,
    output logic           s1_rvalid,
    input                  s1_rready,
    input         [  1: 0] s2_awburst,
    input         [  2: 0] s2_awprot,
    input         [  9: 0] s2_awid,
    input         [  3: 0] s2_awcache,
    input         [ 31: 0] s2_awaddr,
    input         [  2: 0] s2_awsize,
    input         [  1: 0] s2_awlock,
    input         [  7: 0] s2_awlen,
    input                  s2_awvalid,
    output logic           s2_awready,
    input         [  3: 0] s2_wstrb,
    input         [  9: 0] s2_wid,
    input         [ 31: 0] s2_wdata,
    input                  s2_wlast,
    input                  s2_wvalid,
    output logic           s2_wready,
    output logic  [  9: 0] s2_bid,
    output logic  [  1: 0] s2_bresp,
    output logic           s2_bvalid,
    input                  s2_bready,
    input         [ 31: 0] s2_araddr,
    input         [  1: 0] s2_arburst,
    input         [  2: 0] s2_arprot,
    input         [  3: 0] s2_arcache,
    input         [  2: 0] s2_arsize,
    input         [  9: 0] s2_arid,
    input         [  1: 0] s2_arlock,
    input         [  7: 0] s2_arlen,
    input                  s2_arvalid,
    output logic           s2_arready,
    output logic  [ 31: 0] s2_rdata,
    output logic  [  1: 0] s2_rresp,
    output logic  [  9: 0] s2_rid,
    output logic           s2_rlast,
    output logic           s2_rvalid,
    input                  s2_rready,
    input         [  1: 0] s3_awburst,
    input         [  2: 0] s3_awprot,
    input         [  9: 0] s3_awid,
    input         [  3: 0] s3_awcache,
    input         [ 31: 0] s3_awaddr,
    input         [  2: 0] s3_awsize,
    input         [  1: 0] s3_awlock,
    input         [  7: 0] s3_awlen,
    input                  s3_awvalid,
    output logic           s3_awready,
    input         [  3: 0] s3_wstrb,
    input         [  9: 0] s3_wid,
    input         [ 31: 0] s3_wdata,
    input                  s3_wlast,
    input                  s3_wvalid,
    output logic           s3_wready,
    output logic  [  9: 0] s3_bid,
    output logic  [  1: 0] s3_bresp,
    output logic           s3_bvalid,
    input                  s3_bready,
    input         [ 31: 0] s3_araddr,
    input         [  1: 0] s3_arburst,
    input         [  2: 0] s3_arprot,
    input         [  3: 0] s3_arcache,
    input         [  2: 0] s3_arsize,
    input         [  9: 0] s3_arid,
    input         [  1: 0] s3_arlock,
    input         [  7: 0] s3_arlen,
    input                  s3_arvalid,
    output logic           s3_arready,
    output logic  [ 31: 0] s3_rdata,
    output logic  [  1: 0] s3_rresp,
    output logic  [  9: 0] s3_rid,
    output logic           s3_rlast,
    output logic           s3_rvalid,
    input                  s3_rready,
    input         [  1: 0] s4_awburst,
    input         [  2: 0] s4_awprot,
    input         [  9: 0] s4_awid,
    input         [  3: 0] s4_awcache,
    input         [ 31: 0] s4_awaddr,
    input         [  2: 0] s4_awsize,
    input         [  1: 0] s4_awlock,
    input         [  7: 0] s4_awlen,
    input                  s4_awvalid,
    output logic           s4_awready,
    input         [  3: 0] s4_wstrb,
    input         [  9: 0] s4_wid,
    input         [ 31: 0] s4_wdata,
    input                  s4_wlast,
    input                  s4_wvalid,
    output logic           s4_wready,
    output logic  [  9: 0] s4_bid,
    output logic  [  1: 0] s4_bresp,
    output logic           s4_bvalid,
    input                  s4_bready,
    input         [ 31: 0] s4_araddr,
    input         [  1: 0] s4_arburst,
    input         [  2: 0] s4_arprot,
    input         [  3: 0] s4_arcache,
    input         [  2: 0] s4_arsize,
    input         [  9: 0] s4_arid,
    input         [  1: 0] s4_arlock,
    input         [  7: 0] s4_arlen,
    input                  s4_arvalid,
    output logic           s4_arready,
    output logic  [ 31: 0] s4_rdata,
    output logic  [  1: 0] s4_rresp,
    output logic  [  9: 0] s4_rid,
    output logic           s4_rlast,
    output logic           s4_rvalid,
    input                  s4_rready,
    output logic  [  1: 0] m0_awburst,
    output logic  [  2: 0] m0_awprot,
    output logic  [ 12: 0] m0_awid,
    output logic  [  3: 0] m0_awcache,
    output logic  [ 31: 0] m0_awaddr,
    output logic  [  2: 0] m0_awsize,
    output logic  [  1: 0] m0_awlock,
    output logic  [  7: 0] m0_awlen,
    output logic           m0_awvalid,
    input                  m0_awready,
    output logic  [  3: 0] m0_wstrb,
    output logic  [ 12: 0] m0_wid,
    output logic  [ 31: 0] m0_wdata,
    output logic           m0_wlast,
    output logic           m0_wvalid,
    input                  m0_wready,
    input         [ 12: 0] m0_bid,
    input         [  1: 0] m0_bresp,
    input                  m0_bvalid,
    output logic           m0_bready,
    output logic  [ 31: 0] m0_araddr,
    output logic  [  1: 0] m0_arburst,
    output logic  [  2: 0] m0_arprot,
    output logic  [  3: 0] m0_arcache,
    output logic  [  2: 0] m0_arsize,
    output logic  [ 12: 0] m0_arid,
    output logic  [  1: 0] m0_arlock,
    output logic  [  7: 0] m0_arlen,
    output logic           m0_arvalid,
    input                  m0_arready,
    input         [ 31: 0] m0_rdata,
    input         [  1: 0] m0_rresp,
    input         [ 12: 0] m0_rid,
    input                  m0_rlast,
    input                  m0_rvalid,
    output logic           m0_rready,
    output logic  [  1: 0] m1_awburst,
    output logic  [  2: 0] m1_awprot,
    output logic  [ 12: 0] m1_awid,
    output logic  [  3: 0] m1_awcache,
    output logic  [ 31: 0] m1_awaddr,
    output logic  [  2: 0] m1_awsize,
    output logic  [  1: 0] m1_awlock,
    output logic  [  7: 0] m1_awlen,
    output logic           m1_awvalid,
    input                  m1_awready,
    output logic  [  3: 0] m1_wstrb,
    output logic  [ 12: 0] m1_wid,
    output logic  [ 31: 0] m1_wdata,
    output logic           m1_wlast,
    output logic           m1_wvalid,
    input                  m1_wready,
    input         [ 12: 0] m1_bid,
    input         [  1: 0] m1_bresp,
    input                  m1_bvalid,
    output logic           m1_bready,
    output logic  [ 31: 0] m1_araddr,
    output logic  [  1: 0] m1_arburst,
    output logic  [  2: 0] m1_arprot,
    output logic  [  3: 0] m1_arcache,
    output logic  [  2: 0] m1_arsize,
    output logic  [ 12: 0] m1_arid,
    output logic  [  1: 0] m1_arlock,
    output logic  [  7: 0] m1_arlen,
    output logic           m1_arvalid,
    input                  m1_arready,
    input         [ 31: 0] m1_rdata,
    input         [  1: 0] m1_rresp,
    input         [ 12: 0] m1_rid,
    input                  m1_rlast,
    input                  m1_rvalid,
    output logic           m1_rready,
    output logic  [  1: 0] m2_awburst,
    output logic  [  2: 0] m2_awprot,
    output logic  [ 12: 0] m2_awid,
    output logic  [  3: 0] m2_awcache,
    output logic  [ 31: 0] m2_awaddr,
    output logic  [  2: 0] m2_awsize,
    output logic  [  1: 0] m2_awlock,
    output logic  [  7: 0] m2_awlen,
    output logic           m2_awvalid,
    input                  m2_awready,
    output logic  [  3: 0] m2_wstrb,
    output logic  [ 12: 0] m2_wid,
    output logic  [ 31: 0] m2_wdata,
    output logic           m2_wlast,
    output logic           m2_wvalid,
    input                  m2_wready,
    input         [ 12: 0] m2_bid,
    input         [  1: 0] m2_bresp,
    input                  m2_bvalid,
    output logic           m2_bready,
    output logic  [ 31: 0] m2_araddr,
    output logic  [  1: 0] m2_arburst,
    output logic  [  2: 0] m2_arprot,
    output logic  [  3: 0] m2_arcache,
    output logic  [  2: 0] m2_arsize,
    output logic  [ 12: 0] m2_arid,
    output logic  [  1: 0] m2_arlock,
    output logic  [  7: 0] m2_arlen,
    output logic           m2_arvalid,
    input                  m2_arready,
    input         [ 31: 0] m2_rdata,
    input         [  1: 0] m2_rresp,
    input         [ 12: 0] m2_rid,
    input                  m2_rlast,
    input                  m2_rvalid,
    output logic           m2_rready,
    output logic  [  1: 0] m3_awburst,
    output logic  [  2: 0] m3_awprot,
    output logic  [ 12: 0] m3_awid,
    output logic  [  3: 0] m3_awcache,
    output logic  [ 31: 0] m3_awaddr,
    output logic  [  2: 0] m3_awsize,
    output logic  [  1: 0] m3_awlock,
    output logic  [  7: 0] m3_awlen,
    output logic           m3_awvalid,
    input                  m3_awready,
    output logic  [  3: 0] m3_wstrb,
    output logic  [ 12: 0] m3_wid,
    output logic  [ 31: 0] m3_wdata,
    output logic           m3_wlast,
    output logic           m3_wvalid,
    input                  m3_wready,
    input         [ 12: 0] m3_bid,
    input         [  1: 0] m3_bresp,
    input                  m3_bvalid,
    output logic           m3_bready,
    output logic  [ 31: 0] m3_araddr,
    output logic  [  1: 0] m3_arburst,
    output logic  [  2: 0] m3_arprot,
    output logic  [  3: 0] m3_arcache,
    output logic  [  2: 0] m3_arsize,
    output logic  [ 12: 0] m3_arid,
    output logic  [  1: 0] m3_arlock,
    output logic  [  7: 0] m3_arlen,
    output logic           m3_arvalid,
    input                  m3_arready,
    input         [ 31: 0] m3_rdata,
    input         [  1: 0] m3_rresp,
    input         [ 12: 0] m3_rid,
    input                  m3_rlast,
    input                  m3_rvalid,
    output logic           m3_rready,
    output logic  [  1: 0] m4_awburst,
    output logic  [  2: 0] m4_awprot,
    output logic  [ 12: 0] m4_awid,
    output logic  [  3: 0] m4_awcache,
    output logic  [ 31: 0] m4_awaddr,
    output logic  [  2: 0] m4_awsize,
    output logic  [  1: 0] m4_awlock,
    output logic  [  7: 0] m4_awlen,
    output logic           m4_awvalid,
    input                  m4_awready,
    output logic  [  3: 0] m4_wstrb,
    output logic  [ 12: 0] m4_wid,
    output logic  [ 31: 0] m4_wdata,
    output logic           m4_wlast,
    output logic           m4_wvalid,
    input                  m4_wready,
    input         [ 12: 0] m4_bid,
    input         [  1: 0] m4_bresp,
    input                  m4_bvalid,
    output logic           m4_bready,
    output logic  [ 31: 0] m4_araddr,
    output logic  [  1: 0] m4_arburst,
    output logic  [  2: 0] m4_arprot,
    output logic  [  3: 0] m4_arcache,
    output logic  [  2: 0] m4_arsize,
    output logic  [ 12: 0] m4_arid,
    output logic  [  1: 0] m4_arlock,
    output logic  [  7: 0] m4_arlen,
    output logic           m4_arvalid,
    input                  m4_arready,
    input         [ 31: 0] m4_rdata,
    input         [  1: 0] m4_rresp,
    input         [ 12: 0] m4_rid,
    input                  m4_rlast,
    input                  m4_rvalid,
    output logic           m4_rready
);

logic [  1: 0] i0_awburst;
logic [  2: 0] i0_awprot;
logic [ 12: 0] i0_awid;
logic [  3: 0] i0_awcache;
logic [ 31: 0] i0_awaddr;
logic [  2: 0] i0_awsize;
logic [  1: 0] i0_awlock;
logic [  7: 0] i0_awlen;
logic          i0_awvalid;
logic          i0_awready;
logic [  3: 0] i0_wstrb;
logic [ 12: 0] i0_wid;
logic [ 31: 0] i0_wdata;
logic          i0_wlast;
logic          i0_wvalid;
logic          i0_wready;
logic [ 12: 0] i0_bid;
logic [  1: 0] i0_bresp;
logic          i0_bvalid;
logic          i0_bready;
logic [ 31: 0] i0_araddr;
logic [  1: 0] i0_arburst;
logic [  2: 0] i0_arprot;
logic [  3: 0] i0_arcache;
logic [  2: 0] i0_arsize;
logic [ 12: 0] i0_arid;
logic [  1: 0] i0_arlock;
logic [  7: 0] i0_arlen;
logic          i0_arvalid;
logic          i0_arready;
logic [ 31: 0] i0_rdata;
logic [  1: 0] i0_rresp;
logic [ 12: 0] i0_rid;
logic          i0_rlast;
logic          i0_rvalid;
logic          i0_rready;
logic [  1: 0] i1_awburst;
logic [  2: 0] i1_awprot;
logic [ 12: 0] i1_awid;
logic [  3: 0] i1_awcache;
logic [ 31: 0] i1_awaddr;
logic [  2: 0] i1_awsize;
logic [  1: 0] i1_awlock;
logic [  7: 0] i1_awlen;
logic          i1_awvalid;
logic          i1_awready;
logic [  3: 0] i1_wstrb;
logic [ 12: 0] i1_wid;
logic [ 31: 0] i1_wdata;
logic          i1_wlast;
logic          i1_wvalid;
logic          i1_wready;
logic [ 12: 0] i1_bid;
logic [  1: 0] i1_bresp;
logic          i1_bvalid;
logic          i1_bready;
logic [ 31: 0] i1_araddr;
logic [  1: 0] i1_arburst;
logic [  2: 0] i1_arprot;
logic [  3: 0] i1_arcache;
logic [  2: 0] i1_arsize;
logic [ 12: 0] i1_arid;
logic [  1: 0] i1_arlock;
logic [  7: 0] i1_arlen;
logic          i1_arvalid;
logic          i1_arready;
logic [ 31: 0] i1_rdata;
logic [  1: 0] i1_rresp;
logic [ 12: 0] i1_rid;
logic          i1_rlast;
logic          i1_rvalid;
logic          i1_rready;

axi_5to1_mux u_mux (
    .aclk          ( aclk       ),
    .aresetn       ( aresetn    ),
    .s0_awburst    ( s0_awburst ),
    .s0_awprot     ( s0_awprot  ),
    .s0_awid       ( s0_awid    ),
    .s0_awcache    ( s0_awcache ),
    .s0_awaddr     ( s0_awaddr  ),
    .s0_awsize     ( s0_awsize  ),
    .s0_awlock     ( s0_awlock  ),
    .s0_awlen      ( s0_awlen   ),
    .s0_awvalid    ( s0_awvalid ),
    .s0_awready    ( s0_awready ),
    .s0_wstrb      ( s0_wstrb   ),
    .s0_wid        ( s0_wid     ),
    .s0_wdata      ( s0_wdata   ),
    .s0_wlast      ( s0_wlast   ),
    .s0_wvalid     ( s0_wvalid  ),
    .s0_wready     ( s0_wready  ),
    .s0_bid        ( s0_bid     ),
    .s0_bresp      ( s0_bresp   ),
    .s0_bvalid     ( s0_bvalid  ),
    .s0_bready     ( s0_bready  ),
    .s0_araddr     ( s0_araddr  ),
    .s0_arburst    ( s0_arburst ),
    .s0_arprot     ( s0_arprot  ),
    .s0_arcache    ( s0_arcache ),
    .s0_arsize     ( s0_arsize  ),
    .s0_arid       ( s0_arid    ),
    .s0_arlock     ( s0_arlock  ),
    .s0_arlen      ( s0_arlen   ),
    .s0_arvalid    ( s0_arvalid ),
    .s0_arready    ( s0_arready ),
    .s0_rdata      ( s0_rdata   ),
    .s0_rresp      ( s0_rresp   ),
    .s0_rid        ( s0_rid     ),
    .s0_rlast      ( s0_rlast   ),
    .s0_rvalid     ( s0_rvalid  ),
    .s0_rready     ( s0_rready  ),
    .s1_awburst    ( s1_awburst ),
    .s1_awprot     ( s1_awprot  ),
    .s1_awid       ( s1_awid    ),
    .s1_awcache    ( s1_awcache ),
    .s1_awaddr     ( s1_awaddr  ),
    .s1_awsize     ( s1_awsize  ),
    .s1_awlock     ( s1_awlock  ),
    .s1_awlen      ( s1_awlen   ),
    .s1_awvalid    ( s1_awvalid ),
    .s1_awready    ( s1_awready ),
    .s1_wstrb      ( s1_wstrb   ),
    .s1_wid        ( s1_wid     ),
    .s1_wdata      ( s1_wdata   ),
    .s1_wlast      ( s1_wlast   ),
    .s1_wvalid     ( s1_wvalid  ),
    .s1_wready     ( s1_wready  ),
    .s1_bid        ( s1_bid     ),
    .s1_bresp      ( s1_bresp   ),
    .s1_bvalid     ( s1_bvalid  ),
    .s1_bready     ( s1_bready  ),
    .s1_araddr     ( s1_araddr  ),
    .s1_arburst    ( s1_arburst ),
    .s1_arprot     ( s1_arprot  ),
    .s1_arcache    ( s1_arcache ),
    .s1_arsize     ( s1_arsize  ),
    .s1_arid       ( s1_arid    ),
    .s1_arlock     ( s1_arlock  ),
    .s1_arlen      ( s1_arlen   ),
    .s1_arvalid    ( s1_arvalid ),
    .s1_arready    ( s1_arready ),
    .s1_rdata      ( s1_rdata   ),
    .s1_rresp      ( s1_rresp   ),
    .s1_rid        ( s1_rid     ),
    .s1_rlast      ( s1_rlast   ),
    .s1_rvalid     ( s1_rvalid  ),
    .s1_rready     ( s1_rready  ),
    .s2_awburst    ( s2_awburst ),
    .s2_awprot     ( s2_awprot  ),
    .s2_awid       ( s2_awid    ),
    .s2_awcache    ( s2_awcache ),
    .s2_awaddr     ( s2_awaddr  ),
    .s2_awsize     ( s2_awsize  ),
    .s2_awlock     ( s2_awlock  ),
    .s2_awlen      ( s2_awlen   ),
    .s2_awvalid    ( s2_awvalid ),
    .s2_awready    ( s2_awready ),
    .s2_wstrb      ( s2_wstrb   ),
    .s2_wid        ( s2_wid     ),
    .s2_wdata      ( s2_wdata   ),
    .s2_wlast      ( s2_wlast   ),
    .s2_wvalid     ( s2_wvalid  ),
    .s2_wready     ( s2_wready  ),
    .s2_bid        ( s2_bid     ),
    .s2_bresp      ( s2_bresp   ),
    .s2_bvalid     ( s2_bvalid  ),
    .s2_bready     ( s2_bready  ),
    .s2_araddr     ( s2_araddr  ),
    .s2_arburst    ( s2_arburst ),
    .s2_arprot     ( s2_arprot  ),
    .s2_arcache    ( s2_arcache ),
    .s2_arsize     ( s2_arsize  ),
    .s2_arid       ( s2_arid    ),
    .s2_arlock     ( s2_arlock  ),
    .s2_arlen      ( s2_arlen   ),
    .s2_arvalid    ( s2_arvalid ),
    .s2_arready    ( s2_arready ),
    .s2_rdata      ( s2_rdata   ),
    .s2_rresp      ( s2_rresp   ),
    .s2_rid        ( s2_rid     ),
    .s2_rlast      ( s2_rlast   ),
    .s2_rvalid     ( s2_rvalid  ),
    .s2_rready     ( s2_rready  ),
    .s3_awburst    ( s3_awburst ),
    .s3_awprot     ( s3_awprot  ),
    .s3_awid       ( s3_awid    ),
    .s3_awcache    ( s3_awcache ),
    .s3_awaddr     ( s3_awaddr  ),
    .s3_awsize     ( s3_awsize  ),
    .s3_awlock     ( s3_awlock  ),
    .s3_awlen      ( s3_awlen   ),
    .s3_awvalid    ( s3_awvalid ),
    .s3_awready    ( s3_awready ),
    .s3_wstrb      ( s3_wstrb   ),
    .s3_wid        ( s3_wid     ),
    .s3_wdata      ( s3_wdata   ),
    .s3_wlast      ( s3_wlast   ),
    .s3_wvalid     ( s3_wvalid  ),
    .s3_wready     ( s3_wready  ),
    .s3_bid        ( s3_bid     ),
    .s3_bresp      ( s3_bresp   ),
    .s3_bvalid     ( s3_bvalid  ),
    .s3_bready     ( s3_bready  ),
    .s3_araddr     ( s3_araddr  ),
    .s3_arburst    ( s3_arburst ),
    .s3_arprot     ( s3_arprot  ),
    .s3_arcache    ( s3_arcache ),
    .s3_arsize     ( s3_arsize  ),
    .s3_arid       ( s3_arid    ),
    .s3_arlock     ( s3_arlock  ),
    .s3_arlen      ( s3_arlen   ),
    .s3_arvalid    ( s3_arvalid ),
    .s3_arready    ( s3_arready ),
    .s3_rdata      ( s3_rdata   ),
    .s3_rresp      ( s3_rresp   ),
    .s3_rid        ( s3_rid     ),
    .s3_rlast      ( s3_rlast   ),
    .s3_rvalid     ( s3_rvalid  ),
    .s3_rready     ( s3_rready  ),
    .s4_awburst    ( s4_awburst ),
    .s4_awprot     ( s4_awprot  ),
    .s4_awid       ( s4_awid    ),
    .s4_awcache    ( s4_awcache ),
    .s4_awaddr     ( s4_awaddr  ),
    .s4_awsize     ( s4_awsize  ),
    .s4_awlock     ( s4_awlock  ),
    .s4_awlen      ( s4_awlen   ),
    .s4_awvalid    ( s4_awvalid ),
    .s4_awready    ( s4_awready ),
    .s4_wstrb      ( s4_wstrb   ),
    .s4_wid        ( s4_wid     ),
    .s4_wdata      ( s4_wdata   ),
    .s4_wlast      ( s4_wlast   ),
    .s4_wvalid     ( s4_wvalid  ),
    .s4_wready     ( s4_wready  ),
    .s4_bid        ( s4_bid     ),
    .s4_bresp      ( s4_bresp   ),
    .s4_bvalid     ( s4_bvalid  ),
    .s4_bready     ( s4_bready  ),
    .s4_araddr     ( s4_araddr  ),
    .s4_arburst    ( s4_arburst ),
    .s4_arprot     ( s4_arprot  ),
    .s4_arcache    ( s4_arcache ),
    .s4_arsize     ( s4_arsize  ),
    .s4_arid       ( s4_arid    ),
    .s4_arlock     ( s4_arlock  ),
    .s4_arlen      ( s4_arlen   ),
    .s4_arvalid    ( s4_arvalid ),
    .s4_arready    ( s4_arready ),
    .s4_rdata      ( s4_rdata   ),
    .s4_rresp      ( s4_rresp   ),
    .s4_rid        ( s4_rid     ),
    .s4_rlast      ( s4_rlast   ),
    .s4_rvalid     ( s4_rvalid  ),
    .s4_rready     ( s4_rready  ),
    .m_awburst     ( i0_awburst ),
    .m_awprot      ( i0_awprot  ),
    .m_awid        ( i0_awid    ),
    .m_awcache     ( i0_awcache ),
    .m_awaddr      ( i0_awaddr  ),
    .m_awsize      ( i0_awsize  ),
    .m_awlock      ( i0_awlock  ),
    .m_awlen       ( i0_awlen   ),
    .m_awvalid     ( i0_awvalid ),
    .m_awready     ( i0_awready ),
    .m_wstrb       ( i0_wstrb   ),
    .m_wid         ( i0_wid     ),
    .m_wdata       ( i0_wdata   ),
    .m_wlast       ( i0_wlast   ),
    .m_wvalid      ( i0_wvalid  ),
    .m_wready      ( i0_wready  ),
    .m_bid         ( i0_bid     ),
    .m_bresp       ( i0_bresp   ),
    .m_bvalid      ( i0_bvalid  ),
    .m_bready      ( i0_bready  ),
    .m_araddr      ( i0_araddr  ),
    .m_arburst     ( i0_arburst ),
    .m_arprot      ( i0_arprot  ),
    .m_arcache     ( i0_arcache ),
    .m_arsize      ( i0_arsize  ),
    .m_arid        ( i0_arid    ),
    .m_arlock      ( i0_arlock  ),
    .m_arlen       ( i0_arlen   ),
    .m_arvalid     ( i0_arvalid ),
    .m_arready     ( i0_arready ),
    .m_rdata       ( i0_rdata   ),
    .m_rresp       ( i0_rresp   ),
    .m_rid         ( i0_rid     ),
    .m_rlast       ( i0_rlast   ),
    .m_rvalid      ( i0_rvalid  ),
    .m_rready      ( i0_rready  )
);

logic [ 66: 0] s_awpayload;
logic [ 49: 0] s_wpayload;
logic [ 14: 0] s_bpayload;
logic [ 66: 0] s_arpayload;
logic [ 47: 0] s_rpayload;
logic [ 66: 0] m_awpayload;
logic [ 49: 0] m_wpayload;
logic [ 14: 0] m_bpayload;
logic [ 66: 0] m_arpayload;
logic [ 47: 0] m_rpayload;

assign s_awpayload = {i0_awburst, i0_awprot, i0_awid, i0_awcache, i0_awaddr, i0_awsize, i0_awlock, i0_awlen};
assign s_wpayload  = {i0_wlast, i0_wstrb, i0_wid, i0_wdata};
assign {i0_bid, i0_bresp} = s_bpayload;
assign s_arpayload = {i0_araddr, i0_arburst, i0_arprot, i0_arcache, i0_arsize, i0_arid, i0_arlock, i0_arlen};
assign {i0_rlast, i0_rdata, i0_rresp, i0_rid} = s_rpayload;

assign {i1_awburst, i1_awprot, i1_awid, i1_awcache, i1_awaddr, i1_awsize, i1_awlock, i1_awlen} = m_awpayload;
assign {i1_wlast, i1_wstrb, i1_wid, i1_wdata} = m_wpayload;
assign m_bpayload = {i1_bid, i1_bresp};
assign {i1_araddr, i1_arburst, i1_arprot, i1_arcache, i1_arsize, i1_arid, i1_arlock, i1_arlen} = m_arpayload;
assign m_rpayload = {i1_rlast, i1_rdata, i1_rresp, i1_rid};

axi_slice u_axi_slice (
    .aclk          ( aclk       ),
    .aresetn       ( aresetn    ),
    .s_awpayload   ( s_awpayload ),
    .s_awvalid     ( i0_awvalid ),
    .s_awready     ( i0_awready ),
    .s_wpayload    ( s_wpayload ),
    .s_wvalid      ( i0_wvalid  ),
    .s_wready      ( i0_wready  ),
    .s_bpayload    ( s_bpayload ),
    .s_bvalid      ( i0_bvalid  ),
    .s_bready      ( i0_bready  ),
    .s_arpayload   ( s_arpayload ),
    .s_arvalid     ( i0_arvalid ),
    .s_arready     ( i0_arready ),
    .s_rpayload    ( s_rpayload ),
    .s_rvalid      ( i0_rvalid  ),
    .s_rready      ( i0_rready  ),
    .m_awpayload   ( m_awpayload ),
    .m_awvalid     ( i1_awvalid ),
    .m_awready     ( i1_awready ),
    .m_wpayload    ( m_wpayload ),
    .m_wvalid      ( i1_wvalid  ),
    .m_wready      ( i1_wready  ),
    .m_bpayload    ( m_bpayload ),
    .m_bvalid      ( i1_bvalid  ),
    .m_bready      ( i1_bready  ),
    .m_arpayload   ( m_arpayload ),
    .m_arvalid     ( i1_arvalid ),
    .m_arready     ( i1_arready ),
    .m_rpayload    ( m_rpayload ),
    .m_rvalid      ( i1_rvalid  ),
    .m_rready      ( i1_rready  )
);

axi_1to5_dec u_dec (
    .aclk          ( aclk       ),
    .aresetn       ( aresetn    ),
    .s_awburst     ( i1_awburst ),
    .s_awprot      ( i1_awprot  ),
    .s_awid        ( i1_awid    ),
    .s_awcache     ( i1_awcache ),
    .s_awaddr      ( i1_awaddr  ),
    .s_awsize      ( i1_awsize  ),
    .s_awlock      ( i1_awlock  ),
    .s_awlen       ( i1_awlen   ),
    .s_awvalid     ( i1_awvalid ),
    .s_awready     ( i1_awready ),
    .s_wstrb       ( i1_wstrb   ),
    .s_wid         ( i1_wid     ),
    .s_wdata       ( i1_wdata   ),
    .s_wlast       ( i1_wlast   ),
    .s_wvalid      ( i1_wvalid  ),
    .s_wready      ( i1_wready  ),
    .s_bid         ( i1_bid     ),
    .s_bresp       ( i1_bresp   ),
    .s_bvalid      ( i1_bvalid  ),
    .s_bready      ( i1_bready  ),
    .s_araddr      ( i1_araddr  ),
    .s_arburst     ( i1_arburst ),
    .s_arprot      ( i1_arprot  ),
    .s_arcache     ( i1_arcache ),
    .s_arsize      ( i1_arsize  ),
    .s_arid        ( i1_arid    ),
    .s_arlock      ( i1_arlock  ),
    .s_arlen       ( i1_arlen   ),
    .s_arvalid     ( i1_arvalid ),
    .s_arready     ( i1_arready ),
    .s_rdata       ( i1_rdata   ),
    .s_rresp       ( i1_rresp   ),
    .s_rid         ( i1_rid     ),
    .s_rlast       ( i1_rlast   ),
    .s_rvalid      ( i1_rvalid  ),
    .s_rready      ( i1_rready  ),
    .m0_awburst    ( m0_awburst ),
    .m0_awprot     ( m0_awprot  ),
    .m0_awid       ( m0_awid    ),
    .m0_awcache    ( m0_awcache ),
    .m0_awaddr     ( m0_awaddr  ),
    .m0_awsize     ( m0_awsize  ),
    .m0_awlock     ( m0_awlock  ),
    .m0_awlen      ( m0_awlen   ),
    .m0_awvalid    ( m0_awvalid ),
    .m0_awready    ( m0_awready ),
    .m0_wstrb      ( m0_wstrb   ),
    .m0_wid        ( m0_wid     ),
    .m0_wdata      ( m0_wdata   ),
    .m0_wlast      ( m0_wlast   ),
    .m0_wvalid     ( m0_wvalid  ),
    .m0_wready     ( m0_wready  ),
    .m0_bid        ( m0_bid     ),
    .m0_bresp      ( m0_bresp   ),
    .m0_bvalid     ( m0_bvalid  ),
    .m0_bready     ( m0_bready  ),
    .m0_araddr     ( m0_araddr  ),
    .m0_arburst    ( m0_arburst ),
    .m0_arprot     ( m0_arprot  ),
    .m0_arcache    ( m0_arcache ),
    .m0_arsize     ( m0_arsize  ),
    .m0_arid       ( m0_arid    ),
    .m0_arlock     ( m0_arlock  ),
    .m0_arlen      ( m0_arlen   ),
    .m0_arvalid    ( m0_arvalid ),
    .m0_arready    ( m0_arready ),
    .m0_rdata      ( m0_rdata   ),
    .m0_rresp      ( m0_rresp   ),
    .m0_rid        ( m0_rid     ),
    .m0_rlast      ( m0_rlast   ),
    .m0_rvalid     ( m0_rvalid  ),
    .m0_rready     ( m0_rready  ),
    .m1_awburst    ( m1_awburst ),
    .m1_awprot     ( m1_awprot  ),
    .m1_awid       ( m1_awid    ),
    .m1_awcache    ( m1_awcache ),
    .m1_awaddr     ( m1_awaddr  ),
    .m1_awsize     ( m1_awsize  ),
    .m1_awlock     ( m1_awlock  ),
    .m1_awlen      ( m1_awlen   ),
    .m1_awvalid    ( m1_awvalid ),
    .m1_awready    ( m1_awready ),
    .m1_wstrb      ( m1_wstrb   ),
    .m1_wid        ( m1_wid     ),
    .m1_wdata      ( m1_wdata   ),
    .m1_wlast      ( m1_wlast   ),
    .m1_wvalid     ( m1_wvalid  ),
    .m1_wready     ( m1_wready  ),
    .m1_bid        ( m1_bid     ),
    .m1_bresp      ( m1_bresp   ),
    .m1_bvalid     ( m1_bvalid  ),
    .m1_bready     ( m1_bready  ),
    .m1_araddr     ( m1_araddr  ),
    .m1_arburst    ( m1_arburst ),
    .m1_arprot     ( m1_arprot  ),
    .m1_arcache    ( m1_arcache ),
    .m1_arsize     ( m1_arsize  ),
    .m1_arid       ( m1_arid    ),
    .m1_arlock     ( m1_arlock  ),
    .m1_arlen      ( m1_arlen   ),
    .m1_arvalid    ( m1_arvalid ),
    .m1_arready    ( m1_arready ),
    .m1_rdata      ( m1_rdata   ),
    .m1_rresp      ( m1_rresp   ),
    .m1_rid        ( m1_rid     ),
    .m1_rlast      ( m1_rlast   ),
    .m1_rvalid     ( m1_rvalid  ),
    .m1_rready     ( m1_rready  ),
    .m2_awburst    ( m2_awburst ),
    .m2_awprot     ( m2_awprot  ),
    .m2_awid       ( m2_awid    ),
    .m2_awcache    ( m2_awcache ),
    .m2_awaddr     ( m2_awaddr  ),
    .m2_awsize     ( m2_awsize  ),
    .m2_awlock     ( m2_awlock  ),
    .m2_awlen      ( m2_awlen   ),
    .m2_awvalid    ( m2_awvalid ),
    .m2_awready    ( m2_awready ),
    .m2_wstrb      ( m2_wstrb   ),
    .m2_wid        ( m2_wid     ),
    .m2_wdata      ( m2_wdata   ),
    .m2_wlast      ( m2_wlast   ),
    .m2_wvalid     ( m2_wvalid  ),
    .m2_wready     ( m2_wready  ),
    .m2_bid        ( m2_bid     ),
    .m2_bresp      ( m2_bresp   ),
    .m2_bvalid     ( m2_bvalid  ),
    .m2_bready     ( m2_bready  ),
    .m2_araddr     ( m2_araddr  ),
    .m2_arburst    ( m2_arburst ),
    .m2_arprot     ( m2_arprot  ),
    .m2_arcache    ( m2_arcache ),
    .m2_arsize     ( m2_arsize  ),
    .m2_arid       ( m2_arid    ),
    .m2_arlock     ( m2_arlock  ),
    .m2_arlen      ( m2_arlen   ),
    .m2_arvalid    ( m2_arvalid ),
    .m2_arready    ( m2_arready ),
    .m2_rdata      ( m2_rdata   ),
    .m2_rresp      ( m2_rresp   ),
    .m2_rid        ( m2_rid     ),
    .m2_rlast      ( m2_rlast   ),
    .m2_rvalid     ( m2_rvalid  ),
    .m2_rready     ( m2_rready  ),
    .m3_awburst    ( m3_awburst ),
    .m3_awprot     ( m3_awprot  ),
    .m3_awid       ( m3_awid    ),
    .m3_awcache    ( m3_awcache ),
    .m3_awaddr     ( m3_awaddr  ),
    .m3_awsize     ( m3_awsize  ),
    .m3_awlock     ( m3_awlock  ),
    .m3_awlen      ( m3_awlen   ),
    .m3_awvalid    ( m3_awvalid ),
    .m3_awready    ( m3_awready ),
    .m3_wstrb      ( m3_wstrb   ),
    .m3_wid        ( m3_wid     ),
    .m3_wdata      ( m3_wdata   ),
    .m3_wlast      ( m3_wlast   ),
    .m3_wvalid     ( m3_wvalid  ),
    .m3_wready     ( m3_wready  ),
    .m3_bid        ( m3_bid     ),
    .m3_bresp      ( m3_bresp   ),
    .m3_bvalid     ( m3_bvalid  ),
    .m3_bready     ( m3_bready  ),
    .m3_araddr     ( m3_araddr  ),
    .m3_arburst    ( m3_arburst ),
    .m3_arprot     ( m3_arprot  ),
    .m3_arcache    ( m3_arcache ),
    .m3_arsize     ( m3_arsize  ),
    .m3_arid       ( m3_arid    ),
    .m3_arlock     ( m3_arlock  ),
    .m3_arlen      ( m3_arlen   ),
    .m3_arvalid    ( m3_arvalid ),
    .m3_arready    ( m3_arready ),
    .m3_rdata      ( m3_rdata   ),
    .m3_rresp      ( m3_rresp   ),
    .m3_rid        ( m3_rid     ),
    .m3_rlast      ( m3_rlast   ),
    .m3_rvalid     ( m3_rvalid  ),
    .m3_rready     ( m3_rready  ),
    .m4_awburst    ( m4_awburst ),
    .m4_awprot     ( m4_awprot  ),
    .m4_awid       ( m4_awid    ),
    .m4_awcache    ( m4_awcache ),
    .m4_awaddr     ( m4_awaddr  ),
    .m4_awsize     ( m4_awsize  ),
    .m4_awlock     ( m4_awlock  ),
    .m4_awlen      ( m4_awlen   ),
    .m4_awvalid    ( m4_awvalid ),
    .m4_awready    ( m4_awready ),
    .m4_wstrb      ( m4_wstrb   ),
    .m4_wid        ( m4_wid     ),
    .m4_wdata      ( m4_wdata   ),
    .m4_wlast      ( m4_wlast   ),
    .m4_wvalid     ( m4_wvalid  ),
    .m4_wready     ( m4_wready  ),
    .m4_bid        ( m4_bid     ),
    .m4_bresp      ( m4_bresp   ),
    .m4_bvalid     ( m4_bvalid  ),
    .m4_bready     ( m4_bready  ),
    .m4_araddr     ( m4_araddr  ),
    .m4_arburst    ( m4_arburst ),
    .m4_arprot     ( m4_arprot  ),
    .m4_arcache    ( m4_arcache ),
    .m4_arsize     ( m4_arsize  ),
    .m4_arid       ( m4_arid    ),
    .m4_arlock     ( m4_arlock  ),
    .m4_arlen      ( m4_arlen   ),
    .m4_arvalid    ( m4_arvalid ),
    .m4_arready    ( m4_arready ),
    .m4_rdata      ( m4_rdata   ),
    .m4_rresp      ( m4_rresp   ),
    .m4_rid        ( m4_rid     ),
    .m4_rlast      ( m4_rlast   ),
    .m4_rvalid     ( m4_rvalid  ),
    .m4_rready     ( m4_rready  )
);

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/axi_5to1_mux.sv
/*--------------------------------------*/

/*-----------------------------------------------------*/
// axi_5to1_mux.sv is generated by gen_axi_mux.sh
//
//                                         2023-03-24
//                                           00:30:43
/*-----------------------------------------------------*/

module axi_5to1_mux (
    input                  aclk,
    input                  aresetn,
    input         [  1: 0] s0_awburst,
    input         [  2: 0] s0_awprot,
    input         [  9: 0] s0_awid,
    input         [  3: 0] s0_awcache,
    input         [ 31: 0] s0_awaddr,
    input         [  2: 0] s0_awsize,
    input         [  1: 0] s0_awlock,
    input         [  7: 0] s0_awlen,
    input                  s0_awvalid,
    output logic           s0_awready,
    input         [  3: 0] s0_wstrb,
    input         [  9: 0] s0_wid,
    input         [ 31: 0] s0_wdata,
    input                  s0_wlast,
    input                  s0_wvalid,
    output logic           s0_wready,
    output logic  [  9: 0] s0_bid,
    output logic  [  1: 0] s0_bresp,
    output logic           s0_bvalid,
    input                  s0_bready,
    input         [ 31: 0] s0_araddr,
    input         [  1: 0] s0_arburst,
    input         [  2: 0] s0_arprot,
    input         [  3: 0] s0_arcache,
    input         [  2: 0] s0_arsize,
    input         [  9: 0] s0_arid,
    input         [  1: 0] s0_arlock,
    input         [  7: 0] s0_arlen,
    input                  s0_arvalid,
    output logic           s0_arready,
    output logic  [ 31: 0] s0_rdata,
    output logic  [  1: 0] s0_rresp,
    output logic  [  9: 0] s0_rid,
    output logic           s0_rlast,
    output logic           s0_rvalid,
    input                  s0_rready,
    input         [  1: 0] s1_awburst,
    input         [  2: 0] s1_awprot,
    input         [  9: 0] s1_awid,
    input         [  3: 0] s1_awcache,
    input         [ 31: 0] s1_awaddr,
    input         [  2: 0] s1_awsize,
    input         [  1: 0] s1_awlock,
    input         [  7: 0] s1_awlen,
    input                  s1_awvalid,
    output logic           s1_awready,
    input         [  3: 0] s1_wstrb,
    input         [  9: 0] s1_wid,
    input         [ 31: 0] s1_wdata,
    input                  s1_wlast,
    input                  s1_wvalid,
    output logic           s1_wready,
    output logic  [  9: 0] s1_bid,
    output logic  [  1: 0] s1_bresp,
    output logic           s1_bvalid,
    input                  s1_bready,
    input         [ 31: 0] s1_araddr,
    input         [  1: 0] s1_arburst,
    input         [  2: 0] s1_arprot,
    input         [  3: 0] s1_arcache,
    input         [  2: 0] s1_arsize,
    input         [  9: 0] s1_arid,
    input         [  1: 0] s1_arlock,
    input         [  7: 0] s1_arlen,
    input                  s1_arvalid,
    output logic           s1_arready,
    output logic  [ 31: 0] s1_rdata,
    output logic  [  1: 0] s1_rresp,
    output logic  [  9: 0] s1_rid,
    output logic           s1_rlast,
    output logic           s1_rvalid,
    input                  s1_rready,
    input         [  1: 0] s2_awburst,
    input         [  2: 0] s2_awprot,
    input         [  9: 0] s2_awid,
    input         [  3: 0] s2_awcache,
    input         [ 31: 0] s2_awaddr,
    input         [  2: 0] s2_awsize,
    input         [  1: 0] s2_awlock,
    input         [  7: 0] s2_awlen,
    input                  s2_awvalid,
    output logic           s2_awready,
    input         [  3: 0] s2_wstrb,
    input         [  9: 0] s2_wid,
    input         [ 31: 0] s2_wdata,
    input                  s2_wlast,
    input                  s2_wvalid,
    output logic           s2_wready,
    output logic  [  9: 0] s2_bid,
    output logic  [  1: 0] s2_bresp,
    output logic           s2_bvalid,
    input                  s2_bready,
    input         [ 31: 0] s2_araddr,
    input         [  1: 0] s2_arburst,
    input         [  2: 0] s2_arprot,
    input         [  3: 0] s2_arcache,
    input         [  2: 0] s2_arsize,
    input         [  9: 0] s2_arid,
    input         [  1: 0] s2_arlock,
    input         [  7: 0] s2_arlen,
    input                  s2_arvalid,
    output logic           s2_arready,
    output logic  [ 31: 0] s2_rdata,
    output logic  [  1: 0] s2_rresp,
    output logic  [  9: 0] s2_rid,
    output logic           s2_rlast,
    output logic           s2_rvalid,
    input                  s2_rready,
    input         [  1: 0] s3_awburst,
    input         [  2: 0] s3_awprot,
    input         [  9: 0] s3_awid,
    input         [  3: 0] s3_awcache,
    input         [ 31: 0] s3_awaddr,
    input         [  2: 0] s3_awsize,
    input         [  1: 0] s3_awlock,
    input         [  7: 0] s3_awlen,
    input                  s3_awvalid,
    output logic           s3_awready,
    input         [  3: 0] s3_wstrb,
    input         [  9: 0] s3_wid,
    input         [ 31: 0] s3_wdata,
    input                  s3_wlast,
    input                  s3_wvalid,
    output logic           s3_wready,
    output logic  [  9: 0] s3_bid,
    output logic  [  1: 0] s3_bresp,
    output logic           s3_bvalid,
    input                  s3_bready,
    input         [ 31: 0] s3_araddr,
    input         [  1: 0] s3_arburst,
    input         [  2: 0] s3_arprot,
    input         [  3: 0] s3_arcache,
    input         [  2: 0] s3_arsize,
    input         [  9: 0] s3_arid,
    input         [  1: 0] s3_arlock,
    input         [  7: 0] s3_arlen,
    input                  s3_arvalid,
    output logic           s3_arready,
    output logic  [ 31: 0] s3_rdata,
    output logic  [  1: 0] s3_rresp,
    output logic  [  9: 0] s3_rid,
    output logic           s3_rlast,
    output logic           s3_rvalid,
    input                  s3_rready,
    input         [  1: 0] s4_awburst,
    input         [  2: 0] s4_awprot,
    input         [  9: 0] s4_awid,
    input         [  3: 0] s4_awcache,
    input         [ 31: 0] s4_awaddr,
    input         [  2: 0] s4_awsize,
    input         [  1: 0] s4_awlock,
    input         [  7: 0] s4_awlen,
    input                  s4_awvalid,
    output logic           s4_awready,
    input         [  3: 0] s4_wstrb,
    input         [  9: 0] s4_wid,
    input         [ 31: 0] s4_wdata,
    input                  s4_wlast,
    input                  s4_wvalid,
    output logic           s4_wready,
    output logic  [  9: 0] s4_bid,
    output logic  [  1: 0] s4_bresp,
    output logic           s4_bvalid,
    input                  s4_bready,
    input         [ 31: 0] s4_araddr,
    input         [  1: 0] s4_arburst,
    input         [  2: 0] s4_arprot,
    input         [  3: 0] s4_arcache,
    input         [  2: 0] s4_arsize,
    input         [  9: 0] s4_arid,
    input         [  1: 0] s4_arlock,
    input         [  7: 0] s4_arlen,
    input                  s4_arvalid,
    output logic           s4_arready,
    output logic  [ 31: 0] s4_rdata,
    output logic  [  1: 0] s4_rresp,
    output logic  [  9: 0] s4_rid,
    output logic           s4_rlast,
    output logic           s4_rvalid,
    input                  s4_rready,
    output logic  [  1: 0] m_awburst,
    output logic  [  2: 0] m_awprot,
    output logic  [ 12: 0] m_awid,
    output logic  [  3: 0] m_awcache,
    output logic  [ 31: 0] m_awaddr,
    output logic  [  2: 0] m_awsize,
    output logic  [  1: 0] m_awlock,
    output logic  [  7: 0] m_awlen,
    output logic           m_awvalid,
    input                  m_awready,
    output logic  [  3: 0] m_wstrb,
    output logic  [ 12: 0] m_wid,
    output logic  [ 31: 0] m_wdata,
    output logic           m_wlast,
    output logic           m_wvalid,
    input                  m_wready,
    input         [ 12: 0] m_bid,
    input         [  1: 0] m_bresp,
    input                  m_bvalid,
    output logic           m_bready,
    output logic  [ 31: 0] m_araddr,
    output logic  [  1: 0] m_arburst,
    output logic  [  2: 0] m_arprot,
    output logic  [  3: 0] m_arcache,
    output logic  [  2: 0] m_arsize,
    output logic  [ 12: 0] m_arid,
    output logic  [  1: 0] m_arlock,
    output logic  [  7: 0] m_arlen,
    output logic           m_arvalid,
    input                  m_arready,
    input         [ 31: 0] m_rdata,
    input         [  1: 0] m_rresp,
    input         [ 12: 0] m_rid,
    input                  m_rlast,
    input                  m_rvalid,
    output logic           m_rready
);

logic [  1: 0] s_awburst  [0:   4];
logic [  2: 0] s_awprot   [0:   4];
logic [  9: 0] s_awid     [0:   4];
logic [  3: 0] s_awcache  [0:   4];
logic [ 31: 0] s_awaddr   [0:   4];
logic [  2: 0] s_awsize   [0:   4];
logic [  1: 0] s_awlock   [0:   4];
logic [  7: 0] s_awlen    [0:   4];
logic [  3: 0] s_wstrb    [0:   4];
logic [  9: 0] s_wid      [0:   4];
logic [ 31: 0] s_wdata    [0:   4];
logic [  9: 0] s_bid      [0:   4];
logic [  1: 0] s_bresp    [0:   4];
logic [ 31: 0] s_araddr   [0:   4];
logic [  1: 0] s_arburst  [0:   4];
logic [  2: 0] s_arprot   [0:   4];
logic [  3: 0] s_arcache  [0:   4];
logic [  2: 0] s_arsize   [0:   4];
logic [  9: 0] s_arid     [0:   4];
logic [  1: 0] s_arlock   [0:   4];
logic [  7: 0] s_arlen    [0:   4];
logic [ 31: 0] s_rdata    [0:   4];
logic [  1: 0] s_rresp    [0:   4];
logic [  9: 0] s_rid      [0:   4];

logic [  4: 0] s_arsel;
logic [  4: 0] s_awsel;
logic [  4: 0] s_wsel;

logic [  4: 0] s_arvalid;
logic [  4: 0] s_arready;
logic [  4: 0] s_rlast;
logic [  4: 0] s_rvalid;
logic [  4: 0] s_rready;
logic [  4: 0] s_awvalid;
logic [  4: 0] s_awready;
logic [  4: 0] s_wlast;
logic [  4: 0] s_wvalid;
logic [  4: 0] s_wready;
logic [  4: 0] s_bvalid;
logic [  4: 0] s_bready;

assign s_awburst [0] = s0_awburst;
assign s_awprot  [0] = s0_awprot;
assign s_awid    [0] = s0_awid;
assign s_awcache [0] = s0_awcache;
assign s_awaddr  [0] = s0_awaddr;
assign s_awsize  [0] = s0_awsize;
assign s_awlock  [0] = s0_awlock;
assign s_awlen   [0] = s0_awlen;
assign s_wstrb   [0] = s0_wstrb;
assign s_wid     [0] = s0_wid;
assign s_wdata   [0] = s0_wdata;
assign s_araddr  [0] = s0_araddr;
assign s_arburst [0] = s0_arburst;
assign s_arprot  [0] = s0_arprot;
assign s_arcache [0] = s0_arcache;
assign s_arsize  [0] = s0_arsize;
assign s_arid    [0] = s0_arid;
assign s_arlock  [0] = s0_arlock;
assign s_arlen   [0] = s0_arlen;
assign s_awburst [1] = s1_awburst;
assign s_awprot  [1] = s1_awprot;
assign s_awid    [1] = s1_awid;
assign s_awcache [1] = s1_awcache;
assign s_awaddr  [1] = s1_awaddr;
assign s_awsize  [1] = s1_awsize;
assign s_awlock  [1] = s1_awlock;
assign s_awlen   [1] = s1_awlen;
assign s_wstrb   [1] = s1_wstrb;
assign s_wid     [1] = s1_wid;
assign s_wdata   [1] = s1_wdata;
assign s_araddr  [1] = s1_araddr;
assign s_arburst [1] = s1_arburst;
assign s_arprot  [1] = s1_arprot;
assign s_arcache [1] = s1_arcache;
assign s_arsize  [1] = s1_arsize;
assign s_arid    [1] = s1_arid;
assign s_arlock  [1] = s1_arlock;
assign s_arlen   [1] = s1_arlen;
assign s_awburst [2] = s2_awburst;
assign s_awprot  [2] = s2_awprot;
assign s_awid    [2] = s2_awid;
assign s_awcache [2] = s2_awcache;
assign s_awaddr  [2] = s2_awaddr;
assign s_awsize  [2] = s2_awsize;
assign s_awlock  [2] = s2_awlock;
assign s_awlen   [2] = s2_awlen;
assign s_wstrb   [2] = s2_wstrb;
assign s_wid     [2] = s2_wid;
assign s_wdata   [2] = s2_wdata;
assign s_araddr  [2] = s2_araddr;
assign s_arburst [2] = s2_arburst;
assign s_arprot  [2] = s2_arprot;
assign s_arcache [2] = s2_arcache;
assign s_arsize  [2] = s2_arsize;
assign s_arid    [2] = s2_arid;
assign s_arlock  [2] = s2_arlock;
assign s_arlen   [2] = s2_arlen;
assign s_awburst [3] = s3_awburst;
assign s_awprot  [3] = s3_awprot;
assign s_awid    [3] = s3_awid;
assign s_awcache [3] = s3_awcache;
assign s_awaddr  [3] = s3_awaddr;
assign s_awsize  [3] = s3_awsize;
assign s_awlock  [3] = s3_awlock;
assign s_awlen   [3] = s3_awlen;
assign s_wstrb   [3] = s3_wstrb;
assign s_wid     [3] = s3_wid;
assign s_wdata   [3] = s3_wdata;
assign s_araddr  [3] = s3_araddr;
assign s_arburst [3] = s3_arburst;
assign s_arprot  [3] = s3_arprot;
assign s_arcache [3] = s3_arcache;
assign s_arsize  [3] = s3_arsize;
assign s_arid    [3] = s3_arid;
assign s_arlock  [3] = s3_arlock;
assign s_arlen   [3] = s3_arlen;
assign s_awburst [4] = s4_awburst;
assign s_awprot  [4] = s4_awprot;
assign s_awid    [4] = s4_awid;
assign s_awcache [4] = s4_awcache;
assign s_awaddr  [4] = s4_awaddr;
assign s_awsize  [4] = s4_awsize;
assign s_awlock  [4] = s4_awlock;
assign s_awlen   [4] = s4_awlen;
assign s_wstrb   [4] = s4_wstrb;
assign s_wid     [4] = s4_wid;
assign s_wdata   [4] = s4_wdata;
assign s_araddr  [4] = s4_araddr;
assign s_arburst [4] = s4_arburst;
assign s_arprot  [4] = s4_arprot;
assign s_arcache [4] = s4_arcache;
assign s_arsize  [4] = s4_arsize;
assign s_arid    [4] = s4_arid;
assign s_arlock  [4] = s4_arlock;
assign s_arlen   [4] = s4_arlen;

assign s0_bid     = s_bid     [0];
assign s0_bresp   = s_bresp   [0];
assign s0_rdata   = s_rdata   [0];
assign s0_rresp   = s_rresp   [0];
assign s0_rid     = s_rid     [0];
assign s1_bid     = s_bid     [1];
assign s1_bresp   = s_bresp   [1];
assign s1_rdata   = s_rdata   [1];
assign s1_rresp   = s_rresp   [1];
assign s1_rid     = s_rid     [1];
assign s2_bid     = s_bid     [2];
assign s2_bresp   = s_bresp   [2];
assign s2_rdata   = s_rdata   [2];
assign s2_rresp   = s_rresp   [2];
assign s2_rid     = s_rid     [2];
assign s3_bid     = s_bid     [3];
assign s3_bresp   = s_bresp   [3];
assign s3_rdata   = s_rdata   [3];
assign s3_rresp   = s_rresp   [3];
assign s3_rid     = s_rid     [3];
assign s4_bid     = s_bid     [4];
assign s4_bresp   = s_bresp   [4];
assign s4_rdata   = s_rdata   [4];
assign s4_rresp   = s_rresp   [4];
assign s4_rid     = s_rid     [4];

assign s_arvalid [0] = s0_arvalid;
assign s_awvalid [0] = s0_awvalid;
assign s_wvalid  [0] = s0_wvalid;
assign s_wlast   [0] = s0_wlast;
assign s_bready  [0] = s0_bready;
assign s_rready  [0] = s0_rready;
assign s_arvalid [1] = s1_arvalid;
assign s_awvalid [1] = s1_awvalid;
assign s_wvalid  [1] = s1_wvalid;
assign s_wlast   [1] = s1_wlast;
assign s_bready  [1] = s1_bready;
assign s_rready  [1] = s1_rready;
assign s_arvalid [2] = s2_arvalid;
assign s_awvalid [2] = s2_awvalid;
assign s_wvalid  [2] = s2_wvalid;
assign s_wlast   [2] = s2_wlast;
assign s_bready  [2] = s2_bready;
assign s_rready  [2] = s2_rready;
assign s_arvalid [3] = s3_arvalid;
assign s_awvalid [3] = s3_awvalid;
assign s_wvalid  [3] = s3_wvalid;
assign s_wlast   [3] = s3_wlast;
assign s_bready  [3] = s3_bready;
assign s_rready  [3] = s3_rready;
assign s_arvalid [4] = s4_arvalid;
assign s_awvalid [4] = s4_awvalid;
assign s_wvalid  [4] = s4_wvalid;
assign s_wlast   [4] = s4_wlast;
assign s_bready  [4] = s4_bready;
assign s_rready  [4] = s4_rready;

assign s0_arready = s_arready [0];
assign s0_awready = s_awready [0];
assign s0_wready  = s_wready  [0];
assign s0_bvalid  = s_bvalid  [0];
assign s0_rlast   = s_rlast   [0];
assign s0_rvalid  = s_rvalid  [0];
assign s1_arready = s_arready [1];
assign s1_awready = s_awready [1];
assign s1_wready  = s_wready  [1];
assign s1_bvalid  = s_bvalid  [1];
assign s1_rlast   = s_rlast   [1];
assign s1_rvalid  = s_rvalid  [1];
assign s2_arready = s_arready [2];
assign s2_awready = s_awready [2];
assign s2_wready  = s_wready  [2];
assign s2_bvalid  = s_bvalid  [2];
assign s2_rlast   = s_rlast   [2];
assign s2_rvalid  = s_rvalid  [2];
assign s3_arready = s_arready [3];
assign s3_awready = s_awready [3];
assign s3_wready  = s_wready  [3];
assign s3_bvalid  = s_bvalid  [3];
assign s3_rlast   = s_rlast   [3];
assign s3_rvalid  = s_rvalid  [3];
assign s4_arready = s_arready [4];
assign s4_awready = s_awready [4];
assign s4_wready  = s_wready  [4];
assign s4_bvalid  = s_bvalid  [4];
assign s4_rlast   = s_rlast   [4];
assign s4_rvalid  = s_rvalid  [4];

axi_arbitrator_5s u_axi_arbitrator (
    .aclk          ( aclk       ),
    .aresetn       ( aresetn    ),
    .s_arsel       ( s_arsel    ),
    .s_awsel       ( s_awsel    ),
    .s_wsel        ( s_wsel     ),
    .s_arvalid     ( s_arvalid  ),
    .s_arready     ( s_arready  ),
    .s_awvalid     ( s_awvalid  ),
    .s_awready     ( s_awready  ),
    .s_wlast       ( s_wlast    ),
    .s_wvalid      ( s_wvalid   ),
    .s_wready      ( s_wready   ),
    .m_arvalid     ( m_arvalid  ),
    .m_arready     ( m_arready  ),
    .m_awvalid     ( m_awvalid  ),
    .m_awready     ( m_awready  ),
    .m_wlast       ( m_wlast    ),
    .m_wvalid      ( m_wvalid   ),
    .m_wready      ( m_wready   )
);

always_comb begin
    integer i;

    m_awburst  = {          2{1'b0}};
    m_awprot   = {          3{1'b0}};
    m_awid     = {( 10 +   3){1'b0}};
    m_awcache  = {          4{1'b0}};
    m_awaddr   = {         32{1'b0}};
    m_awsize   = {          3{1'b0}};
    m_awlock   = {          2{1'b0}};
    m_awlen    = {          8{1'b0}};
    for (i = 0; i < 5; i = i + 1) begin
        m_awburst            = m_awburst        | ({  2{s_awsel[i]}} & s_awburst [i]);
        m_awprot             = m_awprot         | ({  3{s_awsel[i]}} & s_awprot  [i]);
        m_awid    [  0+:  3] = m_awid[  0+:  3] | ({  3{s_awsel[i]}} & i[0+:3]      );
        m_awid    [  3+: 10] = m_awid[  3+: 10] | ({ 10{s_awsel[i]}} & s_awid    [i]);
        m_awcache            = m_awcache        | ({  4{s_awsel[i]}} & s_awcache [i]);
        m_awaddr             = m_awaddr         | ({ 32{s_awsel[i]}} & s_awaddr  [i]);
        m_awsize             = m_awsize         | ({  3{s_awsel[i]}} & s_awsize  [i]);
        m_awlock             = m_awlock         | ({  2{s_awsel[i]}} & s_awlock  [i]);
        m_awlen              = m_awlen          | ({  8{s_awsel[i]}} & s_awlen   [i]);
    end

    m_wstrb    = {          4{1'b0}};
    m_wid      = {( 10 +   3){1'b0}};
    m_wdata    = {         32{1'b0}};
    for (i = 0; i < 5; i = i + 1) begin
        m_wstrb              = m_wstrb          | ({  4{s_wsel[i]}} & s_wstrb   [i]);
        m_wid     [  0+:  3] = m_wid [  0+:  3] | ({  3{s_wsel[i]}} & i[0+:3]      );
        m_wid     [  3+: 10] = m_wid [  3+: 10] | ({ 10{s_wsel[i]}} & s_wid     [i]);
        m_wdata              = m_wdata          | ({ 32{s_wsel[i]}} & s_wdata   [i]);
    end

    m_araddr   = {         32{1'b0}};
    m_arburst  = {          2{1'b0}};
    m_arprot   = {          3{1'b0}};
    m_arcache  = {          4{1'b0}};
    m_arsize   = {          3{1'b0}};
    m_arid     = {( 10 +   3){1'b0}};
    m_arlock   = {          2{1'b0}};
    m_arlen    = {          8{1'b0}};
    for (i = 0; i < 5; i = i + 1) begin
        m_araddr             = m_araddr         | ({ 32{s_arsel[i]}} & s_araddr  [i]);
        m_arburst            = m_arburst        | ({  2{s_arsel[i]}} & s_arburst [i]);
        m_arprot             = m_arprot         | ({  3{s_arsel[i]}} & s_arprot  [i]);
        m_arcache            = m_arcache        | ({  4{s_arsel[i]}} & s_arcache [i]);
        m_arsize             = m_arsize         | ({  3{s_arsel[i]}} & s_arsize  [i]);
        m_arid    [  0+:  3] = m_arid[  0+:  3] | ({  3{s_arsel[i]}} & i[0+:3]      );
        m_arid    [  3+: 10] = m_arid[  3+: 10] | ({ 10{s_arsel[i]}} & s_arid    [i]);
        m_arlock             = m_arlock         | ({  2{s_arsel[i]}} & s_arlock  [i]);
        m_arlen              = m_arlen          | ({  8{s_arsel[i]}} & s_arlen   [i]);
    end
end

logic [  2: 0] bsel;
logic [  2: 0] rsel;

always_comb begin
    integer i;

    for (i = 0; i < 5; i = i + 1) begin
        s_bid     [i] = { 10{bsel == i[0+:  3]}} & m_bid[  3+: 10];
        s_bresp   [i] = {  2{bsel == i[0+:  3]}} & m_bresp;
        s_bvalid  [i] = {  1{bsel == i[0+:  3]}} & m_bvalid;

        s_rdata   [i] = { 32{rsel == i[0+:  3]}} & m_rdata;
        s_rresp   [i] = {  2{rsel == i[0+:  3]}} & m_rresp;
        s_rid     [i] = { 10{rsel == i[0+:  3]}} & m_rid[  3+: 10];
        s_rlast   [i] = {  1{rsel == i[0+:  3]}} & m_rlast;
        s_rvalid  [i] = {  1{rsel == i[0+:  3]}} & m_rvalid;
    end
end

assign bsel = m_bid[  0+:  3];
assign rsel = m_rid[  0+:  3];

assign m_bready = s_bready[bsel];
assign m_rready = s_rready[rsel];

endmodule

module axi_arbitrator_5s (
    input                  aclk,
    input                  aresetn,
    output logic  [  4: 0] s_arsel,
    output logic  [  4: 0] s_awsel,
    output logic  [  4: 0] s_wsel,
    input         [  4: 0] s_arvalid,
    output logic  [  4: 0] s_arready,
    input         [  4: 0] s_awvalid,
    output logic  [  4: 0] s_awready,
    input         [  4: 0] s_wlast,
    input         [  4: 0] s_wvalid,
    output logic  [  4: 0] s_wready,
    output logic           m_arvalid,
    input                  m_arready,
    output logic           m_awvalid,
    input                  m_awready,
    output logic           m_wlast,
    output logic           m_wvalid,
    input                  m_wready
);

parameter SLV_NUM = 5;

// AR arbitrator
logic [SLV_NUM - 1:0] ar_prior;
logic [SLV_NUM - 1:0] ar_prior_nxt;

assign ar_prior_nxt = {ar_prior[SLV_NUM - 2:0], ar_prior[SLV_NUM - 1]};

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        ar_prior <= {{(SLV_NUM-1){1'b0}}, 1'b1};
    end
    else begin
        if (m_arvalid & m_arready) begin
            ar_prior <= ar_prior_nxt;
        end
    end
end

logic [SLV_NUM - 1:0] ar_grant_matrix [0:SLV_NUM - 1];

always_comb begin
    integer i, j, k;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        ar_grant_matrix[i] = ar_prior;
        for (j = 0; j < SLV_NUM - 1; j = j + 1) begin
            for (k = 1; k < SLV_NUM - j; k = k + 1) begin
                ar_grant_matrix[i][(i + j + 1) % SLV_NUM] = ar_grant_matrix[i][(i + j + 1) % SLV_NUM] &
                                                            ~s_arvalid[(i - k + SLV_NUM) % SLV_NUM];
            end
        end
    end
end

always_comb begin
    integer i;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        s_arready[i]  = s_arvalid[i] & (|ar_grant_matrix[i]) & m_arready;
        s_arsel  [i]  = s_arvalid[i] & (|ar_grant_matrix[i]);
    end
end

assign m_arvalid = |s_arvalid;

// AW arbitrator
logic [SLV_NUM - 1:0] aw_prior;
logic [SLV_NUM - 1:0] aw_prior_nxt;

assign aw_prior_nxt = {aw_prior[SLV_NUM - 2:0], aw_prior[SLV_NUM - 1]};

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        aw_prior <= {{(SLV_NUM-1){1'b0}}, 1'b1};
    end
    else begin
        if (m_wlast & m_wvalid & m_wready) begin
            aw_prior <= aw_prior_nxt;
        end
    end
end
logic [SLV_NUM - 1:0] aw_grant_matrix [0:SLV_NUM - 1];

always_comb begin
    integer i, j, k;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        aw_grant_matrix[i] = aw_prior;
        for (j = 0; j < SLV_NUM - 1; j = j + 1) begin
            for (k = 1; k < SLV_NUM - j; k = k + 1) begin
                aw_grant_matrix[i][(i + j + 1) % SLV_NUM] =  aw_grant_matrix[i][(i + j + 1) % SLV_NUM] &
                                                            ~s_awvalid[(i - k + SLV_NUM) % SLV_NUM];
            end
        end
    end
end

always_comb begin
    integer i;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        s_awready[i]  = s_awvalid[i] & (|aw_grant_matrix[i]) & ~|s_wsel & m_awready;
        s_awsel  [i]  = s_awvalid[i] & (|aw_grant_matrix[i]);
    end
end

assign m_awvalid = |s_awvalid & ~|s_wsel;

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        s_wsel <= {SLV_NUM{1'b0}};
    end
    else begin
        if (m_wready & m_wvalid & m_wlast) begin
            s_wsel <= {SLV_NUM{1'b0}};
        end
        else if (~|s_wsel & m_awvalid & m_awready) begin
            s_wsel <= s_awready;
        end
    end
end

assign s_wready = s_wsel & {SLV_NUM{m_wready}};

assign m_wvalid = |(s_wsel & s_wvalid);
assign m_wlast  = |(s_wsel & s_wlast);

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/axi_1to5_dec.sv
/*--------------------------------------*/

/*-----------------------------------------------------*/
// axi_1to5_dec.sv is generated by ./../../script/gen_axi_dec.sh
//
//                                         2023-03-24
//                                           00:30:44
/*-----------------------------------------------------*/

module axi_1to5_dec (
    input                  aclk,
    input                  aresetn,
    input         [  1: 0] s_awburst,
    input         [  2: 0] s_awprot,
    input         [ 12: 0] s_awid,
    input         [  3: 0] s_awcache,
    input         [ 31: 0] s_awaddr,
    input         [  2: 0] s_awsize,
    input         [  1: 0] s_awlock,
    input         [  7: 0] s_awlen,
    input                  s_awvalid,
    output logic           s_awready,
    input         [  3: 0] s_wstrb,
    input         [ 12: 0] s_wid,
    input         [ 31: 0] s_wdata,
    input                  s_wlast,
    input                  s_wvalid,
    output logic           s_wready,
    output logic  [ 12: 0] s_bid,
    output logic  [  1: 0] s_bresp,
    output logic           s_bvalid,
    input                  s_bready,
    input         [ 31: 0] s_araddr,
    input         [  1: 0] s_arburst,
    input         [  2: 0] s_arprot,
    input         [  3: 0] s_arcache,
    input         [  2: 0] s_arsize,
    input         [ 12: 0] s_arid,
    input         [  1: 0] s_arlock,
    input         [  7: 0] s_arlen,
    input                  s_arvalid,
    output logic           s_arready,
    output logic  [ 31: 0] s_rdata,
    output logic  [  1: 0] s_rresp,
    output logic  [ 12: 0] s_rid,
    output logic           s_rlast,
    output logic           s_rvalid,
    input                  s_rready,
    output logic  [  1: 0] m0_awburst,
    output logic  [  2: 0] m0_awprot,
    output logic  [ 12: 0] m0_awid,
    output logic  [  3: 0] m0_awcache,
    output logic  [ 31: 0] m0_awaddr,
    output logic  [  2: 0] m0_awsize,
    output logic  [  1: 0] m0_awlock,
    output logic  [  7: 0] m0_awlen,
    output logic           m0_awvalid,
    input                  m0_awready,
    output logic  [  3: 0] m0_wstrb,
    output logic  [ 12: 0] m0_wid,
    output logic  [ 31: 0] m0_wdata,
    output logic           m0_wlast,
    output logic           m0_wvalid,
    input                  m0_wready,
    input         [ 12: 0] m0_bid,
    input         [  1: 0] m0_bresp,
    input                  m0_bvalid,
    output logic           m0_bready,
    output logic  [ 31: 0] m0_araddr,
    output logic  [  1: 0] m0_arburst,
    output logic  [  2: 0] m0_arprot,
    output logic  [  3: 0] m0_arcache,
    output logic  [  2: 0] m0_arsize,
    output logic  [ 12: 0] m0_arid,
    output logic  [  1: 0] m0_arlock,
    output logic  [  7: 0] m0_arlen,
    output logic           m0_arvalid,
    input                  m0_arready,
    input         [ 31: 0] m0_rdata,
    input         [  1: 0] m0_rresp,
    input         [ 12: 0] m0_rid,
    input                  m0_rlast,
    input                  m0_rvalid,
    output logic           m0_rready,
    output logic  [  1: 0] m1_awburst,
    output logic  [  2: 0] m1_awprot,
    output logic  [ 12: 0] m1_awid,
    output logic  [  3: 0] m1_awcache,
    output logic  [ 31: 0] m1_awaddr,
    output logic  [  2: 0] m1_awsize,
    output logic  [  1: 0] m1_awlock,
    output logic  [  7: 0] m1_awlen,
    output logic           m1_awvalid,
    input                  m1_awready,
    output logic  [  3: 0] m1_wstrb,
    output logic  [ 12: 0] m1_wid,
    output logic  [ 31: 0] m1_wdata,
    output logic           m1_wlast,
    output logic           m1_wvalid,
    input                  m1_wready,
    input         [ 12: 0] m1_bid,
    input         [  1: 0] m1_bresp,
    input                  m1_bvalid,
    output logic           m1_bready,
    output logic  [ 31: 0] m1_araddr,
    output logic  [  1: 0] m1_arburst,
    output logic  [  2: 0] m1_arprot,
    output logic  [  3: 0] m1_arcache,
    output logic  [  2: 0] m1_arsize,
    output logic  [ 12: 0] m1_arid,
    output logic  [  1: 0] m1_arlock,
    output logic  [  7: 0] m1_arlen,
    output logic           m1_arvalid,
    input                  m1_arready,
    input         [ 31: 0] m1_rdata,
    input         [  1: 0] m1_rresp,
    input         [ 12: 0] m1_rid,
    input                  m1_rlast,
    input                  m1_rvalid,
    output logic           m1_rready,
    output logic  [  1: 0] m2_awburst,
    output logic  [  2: 0] m2_awprot,
    output logic  [ 12: 0] m2_awid,
    output logic  [  3: 0] m2_awcache,
    output logic  [ 31: 0] m2_awaddr,
    output logic  [  2: 0] m2_awsize,
    output logic  [  1: 0] m2_awlock,
    output logic  [  7: 0] m2_awlen,
    output logic           m2_awvalid,
    input                  m2_awready,
    output logic  [  3: 0] m2_wstrb,
    output logic  [ 12: 0] m2_wid,
    output logic  [ 31: 0] m2_wdata,
    output logic           m2_wlast,
    output logic           m2_wvalid,
    input                  m2_wready,
    input         [ 12: 0] m2_bid,
    input         [  1: 0] m2_bresp,
    input                  m2_bvalid,
    output logic           m2_bready,
    output logic  [ 31: 0] m2_araddr,
    output logic  [  1: 0] m2_arburst,
    output logic  [  2: 0] m2_arprot,
    output logic  [  3: 0] m2_arcache,
    output logic  [  2: 0] m2_arsize,
    output logic  [ 12: 0] m2_arid,
    output logic  [  1: 0] m2_arlock,
    output logic  [  7: 0] m2_arlen,
    output logic           m2_arvalid,
    input                  m2_arready,
    input         [ 31: 0] m2_rdata,
    input         [  1: 0] m2_rresp,
    input         [ 12: 0] m2_rid,
    input                  m2_rlast,
    input                  m2_rvalid,
    output logic           m2_rready,
    output logic  [  1: 0] m3_awburst,
    output logic  [  2: 0] m3_awprot,
    output logic  [ 12: 0] m3_awid,
    output logic  [  3: 0] m3_awcache,
    output logic  [ 31: 0] m3_awaddr,
    output logic  [  2: 0] m3_awsize,
    output logic  [  1: 0] m3_awlock,
    output logic  [  7: 0] m3_awlen,
    output logic           m3_awvalid,
    input                  m3_awready,
    output logic  [  3: 0] m3_wstrb,
    output logic  [ 12: 0] m3_wid,
    output logic  [ 31: 0] m3_wdata,
    output logic           m3_wlast,
    output logic           m3_wvalid,
    input                  m3_wready,
    input         [ 12: 0] m3_bid,
    input         [  1: 0] m3_bresp,
    input                  m3_bvalid,
    output logic           m3_bready,
    output logic  [ 31: 0] m3_araddr,
    output logic  [  1: 0] m3_arburst,
    output logic  [  2: 0] m3_arprot,
    output logic  [  3: 0] m3_arcache,
    output logic  [  2: 0] m3_arsize,
    output logic  [ 12: 0] m3_arid,
    output logic  [  1: 0] m3_arlock,
    output logic  [  7: 0] m3_arlen,
    output logic           m3_arvalid,
    input                  m3_arready,
    input         [ 31: 0] m3_rdata,
    input         [  1: 0] m3_rresp,
    input         [ 12: 0] m3_rid,
    input                  m3_rlast,
    input                  m3_rvalid,
    output logic           m3_rready,
    output logic  [  1: 0] m4_awburst,
    output logic  [  2: 0] m4_awprot,
    output logic  [ 12: 0] m4_awid,
    output logic  [  3: 0] m4_awcache,
    output logic  [ 31: 0] m4_awaddr,
    output logic  [  2: 0] m4_awsize,
    output logic  [  1: 0] m4_awlock,
    output logic  [  7: 0] m4_awlen,
    output logic           m4_awvalid,
    input                  m4_awready,
    output logic  [  3: 0] m4_wstrb,
    output logic  [ 12: 0] m4_wid,
    output logic  [ 31: 0] m4_wdata,
    output logic           m4_wlast,
    output logic           m4_wvalid,
    input                  m4_wready,
    input         [ 12: 0] m4_bid,
    input         [  1: 0] m4_bresp,
    input                  m4_bvalid,
    output logic           m4_bready,
    output logic  [ 31: 0] m4_araddr,
    output logic  [  1: 0] m4_arburst,
    output logic  [  2: 0] m4_arprot,
    output logic  [  3: 0] m4_arcache,
    output logic  [  2: 0] m4_arsize,
    output logic  [ 12: 0] m4_arid,
    output logic  [  1: 0] m4_arlock,
    output logic  [  7: 0] m4_arlen,
    output logic           m4_arvalid,
    input                  m4_arready,
    input         [ 31: 0] m4_rdata,
    input         [  1: 0] m4_rresp,
    input         [ 12: 0] m4_rid,
    input                  m4_rlast,
    input                  m4_rvalid,
    output logic           m4_rready
);

logic [  1: 0] m_awburst  [0:   5];
logic [  2: 0] m_awprot   [0:   5];
logic [ 12: 0] m_awid     [0:   5];
logic [  3: 0] m_awcache  [0:   5];
logic [ 31: 0] m_awaddr   [0:   5];
logic [  2: 0] m_awsize   [0:   5];
logic [  1: 0] m_awlock   [0:   5];
logic [  7: 0] m_awlen    [0:   5];
logic [  3: 0] m_wstrb    [0:   5];
logic [ 12: 0] m_wid      [0:   5];
logic [ 31: 0] m_wdata    [0:   5];
logic [ 12: 0] m_bid      [0:   5];
logic [  1: 0] m_bresp    [0:   5];
logic [ 31: 0] m_araddr   [0:   5];
logic [  1: 0] m_arburst  [0:   5];
logic [  2: 0] m_arprot   [0:   5];
logic [  3: 0] m_arcache  [0:   5];
logic [  2: 0] m_arsize   [0:   5];
logic [ 12: 0] m_arid     [0:   5];
logic [  1: 0] m_arlock   [0:   5];
logic [  7: 0] m_arlen    [0:   5];
logic [ 31: 0] m_rdata    [0:   5];
logic [  1: 0] m_rresp    [0:   5];
logic [ 12: 0] m_rid      [0:   5];

logic [  5: 0] m_arvalid;
logic [  5: 0] m_arready;
logic [  5: 0] m_rlast;
logic [  5: 0] m_rvalid;
logic [  5: 0] m_rready;
logic [  5: 0] m_awvalid;
logic [  5: 0] m_awready;
logic [  5: 0] m_wlast;
logic [  5: 0] m_wvalid;
logic [  5: 0] m_wready;
logic [  5: 0] m_bvalid;
logic [  5: 0] m_bready;

assign m0_awburst = m_awburst [0];
assign m0_awprot  = m_awprot  [0];
assign m0_awid    = m_awid    [0];
assign m0_awcache = m_awcache [0];
assign m0_awaddr  = m_awaddr  [0];
assign m0_awsize  = m_awsize  [0];
assign m0_awlock  = m_awlock  [0];
assign m0_awlen   = m_awlen   [0];
assign m0_wstrb   = m_wstrb   [0];
assign m0_wid     = m_wid     [0];
assign m0_wdata   = m_wdata   [0];
assign m0_araddr  = m_araddr  [0];
assign m0_arburst = m_arburst [0];
assign m0_arprot  = m_arprot  [0];
assign m0_arcache = m_arcache [0];
assign m0_arsize  = m_arsize  [0];
assign m0_arid    = m_arid    [0];
assign m0_arlock  = m_arlock  [0];
assign m0_arlen   = m_arlen   [0];
assign m1_awburst = m_awburst [1];
assign m1_awprot  = m_awprot  [1];
assign m1_awid    = m_awid    [1];
assign m1_awcache = m_awcache [1];
assign m1_awaddr  = m_awaddr  [1];
assign m1_awsize  = m_awsize  [1];
assign m1_awlock  = m_awlock  [1];
assign m1_awlen   = m_awlen   [1];
assign m1_wstrb   = m_wstrb   [1];
assign m1_wid     = m_wid     [1];
assign m1_wdata   = m_wdata   [1];
assign m1_araddr  = m_araddr  [1];
assign m1_arburst = m_arburst [1];
assign m1_arprot  = m_arprot  [1];
assign m1_arcache = m_arcache [1];
assign m1_arsize  = m_arsize  [1];
assign m1_arid    = m_arid    [1];
assign m1_arlock  = m_arlock  [1];
assign m1_arlen   = m_arlen   [1];
assign m2_awburst = m_awburst [2];
assign m2_awprot  = m_awprot  [2];
assign m2_awid    = m_awid    [2];
assign m2_awcache = m_awcache [2];
assign m2_awaddr  = m_awaddr  [2];
assign m2_awsize  = m_awsize  [2];
assign m2_awlock  = m_awlock  [2];
assign m2_awlen   = m_awlen   [2];
assign m2_wstrb   = m_wstrb   [2];
assign m2_wid     = m_wid     [2];
assign m2_wdata   = m_wdata   [2];
assign m2_araddr  = m_araddr  [2];
assign m2_arburst = m_arburst [2];
assign m2_arprot  = m_arprot  [2];
assign m2_arcache = m_arcache [2];
assign m2_arsize  = m_arsize  [2];
assign m2_arid    = m_arid    [2];
assign m2_arlock  = m_arlock  [2];
assign m2_arlen   = m_arlen   [2];
assign m3_awburst = m_awburst [3];
assign m3_awprot  = m_awprot  [3];
assign m3_awid    = m_awid    [3];
assign m3_awcache = m_awcache [3];
assign m3_awaddr  = m_awaddr  [3];
assign m3_awsize  = m_awsize  [3];
assign m3_awlock  = m_awlock  [3];
assign m3_awlen   = m_awlen   [3];
assign m3_wstrb   = m_wstrb   [3];
assign m3_wid     = m_wid     [3];
assign m3_wdata   = m_wdata   [3];
assign m3_araddr  = m_araddr  [3];
assign m3_arburst = m_arburst [3];
assign m3_arprot  = m_arprot  [3];
assign m3_arcache = m_arcache [3];
assign m3_arsize  = m_arsize  [3];
assign m3_arid    = m_arid    [3];
assign m3_arlock  = m_arlock  [3];
assign m3_arlen   = m_arlen   [3];
assign m4_awburst = m_awburst [4];
assign m4_awprot  = m_awprot  [4];
assign m4_awid    = m_awid    [4];
assign m4_awcache = m_awcache [4];
assign m4_awaddr  = m_awaddr  [4];
assign m4_awsize  = m_awsize  [4];
assign m4_awlock  = m_awlock  [4];
assign m4_awlen   = m_awlen   [4];
assign m4_wstrb   = m_wstrb   [4];
assign m4_wid     = m_wid     [4];
assign m4_wdata   = m_wdata   [4];
assign m4_araddr  = m_araddr  [4];
assign m4_arburst = m_arburst [4];
assign m4_arprot  = m_arprot  [4];
assign m4_arcache = m_arcache [4];
assign m4_arsize  = m_arsize  [4];
assign m4_arid    = m_arid    [4];
assign m4_arlock  = m_arlock  [4];
assign m4_arlen   = m_arlen   [4];

assign m_bid     [0] = m0_bid;
assign m_bresp   [0] = m0_bresp;
assign m_rdata   [0] = m0_rdata;
assign m_rresp   [0] = m0_rresp;
assign m_rid     [0] = m0_rid;
assign m_bid     [1] = m1_bid;
assign m_bresp   [1] = m1_bresp;
assign m_rdata   [1] = m1_rdata;
assign m_rresp   [1] = m1_rresp;
assign m_rid     [1] = m1_rid;
assign m_bid     [2] = m2_bid;
assign m_bresp   [2] = m2_bresp;
assign m_rdata   [2] = m2_rdata;
assign m_rresp   [2] = m2_rresp;
assign m_rid     [2] = m2_rid;
assign m_bid     [3] = m3_bid;
assign m_bresp   [3] = m3_bresp;
assign m_rdata   [3] = m3_rdata;
assign m_rresp   [3] = m3_rresp;
assign m_rid     [3] = m3_rid;
assign m_bid     [4] = m4_bid;
assign m_bresp   [4] = m4_bresp;
assign m_rdata   [4] = m4_rdata;
assign m_rresp   [4] = m4_rresp;
assign m_rid     [4] = m4_rid;

assign m0_arvalid = m_arvalid [0];
assign m0_awvalid = m_awvalid [0];
assign m0_wvalid  = m_wvalid  [0];
assign m0_wlast   = m_wlast   [0];
assign m0_bready  = m_bready  [0];
assign m0_rready  = m_rready  [0];
assign m1_arvalid = m_arvalid [1];
assign m1_awvalid = m_awvalid [1];
assign m1_wvalid  = m_wvalid  [1];
assign m1_wlast   = m_wlast   [1];
assign m1_bready  = m_bready  [1];
assign m1_rready  = m_rready  [1];
assign m2_arvalid = m_arvalid [2];
assign m2_awvalid = m_awvalid [2];
assign m2_wvalid  = m_wvalid  [2];
assign m2_wlast   = m_wlast   [2];
assign m2_bready  = m_bready  [2];
assign m2_rready  = m_rready  [2];
assign m3_arvalid = m_arvalid [3];
assign m3_awvalid = m_awvalid [3];
assign m3_wvalid  = m_wvalid  [3];
assign m3_wlast   = m_wlast   [3];
assign m3_bready  = m_bready  [3];
assign m3_rready  = m_rready  [3];
assign m4_arvalid = m_arvalid [4];
assign m4_awvalid = m_awvalid [4];
assign m4_wvalid  = m_wvalid  [4];
assign m4_wlast   = m_wlast   [4];
assign m4_bready  = m_bready  [4];
assign m4_rready  = m_rready  [4];

assign m_arready [0] = m0_arready;
assign m_awready [0] = m0_awready;
assign m_wready  [0] = m0_wready;
assign m_bvalid  [0] = m0_bvalid;
assign m_rlast   [0] = m0_rlast;
assign m_rvalid  [0] = m0_rvalid;
assign m_arready [1] = m1_arready;
assign m_awready [1] = m1_awready;
assign m_wready  [1] = m1_wready;
assign m_bvalid  [1] = m1_bvalid;
assign m_rlast   [1] = m1_rlast;
assign m_rvalid  [1] = m1_rvalid;
assign m_arready [2] = m2_arready;
assign m_awready [2] = m2_awready;
assign m_wready  [2] = m2_wready;
assign m_bvalid  [2] = m2_bvalid;
assign m_rlast   [2] = m2_rlast;
assign m_rvalid  [2] = m2_rvalid;
assign m_arready [3] = m3_arready;
assign m_awready [3] = m3_awready;
assign m_wready  [3] = m3_wready;
assign m_bvalid  [3] = m3_bvalid;
assign m_rlast   [3] = m3_rlast;
assign m_rvalid  [3] = m3_rvalid;
assign m_arready [4] = m4_arready;
assign m_awready [4] = m4_awready;
assign m_wready  [4] = m4_wready;
assign m_bvalid  [4] = m4_bvalid;
assign m_rlast   [4] = m4_rlast;
assign m_rvalid  [4] = m4_rvalid;

logic [  5: 0] awsel;
logic [  5: 0] wsel;
logic [  5: 0] bsel;
logic [  5: 0] arsel;
logic [  5: 0] rsel;

logic          b_fifo_wr;
logic          b_fifo_rd;
logic          b_fifo_empty;
logic          b_fifo_full;
logic          r_fifo_wr;
logic          r_fifo_rd;
logic          r_fifo_empty;
logic          r_fifo_full;

assign awsel[  0] = {1'b0, s_awaddr} >= 33'h0000_0000 && {1'b0, s_awaddr} < 33'h0000_0000 + 33'h0000_2000;
assign awsel[  1] = {1'b0, s_awaddr} >= 33'h0002_0000 && {1'b0, s_awaddr} < 33'h0002_0000 + 33'h0002_0000;
assign awsel[  2] = {1'b0, s_awaddr} >= 33'h0400_0000 && {1'b0, s_awaddr} < 33'h0400_0000 + 33'h0c00_0000;
assign awsel[  3] = {1'b0, s_awaddr} >= 33'h1000_0000 && {1'b0, s_awaddr} < 33'h1000_0000 + 33'h0000_3000;
assign awsel[  4] = {1'b0, s_awaddr} >= 33'h8000_0000 && {1'b0, s_awaddr} < 33'h8000_0000 + 33'h8000_0000;
assign awsel[  5] = ~|awsel[4:0]; // default slv

assign arsel[  0] = {1'b0, s_araddr} >= 33'h0000_0000 && {1'b0, s_araddr} < 33'h0000_0000 + 33'h0000_2000;
assign arsel[  1] = {1'b0, s_araddr} >= 33'h0002_0000 && {1'b0, s_araddr} < 33'h0002_0000 + 33'h0002_0000;
assign arsel[  2] = {1'b0, s_araddr} >= 33'h0400_0000 && {1'b0, s_araddr} < 33'h0400_0000 + 33'h0c00_0000;
assign arsel[  3] = {1'b0, s_araddr} >= 33'h1000_0000 && {1'b0, s_araddr} < 33'h1000_0000 + 33'h0000_3000;
assign arsel[  4] = {1'b0, s_araddr} >= 33'h8000_0000 && {1'b0, s_araddr} < 33'h8000_0000 + 33'h8000_0000;
assign arsel[  5] = ~|arsel[4:0]; // default slv

assign b_fifo_wr = s_awvalid & s_awready;
assign b_fifo_rd = s_bvalid  & s_bready;

assign r_fifo_wr = s_arvalid & s_arready;
assign r_fifo_rd = s_rlast  & s_rvalid & s_rready;

axi_dec_fifo u_b_fifo (
    .clk           ( aclk       ),
    .rstn          ( aresetn    ),
    .wr            ( b_fifo_wr  ),
    .wdata         ( awsel      ),
    .rd            ( b_fifo_rd  ),
    .rdata         ( bsel       ),
    .empty         ( b_fifo_empty ),
    .full          ( b_fifo_full )
);

axi_dec_fifo u_r_fifo (
    .clk           ( aclk       ),
    .rstn          ( aresetn    ),
    .wr            ( r_fifo_wr  ),
    .wdata         ( arsel      ),
    .rd            ( r_fifo_rd  ),
    .rdata         ( rsel       ),
    .empty         ( r_fifo_empty ),
    .full          ( r_fifo_full )
);

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        wsel <= 6'b0;
    end
    else begin
        if (s_awvalid & s_awready & ~|wsel) begin
            wsel <= awsel;
        end
        else if (s_wlast & s_wvalid & s_wready) begin
            wsel <= 6'b0;
        end
    end
end

always_comb begin
    integer i;

    for (i = 0; i <= 5; i = i + 1) begin
        m_awburst [i] = {    2{awsel[i]}} & s_awburst;
        m_awprot  [i] = {    3{awsel[i]}} & s_awprot;
        m_awid    [i] = {   13{awsel[i]}} & s_awid;
        m_awcache [i] = {    4{awsel[i]}} & s_awcache;
        m_awaddr  [i] = {   32{awsel[i]}} & s_awaddr;
        m_awsize  [i] = {    3{awsel[i]}} & s_awsize;
        m_awlock  [i] = {    2{awsel[i]}} & s_awlock;
        m_awlen   [i] = {    8{awsel[i]}} & s_awlen;

        m_wstrb   [i] = {    4{ wsel[i]}} & s_wstrb;
        m_wid     [i] = {   13{ wsel[i]}} & s_wid;
        m_wdata   [i] = {   32{ wsel[i]}} & s_wdata;

        m_araddr  [i] = {   32{arsel[i]}} & s_araddr;
        m_arburst [i] = {    2{arsel[i]}} & s_arburst;
        m_arprot  [i] = {    3{arsel[i]}} & s_arprot;
        m_arcache [i] = {    4{arsel[i]}} & s_arcache;
        m_arsize  [i] = {    3{arsel[i]}} & s_arsize;
        m_arid    [i] = {   13{arsel[i]}} & s_arid;
        m_arlock  [i] = {    2{arsel[i]}} & s_arlock;
        m_arlen   [i] = {    8{arsel[i]}} & s_arlen;
    end
end

always_comb begin
    integer i;

    s_bid      =  13'b0;
    s_bresp    =   2'b0;

    s_rdata    =  32'b0;
    s_rresp    =   2'b0;
    s_rid      =  13'b0;
    for (i = 0; i <= 5; i = i + 1) begin
        s_bid      = s_bid      | ({   13{bsel[i]}} & m_bid     [i]);
        s_bresp    = s_bresp    | ({    2{bsel[i]}} & m_bresp   [i]);

        s_rdata    = s_rdata    | ({   32{rsel[i]}} & m_rdata   [i]);
        s_rresp    = s_rresp    | ({    2{rsel[i]}} & m_rresp   [i]);
        s_rid      = s_rid      | ({   13{rsel[i]}} & m_rid     [i]);
    end
end

assign m_awvalid = awsel & {6{s_awvalid & ~|wsel & ~b_fifo_full}};
assign s_awready = |(awsel & m_awready) & ~|wsel & ~b_fifo_full;

assign m_wlast   = wsel & {6{s_wlast }};
assign m_wvalid  = wsel & {6{s_wvalid}};
assign s_wready  = |(wsel  & m_wready );

assign s_bvalid  = |(bsel  & m_bvalid) & ~b_fifo_empty;
assign m_bready  = bsel & {6{s_bready}};

assign m_arvalid = arsel & {6{s_arvalid & ~r_fifo_full}};
assign s_arready = |(arsel & m_arready) & ~r_fifo_full;

assign s_rlast   = |(rsel  & m_rlast ) & ~r_fifo_empty;
assign s_rvalid  = |(rsel  & m_rvalid) & ~r_fifo_empty;
assign m_rready  = rsel & {6{s_rready}};

axi_dfslv u_axi_dfslv (
    .aclk          ( aclk       ),
    .aresetn       ( aresetn    ),
    .s_awburst     ( m_awburst[5] ),
    .s_awprot      ( m_awprot[5] ),
    .s_awid        ( m_awid[5]  ),
    .s_awcache     ( m_awcache[5] ),
    .s_awaddr      ( m_awaddr[5] ),
    .s_awsize      ( m_awsize[5] ),
    .s_awlock      ( m_awlock[5] ),
    .s_awlen       ( m_awlen[5] ),
    .s_awvalid     ( m_awvalid[5] ),
    .s_awready     ( m_awready[5] ),
    .s_wstrb       ( m_wstrb[5] ),
    .s_wid         ( m_wid[5]   ),
    .s_wdata       ( m_wdata[5] ),
    .s_wlast       ( m_wlast[5] ),
    .s_wvalid      ( m_wvalid[5] ),
    .s_wready      ( m_wready[5] ),
    .s_bid         ( m_bid[5]   ),
    .s_bresp       ( m_bresp[5] ),
    .s_bvalid      ( m_bvalid[5] ),
    .s_bready      ( m_bready[5] ),
    .s_araddr      ( m_araddr[5] ),
    .s_arburst     ( m_arburst[5] ),
    .s_arprot      ( m_arprot[5] ),
    .s_arcache     ( m_arcache[5] ),
    .s_arsize      ( m_arsize[5] ),
    .s_arid        ( m_arid[5]  ),
    .s_arlock      ( m_arlock[5] ),
    .s_arlen       ( m_arlen[5] ),
    .s_arvalid     ( m_arvalid[5] ),
    .s_arready     ( m_arready[5] ),
    .s_rdata       ( m_rdata[5] ),
    .s_rresp       ( m_rresp[5] ),
    .s_rid         ( m_rid[5]   ),
    .s_rlast       ( m_rlast[5] ),
    .s_rvalid      ( m_rvalid[5] ),
    .s_rready      ( m_rready[5] )
);

endmodule

module axi_dec_fifo (
    input                  clk,
    input                  rstn,
    input                  wr,
    input         [  5: 0] wdata,
    input                  rd,
    output logic  [  5: 0] rdata,
    output logic           empty,
    output logic           full
);

parameter FIFO_DEPTH = 4;

logic [  5: 0] fifo       [0: FIFO_DEPTH - 1];

logic [  2: 0] wptr;
logic [  2: 0] rptr;

assign empty = wptr == rptr;
assign full  = (wptr[2] ^ rptr[2]) && (wptr[0+:2] == rptr[0+:2]);

assign rdata = fifo[rptr[0+:2]];

always_ff @(posedge clk or negedge rstn) begin
    integer i;

    if (~rstn) begin
        wptr <= 3'b0;
        rptr <= 3'b0;
    end
    else begin
        if (wr & ~full)  wptr <= wptr + 3'b1;
        if (rd & ~empty) rptr <= rptr + 3'b1;
    end

    if (~rstn) begin
        for (i = 0; i < FIFO_DEPTH; i = i + 1)
            fifo[i] <= 6'b0;
    end
    else begin
        if (wr & ~full) fifo[wptr[0+:2]] <= wdata;
    end
end
endmodule

module axi_dfslv (
    input                  aclk,
    input                  aresetn,
    input         [  1: 0] s_awburst,
    input         [  2: 0] s_awprot,
    input         [ 12: 0] s_awid,
    input         [  3: 0] s_awcache,
    input         [ 31: 0] s_awaddr,
    input         [  2: 0] s_awsize,
    input         [  1: 0] s_awlock,
    input         [  7: 0] s_awlen,
    input                  s_awvalid,
    output logic           s_awready,
    input         [  3: 0] s_wstrb,
    input         [ 12: 0] s_wid,
    input         [ 31: 0] s_wdata,
    input                  s_wlast,
    input                  s_wvalid,
    output logic           s_wready,
    output logic  [ 12: 0] s_bid,
    output logic  [  1: 0] s_bresp,
    output logic           s_bvalid,
    input                  s_bready,
    input         [ 31: 0] s_araddr,
    input         [  1: 0] s_arburst,
    input         [  2: 0] s_arprot,
    input         [  3: 0] s_arcache,
    input         [  2: 0] s_arsize,
    input         [ 12: 0] s_arid,
    input         [  1: 0] s_arlock,
    input         [  7: 0] s_arlen,
    input                  s_arvalid,
    output logic           s_arready,
    output logic  [ 31: 0] s_rdata,
    output logic  [  1: 0] s_rresp,
    output logic  [ 12: 0] s_rid,
    output logic           s_rlast,
    output logic           s_rvalid,
    input                  s_rready
);

`define AXI_RESP_OKAY   2'b00
`define AXI_RESP_EXOKAY 2'b01
`define AXI_RESP_SLVERR 2'b10
`define AXI_RESP_DECERR 2'b11

// READ
logic [  7: 0] rlen;

assign s_rdata    =  32'b0;
assign s_rresp    = `AXI_RESP_DECERR;
assign s_rlast    = ~|rlen;
assign s_arready  = ~s_rvalid | (s_rlast & s_rvalid & s_rready);

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        s_rid <=  13'b0;
    end
    else begin
        if (s_arvalid & s_arready) begin
            s_rid <= s_arid;
        end
    end

    if (~aresetn) begin
        rlen <= 8'b0;
    end
    else begin
        if (s_arvalid & s_arready) begin
            rlen <= s_arlen;
        end
        else if (~s_rlast & s_rvalid & s_rready) begin
            rlen <= rlen - 8'b1;
        end
    end

    if (~aresetn) begin
        s_rvalid <= 1'b0;
    end
    else begin
        if (s_arvalid & s_arready) begin
            s_rvalid <= 1'b1;
        end
        else if (s_rlast & s_rvalid & s_rready) begin
            s_rvalid <= 1'b0;
        end
    end
end

// WRITE
assign s_bresp    = `AXI_RESP_DECERR;
assign s_awready  = (~s_wready & ~s_bvalid) | (s_bvalid & s_bready);

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        s_wready <= 1'b0;
    end
    else begin
        if (s_awvalid & s_awready) begin
            s_wready <= 1'b1;
        end
        else if (s_wvalid & s_wlast) begin
            s_wready <= 1'b0;
        end
    end

    if (~aresetn) begin
        s_bid <= 13'b0;
    end
    else begin
        if (s_awvalid & s_awready) begin
            s_bid <= s_awid;
        end
    end

    if (~aresetn) begin
        s_bvalid <= 1'b0;
    end
    else begin
        if (s_wvalid & s_wlast & s_wready) begin
            s_bvalid <= 1'b1;
        end
        else if (s_bready) begin
            s_bvalid <= 1'b0;
        end
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/axi_2to1_mux_id8.sv
/*--------------------------------------*/

/*-----------------------------------------------------*/
// axi_2to1_mux_id8.sv is generated by gen_axi_mux.sh
//
//                                         2022-03-13
//                                           18:16:28
/*-----------------------------------------------------*/

module axi_2to1_mux_id8 (
    input                  aclk,
    input                  aresetn,
    input         [  1: 0] s0_awburst,
    input         [  2: 0] s0_awprot,
    input         [  7: 0] s0_awid,
    input         [  3: 0] s0_awcache,
    input         [ 31: 0] s0_awaddr,
    input         [  2: 0] s0_awsize,
    input         [  1: 0] s0_awlock,
    input         [  7: 0] s0_awlen,
    input                  s0_awvalid,
    output logic           s0_awready,
    input         [  3: 0] s0_wstrb,
    input         [  7: 0] s0_wid,
    input         [ 31: 0] s0_wdata,
    input                  s0_wlast,
    input                  s0_wvalid,
    output logic           s0_wready,
    output logic  [  7: 0] s0_bid,
    output logic  [  1: 0] s0_bresp,
    output logic           s0_bvalid,
    input                  s0_bready,
    input         [ 31: 0] s0_araddr,
    input         [  1: 0] s0_arburst,
    input         [  2: 0] s0_arprot,
    input         [  3: 0] s0_arcache,
    input         [  2: 0] s0_arsize,
    input         [  7: 0] s0_arid,
    input         [  1: 0] s0_arlock,
    input         [  7: 0] s0_arlen,
    input                  s0_arvalid,
    output logic           s0_arready,
    output logic  [ 31: 0] s0_rdata,
    output logic  [  1: 0] s0_rresp,
    output logic  [  7: 0] s0_rid,
    output logic           s0_rlast,
    output logic           s0_rvalid,
    input                  s0_rready,
    input         [  1: 0] s1_awburst,
    input         [  2: 0] s1_awprot,
    input         [  7: 0] s1_awid,
    input         [  3: 0] s1_awcache,
    input         [ 31: 0] s1_awaddr,
    input         [  2: 0] s1_awsize,
    input         [  1: 0] s1_awlock,
    input         [  7: 0] s1_awlen,
    input                  s1_awvalid,
    output logic           s1_awready,
    input         [  3: 0] s1_wstrb,
    input         [  7: 0] s1_wid,
    input         [ 31: 0] s1_wdata,
    input                  s1_wlast,
    input                  s1_wvalid,
    output logic           s1_wready,
    output logic  [  7: 0] s1_bid,
    output logic  [  1: 0] s1_bresp,
    output logic           s1_bvalid,
    input                  s1_bready,
    input         [ 31: 0] s1_araddr,
    input         [  1: 0] s1_arburst,
    input         [  2: 0] s1_arprot,
    input         [  3: 0] s1_arcache,
    input         [  2: 0] s1_arsize,
    input         [  7: 0] s1_arid,
    input         [  1: 0] s1_arlock,
    input         [  7: 0] s1_arlen,
    input                  s1_arvalid,
    output logic           s1_arready,
    output logic  [ 31: 0] s1_rdata,
    output logic  [  1: 0] s1_rresp,
    output logic  [  7: 0] s1_rid,
    output logic           s1_rlast,
    output logic           s1_rvalid,
    input                  s1_rready,
    output logic  [  1: 0] m_awburst,
    output logic  [  2: 0] m_awprot,
    output logic  [  8: 0] m_awid,
    output logic  [  3: 0] m_awcache,
    output logic  [ 31: 0] m_awaddr,
    output logic  [  2: 0] m_awsize,
    output logic  [  1: 0] m_awlock,
    output logic  [  7: 0] m_awlen,
    output logic           m_awvalid,
    input                  m_awready,
    output logic  [  3: 0] m_wstrb,
    output logic  [  8: 0] m_wid,
    output logic  [ 31: 0] m_wdata,
    output logic           m_wlast,
    output logic           m_wvalid,
    input                  m_wready,
    input         [  8: 0] m_bid,
    input         [  1: 0] m_bresp,
    input                  m_bvalid,
    output logic           m_bready,
    output logic  [ 31: 0] m_araddr,
    output logic  [  1: 0] m_arburst,
    output logic  [  2: 0] m_arprot,
    output logic  [  3: 0] m_arcache,
    output logic  [  2: 0] m_arsize,
    output logic  [  8: 0] m_arid,
    output logic  [  1: 0] m_arlock,
    output logic  [  7: 0] m_arlen,
    output logic           m_arvalid,
    input                  m_arready,
    input         [ 31: 0] m_rdata,
    input         [  1: 0] m_rresp,
    input         [  8: 0] m_rid,
    input                  m_rlast,
    input                  m_rvalid,
    output logic           m_rready
);

logic [  1: 0] s_awburst  [0:   1];
logic [  2: 0] s_awprot   [0:   1];
logic [  7: 0] s_awid     [0:   1];
logic [  3: 0] s_awcache  [0:   1];
logic [ 31: 0] s_awaddr   [0:   1];
logic [  2: 0] s_awsize   [0:   1];
logic [  1: 0] s_awlock   [0:   1];
logic [  7: 0] s_awlen    [0:   1];
logic [  3: 0] s_wstrb    [0:   1];
logic [  7: 0] s_wid      [0:   1];
logic [ 31: 0] s_wdata    [0:   1];
logic [  7: 0] s_bid      [0:   1];
logic [  1: 0] s_bresp    [0:   1];
logic [ 31: 0] s_araddr   [0:   1];
logic [  1: 0] s_arburst  [0:   1];
logic [  2: 0] s_arprot   [0:   1];
logic [  3: 0] s_arcache  [0:   1];
logic [  2: 0] s_arsize   [0:   1];
logic [  7: 0] s_arid     [0:   1];
logic [  1: 0] s_arlock   [0:   1];
logic [  7: 0] s_arlen    [0:   1];
logic [ 31: 0] s_rdata    [0:   1];
logic [  1: 0] s_rresp    [0:   1];
logic [  7: 0] s_rid      [0:   1];

logic [  1: 0] s_arsel;
logic [  1: 0] s_awsel;
logic [  1: 0] s_wsel;

logic [  1: 0] s_arvalid;
logic [  1: 0] s_arready;
logic [  1: 0] s_rlast;
logic [  1: 0] s_rvalid;
logic [  1: 0] s_rready;
logic [  1: 0] s_awvalid;
logic [  1: 0] s_awready;
logic [  1: 0] s_wlast;
logic [  1: 0] s_wvalid;
logic [  1: 0] s_wready;
logic [  1: 0] s_bvalid;
logic [  1: 0] s_bready;

assign s_awburst [0] = s0_awburst;
assign s_awprot  [0] = s0_awprot;
assign s_awid    [0] = s0_awid;
assign s_awcache [0] = s0_awcache;
assign s_awaddr  [0] = s0_awaddr;
assign s_awsize  [0] = s0_awsize;
assign s_awlock  [0] = s0_awlock;
assign s_awlen   [0] = s0_awlen;
assign s_wstrb   [0] = s0_wstrb;
assign s_wid     [0] = s0_wid;
assign s_wdata   [0] = s0_wdata;
assign s_araddr  [0] = s0_araddr;
assign s_arburst [0] = s0_arburst;
assign s_arprot  [0] = s0_arprot;
assign s_arcache [0] = s0_arcache;
assign s_arsize  [0] = s0_arsize;
assign s_arid    [0] = s0_arid;
assign s_arlock  [0] = s0_arlock;
assign s_arlen   [0] = s0_arlen;
assign s_awburst [1] = s1_awburst;
assign s_awprot  [1] = s1_awprot;
assign s_awid    [1] = s1_awid;
assign s_awcache [1] = s1_awcache;
assign s_awaddr  [1] = s1_awaddr;
assign s_awsize  [1] = s1_awsize;
assign s_awlock  [1] = s1_awlock;
assign s_awlen   [1] = s1_awlen;
assign s_wstrb   [1] = s1_wstrb;
assign s_wid     [1] = s1_wid;
assign s_wdata   [1] = s1_wdata;
assign s_araddr  [1] = s1_araddr;
assign s_arburst [1] = s1_arburst;
assign s_arprot  [1] = s1_arprot;
assign s_arcache [1] = s1_arcache;
assign s_arsize  [1] = s1_arsize;
assign s_arid    [1] = s1_arid;
assign s_arlock  [1] = s1_arlock;
assign s_arlen   [1] = s1_arlen;

assign s0_bid     = s_bid     [0];
assign s0_bresp   = s_bresp   [0];
assign s0_rdata   = s_rdata   [0];
assign s0_rresp   = s_rresp   [0];
assign s0_rid     = s_rid     [0];
assign s1_bid     = s_bid     [1];
assign s1_bresp   = s_bresp   [1];
assign s1_rdata   = s_rdata   [1];
assign s1_rresp   = s_rresp   [1];
assign s1_rid     = s_rid     [1];

assign s_arvalid [0] = s0_arvalid;
assign s_awvalid [0] = s0_awvalid;
assign s_wvalid  [0] = s0_wvalid;
assign s_wlast   [0] = s0_wlast;
assign s_bready  [0] = s0_bready;
assign s_rready  [0] = s0_rready;
assign s_arvalid [1] = s1_arvalid;
assign s_awvalid [1] = s1_awvalid;
assign s_wvalid  [1] = s1_wvalid;
assign s_wlast   [1] = s1_wlast;
assign s_bready  [1] = s1_bready;
assign s_rready  [1] = s1_rready;

assign s0_arready = s_arready [0];
assign s0_awready = s_awready [0];
assign s0_wready  = s_wready  [0];
assign s0_bvalid  = s_bvalid  [0];
assign s0_rlast   = s_rlast   [0];
assign s0_rvalid  = s_rvalid  [0];
assign s1_arready = s_arready [1];
assign s1_awready = s_awready [1];
assign s1_wready  = s_wready  [1];
assign s1_bvalid  = s_bvalid  [1];
assign s1_rlast   = s_rlast   [1];
assign s1_rvalid  = s_rvalid  [1];

axi_arbitrator_2s_id8 u_axi_arbitrator (
    .aclk          ( aclk       ),
    .aresetn       ( aresetn    ),
    .s_arsel       ( s_arsel    ),
    .s_awsel       ( s_awsel    ),
    .s_wsel        ( s_wsel     ),
    .s_arvalid     ( s_arvalid  ),
    .s_arready     ( s_arready  ),
    .s_awvalid     ( s_awvalid  ),
    .s_awready     ( s_awready  ),
    .s_wlast       ( s_wlast    ),
    .s_wvalid      ( s_wvalid   ),
    .s_wready      ( s_wready   ),
    .m_arvalid     ( m_arvalid  ),
    .m_arready     ( m_arready  ),
    .m_awvalid     ( m_awvalid  ),
    .m_awready     ( m_awready  ),
    .m_wlast       ( m_wlast    ),
    .m_wvalid      ( m_wvalid   ),
    .m_wready      ( m_wready   )
);

always_comb begin
    integer i;

    m_awburst  = {          2{1'b0}};
    m_awprot   = {          3{1'b0}};
    m_awid     = {(  8 +   1){1'b0}};
    m_awcache  = {          4{1'b0}};
    m_awaddr   = {         32{1'b0}};
    m_awsize   = {          3{1'b0}};
    m_awlock   = {          2{1'b0}};
    m_awlen    = {          8{1'b0}};
    for (i = 0; i < 2; i = i + 1) begin
        m_awburst            = m_awburst        | ({  2{s_awsel[i]}} & s_awburst [i]);
        m_awprot             = m_awprot         | ({  3{s_awsel[i]}} & s_awprot  [i]);
        m_awid    [  0+:  1] = m_awid[  0+:  1] | ({  1{s_awsel[i]}} & i[0+:1]      );
        m_awid    [  1+:  8] = m_awid[  1+:  8] | ({  8{s_awsel[i]}} & s_awid    [i]);
        m_awcache            = m_awcache        | ({  4{s_awsel[i]}} & s_awcache [i]);
        m_awaddr             = m_awaddr         | ({ 32{s_awsel[i]}} & s_awaddr  [i]);
        m_awsize             = m_awsize         | ({  3{s_awsel[i]}} & s_awsize  [i]);
        m_awlock             = m_awlock         | ({  2{s_awsel[i]}} & s_awlock  [i]);
        m_awlen              = m_awlen          | ({  8{s_awsel[i]}} & s_awlen   [i]);
    end

    m_wstrb    = {          4{1'b0}};
    m_wid      = {(  8 +   1){1'b0}};
    m_wdata    = {         32{1'b0}};
    for (i = 0; i < 2; i = i + 1) begin
        m_wstrb              = m_wstrb          | ({  4{s_wsel[i]}} & s_wstrb   [i]);
        m_wid     [  0+:  1] = m_wid [  0+:  1] | ({  1{s_wsel[i]}} & i[0+:1]      );
        m_wid     [  1+:  8] = m_wid [  1+:  8] | ({  8{s_wsel[i]}} & s_wid     [i]);
        m_wdata              = m_wdata          | ({ 32{s_wsel[i]}} & s_wdata   [i]);
    end

    m_araddr   = {         32{1'b0}};
    m_arburst  = {          2{1'b0}};
    m_arprot   = {          3{1'b0}};
    m_arcache  = {          4{1'b0}};
    m_arsize   = {          3{1'b0}};
    m_arid     = {(  8 +   1){1'b0}};
    m_arlock   = {          2{1'b0}};
    m_arlen    = {          8{1'b0}};
    for (i = 0; i < 2; i = i + 1) begin
        m_araddr             = m_araddr         | ({ 32{s_arsel[i]}} & s_araddr  [i]);
        m_arburst            = m_arburst        | ({  2{s_arsel[i]}} & s_arburst [i]);
        m_arprot             = m_arprot         | ({  3{s_arsel[i]}} & s_arprot  [i]);
        m_arcache            = m_arcache        | ({  4{s_arsel[i]}} & s_arcache [i]);
        m_arsize             = m_arsize         | ({  3{s_arsel[i]}} & s_arsize  [i]);
        m_arid    [  0+:  1] = m_arid[  0+:  1] | ({  1{s_arsel[i]}} & i[0+:1]      );
        m_arid    [  1+:  8] = m_arid[  1+:  8] | ({  8{s_arsel[i]}} & s_arid    [i]);
        m_arlock             = m_arlock         | ({  2{s_arsel[i]}} & s_arlock  [i]);
        m_arlen              = m_arlen          | ({  8{s_arsel[i]}} & s_arlen   [i]);
    end
end

logic          bsel;
logic          rsel;

always_comb begin
    integer i;

    for (i = 0; i < 2; i = i + 1) begin
        s_bid     [i] = {  8{bsel == i[0+:  1]}} & m_bid[  1+:  8];
        s_bresp   [i] = {  2{bsel == i[0+:  1]}} & m_bresp;
        s_bvalid  [i] = {  1{bsel == i[0+:  1]}} & m_bvalid;

        s_rdata   [i] = { 32{rsel == i[0+:  1]}} & m_rdata;
        s_rresp   [i] = {  2{rsel == i[0+:  1]}} & m_rresp;
        s_rid     [i] = {  8{rsel == i[0+:  1]}} & m_rid[  1+:  8];
        s_rlast   [i] = {  1{rsel == i[0+:  1]}} & m_rlast;
        s_rvalid  [i] = {  1{rsel == i[0+:  1]}} & m_rvalid;
    end
end

assign bsel = m_bid[  0+:  1];
assign rsel = m_rid[  0+:  1];

assign m_bready = s_bready[bsel];
assign m_rready = s_rready[rsel];

endmodule

module axi_arbitrator_2s_id8 (
    input                  aclk,
    input                  aresetn,
    output logic  [  1: 0] s_arsel,
    output logic  [  1: 0] s_awsel,
    output logic  [  1: 0] s_wsel,
    input         [  1: 0] s_arvalid,
    output logic  [  1: 0] s_arready,
    input         [  1: 0] s_awvalid,
    output logic  [  1: 0] s_awready,
    input         [  1: 0] s_wlast,
    input         [  1: 0] s_wvalid,
    output logic  [  1: 0] s_wready,
    output logic           m_arvalid,
    input                  m_arready,
    output logic           m_awvalid,
    input                  m_awready,
    output logic           m_wlast,
    output logic           m_wvalid,
    input                  m_wready
);

parameter SLV_NUM = 2;

// AR arbitrator
logic [SLV_NUM - 1:0] ar_prior;
logic [SLV_NUM - 1:0] ar_prior_nxt;

assign ar_prior_nxt = {ar_prior[SLV_NUM - 2:0], ar_prior[SLV_NUM - 1]};

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        ar_prior <= {{(SLV_NUM-1){1'b0}}, 1'b1};
    end
    else begin
        if (m_arvalid & m_arready) begin
            ar_prior <= ar_prior_nxt;
        end
    end
end

logic [SLV_NUM - 1:0] ar_grant_matrix [0:SLV_NUM - 1];

always_comb begin
    integer i, j, k;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        ar_grant_matrix[i] = ar_prior;
        for (j = 0; j < SLV_NUM - 1; j = j + 1) begin
            for (k = 1; k < SLV_NUM - j; k = k + 1) begin
                ar_grant_matrix[i][(i + j + 1) % SLV_NUM] = ar_grant_matrix[i][(i + j + 1) % SLV_NUM] &
                                                            ~s_arvalid[(i - k + SLV_NUM) % SLV_NUM];
            end
        end
    end
end

always_comb begin
    integer i;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        s_arready[i]  = s_arvalid[i] & (|ar_grant_matrix[i]) & m_arready;
        s_arsel  [i]  = s_arvalid[i] & (|ar_grant_matrix[i]);
    end
end

assign m_arvalid = |s_arvalid;

// AW arbitrator
logic [SLV_NUM - 1:0] aw_prior;
logic [SLV_NUM - 1:0] aw_prior_nxt;

assign aw_prior_nxt = {aw_prior[SLV_NUM - 2:0], aw_prior[SLV_NUM - 1]};

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        aw_prior <= {{(SLV_NUM-1){1'b0}}, 1'b1};
    end
    else begin
        if (m_wlast & m_wvalid & m_wready) begin
            aw_prior <= aw_prior_nxt;
        end
    end
end
logic [SLV_NUM - 1:0] aw_grant_matrix [0:SLV_NUM - 1];

always_comb begin
    integer i, j, k;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        aw_grant_matrix[i] = aw_prior;
        for (j = 0; j < SLV_NUM - 1; j = j + 1) begin
            for (k = 1; k < SLV_NUM - j; k = k + 1) begin
                aw_grant_matrix[i][(i + j + 1) % SLV_NUM] =  aw_grant_matrix[i][(i + j + 1) % SLV_NUM] &
                                                            ~s_awvalid[(i - k + SLV_NUM) % SLV_NUM];
            end
        end
    end
end

always_comb begin
    integer i;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        s_awready[i]  = s_awvalid[i] & (|aw_grant_matrix[i]) & ~|s_wsel & m_awready;
        s_awsel  [i]  = s_awvalid[i] & (|aw_grant_matrix[i]);
    end
end

assign m_awvalid = |s_awvalid & ~|s_wsel;

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        s_wsel <= {SLV_NUM{1'b0}};
    end
    else begin
        if (m_wready & m_wvalid & m_wlast) begin
            s_wsel <= {SLV_NUM{1'b0}};
        end
        else if (~|s_wsel & m_awvalid & m_awready) begin
            s_wsel <= s_awready;
        end
    end
end

assign s_wready = s_wsel & {SLV_NUM{m_wready}};

assign m_wvalid = |(s_wsel & s_wvalid);
assign m_wlast  = |(s_wsel & s_wlast);

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/axi_2to1_mux_id9.sv
/*--------------------------------------*/

/*-----------------------------------------------------*/
// axi_2to1_mux_id9.sv is generated by gen_axi_mux.sh
//
//                                         2022-03-13
//                                           18:16:28
/*-----------------------------------------------------*/

module axi_2to1_mux_id9 (
    input                  aclk,
    input                  aresetn,
    input         [  1: 0] s0_awburst,
    input         [  2: 0] s0_awprot,
    input         [  8: 0] s0_awid,
    input         [  3: 0] s0_awcache,
    input         [ 31: 0] s0_awaddr,
    input         [  2: 0] s0_awsize,
    input         [  1: 0] s0_awlock,
    input         [  7: 0] s0_awlen,
    input                  s0_awvalid,
    output logic           s0_awready,
    input         [  3: 0] s0_wstrb,
    input         [  8: 0] s0_wid,
    input         [ 31: 0] s0_wdata,
    input                  s0_wlast,
    input                  s0_wvalid,
    output logic           s0_wready,
    output logic  [  8: 0] s0_bid,
    output logic  [  1: 0] s0_bresp,
    output logic           s0_bvalid,
    input                  s0_bready,
    input         [ 31: 0] s0_araddr,
    input         [  1: 0] s0_arburst,
    input         [  2: 0] s0_arprot,
    input         [  3: 0] s0_arcache,
    input         [  2: 0] s0_arsize,
    input         [  8: 0] s0_arid,
    input         [  1: 0] s0_arlock,
    input         [  7: 0] s0_arlen,
    input                  s0_arvalid,
    output logic           s0_arready,
    output logic  [ 31: 0] s0_rdata,
    output logic  [  1: 0] s0_rresp,
    output logic  [  8: 0] s0_rid,
    output logic           s0_rlast,
    output logic           s0_rvalid,
    input                  s0_rready,
    input         [  1: 0] s1_awburst,
    input         [  2: 0] s1_awprot,
    input         [  8: 0] s1_awid,
    input         [  3: 0] s1_awcache,
    input         [ 31: 0] s1_awaddr,
    input         [  2: 0] s1_awsize,
    input         [  1: 0] s1_awlock,
    input         [  7: 0] s1_awlen,
    input                  s1_awvalid,
    output logic           s1_awready,
    input         [  3: 0] s1_wstrb,
    input         [  8: 0] s1_wid,
    input         [ 31: 0] s1_wdata,
    input                  s1_wlast,
    input                  s1_wvalid,
    output logic           s1_wready,
    output logic  [  8: 0] s1_bid,
    output logic  [  1: 0] s1_bresp,
    output logic           s1_bvalid,
    input                  s1_bready,
    input         [ 31: 0] s1_araddr,
    input         [  1: 0] s1_arburst,
    input         [  2: 0] s1_arprot,
    input         [  3: 0] s1_arcache,
    input         [  2: 0] s1_arsize,
    input         [  8: 0] s1_arid,
    input         [  1: 0] s1_arlock,
    input         [  7: 0] s1_arlen,
    input                  s1_arvalid,
    output logic           s1_arready,
    output logic  [ 31: 0] s1_rdata,
    output logic  [  1: 0] s1_rresp,
    output logic  [  8: 0] s1_rid,
    output logic           s1_rlast,
    output logic           s1_rvalid,
    input                  s1_rready,
    output logic  [  1: 0] m_awburst,
    output logic  [  2: 0] m_awprot,
    output logic  [  9: 0] m_awid,
    output logic  [  3: 0] m_awcache,
    output logic  [ 31: 0] m_awaddr,
    output logic  [  2: 0] m_awsize,
    output logic  [  1: 0] m_awlock,
    output logic  [  7: 0] m_awlen,
    output logic           m_awvalid,
    input                  m_awready,
    output logic  [  3: 0] m_wstrb,
    output logic  [  9: 0] m_wid,
    output logic  [ 31: 0] m_wdata,
    output logic           m_wlast,
    output logic           m_wvalid,
    input                  m_wready,
    input         [  9: 0] m_bid,
    input         [  1: 0] m_bresp,
    input                  m_bvalid,
    output logic           m_bready,
    output logic  [ 31: 0] m_araddr,
    output logic  [  1: 0] m_arburst,
    output logic  [  2: 0] m_arprot,
    output logic  [  3: 0] m_arcache,
    output logic  [  2: 0] m_arsize,
    output logic  [  9: 0] m_arid,
    output logic  [  1: 0] m_arlock,
    output logic  [  7: 0] m_arlen,
    output logic           m_arvalid,
    input                  m_arready,
    input         [ 31: 0] m_rdata,
    input         [  1: 0] m_rresp,
    input         [  9: 0] m_rid,
    input                  m_rlast,
    input                  m_rvalid,
    output logic           m_rready
);

logic [  1: 0] s_awburst  [0:   1];
logic [  2: 0] s_awprot   [0:   1];
logic [  8: 0] s_awid     [0:   1];
logic [  3: 0] s_awcache  [0:   1];
logic [ 31: 0] s_awaddr   [0:   1];
logic [  2: 0] s_awsize   [0:   1];
logic [  1: 0] s_awlock   [0:   1];
logic [  7: 0] s_awlen    [0:   1];
logic [  3: 0] s_wstrb    [0:   1];
logic [  8: 0] s_wid      [0:   1];
logic [ 31: 0] s_wdata    [0:   1];
logic [  8: 0] s_bid      [0:   1];
logic [  1: 0] s_bresp    [0:   1];
logic [ 31: 0] s_araddr   [0:   1];
logic [  1: 0] s_arburst  [0:   1];
logic [  2: 0] s_arprot   [0:   1];
logic [  3: 0] s_arcache  [0:   1];
logic [  2: 0] s_arsize   [0:   1];
logic [  8: 0] s_arid     [0:   1];
logic [  1: 0] s_arlock   [0:   1];
logic [  7: 0] s_arlen    [0:   1];
logic [ 31: 0] s_rdata    [0:   1];
logic [  1: 0] s_rresp    [0:   1];
logic [  8: 0] s_rid      [0:   1];

logic [  1: 0] s_arsel;
logic [  1: 0] s_awsel;
logic [  1: 0] s_wsel;

logic [  1: 0] s_arvalid;
logic [  1: 0] s_arready;
logic [  1: 0] s_rlast;
logic [  1: 0] s_rvalid;
logic [  1: 0] s_rready;
logic [  1: 0] s_awvalid;
logic [  1: 0] s_awready;
logic [  1: 0] s_wlast;
logic [  1: 0] s_wvalid;
logic [  1: 0] s_wready;
logic [  1: 0] s_bvalid;
logic [  1: 0] s_bready;

assign s_awburst [0] = s0_awburst;
assign s_awprot  [0] = s0_awprot;
assign s_awid    [0] = s0_awid;
assign s_awcache [0] = s0_awcache;
assign s_awaddr  [0] = s0_awaddr;
assign s_awsize  [0] = s0_awsize;
assign s_awlock  [0] = s0_awlock;
assign s_awlen   [0] = s0_awlen;
assign s_wstrb   [0] = s0_wstrb;
assign s_wid     [0] = s0_wid;
assign s_wdata   [0] = s0_wdata;
assign s_araddr  [0] = s0_araddr;
assign s_arburst [0] = s0_arburst;
assign s_arprot  [0] = s0_arprot;
assign s_arcache [0] = s0_arcache;
assign s_arsize  [0] = s0_arsize;
assign s_arid    [0] = s0_arid;
assign s_arlock  [0] = s0_arlock;
assign s_arlen   [0] = s0_arlen;
assign s_awburst [1] = s1_awburst;
assign s_awprot  [1] = s1_awprot;
assign s_awid    [1] = s1_awid;
assign s_awcache [1] = s1_awcache;
assign s_awaddr  [1] = s1_awaddr;
assign s_awsize  [1] = s1_awsize;
assign s_awlock  [1] = s1_awlock;
assign s_awlen   [1] = s1_awlen;
assign s_wstrb   [1] = s1_wstrb;
assign s_wid     [1] = s1_wid;
assign s_wdata   [1] = s1_wdata;
assign s_araddr  [1] = s1_araddr;
assign s_arburst [1] = s1_arburst;
assign s_arprot  [1] = s1_arprot;
assign s_arcache [1] = s1_arcache;
assign s_arsize  [1] = s1_arsize;
assign s_arid    [1] = s1_arid;
assign s_arlock  [1] = s1_arlock;
assign s_arlen   [1] = s1_arlen;

assign s0_bid     = s_bid     [0];
assign s0_bresp   = s_bresp   [0];
assign s0_rdata   = s_rdata   [0];
assign s0_rresp   = s_rresp   [0];
assign s0_rid     = s_rid     [0];
assign s1_bid     = s_bid     [1];
assign s1_bresp   = s_bresp   [1];
assign s1_rdata   = s_rdata   [1];
assign s1_rresp   = s_rresp   [1];
assign s1_rid     = s_rid     [1];

assign s_arvalid [0] = s0_arvalid;
assign s_awvalid [0] = s0_awvalid;
assign s_wvalid  [0] = s0_wvalid;
assign s_wlast   [0] = s0_wlast;
assign s_bready  [0] = s0_bready;
assign s_rready  [0] = s0_rready;
assign s_arvalid [1] = s1_arvalid;
assign s_awvalid [1] = s1_awvalid;
assign s_wvalid  [1] = s1_wvalid;
assign s_wlast   [1] = s1_wlast;
assign s_bready  [1] = s1_bready;
assign s_rready  [1] = s1_rready;

assign s0_arready = s_arready [0];
assign s0_awready = s_awready [0];
assign s0_wready  = s_wready  [0];
assign s0_bvalid  = s_bvalid  [0];
assign s0_rlast   = s_rlast   [0];
assign s0_rvalid  = s_rvalid  [0];
assign s1_arready = s_arready [1];
assign s1_awready = s_awready [1];
assign s1_wready  = s_wready  [1];
assign s1_bvalid  = s_bvalid  [1];
assign s1_rlast   = s_rlast   [1];
assign s1_rvalid  = s_rvalid  [1];

axi_arbitrator_2s_id9 u_axi_arbitrator (
    .aclk          ( aclk       ),
    .aresetn       ( aresetn    ),
    .s_arsel       ( s_arsel    ),
    .s_awsel       ( s_awsel    ),
    .s_wsel        ( s_wsel     ),
    .s_arvalid     ( s_arvalid  ),
    .s_arready     ( s_arready  ),
    .s_awvalid     ( s_awvalid  ),
    .s_awready     ( s_awready  ),
    .s_wlast       ( s_wlast    ),
    .s_wvalid      ( s_wvalid   ),
    .s_wready      ( s_wready   ),
    .m_arvalid     ( m_arvalid  ),
    .m_arready     ( m_arready  ),
    .m_awvalid     ( m_awvalid  ),
    .m_awready     ( m_awready  ),
    .m_wlast       ( m_wlast    ),
    .m_wvalid      ( m_wvalid   ),
    .m_wready      ( m_wready   )
);

always_comb begin
    integer i;

    m_awburst  = {          2{1'b0}};
    m_awprot   = {          3{1'b0}};
    m_awid     = {(  9 +   1){1'b0}};
    m_awcache  = {          4{1'b0}};
    m_awaddr   = {         32{1'b0}};
    m_awsize   = {          3{1'b0}};
    m_awlock   = {          2{1'b0}};
    m_awlen    = {          8{1'b0}};
    for (i = 0; i < 2; i = i + 1) begin
        m_awburst            = m_awburst        | ({  2{s_awsel[i]}} & s_awburst [i]);
        m_awprot             = m_awprot         | ({  3{s_awsel[i]}} & s_awprot  [i]);
        m_awid    [  0+:  1] = m_awid[  0+:  1] | ({  1{s_awsel[i]}} & i[0+:1]      );
        m_awid    [  1+:  9] = m_awid[  1+:  9] | ({  9{s_awsel[i]}} & s_awid    [i]);
        m_awcache            = m_awcache        | ({  4{s_awsel[i]}} & s_awcache [i]);
        m_awaddr             = m_awaddr         | ({ 32{s_awsel[i]}} & s_awaddr  [i]);
        m_awsize             = m_awsize         | ({  3{s_awsel[i]}} & s_awsize  [i]);
        m_awlock             = m_awlock         | ({  2{s_awsel[i]}} & s_awlock  [i]);
        m_awlen              = m_awlen          | ({  8{s_awsel[i]}} & s_awlen   [i]);
    end

    m_wstrb    = {          4{1'b0}};
    m_wid      = {(  9 +   1){1'b0}};
    m_wdata    = {         32{1'b0}};
    for (i = 0; i < 2; i = i + 1) begin
        m_wstrb              = m_wstrb          | ({  4{s_wsel[i]}} & s_wstrb   [i]);
        m_wid     [  0+:  1] = m_wid [  0+:  1] | ({  1{s_wsel[i]}} & i[0+:1]      );
        m_wid     [  1+:  9] = m_wid [  1+:  9] | ({  9{s_wsel[i]}} & s_wid     [i]);
        m_wdata              = m_wdata          | ({ 32{s_wsel[i]}} & s_wdata   [i]);
    end

    m_araddr   = {         32{1'b0}};
    m_arburst  = {          2{1'b0}};
    m_arprot   = {          3{1'b0}};
    m_arcache  = {          4{1'b0}};
    m_arsize   = {          3{1'b0}};
    m_arid     = {(  9 +   1){1'b0}};
    m_arlock   = {          2{1'b0}};
    m_arlen    = {          8{1'b0}};
    for (i = 0; i < 2; i = i + 1) begin
        m_araddr             = m_araddr         | ({ 32{s_arsel[i]}} & s_araddr  [i]);
        m_arburst            = m_arburst        | ({  2{s_arsel[i]}} & s_arburst [i]);
        m_arprot             = m_arprot         | ({  3{s_arsel[i]}} & s_arprot  [i]);
        m_arcache            = m_arcache        | ({  4{s_arsel[i]}} & s_arcache [i]);
        m_arsize             = m_arsize         | ({  3{s_arsel[i]}} & s_arsize  [i]);
        m_arid    [  0+:  1] = m_arid[  0+:  1] | ({  1{s_arsel[i]}} & i[0+:1]      );
        m_arid    [  1+:  9] = m_arid[  1+:  9] | ({  9{s_arsel[i]}} & s_arid    [i]);
        m_arlock             = m_arlock         | ({  2{s_arsel[i]}} & s_arlock  [i]);
        m_arlen              = m_arlen          | ({  8{s_arsel[i]}} & s_arlen   [i]);
    end
end

logic          bsel;
logic          rsel;

always_comb begin
    integer i;

    for (i = 0; i < 2; i = i + 1) begin
        s_bid     [i] = {  9{bsel == i[0+:  1]}} & m_bid[  1+:  9];
        s_bresp   [i] = {  2{bsel == i[0+:  1]}} & m_bresp;
        s_bvalid  [i] = {  1{bsel == i[0+:  1]}} & m_bvalid;

        s_rdata   [i] = { 32{rsel == i[0+:  1]}} & m_rdata;
        s_rresp   [i] = {  2{rsel == i[0+:  1]}} & m_rresp;
        s_rid     [i] = {  9{rsel == i[0+:  1]}} & m_rid[  1+:  9];
        s_rlast   [i] = {  1{rsel == i[0+:  1]}} & m_rlast;
        s_rvalid  [i] = {  1{rsel == i[0+:  1]}} & m_rvalid;
    end
end

assign bsel = m_bid[  0+:  1];
assign rsel = m_rid[  0+:  1];

assign m_bready = s_bready[bsel];
assign m_rready = s_rready[rsel];

endmodule

module axi_arbitrator_2s_id9 (
    input                  aclk,
    input                  aresetn,
    output logic  [  1: 0] s_arsel,
    output logic  [  1: 0] s_awsel,
    output logic  [  1: 0] s_wsel,
    input         [  1: 0] s_arvalid,
    output logic  [  1: 0] s_arready,
    input         [  1: 0] s_awvalid,
    output logic  [  1: 0] s_awready,
    input         [  1: 0] s_wlast,
    input         [  1: 0] s_wvalid,
    output logic  [  1: 0] s_wready,
    output logic           m_arvalid,
    input                  m_arready,
    output logic           m_awvalid,
    input                  m_awready,
    output logic           m_wlast,
    output logic           m_wvalid,
    input                  m_wready
);

parameter SLV_NUM = 2;

// AR arbitrator
logic [SLV_NUM - 1:0] ar_prior;
logic [SLV_NUM - 1:0] ar_prior_nxt;

assign ar_prior_nxt = {ar_prior[SLV_NUM - 2:0], ar_prior[SLV_NUM - 1]};

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        ar_prior <= {{(SLV_NUM-1){1'b0}}, 1'b1};
    end
    else begin
        if (m_arvalid & m_arready) begin
            ar_prior <= ar_prior_nxt;
        end
    end
end

logic [SLV_NUM - 1:0] ar_grant_matrix [0:SLV_NUM - 1];

always_comb begin
    integer i, j, k;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        ar_grant_matrix[i] = ar_prior;
        for (j = 0; j < SLV_NUM - 1; j = j + 1) begin
            for (k = 1; k < SLV_NUM - j; k = k + 1) begin
                ar_grant_matrix[i][(i + j + 1) % SLV_NUM] = ar_grant_matrix[i][(i + j + 1) % SLV_NUM] &
                                                            ~s_arvalid[(i - k + SLV_NUM) % SLV_NUM];
            end
        end
    end
end

always_comb begin
    integer i;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        s_arready[i]  = s_arvalid[i] & (|ar_grant_matrix[i]) & m_arready;
        s_arsel  [i]  = s_arvalid[i] & (|ar_grant_matrix[i]);
    end
end

assign m_arvalid = |s_arvalid;

// AW arbitrator
logic [SLV_NUM - 1:0] aw_prior;
logic [SLV_NUM - 1:0] aw_prior_nxt;

assign aw_prior_nxt = {aw_prior[SLV_NUM - 2:0], aw_prior[SLV_NUM - 1]};

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        aw_prior <= {{(SLV_NUM-1){1'b0}}, 1'b1};
    end
    else begin
        if (m_wlast & m_wvalid & m_wready) begin
            aw_prior <= aw_prior_nxt;
        end
    end
end
logic [SLV_NUM - 1:0] aw_grant_matrix [0:SLV_NUM - 1];

always_comb begin
    integer i, j, k;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        aw_grant_matrix[i] = aw_prior;
        for (j = 0; j < SLV_NUM - 1; j = j + 1) begin
            for (k = 1; k < SLV_NUM - j; k = k + 1) begin
                aw_grant_matrix[i][(i + j + 1) % SLV_NUM] =  aw_grant_matrix[i][(i + j + 1) % SLV_NUM] &
                                                            ~s_awvalid[(i - k + SLV_NUM) % SLV_NUM];
            end
        end
    end
end

always_comb begin
    integer i;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        s_awready[i]  = s_awvalid[i] & (|aw_grant_matrix[i]) & ~|s_wsel & m_awready;
        s_awsel  [i]  = s_awvalid[i] & (|aw_grant_matrix[i]);
    end
end

assign m_awvalid = |s_awvalid & ~|s_wsel;

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        s_wsel <= {SLV_NUM{1'b0}};
    end
    else begin
        if (m_wready & m_wvalid & m_wlast) begin
            s_wsel <= {SLV_NUM{1'b0}};
        end
        else if (~|s_wsel & m_awvalid & m_awready) begin
            s_wsel <= s_awready;
        end
    end
end

assign s_wready = s_wsel & {SLV_NUM{m_wready}};

assign m_wvalid = |(s_wsel & s_wvalid);
assign m_wlast  = |(s_wsel & s_wlast);

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/axi_slice.sv
/*--------------------------------------*/

/*-----------------------------------------------------*/
// axi_slice.sv is generated by gen_axi_mux.sh
//
//                                         2023-03-24
//                                           00:30:46
/*-----------------------------------------------------*/

module axi_slice (
    input                  aclk,
    input                  aresetn,
    input         [ 66: 0] s_awpayload,
    input                  s_awvalid,
    output logic           s_awready,
    input         [ 49: 0] s_wpayload,
    input                  s_wvalid,
    output logic           s_wready,
    output logic  [ 14: 0] s_bpayload,
    output logic           s_bvalid,
    input                  s_bready,
    input         [ 66: 0] s_arpayload,
    input                  s_arvalid,
    output logic           s_arready,
    output logic  [ 47: 0] s_rpayload,
    output logic           s_rvalid,
    input                  s_rready,
    output logic  [ 66: 0] m_awpayload,
    output logic           m_awvalid,
    input                  m_awready,
    output logic  [ 49: 0] m_wpayload,
    output logic           m_wvalid,
    input                  m_wready,
    input         [ 14: 0] m_bpayload,
    input                  m_bvalid,
    output logic           m_bready,
    output logic  [ 66: 0] m_arpayload,
    output logic           m_arvalid,
    input                  m_arready,
    input         [ 47: 0] m_rpayload,
    input                  m_rvalid,
    output logic           m_rready
);

logic [ 66: 0] awpayload_latch [0:   1];
logic [ 49: 0] wpayload_latch [0:   1];
logic [ 14: 0] bpayload_latch [0:   1];
logic [ 66: 0] arpayload_latch [0:   1];
logic [ 47: 0] rpayload_latch [0:   1];

logic [  1: 0] aw_wptr;
logic [  1: 0] w_wptr;
logic [  1: 0] b_wptr;
logic [  1: 0] ar_wptr;
logic [  1: 0] r_wptr;

logic [  1: 0] aw_rptr;
logic [  1: 0] w_rptr;
logic [  1: 0] b_rptr;
logic [  1: 0] ar_rptr;
logic [  1: 0] r_rptr;

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        awpayload_latch <= { 67'b0,  67'b0};
        wpayload_latch  <= { 50'b0,  50'b0};
        bpayload_latch  <= { 15'b0,  15'b0};
        arpayload_latch <= { 67'b0,  67'b0};
        rpayload_latch  <= { 48'b0,  48'b0};
    end
    else begin
        if (s_awvalid && s_awready) awpayload_latch[aw_wptr[0]] <= s_awpayload;
        if (s_wvalid  && s_wready)  wpayload_latch[w_wptr[0]]   <= s_wpayload;
        if (m_bvalid  && m_bready)  bpayload_latch[b_wptr[0]]   <= m_bpayload;
        if (s_arvalid && s_arready) arpayload_latch[ar_wptr[0]] <= s_arpayload;
        if (m_rvalid  && m_rready)  rpayload_latch[r_wptr[0]]   <= m_rpayload;
    end
end

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        aw_wptr <= 2'b0;
        w_wptr  <= 2'b0;
        b_wptr  <= 2'b0;
        ar_wptr <= 2'b0;
        r_wptr  <= 2'b0;
    end
    else begin
        if (s_awvalid && s_awready) aw_wptr <= aw_wptr + 2'b1;
        if (s_wvalid  && s_wready)  w_wptr  <= w_wptr  + 2'b1;
        if (m_bvalid  && m_bready)  b_wptr  <= b_wptr  + 2'b1;
        if (s_arvalid && s_arready) ar_wptr <= ar_wptr + 2'b1;
        if (m_rvalid  && m_rready)  r_wptr  <= r_wptr  + 2'b1;
    end
end

assign s_awready = !((aw_wptr[1] != aw_rptr[1]) && (aw_wptr[0] == aw_rptr[0]));
assign s_wready  = !((w_wptr[1]  != w_rptr[1] ) && (w_wptr[0]  == w_rptr[0] ));
assign m_bready  = !((b_wptr[1]  != b_rptr[1] ) && (b_wptr[0]  == b_rptr[0] ));
assign s_arready = !((ar_wptr[1] != ar_rptr[1]) && (ar_wptr[0] == ar_rptr[0]));
assign m_rready  = !((r_wptr[1]  != r_rptr[1] ) && (r_wptr[0]  == r_rptr[0] ));

always_ff @(posedge aclk or negedge aresetn) begin
    if (~aresetn) begin
        aw_rptr <= 2'b0;
        w_rptr  <= 2'b0;
        b_rptr  <= 2'b0;
        ar_rptr <= 2'b0;
        r_rptr  <= 2'b0;
    end
    else begin
        if (m_awvalid && m_awready) aw_rptr <= aw_rptr + 2'b1;
        if (m_wvalid  && m_wready)  w_rptr  <= w_rptr  + 2'b1;
        if (s_bvalid  && s_bready)  b_rptr  <= b_rptr  + 2'b1;
        if (m_arvalid && m_arready) ar_rptr <= ar_rptr + 2'b1;
        if (s_rvalid  && s_rready)  r_rptr  <= r_rptr  + 2'b1;
    end
end

assign m_awvalid = aw_wptr != aw_rptr;
assign m_wvalid  = w_wptr  != w_rptr ;
assign s_bvalid  = b_wptr  != b_rptr ;
assign m_arvalid = ar_wptr != ar_rptr;
assign s_rvalid  = r_wptr  != r_rptr ;

assign m_awpayload = awpayload_latch[aw_rptr[0]];
assign m_wpayload  = wpayload_latch [ w_rptr[0]];
assign s_bpayload  = bpayload_latch [ b_rptr[0]];
assign m_arpayload = arpayload_latch[ar_rptr[0]];
assign s_rpayload  = rpayload_latch [ r_rptr[0]];

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/apb_2to1_mux.sv
/*--------------------------------------*/

module apb_2to1_mux (
    input           clk,
    input           rstn,

    apb_intf.slave  s0_apb_intf,
    apb_intf.slave  s1_apb_intf,

    apb_intf.master m_apb_intf
);

localparam SLV_NUM = 2;

logic [SLV_NUM-1:0] s_lock;
logic [SLV_NUM-1:0] s_sel;

logic        s_psel    [SLV_NUM];
logic        s_penable [SLV_NUM];
logic [31:0] s_paddr   [SLV_NUM];
logic        s_pwrite  [SLV_NUM];
logic [ 3:0] s_pstrb   [SLV_NUM];
logic [ 2:0] s_pprot   [SLV_NUM];
logic [31:0] s_pwdata  [SLV_NUM];
logic [31:0] s_prdata  [SLV_NUM];
logic        s_pslverr [SLV_NUM];
logic        s_pready  [SLV_NUM];

assign s_psel   [0] = s0_apb_intf.psel;
assign s_penable[0] = s0_apb_intf.penable;
assign s_paddr  [0] = s0_apb_intf.paddr;
assign s_pwrite [0] = s0_apb_intf.pwrite;
assign s_pstrb  [0] = s0_apb_intf.pstrb;
assign s_pprot  [0] = s0_apb_intf.pprot;
assign s_pwdata [0] = s0_apb_intf.pwdata;

assign s_psel   [1] = s1_apb_intf.psel;
assign s_penable[1] = s1_apb_intf.penable;
assign s_paddr  [1] = s1_apb_intf.paddr;
assign s_pwrite [1] = s1_apb_intf.pwrite;
assign s_pstrb  [1] = s1_apb_intf.pstrb;
assign s_pprot  [1] = s1_apb_intf.pprot;
assign s_pwdata [1] = s1_apb_intf.pwdata;

assign s0_apb_intf.prdata  = s_prdata [0];
assign s0_apb_intf.pslverr = s_pslverr[0];
assign s0_apb_intf.pready  = s_pready [0];

assign s1_apb_intf.prdata  = s_prdata [1];
assign s1_apb_intf.pslverr = s_pslverr[1];
assign s1_apb_intf.pready  = s_pready [1];

logic [SLV_NUM - 1:0] prior;
logic [SLV_NUM - 1:0] prior_nxt;

assign prior_nxt = {prior[SLV_NUM - 2:0], prior[SLV_NUM - 1]};

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        prior <= {{(SLV_NUM-1){1'b0}}, 1'b1};
    end
    else begin
        if (m_apb_intf.penable & m_apb_intf.pready) begin
            prior <= prior_nxt;
        end
    end
end

logic [SLV_NUM - 1:0] grant_matrix [0:SLV_NUM - 1];

always_comb begin
    integer i, j, k;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        grant_matrix[i] = prior;
        for (j = 0; j < SLV_NUM - 1; j = j + 1) begin
            for (k = 1; k < SLV_NUM - j; k = k + 1) begin
                grant_matrix[i][(i + j + 1) % SLV_NUM] = grant_matrix[i][(i + j + 1) % SLV_NUM] &
                                                         ~s_psel[(i - k + SLV_NUM) % SLV_NUM];
            end
        end
    end
end

always_comb begin
    integer i;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        s_sel[i]  = s_psel[i] & (|grant_matrix[i]);
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        s_lock <= {SLV_NUM{1'b0}};
    end
    else begin
        if (m_apb_intf.penable & m_apb_intf.pready) begin
            s_lock <= {SLV_NUM{1'b0}};
        end
        else if (~|s_lock) begin
            s_lock <= s_sel;
        end
    end
end

always_comb begin
    integer i;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        s_prdata [i] = {32{s_sel[i]}} & m_apb_intf.prdata;
        s_pslverr[i] = { 1{s_sel[i]}} & m_apb_intf.pslverr;
        s_pready [i] = { 1{s_sel[i]}} & m_apb_intf.pready & m_apb_intf.penable;
    end
end

always_comb begin
    integer i;
    m_apb_intf.psel   = 1'b0;
    m_apb_intf.paddr  = 32'b0;
    m_apb_intf.pwrite = 1'b0;
    m_apb_intf.pstrb  = 4'b0;
    m_apb_intf.pprot  = 3'b0;
    m_apb_intf.pwdata = 32'b0;
    for (i = 0; i < SLV_NUM; i = i + 1) begin
        m_apb_intf.psel   = m_apb_intf.psel   | ({ 1{s_sel[i]}} & s_psel  [i]);
        m_apb_intf.paddr  = m_apb_intf.paddr  | ({32{s_sel[i]}} & s_paddr [i]);
        m_apb_intf.pwrite = m_apb_intf.pwrite | ({ 1{s_sel[i]}} & s_pwrite[i]);
        m_apb_intf.pstrb  = m_apb_intf.pstrb  | ({ 4{s_sel[i]}} & s_pstrb [i]);
        m_apb_intf.pprot  = m_apb_intf.pprot  | ({ 3{s_sel[i]}} & s_pprot [i]);
        m_apb_intf.pwdata = m_apb_intf.pwdata | ({32{s_sel[i]}} & s_pwdata[i]);
    end
end

always_ff @(posedge clk or negedge rstn) begin
    if (~rstn) begin
        m_apb_intf.penable <= 1'b0;
    end
    else if (~m_apb_intf.penable) begin
        m_apb_intf.penable <= m_apb_intf.psel;
    end
    else begin
        m_apb_intf.penable <= ~m_apb_intf.pready;
    end
end

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/core_apb_conn.sv
/*--------------------------------------*/

module core_apb_conn (
    apb_intf.slave  core_apb,
    apb_intf.master cfgreg_apb,
    apb_intf.master dbgmon_apb,
    apb_intf.master intc_apb
);

assign cfgreg_apb.psel    = ~core_apb.paddr[27] && ~|core_apb.paddr[13:12] && core_apb.psel;
assign cfgreg_apb.penable = ~core_apb.paddr[27] && ~|core_apb.paddr[13:12] && core_apb.penable;
assign cfgreg_apb.paddr   = core_apb.paddr;
assign cfgreg_apb.pwrite  = core_apb.pwrite;
assign cfgreg_apb.pstrb   = core_apb.pstrb;
assign cfgreg_apb.pprot   = core_apb.pprot;
assign cfgreg_apb.pwdata  = core_apb.pwdata;

assign dbgmon_apb.psel    = ~core_apb.paddr[27] && core_apb.paddr[13] && core_apb.psel;
assign dbgmon_apb.penable = ~core_apb.paddr[27] && core_apb.paddr[13] && core_apb.penable;
assign dbgmon_apb.paddr   = core_apb.paddr;
assign dbgmon_apb.pwrite  = core_apb.pwrite;
assign dbgmon_apb.pstrb   = core_apb.pstrb;
assign dbgmon_apb.pprot   = core_apb.pprot;
assign dbgmon_apb.pwdata  = core_apb.pwdata;

assign intc_apb.psel      = core_apb.paddr[27] && core_apb.psel;
assign intc_apb.penable   = core_apb.paddr[27] && core_apb.penable;
assign intc_apb.paddr     = core_apb.paddr;
assign intc_apb.pwrite    = core_apb.pwrite;
assign intc_apb.pstrb     = core_apb.pstrb;
assign intc_apb.pprot     = core_apb.pprot;
assign intc_apb.pwdata    = core_apb.pwdata;

assign core_apb.prdata    =  core_apb.paddr[27] ? intc_apb.prdata:
                             core_apb.paddr[13] ? dbgmon_apb.prdata:
                            ~core_apb.paddr[12] ? cfgreg_apb.prdata:
                                                  32'hdeadbeef;
assign core_apb.pslverr   =  core_apb.paddr[27] ? intc_apb.pslverr:
                             core_apb.paddr[13] ? dbgmon_apb.pslverr:
                            ~core_apb.paddr[12] ? cfgreg_apb.pslverr:
                                                  1'b1;
assign core_apb.pready    =  core_apb.paddr[27] ? intc_apb.pready:
                             core_apb.paddr[13] ? dbgmon_apb.pready:
                            ~core_apb.paddr[12] ? cfgreg_apb.pready:
                                                  1'b1;

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/intc_apb_conn.sv
/*--------------------------------------*/

module intc_apb_conn (
    apb_intf.slave  intc_apb,
    apb_intf.master clint_apb,
    apb_intf.master plic_apb
);

assign clint_apb.psel    = ~intc_apb.paddr[26] && intc_apb.psel;
assign clint_apb.penable = ~intc_apb.paddr[26] && intc_apb.penable;
assign clint_apb.paddr   = intc_apb.paddr;
assign clint_apb.pwrite  = intc_apb.pwrite;
assign clint_apb.pstrb   = intc_apb.pstrb;
assign clint_apb.pprot   = intc_apb.pprot;
assign clint_apb.pwdata  = intc_apb.pwdata;

assign plic_apb.psel      = intc_apb.paddr[26] && intc_apb.psel;
assign plic_apb.penable   = intc_apb.paddr[26] && intc_apb.penable;
assign plic_apb.paddr     = intc_apb.paddr;
assign plic_apb.pwrite    = intc_apb.pwrite;
assign plic_apb.pstrb     = intc_apb.pstrb;
assign plic_apb.pprot     = intc_apb.pprot;
assign plic_apb.pwdata    = intc_apb.pwdata;

assign intc_apb.prdata    = intc_apb.paddr[26] ? plic_apb.prdata  : clint_apb.prdata;
assign intc_apb.pslverr   = intc_apb.paddr[26] ? plic_apb.pslverr : clint_apb.pslverr;
assign intc_apb.pready    = intc_apb.paddr[26] ? plic_apb.pready  : clint_apb.pready;

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/peri_apb_conn.sv
/*--------------------------------------*/

module peri_apb_conn (
    apb_intf.slave  peri_apb,
    apb_intf.master uart_apb,
    apb_intf.master spi_apb,
    apb_intf.master mac_apb
);

assign uart_apb.psel    = ~|peri_apb.paddr[13:12] && peri_apb.psel;
assign uart_apb.penable = ~|peri_apb.paddr[13:12] && peri_apb.penable;
assign uart_apb.paddr   =   peri_apb.paddr;
assign uart_apb.pwrite  =   peri_apb.pwrite;
assign uart_apb.pstrb   =   peri_apb.pstrb;
assign uart_apb.pprot   =   peri_apb.pprot;
assign uart_apb.pwdata  =   peri_apb.pwdata;

assign spi_apb.psel     =   peri_apb.paddr[12] && peri_apb.psel;
assign spi_apb.penable  =   peri_apb.paddr[12] && peri_apb.penable;
assign spi_apb.paddr    =   peri_apb.paddr;
assign spi_apb.pwrite   =   peri_apb.pwrite;
assign spi_apb.pstrb    =   peri_apb.pstrb;
assign spi_apb.pprot    =   peri_apb.pprot;
assign spi_apb.pwdata   =   peri_apb.pwdata;

assign mac_apb.psel     =   peri_apb.paddr[13] && peri_apb.psel;
assign mac_apb.penable  =   peri_apb.paddr[13] && peri_apb.penable;
assign mac_apb.paddr    =   peri_apb.paddr;
assign mac_apb.pwrite   =   peri_apb.pwrite;
assign mac_apb.pstrb    =   peri_apb.pstrb;
assign mac_apb.pprot    =   peri_apb.pprot;
assign mac_apb.pwdata   =   peri_apb.pwdata;

assign peri_apb.prdata  =   peri_apb.paddr[12] ? spi_apb.prdata  : peri_apb.paddr[13] ? mac_apb.prdata  : uart_apb.prdata;
assign peri_apb.pslverr =   peri_apb.paddr[12] ? spi_apb.pslverr : peri_apb.paddr[13] ? mac_apb.pslverr : uart_apb.pslverr;
assign peri_apb.pready  =   peri_apb.paddr[12] ? spi_apb.pready  : peri_apb.paddr[13] ? mac_apb.pready  : uart_apb.pready;

endmodule

/*--------------------------------------*/
// FILE: ../src/bus/spi_core_apb_conn.sv
/*--------------------------------------*/

module spi_core_apb_conn (
    apb_intf.slave  spi_core_apb,
    apb_intf.master spi_apb,
    apb_intf.master dma_apb
);

assign spi_apb.psel         = ~spi_core_apb.paddr[11] && spi_core_apb.psel;
assign spi_apb.penable      = ~spi_core_apb.paddr[11] && spi_core_apb.penable;
assign spi_apb.paddr        =  spi_core_apb.paddr;
assign spi_apb.pwrite       =  spi_core_apb.pwrite;
assign spi_apb.pstrb        =  spi_core_apb.pstrb;
assign spi_apb.pprot        =  spi_core_apb.pprot;
assign spi_apb.pwdata       =  spi_core_apb.pwdata;

assign dma_apb.psel         =  spi_core_apb.paddr[11] && spi_core_apb.psel;
assign dma_apb.penable      =  spi_core_apb.paddr[11] && spi_core_apb.penable;
assign dma_apb.paddr        =  spi_core_apb.paddr;
assign dma_apb.pwrite       =  spi_core_apb.pwrite;
assign dma_apb.pstrb        =  spi_core_apb.pstrb;
assign dma_apb.pprot        =  spi_core_apb.pprot;
assign dma_apb.pwdata       =  spi_core_apb.pwdata;

assign spi_core_apb.prdata  =  spi_core_apb.paddr[11] ? dma_apb.prdata  : spi_apb.prdata;
assign spi_core_apb.pslverr =  spi_core_apb.paddr[11] ? dma_apb.pslverr : spi_apb.pslverr;
assign spi_core_apb.pready  =  spi_core_apb.paddr[11] ? dma_apb.pready  : spi_apb.pready;

endmodule

/*--------------------------------------*/
// FILE: ../src/intf/apb_intf.sv
/*--------------------------------------*/

interface apb_intf #(
    parameter ADDR_WIDTH = 32,
    parameter DATA_WIDTH = 32
);

logic                    psel;
logic                    penable;
logic [  ADDR_WIDTH-1:0] paddr;
logic                    pwrite;
logic [DATA_WIDTH/8-1:0] pstrb;
logic [             2:0] pprot;
logic [  DATA_WIDTH-1:0] pwdata;
logic [  DATA_WIDTH-1:0] prdata;
logic                    pslverr;
logic                    pready;

modport slave (
    input  psel,
    input  penable,
    input  paddr,
    input  pwrite,
    input  pstrb,
    input  pprot,
    input  pwdata,
    output prdata,
    output pslverr,
    output pready
);

modport master (
    output psel,
    output penable,
    output paddr,
    output pwrite,
    output pstrb,
    output pprot,
    output pwdata,
    input  prdata,
    input  pslverr,
    input  pready
);

endinterface

/*--------------------------------------*/
// FILE: ../src/intf/axi_intf.sv
/*--------------------------------------*/

interface axi_intf #(
    parameter ID_WIDTH   = 10,
    parameter ADDR_WIDTH = 32,
    parameter DATA_WIDTH = 32
);

logic [    ID_WIDTH-1:0] awid;
logic [  ADDR_WIDTH-1:0] awaddr;
logic [             1:0] awburst;
logic [             2:0] awsize;
logic [             7:0] awlen;
logic [             1:0] awlock;
logic [             3:0] awcache;
logic [             2:0] awprot;
logic                    awvalid;
logic                    awready;
logic [    ID_WIDTH-1:0] wid;
logic [DATA_WIDTH/8-1:0] wstrb;
logic [  DATA_WIDTH-1:0] wdata;
logic                    wlast;
logic                    wvalid;
logic                    wready;
logic [    ID_WIDTH-1:0] bid;
logic [             1:0] bresp;
logic                    bvalid;
logic                    bready;
logic [    ID_WIDTH-1:0] arid;
logic [  ADDR_WIDTH-1:0] araddr;
logic [             1:0] arburst;
logic [             2:0] arsize;
logic [             7:0] arlen;
logic [             1:0] arlock;
logic [             3:0] arcache;
logic [             2:0] arprot;
logic                    arvalid;
logic                    arready;
logic [    ID_WIDTH-1:0] rid;
logic [  DATA_WIDTH-1:0] rdata;
logic [             1:0] rresp;
logic                    rlast;
logic                    rvalid;
logic                    rready;

modport slave (
    input  awid,
    input  awaddr,
    input  awburst,
    input  awsize,
    input  awlen,
    input  awlock,
    input  awcache,
    input  awprot,
    input  awvalid,
    output awready,
    input  wid,
    input  wstrb,
    input  wdata,
    input  wlast,
    input  wvalid,
    output wready,
    output bid,
    output bresp,
    output bvalid,
    input  bready,
    input  arid,
    input  araddr,
    input  arburst,
    input  arsize,
    input  arlen,
    input  arlock,
    input  arcache,
    input  arprot,
    input  arvalid,
    output arready,
    output rid,
    output rdata,
    output rresp,
    output rlast,
    output rvalid,
    input  rready
);

modport master (
    output awid,
    output awaddr,
    output awburst,
    output awsize,
    output awlen,
    output awlock,
    output awcache,
    output awprot,
    output awvalid,
    input  awready,
    output wid,
    output wstrb,
    output wdata,
    output wlast,
    output wvalid,
    input  wready,
    input  bid,
    input  bresp,
    input  bvalid,
    output bready,
    output arid,
    output araddr,
    output arburst,
    output arsize,
    output arlen,
    output arlock,
    output arcache,
    output arprot,
    output arvalid,
    input  arready,
    input  rid,
    input  rdata,
    input  rresp,
    input  rlast,
    input  rvalid,
    output rready
);

endinterface

/*--------------------------------------*/
// FILE: ../src/mem/rom32x2048.sv
/*--------------------------------------*/

module rom32x2048 (
    input               CK,
    input               CS,
    input        [10:0] A,
    input               WE,
    input        [ 3:0] BYTE,
    input        [31:0] DI,
    output logic [31:0] DO
);
    
`ifdef BROM
(* rom_style = "block" *) logic [7:0] byte_0 [2048];
(* rom_style = "block" *) logic [7:0] byte_1 [2048];
(* rom_style = "block" *) logic [7:0] byte_2 [2048];
(* rom_style = "block" *) logic [7:0] byte_3 [2048];

initial begin
    $readmemh("rom_0.hex", byte_0);
    $readmemh("rom_1.hex", byte_1);
    $readmemh("rom_2.hex", byte_2);
    $readmemh("rom_3.hex", byte_3);
end
  
always_ff @(posedge CK) begin
    if (CS) DO <= {byte_3[A], byte_2[A], byte_1[A], byte_0[A]};
end
`else
logic [31:0] data_out_pre;
logic [7:0] byte_0 [2048];
logic [7:0] byte_1 [2048];
logic [7:0] byte_2 [2048];
logic [7:0] byte_3 [2048];

assign data_out_pre = CS ? {byte_3[A], byte_2[A], byte_1[A], byte_0[A]} : 32'hx;

always_ff @(posedge CK) begin
    if (CS & WE) begin
        if (BYTE[0]) byte_0[A] <= DI[ 7: 0];
        if (BYTE[1]) byte_1[A] <= DI[15: 8];
        if (BYTE[2]) byte_2[A] <= DI[23:16];
        if (BYTE[3]) byte_3[A] <= DI[31:24];
    end
end

always_ff @(posedge CK) begin
    DO <= data_out_pre;
end
`endif
        
endmodule

/*--------------------------------------*/
// FILE: ../src/mem/sram.sv
/*--------------------------------------*/

module sram (
    input               CK,
    input               CS,
    input               WE,
    input        [14:0] A,
    input        [ 3:0] BYTE,
    input        [31:0] DI,
    output logic [31:0] DO
);

`ifdef DC
SRAM i_SRAM (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( A[6]         ),
    .A7   ( A[7]         ),
    .A8   ( A[8]         ),
    .A9   ( A[9]         ),
    .A10  ( A[10]        ),
    .A11  ( A[11]        ),
    .A12  ( A[12]        ),
    .A13  ( A[13]        ),
    .DO0  ( DO[0]        ),
    .DO1  ( DO[1]        ),
    .DO2  ( DO[2]        ),
    .DO3  ( DO[3]        ),
    .DO4  ( DO[4]        ),
    .DO5  ( DO[5]        ),
    .DO6  ( DO[6]        ),
    .DO7  ( DO[7]        ),
    .DO8  ( DO[8]        ),
    .DO9  ( DO[9]        ),
    .DO10 ( DO[10]       ),
    .DO11 ( DO[11]       ),
    .DO12 ( DO[12]       ),
    .DO13 ( DO[13]       ),
    .DO14 ( DO[14]       ),
    .DO15 ( DO[15]       ),
    .DO16 ( DO[16]       ),
    .DO17 ( DO[17]       ),
    .DO18 ( DO[18]       ),
    .DO19 ( DO[19]       ),
    .DO20 ( DO[20]       ),
    .DO21 ( DO[21]       ),
    .DO22 ( DO[22]       ),
    .DO23 ( DO[23]       ),
    .DO24 ( DO[24]       ),
    .DO25 ( DO[25]       ),
    .DO26 ( DO[26]       ),
    .DO27 ( DO[27]       ),
    .DO28 ( DO[28]       ),
    .DO29 ( DO[29]       ),
    .DO30 ( DO[30]       ),
    .DO31 ( DO[31]       ),
    .DI0  ( DI[0]        ),
    .DI1  ( DI[1]        ),
    .DI2  ( DI[2]        ),
    .DI3  ( DI[3]        ),
    .DI4  ( DI[4]        ),
    .DI5  ( DI[5]        ),
    .DI6  ( DI[6]        ),
    .DI7  ( DI[7]        ),
    .DI8  ( DI[8]        ),
    .DI9  ( DI[9]        ),
    .DI10 ( DI[10]       ),
    .DI11 ( DI[11]       ),
    .DI12 ( DI[12]       ),
    .DI13 ( DI[13]       ),
    .DI14 ( DI[14]       ),
    .DI15 ( DI[15]       ),
    .DI16 ( DI[16]       ),
    .DI17 ( DI[17]       ),
    .DI18 ( DI[18]       ),
    .DI19 ( DI[19]       ),
    .DI20 ( DI[20]       ),
    .DI21 ( DI[21]       ),
    .DI22 ( DI[22]       ),
    .DI23 ( DI[23]       ),
    .DI24 ( DI[24]       ),
    .DI25 ( DI[25]       ),
    .DI26 ( DI[26]       ),
    .DI27 ( DI[27]       ),
    .DI28 ( DI[28]       ),
    .DI29 ( DI[29]       ),
    .DI30 ( DI[30]       ),
    .DI31 ( DI[31]       ),
    .CK   ( CK           ),
    .WEB0 ( ~BYTE[0]     ),
    .WEB1 ( ~BYTE[1]     ),
    .WEB2 ( ~BYTE[2]     ),
    .WEB3 ( ~BYTE[3]     ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
`else
logic [31:0] data_out_pre;
logic [31:0] memory [2**15];

assign data_out_pre = CS ? memory[A] : 32'hx;

always_ff @(posedge CK) begin
    if (CS & WE) begin
        if (BYTE[0]) memory[A][ 7: 0] <= DI[ 7: 0];
        if (BYTE[1]) memory[A][15: 8] <= DI[15: 8];
        if (BYTE[2]) memory[A][23:16] <= DI[23:16];
        if (BYTE[3]) memory[A][31:24] <= DI[31:24];
    end
end

always_ff @(posedge CK) begin
    DO <= data_out_pre;
end
`endif

endmodule

/*--------------------------------------*/
// FILE: ../src/mem/sram32x31.sv
/*--------------------------------------*/

module sram32x31 (
    input                CK,
    input                CS,
    input                WE,
    input        [  4:0] A,
    input        [ 30:0] DI,
    output logic [ 30:0] DO
);

`ifdef DC
SRAM i_SRAM (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( 1'b0         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[0]        ),
    .DO1  ( DO[1]        ),
    .DO2  ( DO[2]        ),
    .DO3  ( DO[3]        ),
    .DO4  ( DO[4]        ),
    .DO5  ( DO[5]        ),
    .DO6  ( DO[6]        ),
    .DO7  ( DO[7]        ),
    .DO8  ( DO[8]        ),
    .DO9  ( DO[9]        ),
    .DO10 ( DO[10]       ),
    .DO11 ( DO[11]       ),
    .DO12 ( DO[12]       ),
    .DO13 ( DO[13]       ),
    .DO14 ( DO[14]       ),
    .DO15 ( DO[15]       ),
    .DO16 ( DO[16]       ),
    .DO17 ( DO[17]       ),
    .DO18 ( DO[18]       ),
    .DO19 ( DO[19]       ),
    .DO20 ( DO[20]       ),
    .DO21 ( DO[21]       ),
    .DO22 ( DO[22]       ),
    .DO23 ( DO[23]       ),
    .DO24 ( DO[24]       ),
    .DO25 ( DO[25]       ),
    .DO26 ( DO[26]       ),
    .DO27 ( DO[27]       ),
    .DO28 ( DO[28]       ),
    .DO29 ( DO[29]       ),
    .DO30 ( DO[30]       ),
    .DO31 (              ),
    .DI0  ( DI[0]        ),
    .DI1  ( DI[1]        ),
    .DI2  ( DI[2]        ),
    .DI3  ( DI[3]        ),
    .DI4  ( DI[4]        ),
    .DI5  ( DI[5]        ),
    .DI6  ( DI[6]        ),
    .DI7  ( DI[7]        ),
    .DI8  ( DI[8]        ),
    .DI9  ( DI[9]        ),
    .DI10 ( DI[10]       ),
    .DI11 ( DI[11]       ),
    .DI12 ( DI[12]       ),
    .DI13 ( DI[13]       ),
    .DI14 ( DI[14]       ),
    .DI15 ( DI[15]       ),
    .DI16 ( DI[16]       ),
    .DI17 ( DI[17]       ),
    .DI18 ( DI[18]       ),
    .DI19 ( DI[19]       ),
    .DI20 ( DI[20]       ),
    .DI21 ( DI[21]       ),
    .DI22 ( DI[22]       ),
    .DI23 ( DI[23]       ),
    .DI24 ( DI[24]       ),
    .DI25 ( DI[25]       ),
    .DI26 ( DI[26]       ),
    .DI27 ( DI[27]       ),
    .DI28 ( DI[28]       ),
    .DI29 ( DI[29]       ),
    .DI30 ( DI[30]       ),
    .DI31 ( 1'b0         ),
    .CK   ( CK           ),
    .WEB0 ( 1'b0         ),
    .WEB1 ( 1'b0         ),
    .WEB2 ( 1'b0         ),
    .WEB3 ( 1'b0         ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
`else
logic [30:0] data_out_pre;
logic [30:0] memory [32];

assign data_out_pre = CS ? memory[A] : 31'hx;

always_ff @(posedge CK) begin
    integer i;

    if (CS & WE) begin
        memory[A] <= DI;
    end
end

always_ff @(posedge CK) begin
    DO <= data_out_pre;
end
`endif

endmodule

/*--------------------------------------*/
// FILE: ../src/mem/sram32x64.sv
/*--------------------------------------*/

module sram32x64 (
    input                CK,
    input                CS,
    input                WE,
    input        [  4:0] A,
    input        [ 63:0] DI,
    output logic [ 63:0] DO
);

`ifdef DC
SRAM i_SRAM_LOW (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( 1'b0         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[0]        ),
    .DO1  ( DO[1]        ),
    .DO2  ( DO[2]        ),
    .DO3  ( DO[3]        ),
    .DO4  ( DO[4]        ),
    .DO5  ( DO[5]        ),
    .DO6  ( DO[6]        ),
    .DO7  ( DO[7]        ),
    .DO8  ( DO[8]        ),
    .DO9  ( DO[9]        ),
    .DO10 ( DO[10]       ),
    .DO11 ( DO[11]       ),
    .DO12 ( DO[12]       ),
    .DO13 ( DO[13]       ),
    .DO14 ( DO[14]       ),
    .DO15 ( DO[15]       ),
    .DO16 ( DO[16]       ),
    .DO17 ( DO[17]       ),
    .DO18 ( DO[18]       ),
    .DO19 ( DO[19]       ),
    .DO20 ( DO[20]       ),
    .DO21 ( DO[21]       ),
    .DO22 ( DO[22]       ),
    .DO23 ( DO[23]       ),
    .DO24 ( DO[24]       ),
    .DO25 ( DO[25]       ),
    .DO26 ( DO[26]       ),
    .DO27 ( DO[27]       ),
    .DO28 ( DO[28]       ),
    .DO29 ( DO[29]       ),
    .DO30 ( DO[30]       ),
    .DO31 ( DO[31]       ),
    .DI0  ( DI[0]        ),
    .DI1  ( DI[1]        ),
    .DI2  ( DI[2]        ),
    .DI3  ( DI[3]        ),
    .DI4  ( DI[4]        ),
    .DI5  ( DI[5]        ),
    .DI6  ( DI[6]        ),
    .DI7  ( DI[7]        ),
    .DI8  ( DI[8]        ),
    .DI9  ( DI[9]        ),
    .DI10 ( DI[10]       ),
    .DI11 ( DI[11]       ),
    .DI12 ( DI[12]       ),
    .DI13 ( DI[13]       ),
    .DI14 ( DI[14]       ),
    .DI15 ( DI[15]       ),
    .DI16 ( DI[16]       ),
    .DI17 ( DI[17]       ),
    .DI18 ( DI[18]       ),
    .DI19 ( DI[19]       ),
    .DI20 ( DI[20]       ),
    .DI21 ( DI[21]       ),
    .DI22 ( DI[22]       ),
    .DI23 ( DI[23]       ),
    .DI24 ( DI[24]       ),
    .DI25 ( DI[25]       ),
    .DI26 ( DI[26]       ),
    .DI27 ( DI[27]       ),
    .DI28 ( DI[28]       ),
    .DI29 ( DI[29]       ),
    .DI30 ( DI[30]       ),
    .DI31 ( DI[31]       ),
    .CK   ( CK           ),
    .WEB0 ( 1'b0         ),
    .WEB1 ( 1'b0         ),
    .WEB2 ( 1'b0         ),
    .WEB3 ( 1'b0         ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
SRAM i_SRAM_HIGH (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( 1'b0         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[32+0]     ),
    .DO1  ( DO[32+1]     ),
    .DO2  ( DO[32+2]     ),
    .DO3  ( DO[32+3]     ),
    .DO4  ( DO[32+4]     ),
    .DO5  ( DO[32+5]     ),
    .DO6  ( DO[32+6]     ),
    .DO7  ( DO[32+7]     ),
    .DO8  ( DO[32+8]     ),
    .DO9  ( DO[32+9]     ),
    .DO10 ( DO[32+10]    ),
    .DO11 ( DO[32+11]    ),
    .DO12 ( DO[32+12]    ),
    .DO13 ( DO[32+13]    ),
    .DO14 ( DO[32+14]    ),
    .DO15 ( DO[32+15]    ),
    .DO16 ( DO[32+16]    ),
    .DO17 ( DO[32+17]    ),
    .DO18 ( DO[32+18]    ),
    .DO19 ( DO[32+19]    ),
    .DO20 ( DO[32+20]    ),
    .DO21 ( DO[32+21]    ),
    .DO22 ( DO[32+22]    ),
    .DO23 ( DO[32+23]    ),
    .DO24 ( DO[32+24]    ),
    .DO25 ( DO[32+25]    ),
    .DO26 ( DO[32+26]    ),
    .DO27 ( DO[32+27]    ),
    .DO28 ( DO[32+28]    ),
    .DO29 ( DO[32+29]    ),
    .DO30 ( DO[32+30]    ),
    .DO31 ( DO[32+31]    ),
    .DI0  ( DI[32+0]     ),
    .DI1  ( DI[32+1]     ),
    .DI2  ( DI[32+2]     ),
    .DI3  ( DI[32+3]     ),
    .DI4  ( DI[32+4]     ),
    .DI5  ( DI[32+5]     ),
    .DI6  ( DI[32+6]     ),
    .DI7  ( DI[32+7]     ),
    .DI8  ( DI[32+8]     ),
    .DI9  ( DI[32+9]     ),
    .DI10 ( DI[32+10]    ),
    .DI11 ( DI[32+11]    ),
    .DI12 ( DI[32+12]    ),
    .DI13 ( DI[32+13]    ),
    .DI14 ( DI[32+14]    ),
    .DI15 ( DI[32+15]    ),
    .DI16 ( DI[32+16]    ),
    .DI17 ( DI[32+17]    ),
    .DI18 ( DI[32+18]    ),
    .DI19 ( DI[32+19]    ),
    .DI20 ( DI[32+20]    ),
    .DI21 ( DI[32+21]    ),
    .DI22 ( DI[32+22]    ),
    .DI23 ( DI[32+23]    ),
    .DI24 ( DI[32+24]    ),
    .DI25 ( DI[32+25]    ),
    .DI26 ( DI[32+26]    ),
    .DI27 ( DI[32+27]    ),
    .DI28 ( DI[32+28]    ),
    .DI29 ( DI[32+29]    ),
    .DI30 ( DI[32+30]    ),
    .DI31 ( DI[32+31]    ),
    .CK   ( CK           ),
    .WEB0 ( 1'b0         ),
    .WEB1 ( 1'b0         ),
    .WEB2 ( 1'b0         ),
    .WEB3 ( 1'b0         ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
`else
logic [63:0] data_out_pre;
logic [63:0] memory [32];

assign data_out_pre = CS ? memory[A] : 64'hx;

always_ff @(posedge CK) begin
    integer i;

    if (CS & WE) begin
        memory[A] <= DI;
    end
end

always_ff @(posedge CK) begin
    DO <= data_out_pre;
end
`endif

endmodule

/*--------------------------------------*/
// FILE: ../src/mem/sram64x22.sv
/*--------------------------------------*/

module sram64x22 (
    input               CK,
    input               CS,
    input               WE,
    input        [ 5:0] A,
    input        [21:0] DI,
    output logic [21:0] DO
);

`ifdef DC
SRAM i_SRAM (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[0]        ),
    .DO1  ( DO[1]        ),
    .DO2  ( DO[2]        ),
    .DO3  ( DO[3]        ),
    .DO4  ( DO[4]        ),
    .DO5  ( DO[5]        ),
    .DO6  ( DO[6]        ),
    .DO7  ( DO[7]        ),
    .DO8  ( DO[8]        ),
    .DO9  ( DO[9]        ),
    .DO10 ( DO[10]       ),
    .DO11 ( DO[11]       ),
    .DO12 ( DO[12]       ),
    .DO13 ( DO[13]       ),
    .DO14 ( DO[14]       ),
    .DO15 ( DO[15]       ),
    .DO16 ( DO[16]       ),
    .DO17 ( DO[17]       ),
    .DO18 ( DO[18]       ),
    .DO19 ( DO[19]       ),
    .DO20 ( DO[20]       ),
    .DO21 ( DO[21]       ),
    .DO22 (              ),
    .DO23 (              ),
    .DO24 (              ),
    .DO25 (              ),
    .DO26 (              ),
    .DO27 (              ),
    .DO28 (              ),
    .DO29 (              ),
    .DO30 (              ),
    .DO31 (              ),
    .DI0  ( DI[0]        ),
    .DI1  ( DI[1]        ),
    .DI2  ( DI[2]        ),
    .DI3  ( DI[3]        ),
    .DI4  ( DI[4]        ),
    .DI5  ( DI[5]        ),
    .DI6  ( DI[6]        ),
    .DI7  ( DI[7]        ),
    .DI8  ( DI[8]        ),
    .DI9  ( DI[9]        ),
    .DI10 ( DI[10]       ),
    .DI11 ( DI[11]       ),
    .DI12 ( DI[12]       ),
    .DI13 ( DI[13]       ),
    .DI14 ( DI[14]       ),
    .DI15 ( DI[15]       ),
    .DI16 ( DI[16]       ),
    .DI17 ( DI[17]       ),
    .DI18 ( DI[18]       ),
    .DI19 ( DI[19]       ),
    .DI20 ( DI[20]       ),
    .DI21 ( DI[21]       ),
    .DI22 ( 1'b0         ),
    .DI23 ( 1'b0         ),
    .DI24 ( 1'b0         ),
    .DI25 ( 1'b0         ),
    .DI26 ( 1'b0         ),
    .DI27 ( 1'b0         ),
    .DI28 ( 1'b0         ),
    .DI29 ( 1'b0         ),
    .DI30 ( 1'b0         ),
    .DI31 ( 1'b0         ),
    .CK   ( CK           ),
    .WEB0 ( 1'b0         ),
    .WEB1 ( 1'b0         ),
    .WEB2 ( 1'b0         ),
    .WEB3 ( 1'b0         ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
`else
logic [21:0] data_out_pre;
logic [21:0] memory [64];

assign data_out_pre = CS ? memory[A] : 22'hx;

always_ff @(posedge CK) begin
    if (CS & WE) begin
        memory[A] <= DI;
    end
end

always_ff @(posedge CK) begin
    DO <= data_out_pre;
end
`endif

endmodule

/*--------------------------------------*/
// FILE: ../src/mem/sram64x128.sv
/*--------------------------------------*/

module sram64x128 (
    input                CK,
    input                CS,
    input                WE,
    input        [  5:0] A,
    input        [ 15:0] BYTE,
    input        [127:0] DI,
    output logic [127:0] DO
);

`ifdef DC
SRAM i_SRAM_0 (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[0]        ),
    .DO1  ( DO[1]        ),
    .DO2  ( DO[2]        ),
    .DO3  ( DO[3]        ),
    .DO4  ( DO[4]        ),
    .DO5  ( DO[5]        ),
    .DO6  ( DO[6]        ),
    .DO7  ( DO[7]        ),
    .DO8  ( DO[8]        ),
    .DO9  ( DO[9]        ),
    .DO10 ( DO[10]       ),
    .DO11 ( DO[11]       ),
    .DO12 ( DO[12]       ),
    .DO13 ( DO[13]       ),
    .DO14 ( DO[14]       ),
    .DO15 ( DO[15]       ),
    .DO16 ( DO[16]       ),
    .DO17 ( DO[17]       ),
    .DO18 ( DO[18]       ),
    .DO19 ( DO[19]       ),
    .DO20 ( DO[20]       ),
    .DO21 ( DO[21]       ),
    .DO22 ( DO[22]       ),
    .DO23 ( DO[23]       ),
    .DO24 ( DO[24]       ),
    .DO25 ( DO[25]       ),
    .DO26 ( DO[26]       ),
    .DO27 ( DO[27]       ),
    .DO28 ( DO[28]       ),
    .DO29 ( DO[29]       ),
    .DO30 ( DO[30]       ),
    .DO31 ( DO[31]       ),
    .DI0  ( DI[0]        ),
    .DI1  ( DI[1]        ),
    .DI2  ( DI[2]        ),
    .DI3  ( DI[3]        ),
    .DI4  ( DI[4]        ),
    .DI5  ( DI[5]        ),
    .DI6  ( DI[6]        ),
    .DI7  ( DI[7]        ),
    .DI8  ( DI[8]        ),
    .DI9  ( DI[9]        ),
    .DI10 ( DI[10]       ),
    .DI11 ( DI[11]       ),
    .DI12 ( DI[12]       ),
    .DI13 ( DI[13]       ),
    .DI14 ( DI[14]       ),
    .DI15 ( DI[15]       ),
    .DI16 ( DI[16]       ),
    .DI17 ( DI[17]       ),
    .DI18 ( DI[18]       ),
    .DI19 ( DI[19]       ),
    .DI20 ( DI[20]       ),
    .DI21 ( DI[21]       ),
    .DI22 ( DI[22]       ),
    .DI23 ( DI[23]       ),
    .DI24 ( DI[24]       ),
    .DI25 ( DI[25]       ),
    .DI26 ( DI[26]       ),
    .DI27 ( DI[27]       ),
    .DI28 ( DI[28]       ),
    .DI29 ( DI[29]       ),
    .DI30 ( DI[30]       ),
    .DI31 ( DI[31]       ),
    .CK   ( CK           ),
    .WEB0 ( ~BYTE[0]     ),
    .WEB1 ( ~BYTE[1]     ),
    .WEB2 ( ~BYTE[2]     ),
    .WEB3 ( ~BYTE[3]     ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
SRAM i_SRAM_1 (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[32+0]     ),
    .DO1  ( DO[32+1]     ),
    .DO2  ( DO[32+2]     ),
    .DO3  ( DO[32+3]     ),
    .DO4  ( DO[32+4]     ),
    .DO5  ( DO[32+5]     ),
    .DO6  ( DO[32+6]     ),
    .DO7  ( DO[32+7]     ),
    .DO8  ( DO[32+8]     ),
    .DO9  ( DO[32+9]     ),
    .DO10 ( DO[32+10]    ),
    .DO11 ( DO[32+11]    ),
    .DO12 ( DO[32+12]    ),
    .DO13 ( DO[32+13]    ),
    .DO14 ( DO[32+14]    ),
    .DO15 ( DO[32+15]    ),
    .DO16 ( DO[32+16]    ),
    .DO17 ( DO[32+17]    ),
    .DO18 ( DO[32+18]    ),
    .DO19 ( DO[32+19]    ),
    .DO20 ( DO[32+20]    ),
    .DO21 ( DO[32+21]    ),
    .DO22 ( DO[32+22]    ),
    .DO23 ( DO[32+23]    ),
    .DO24 ( DO[32+24]    ),
    .DO25 ( DO[32+25]    ),
    .DO26 ( DO[32+26]    ),
    .DO27 ( DO[32+27]    ),
    .DO28 ( DO[32+28]    ),
    .DO29 ( DO[32+29]    ),
    .DO30 ( DO[32+30]    ),
    .DO31 ( DO[32+31]    ),
    .DI0  ( DI[32+0]     ),
    .DI1  ( DI[32+1]     ),
    .DI2  ( DI[32+2]     ),
    .DI3  ( DI[32+3]     ),
    .DI4  ( DI[32+4]     ),
    .DI5  ( DI[32+5]     ),
    .DI6  ( DI[32+6]     ),
    .DI7  ( DI[32+7]     ),
    .DI8  ( DI[32+8]     ),
    .DI9  ( DI[32+9]     ),
    .DI10 ( DI[32+10]    ),
    .DI11 ( DI[32+11]    ),
    .DI12 ( DI[32+12]    ),
    .DI13 ( DI[32+13]    ),
    .DI14 ( DI[32+14]    ),
    .DI15 ( DI[32+15]    ),
    .DI16 ( DI[32+16]    ),
    .DI17 ( DI[32+17]    ),
    .DI18 ( DI[32+18]    ),
    .DI19 ( DI[32+19]    ),
    .DI20 ( DI[32+20]    ),
    .DI21 ( DI[32+21]    ),
    .DI22 ( DI[32+22]    ),
    .DI23 ( DI[32+23]    ),
    .DI24 ( DI[32+24]    ),
    .DI25 ( DI[32+25]    ),
    .DI26 ( DI[32+26]    ),
    .DI27 ( DI[32+27]    ),
    .DI28 ( DI[32+28]    ),
    .DI29 ( DI[32+29]    ),
    .DI30 ( DI[32+30]    ),
    .DI31 ( DI[32+31]    ),
    .CK   ( CK           ),
    .WEB0 ( ~BYTE[4+0]   ),
    .WEB1 ( ~BYTE[4+1]   ),
    .WEB2 ( ~BYTE[4+2]   ),
    .WEB3 ( ~BYTE[4+3]   ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
SRAM i_SRAM_2 (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[64+0]     ),
    .DO1  ( DO[64+1]     ),
    .DO2  ( DO[64+2]     ),
    .DO3  ( DO[64+3]     ),
    .DO4  ( DO[64+4]     ),
    .DO5  ( DO[64+5]     ),
    .DO6  ( DO[64+6]     ),
    .DO7  ( DO[64+7]     ),
    .DO8  ( DO[64+8]     ),
    .DO9  ( DO[64+9]     ),
    .DO10 ( DO[64+10]    ),
    .DO11 ( DO[64+11]    ),
    .DO12 ( DO[64+12]    ),
    .DO13 ( DO[64+13]    ),
    .DO14 ( DO[64+14]    ),
    .DO15 ( DO[64+15]    ),
    .DO16 ( DO[64+16]    ),
    .DO17 ( DO[64+17]    ),
    .DO18 ( DO[64+18]    ),
    .DO19 ( DO[64+19]    ),
    .DO20 ( DO[64+20]    ),
    .DO21 ( DO[64+21]    ),
    .DO22 ( DO[64+22]    ),
    .DO23 ( DO[64+23]    ),
    .DO24 ( DO[64+24]    ),
    .DO25 ( DO[64+25]    ),
    .DO26 ( DO[64+26]    ),
    .DO27 ( DO[64+27]    ),
    .DO28 ( DO[64+28]    ),
    .DO29 ( DO[64+29]    ),
    .DO30 ( DO[64+30]    ),
    .DO31 ( DO[64+31]    ),
    .DI0  ( DI[64+0]     ),
    .DI1  ( DI[64+1]     ),
    .DI2  ( DI[64+2]     ),
    .DI3  ( DI[64+3]     ),
    .DI4  ( DI[64+4]     ),
    .DI5  ( DI[64+5]     ),
    .DI6  ( DI[64+6]     ),
    .DI7  ( DI[64+7]     ),
    .DI8  ( DI[64+8]     ),
    .DI9  ( DI[64+9]     ),
    .DI10 ( DI[64+10]    ),
    .DI11 ( DI[64+11]    ),
    .DI12 ( DI[64+12]    ),
    .DI13 ( DI[64+13]    ),
    .DI14 ( DI[64+14]    ),
    .DI15 ( DI[64+15]    ),
    .DI16 ( DI[64+16]    ),
    .DI17 ( DI[64+17]    ),
    .DI18 ( DI[64+18]    ),
    .DI19 ( DI[64+19]    ),
    .DI20 ( DI[64+20]    ),
    .DI21 ( DI[64+21]    ),
    .DI22 ( DI[64+22]    ),
    .DI23 ( DI[64+23]    ),
    .DI24 ( DI[64+24]    ),
    .DI25 ( DI[64+25]    ),
    .DI26 ( DI[64+26]    ),
    .DI27 ( DI[64+27]    ),
    .DI28 ( DI[64+28]    ),
    .DI29 ( DI[64+29]    ),
    .DI30 ( DI[64+30]    ),
    .DI31 ( DI[64+31]    ),
    .CK   ( CK           ),
    .WEB0 ( ~BYTE[8+0]   ),
    .WEB1 ( ~BYTE[8+1]   ),
    .WEB2 ( ~BYTE[8+2]   ),
    .WEB3 ( ~BYTE[8+3]   ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
SRAM i_SRAM_3 (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[96+0]     ),
    .DO1  ( DO[96+1]     ),
    .DO2  ( DO[96+2]     ),
    .DO3  ( DO[96+3]     ),
    .DO4  ( DO[96+4]     ),
    .DO5  ( DO[96+5]     ),
    .DO6  ( DO[96+6]     ),
    .DO7  ( DO[96+7]     ),
    .DO8  ( DO[96+8]     ),
    .DO9  ( DO[96+9]     ),
    .DO10 ( DO[96+10]    ),
    .DO11 ( DO[96+11]    ),
    .DO12 ( DO[96+12]    ),
    .DO13 ( DO[96+13]    ),
    .DO14 ( DO[96+14]    ),
    .DO15 ( DO[96+15]    ),
    .DO16 ( DO[96+16]    ),
    .DO17 ( DO[96+17]    ),
    .DO18 ( DO[96+18]    ),
    .DO19 ( DO[96+19]    ),
    .DO20 ( DO[96+20]    ),
    .DO21 ( DO[96+21]    ),
    .DO22 ( DO[96+22]    ),
    .DO23 ( DO[96+23]    ),
    .DO24 ( DO[96+24]    ),
    .DO25 ( DO[96+25]    ),
    .DO26 ( DO[96+26]    ),
    .DO27 ( DO[96+27]    ),
    .DO28 ( DO[96+28]    ),
    .DO29 ( DO[96+29]    ),
    .DO30 ( DO[96+30]    ),
    .DO31 ( DO[96+31]    ),
    .DI0  ( DI[96+0]     ),
    .DI1  ( DI[96+1]     ),
    .DI2  ( DI[96+2]     ),
    .DI3  ( DI[96+3]     ),
    .DI4  ( DI[96+4]     ),
    .DI5  ( DI[96+5]     ),
    .DI6  ( DI[96+6]     ),
    .DI7  ( DI[96+7]     ),
    .DI8  ( DI[96+8]     ),
    .DI9  ( DI[96+9]     ),
    .DI10 ( DI[96+10]    ),
    .DI11 ( DI[96+11]    ),
    .DI12 ( DI[96+12]    ),
    .DI13 ( DI[96+13]    ),
    .DI14 ( DI[96+14]    ),
    .DI15 ( DI[96+15]    ),
    .DI16 ( DI[96+16]    ),
    .DI17 ( DI[96+17]    ),
    .DI18 ( DI[96+18]    ),
    .DI19 ( DI[96+19]    ),
    .DI20 ( DI[96+20]    ),
    .DI21 ( DI[96+21]    ),
    .DI22 ( DI[96+22]    ),
    .DI23 ( DI[96+23]    ),
    .DI24 ( DI[96+24]    ),
    .DI25 ( DI[96+25]    ),
    .DI26 ( DI[96+26]    ),
    .DI27 ( DI[96+27]    ),
    .DI28 ( DI[96+28]    ),
    .DI29 ( DI[96+29]    ),
    .DI30 ( DI[96+30]    ),
    .DI31 ( DI[96+31]    ),
    .CK   ( CK           ),
    .WEB0 ( ~BYTE[12+0]  ),
    .WEB1 ( ~BYTE[12+1]  ),
    .WEB2 ( ~BYTE[12+2]  ),
    .WEB3 ( ~BYTE[12+3]  ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
`else
logic [127:0] data_out_pre;
logic [127:0] memory [64];

assign data_out_pre = CS ? memory[A] : 128'hx;

always_ff @(posedge CK) begin
    integer i;

    if (CS & WE) begin
        for (i = 0; i < 16; i = i + 1) begin
            if (BYTE[i]) memory[A][i*8+:8] <= DI[i*8+:8];
        end
    end
end

always_ff @(posedge CK) begin
    DO <= data_out_pre;
end
`endif

endmodule

/*--------------------------------------*/
// FILE: ../src/mem/sram128x64.sv
/*--------------------------------------*/

module sram128x64 (
    input               CK,
    input               CS,
    input               WE,
    input        [ 6:0] A,
    input        [ 7:0] BYTE,
    input        [63:0] DI,
    output logic [63:0] DO
);

`ifdef DC
SRAM i_SRAM_0 (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[0]        ),
    .DO1  ( DO[1]        ),
    .DO2  ( DO[2]        ),
    .DO3  ( DO[3]        ),
    .DO4  ( DO[4]        ),
    .DO5  ( DO[5]        ),
    .DO6  ( DO[6]        ),
    .DO7  ( DO[7]        ),
    .DO8  ( DO[8]        ),
    .DO9  ( DO[9]        ),
    .DO10 ( DO[10]       ),
    .DO11 ( DO[11]       ),
    .DO12 ( DO[12]       ),
    .DO13 ( DO[13]       ),
    .DO14 ( DO[14]       ),
    .DO15 ( DO[15]       ),
    .DO16 ( DO[16]       ),
    .DO17 ( DO[17]       ),
    .DO18 ( DO[18]       ),
    .DO19 ( DO[19]       ),
    .DO20 ( DO[20]       ),
    .DO21 ( DO[21]       ),
    .DO22 ( DO[22]       ),
    .DO23 ( DO[23]       ),
    .DO24 ( DO[24]       ),
    .DO25 ( DO[25]       ),
    .DO26 ( DO[26]       ),
    .DO27 ( DO[27]       ),
    .DO28 ( DO[28]       ),
    .DO29 ( DO[29]       ),
    .DO30 ( DO[30]       ),
    .DO31 ( DO[31]       ),
    .DI0  ( DI[0]        ),
    .DI1  ( DI[1]        ),
    .DI2  ( DI[2]        ),
    .DI3  ( DI[3]        ),
    .DI4  ( DI[4]        ),
    .DI5  ( DI[5]        ),
    .DI6  ( DI[6]        ),
    .DI7  ( DI[7]        ),
    .DI8  ( DI[8]        ),
    .DI9  ( DI[9]        ),
    .DI10 ( DI[10]       ),
    .DI11 ( DI[11]       ),
    .DI12 ( DI[12]       ),
    .DI13 ( DI[13]       ),
    .DI14 ( DI[14]       ),
    .DI15 ( DI[15]       ),
    .DI16 ( DI[16]       ),
    .DI17 ( DI[17]       ),
    .DI18 ( DI[18]       ),
    .DI19 ( DI[19]       ),
    .DI20 ( DI[20]       ),
    .DI21 ( DI[21]       ),
    .DI22 ( DI[22]       ),
    .DI23 ( DI[23]       ),
    .DI24 ( DI[24]       ),
    .DI25 ( DI[25]       ),
    .DI26 ( DI[26]       ),
    .DI27 ( DI[27]       ),
    .DI28 ( DI[28]       ),
    .DI29 ( DI[29]       ),
    .DI30 ( DI[30]       ),
    .DI31 ( DI[31]       ),
    .CK   ( CK           ),
    .WEB0 ( ~BYTE[0]     ),
    .WEB1 ( ~BYTE[1]     ),
    .WEB2 ( ~BYTE[2]     ),
    .WEB3 ( ~BYTE[3]     ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
SRAM i_SRAM_1 (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[32+0]     ),
    .DO1  ( DO[32+1]     ),
    .DO2  ( DO[32+2]     ),
    .DO3  ( DO[32+3]     ),
    .DO4  ( DO[32+4]     ),
    .DO5  ( DO[32+5]     ),
    .DO6  ( DO[32+6]     ),
    .DO7  ( DO[32+7]     ),
    .DO8  ( DO[32+8]     ),
    .DO9  ( DO[32+9]     ),
    .DO10 ( DO[32+10]    ),
    .DO11 ( DO[32+11]    ),
    .DO12 ( DO[32+12]    ),
    .DO13 ( DO[32+13]    ),
    .DO14 ( DO[32+14]    ),
    .DO15 ( DO[32+15]    ),
    .DO16 ( DO[32+16]    ),
    .DO17 ( DO[32+17]    ),
    .DO18 ( DO[32+18]    ),
    .DO19 ( DO[32+19]    ),
    .DO20 ( DO[32+20]    ),
    .DO21 ( DO[32+21]    ),
    .DO22 ( DO[32+22]    ),
    .DO23 ( DO[32+23]    ),
    .DO24 ( DO[32+24]    ),
    .DO25 ( DO[32+25]    ),
    .DO26 ( DO[32+26]    ),
    .DO27 ( DO[32+27]    ),
    .DO28 ( DO[32+28]    ),
    .DO29 ( DO[32+29]    ),
    .DO30 ( DO[32+30]    ),
    .DO31 ( DO[32+31]    ),
    .DI0  ( DI[32+0]     ),
    .DI1  ( DI[32+1]     ),
    .DI2  ( DI[32+2]     ),
    .DI3  ( DI[32+3]     ),
    .DI4  ( DI[32+4]     ),
    .DI5  ( DI[32+5]     ),
    .DI6  ( DI[32+6]     ),
    .DI7  ( DI[32+7]     ),
    .DI8  ( DI[32+8]     ),
    .DI9  ( DI[32+9]     ),
    .DI10 ( DI[32+10]    ),
    .DI11 ( DI[32+11]    ),
    .DI12 ( DI[32+12]    ),
    .DI13 ( DI[32+13]    ),
    .DI14 ( DI[32+14]    ),
    .DI15 ( DI[32+15]    ),
    .DI16 ( DI[32+16]    ),
    .DI17 ( DI[32+17]    ),
    .DI18 ( DI[32+18]    ),
    .DI19 ( DI[32+19]    ),
    .DI20 ( DI[32+20]    ),
    .DI21 ( DI[32+21]    ),
    .DI22 ( DI[32+22]    ),
    .DI23 ( DI[32+23]    ),
    .DI24 ( DI[32+24]    ),
    .DI25 ( DI[32+25]    ),
    .DI26 ( DI[32+26]    ),
    .DI27 ( DI[32+27]    ),
    .DI28 ( DI[32+28]    ),
    .DI29 ( DI[32+29]    ),
    .DI30 ( DI[32+30]    ),
    .DI31 ( DI[32+31]    ),
    .CK   ( CK           ),
    .WEB0 ( ~BYTE[4+0]   ),
    .WEB1 ( ~BYTE[4+1]   ),
    .WEB2 ( ~BYTE[4+2]   ),
    .WEB3 ( ~BYTE[4+3]   ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
SRAM i_SRAM_2 (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[64+0]     ),
    .DO1  ( DO[64+1]     ),
    .DO2  ( DO[64+2]     ),
    .DO3  ( DO[64+3]     ),
    .DO4  ( DO[64+4]     ),
    .DO5  ( DO[64+5]     ),
    .DO6  ( DO[64+6]     ),
    .DO7  ( DO[64+7]     ),
    .DO8  ( DO[64+8]     ),
    .DO9  ( DO[64+9]     ),
    .DO10 ( DO[64+10]    ),
    .DO11 ( DO[64+11]    ),
    .DO12 ( DO[64+12]    ),
    .DO13 ( DO[64+13]    ),
    .DO14 ( DO[64+14]    ),
    .DO15 ( DO[64+15]    ),
    .DO16 ( DO[64+16]    ),
    .DO17 ( DO[64+17]    ),
    .DO18 ( DO[64+18]    ),
    .DO19 ( DO[64+19]    ),
    .DO20 ( DO[64+20]    ),
    .DO21 ( DO[64+21]    ),
    .DO22 ( DO[64+22]    ),
    .DO23 ( DO[64+23]    ),
    .DO24 ( DO[64+24]    ),
    .DO25 ( DO[64+25]    ),
    .DO26 ( DO[64+26]    ),
    .DO27 ( DO[64+27]    ),
    .DO28 ( DO[64+28]    ),
    .DO29 ( DO[64+29]    ),
    .DO30 ( DO[64+30]    ),
    .DO31 ( DO[64+31]    ),
    .DI0  ( DI[64+0]     ),
    .DI1  ( DI[64+1]     ),
    .DI2  ( DI[64+2]     ),
    .DI3  ( DI[64+3]     ),
    .DI4  ( DI[64+4]     ),
    .DI5  ( DI[64+5]     ),
    .DI6  ( DI[64+6]     ),
    .DI7  ( DI[64+7]     ),
    .DI8  ( DI[64+8]     ),
    .DI9  ( DI[64+9]     ),
    .DI10 ( DI[64+10]    ),
    .DI11 ( DI[64+11]    ),
    .DI12 ( DI[64+12]    ),
    .DI13 ( DI[64+13]    ),
    .DI14 ( DI[64+14]    ),
    .DI15 ( DI[64+15]    ),
    .DI16 ( DI[64+16]    ),
    .DI17 ( DI[64+17]    ),
    .DI18 ( DI[64+18]    ),
    .DI19 ( DI[64+19]    ),
    .DI20 ( DI[64+20]    ),
    .DI21 ( DI[64+21]    ),
    .DI22 ( DI[64+22]    ),
    .DI23 ( DI[64+23]    ),
    .DI24 ( DI[64+24]    ),
    .DI25 ( DI[64+25]    ),
    .DI26 ( DI[64+26]    ),
    .DI27 ( DI[64+27]    ),
    .DI28 ( DI[64+28]    ),
    .DI29 ( DI[64+29]    ),
    .DI30 ( DI[64+30]    ),
    .DI31 ( DI[64+31]    ),
    .CK   ( CK           ),
    .WEB0 ( ~BYTE[8+0]   ),
    .WEB1 ( ~BYTE[8+1]   ),
    .WEB2 ( ~BYTE[8+2]   ),
    .WEB3 ( ~BYTE[8+3]   ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
SRAM i_SRAM_3 (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( 1'b0         ),
    .A7   ( 1'b0         ),
    .A8   ( 1'b0         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[96+0]     ),
    .DO1  ( DO[96+1]     ),
    .DO2  ( DO[96+2]     ),
    .DO3  ( DO[96+3]     ),
    .DO4  ( DO[96+4]     ),
    .DO5  ( DO[96+5]     ),
    .DO6  ( DO[96+6]     ),
    .DO7  ( DO[96+7]     ),
    .DO8  ( DO[96+8]     ),
    .DO9  ( DO[96+9]     ),
    .DO10 ( DO[96+10]    ),
    .DO11 ( DO[96+11]    ),
    .DO12 ( DO[96+12]    ),
    .DO13 ( DO[96+13]    ),
    .DO14 ( DO[96+14]    ),
    .DO15 ( DO[96+15]    ),
    .DO16 ( DO[96+16]    ),
    .DO17 ( DO[96+17]    ),
    .DO18 ( DO[96+18]    ),
    .DO19 ( DO[96+19]    ),
    .DO20 ( DO[96+20]    ),
    .DO21 ( DO[96+21]    ),
    .DO22 ( DO[96+22]    ),
    .DO23 ( DO[96+23]    ),
    .DO24 ( DO[96+24]    ),
    .DO25 ( DO[96+25]    ),
    .DO26 ( DO[96+26]    ),
    .DO27 ( DO[96+27]    ),
    .DO28 ( DO[96+28]    ),
    .DO29 ( DO[96+29]    ),
    .DO30 ( DO[96+30]    ),
    .DO31 ( DO[96+31]    ),
    .DI0  ( DI[96+0]     ),
    .DI1  ( DI[96+1]     ),
    .DI2  ( DI[96+2]     ),
    .DI3  ( DI[96+3]     ),
    .DI4  ( DI[96+4]     ),
    .DI5  ( DI[96+5]     ),
    .DI6  ( DI[96+6]     ),
    .DI7  ( DI[96+7]     ),
    .DI8  ( DI[96+8]     ),
    .DI9  ( DI[96+9]     ),
    .DI10 ( DI[96+10]    ),
    .DI11 ( DI[96+11]    ),
    .DI12 ( DI[96+12]    ),
    .DI13 ( DI[96+13]    ),
    .DI14 ( DI[96+14]    ),
    .DI15 ( DI[96+15]    ),
    .DI16 ( DI[96+16]    ),
    .DI17 ( DI[96+17]    ),
    .DI18 ( DI[96+18]    ),
    .DI19 ( DI[96+19]    ),
    .DI20 ( DI[96+20]    ),
    .DI21 ( DI[96+21]    ),
    .DI22 ( DI[96+22]    ),
    .DI23 ( DI[96+23]    ),
    .DI24 ( DI[96+24]    ),
    .DI25 ( DI[96+25]    ),
    .DI26 ( DI[96+26]    ),
    .DI27 ( DI[96+27]    ),
    .DI28 ( DI[96+28]    ),
    .DI29 ( DI[96+29]    ),
    .DI30 ( DI[96+30]    ),
    .DI31 ( DI[96+31]    ),
    .CK   ( CK           ),
    .WEB0 ( ~BYTE[12+0]  ),
    .WEB1 ( ~BYTE[12+1]  ),
    .WEB2 ( ~BYTE[12+2]  ),
    .WEB3 ( ~BYTE[12+3]  ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
`else
logic [63:0] data_out_pre;
logic [63:0] memory [128];

assign data_out_pre = CS ? memory[A] : 64'hx;

always_ff @(posedge CK) begin
    integer i;

    if (CS & WE) begin
        for (i = 0; i < 8; i = i + 1) begin
            if (BYTE[i]) memory[A][i*8+:8] <= DI[i*8+:8];
        end
    end
end

always_ff @(posedge CK) begin
    DO <= data_out_pre;
end
`endif

endmodule

/*--------------------------------------*/
// FILE: ../src/mem/sram512x32.sv
/*--------------------------------------*/

module sram512x32 (
    input                CK,
    input                CS,
    input                WE,
    input        [  8:0] A,
    input        [ 31:0] DI,
    output logic [ 31:0] DO
);

`ifdef DC
SRAM i_SRAM (
    .A0   ( A[0]         ),
    .A1   ( A[1]         ),
    .A2   ( A[2]         ),
    .A3   ( A[3]         ),
    .A4   ( A[4]         ),
    .A5   ( A[5]         ),
    .A6   ( A[6]         ),
    .A7   ( A[7]         ),
    .A8   ( A[8]         ),
    .A9   ( 1'b0         ),
    .A10  ( 1'b0         ),
    .A11  ( 1'b0         ),
    .A12  ( 1'b0         ),
    .A13  ( 1'b0         ),
    .DO0  ( DO[0]        ),
    .DO1  ( DO[1]        ),
    .DO2  ( DO[2]        ),
    .DO3  ( DO[3]        ),
    .DO4  ( DO[4]        ),
    .DO5  ( DO[5]        ),
    .DO6  ( DO[6]        ),
    .DO7  ( DO[7]        ),
    .DO8  ( DO[8]        ),
    .DO9  ( DO[9]        ),
    .DO10 ( DO[10]       ),
    .DO11 ( DO[11]       ),
    .DO12 ( DO[12]       ),
    .DO13 ( DO[13]       ),
    .DO14 ( DO[14]       ),
    .DO15 ( DO[15]       ),
    .DO16 ( DO[16]       ),
    .DO17 ( DO[17]       ),
    .DO18 ( DO[18]       ),
    .DO19 ( DO[19]       ),
    .DO20 ( DO[20]       ),
    .DO21 ( DO[21]       ),
    .DO22 ( DO[22]       ),
    .DO23 ( DO[23]       ),
    .DO24 ( DO[24]       ),
    .DO25 ( DO[25]       ),
    .DO26 ( DO[26]       ),
    .DO27 ( DO[27]       ),
    .DO28 ( DO[28]       ),
    .DO29 ( DO[29]       ),
    .DO30 ( DO[30]       ),
    .DO31 ( DO[31]       ),
    .DI0  ( DI[0]        ),
    .DI1  ( DI[1]        ),
    .DI2  ( DI[2]        ),
    .DI3  ( DI[3]        ),
    .DI4  ( DI[4]        ),
    .DI5  ( DI[5]        ),
    .DI6  ( DI[6]        ),
    .DI7  ( DI[7]        ),
    .DI8  ( DI[8]        ),
    .DI9  ( DI[9]        ),
    .DI10 ( DI[10]       ),
    .DI11 ( DI[11]       ),
    .DI12 ( DI[12]       ),
    .DI13 ( DI[13]       ),
    .DI14 ( DI[14]       ),
    .DI15 ( DI[15]       ),
    .DI16 ( DI[16]       ),
    .DI17 ( DI[17]       ),
    .DI18 ( DI[18]       ),
    .DI19 ( DI[19]       ),
    .DI20 ( DI[20]       ),
    .DI21 ( DI[21]       ),
    .DI22 ( DI[22]       ),
    .DI23 ( DI[23]       ),
    .DI24 ( DI[24]       ),
    .DI25 ( DI[25]       ),
    .DI26 ( DI[26]       ),
    .DI27 ( DI[27]       ),
    .DI28 ( DI[28]       ),
    .DI29 ( DI[29]       ),
    .DI30 ( DI[30]       ),
    .DI31 ( DI[31]       ),
    .CK   ( CK           ),
    .WEB0 ( 1'b0         ),
    .WEB1 ( 1'b0         ),
    .WEB2 ( 1'b0         ),
    .WEB3 ( 1'b0         ),
    .OE   ( 1'b1         ),
    .CS   ( CS           )
);
`else
logic [31:0] data_out_pre;
logic [31:0] memory [512];

assign data_out_pre = CS ? memory[A] : 32'hx;

always_ff @(posedge CK) begin
    integer i;

    if (CS & WE) begin
        memory[A] <= DI;
    end
end

always_ff @(posedge CK) begin
    DO <= data_out_pre;
end
`endif

endmodule
